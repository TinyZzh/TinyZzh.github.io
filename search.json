[
  
    {
      "title"       : "Rust语言从入门到精通系列 - SeaORM框架实践(基础篇)",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, SeaORM",
      "url"         : "./rust/2023/05/30/rust_SeaORM_002_Basic_MySQL.html",
      "date"        : "2023-05-30 00:00:00 +0800",
      "description" : "",
      "content"     : "SeaORM是一个基于Rust语言的ORM（对象关系映射）框架，它提供了一种简单的方式来操作SQL数据库。SeaORM的设计理念是将SQL查询和Rust代码结合在一起，从而提供更好的类型安全和代码可读性。在本教程中，我们将介绍SeaORM的基本用法和进阶用法。我们将使用SQLite数据库来演示这些用法。基础用法在使用SeaORM之前，我们需要将其添加到我们的Rust项目中。cargo.toml添加依赖：1sea-orm = \"0.11.3\"连接到数据库在使用SeaORM之前，我们需要连接到一个数据库。我们可以使用DatabaseConnection结构体来完成这个任务。123456789use sea_orm::{DatabaseConnection, DatabaseConnectionInfo};#[async_std::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let db_info = DatabaseConnectionInfo::from_env()?; let db_conn = DatabaseConnection::connect(&amp;db_info).await?; // ... Ok(())}在上面的代码中，我们使用DatabaseConnectionInfo::from_env()方法从环境变量中获取数据库连接信息，并使用DatabaseConnection::connect()方法连接到数据库。定义表在SeaORM中，我们可以使用sea_query::Table结构体来定义表。我们可以定义表的名称、列名和列类型。12345678use sea_query::{ColumnDef, ColumnType, Table};let users = Table::new(\"users\") .add_column(\"id\", ColumnType::Int(Some(11)).Unsigned(true).NotNull(true).AutoIncrement(true)) .add_column(\"name\", ColumnType::String(Some(256)).NotNull(true)) .add_column(\"email\", ColumnType::String(Some(256)).NotNull(true).Unique(true)) .add_column(\"age\", ColumnType::Int(Some(3)).Unsigned(true).NotNull(true)) .set_primary_key(vec![\"id\"]);在上面的代码中，我们定义了一个名为users的表，它有四个列：id、name、email和age。id列是自增的主键，name和email列是字符串类型，age列是整数类型。插入数据在SeaORM中，我们可以使用InsertStatement结构体来插入数据。我们可以使用values()方法来设置要插入的值。12345678910111213use sea_orm::{entity::*, query::*, DatabaseConnection};let user = User { name: \"John Doe\".to_owned(), email: \"john.doe@example.com\".to_owned(), age: 30,};let insert = Insert::single_into(User::table()) .values(user.clone()) .build();let result = User::insert(insert).exec(&amp;db_conn).await?;在上面的代码中，我们使用Insert::single_into()方法和values()方法来设置要插入的值。我们使用User::table()方法来获取User实体的表格。最后，我们使用User::insert()方法和exec()方法来执行插入操作。查询数据在SeaORM中，我们可以使用SelectStatement结构体来查询数据。我们可以使用from()方法来设置要查询的表格，使用column()方法来设置要查询的列，使用where_expr()方法来设置查询条件。12345678use sea_orm::{entity::*, query::*, DatabaseConnection};let query = Select::from_table(User::table()) .column(User::all_columns) .where_expr(User::email.eq(\"john.doe@example.com\")) .build();let result = User::find_by_sql(query).one(&amp;db_conn).await?;在上面的代码中，我们使用Select::from_table()方法和column()方法来设置要查询的表格和列。我们使用where_expr()方法来设置查询条件。最后，我们使用User::find_by_sql()方法和one()方法来查询数据。更新数据在SeaORM中，我们可以使用UpdateStatement结构体来更新数据。我们可以使用set()方法来设置要更新的值，使用where_expr()方法来设置更新条件。12345678use sea_orm::{entity::*, query::*, DatabaseConnection};let update = Update::table(User::table()) .set(User::name, \"Jane Doe\") .where_expr(User::email.eq(\"john.doe@example.com\")) .build();let result = User::update(update).exec(&amp;db_conn).await?;在上面的代码中，我们使用Update::table()方法和set()方法来设置要更新的值。我们使用where_expr()方法来设置更新条件。最后，我们使用User::update()方法和exec()方法来执行更新操作。删除数据在SeaORM中，我们可以使用DeleteStatement结构体来删除数据。我们可以使用where_expr()方法来设置删除条件。1234567use sea_orm::{entity::*, query::*, DatabaseConnection};let delete = Delete::from_table(User::table()) .where_expr(User::email.eq(\"john.doe@example.com\")) .build();let result = User::delete(delete).exec(&amp;db_conn).await?;在上面的代码中，我们使用Delete::from_table()方法和where_expr()方法来设置删除条件。最后，我们使用User::delete()方法和exec()方法来执行删除操作。进阶用法关联表查询在SeaORM中，我们可以使用JoinType枚举来设置关联类型。我们可以使用JoinOn结构体来设置关联条件。12345678use sea_orm::{entity::*, query::*, DatabaseConnection};let query = Select::from_table(User::table()) .inner_join(Post::table(), JoinOn::new(User::id, Post::user_id)) .column((User::name, Post::title)) .build();let result = User::find_by_sql(query).all(&amp;db_conn).await?;在上面的代码中，我们使用Select::from_table()方法和inner_join()方法来设置关联表格。我们使用JoinOn::new()方法来设置关联条件。最后，我们使用User::find_by_sql()方法和all()方法来查询数据。事务处理在SeaORM中，我们可以使用Transaction结构体来处理事务。我们可以使用begin()方法来开始事务，使用commit()方法来提交事务，使用rollback()方法来回滚事务。123456789101112131415161718192021222324use sea_orm::{entity::*, query::*, DatabaseConnection, Transaction};let tx = Transaction::new(&amp;db_conn).await?;let user = User { name: \"John Doe\".to_owned(), email: \"john.doe@example.com\".to_owned(), age: 30,};let insert = Insert::single_into(User::table()) .values(user.clone()) .build();let result = User::insert(insert).exec(&amp;tx).await?;let update = Update::table(User::table()) .set(User::name, \"Jane Doe\") .where_expr(User::email.eq(\"john.doe@example.com\")) .build();let result = User::update(update).exec(&amp;tx).await?;tx.commit().await?;在上面的代码中，我们使用Transaction::new()方法来开始事务。我们使用User::insert()方法和exec()方法来插入数据，使用User::update()方法和exec()方法来更新数据。最后，我们使用tx.commit()方法来提交事务。总结在本教程中，我们介绍了SeaORM的基本用法和进阶用法。SeaORM提供了一种简单的方式来操作SQL数据库，它将SQL查询和Rust代码结合在一起，提供了更好的类型安全和代码可读性。通过本教程的学习，我们可以更好地理解SeaORM的使用方法，从而更好地使用它来开发Rust应用程序。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - SeaORM框架实战(数据库DML篇)",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, SeaORM",
      "url"         : "./rust/2023/05/30/rust_SeaORM_001_DML.html",
      "date"        : "2023-05-30 00:00:00 +0800",
      "description" : "",
      "content"     : "SeaORM是一个Rust语言的ORM框架，提供了简单易用的API，可以帮助我们轻松地操作数据库。SeaORM支持多种数据库，包括MySQL、PostgreSQL、SQLite等等。在本教程中，我们将以Animal实体为例，介绍SeaORM的基本用法，包括创建表、增删改查等操作。准备工作在MySQL中创建一个名为animals的数据库，并在其中创建一个名为animal的表，用于存储动物的信息。表结构如下：1234567CREATE TABLE `animal` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `age` int(11) NOT NULL, `species` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;定义 Entity在SeaORM中，我们可以通过定义实体来操作数据库。实体通常对应着数据库中的一张表。在本例中，我们需要创建一个Animal实体，对应着animal表。首先，我们需要在Cargo.toml中添加SeaORM和MySQL驱动程序的依赖：12[dependencies]sea-orm = \"0.11.3\"然后，在src目录下创建一个名为animal.rs的文件，定义Animal实体：1234567891011use sea_orm::entity::prelude::*;#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]#[sea_orm(table_name = \"animal\")]pub struct Animal { #[sea_orm(primary_key)] pub id: i32, pub name: String, pub age: i32, pub species: String,}这里我们使用了derive宏来自动生成Animal实体的代码。其中，#[sea_orm(table_name = \"animal\")]表示Animal实体对应的表名为animal；#[sea_orm(primary_key)]表示id字段为主键。有了Animal实体之后，我们就可以使用SeaORM提供的API来操作数据库了。下面分别介绍如何进行增删改查操作。增加记录要增加一条记录，我们可以使用Animal::insert()方法。例如，要添加一只名为“Tom”的2岁猫，可以这样写：12345678910111213use sea_orm::{Database, EntityTrait, FromQueryResult};let database_url = \"mysql://root:password@localhost:3306/animals\";let db = Database::connect(database_url).await.unwrap();let animal = Animal { id: 0, name: \"Tom\".to_owned(), age: 2, species: \"cat\".to_owned(),};let inserted_animal = Animal::insert(&amp;animal).exec(&amp;db).await.unwrap();这里我们首先连接到了名为animals的MySQL数据库，然后创建了一只名为“Tom”的2岁猫，使用Animal::insert()方法将其插入到数据库中，最后返回插入的记录。删除记录要删除一条记录，我们可以使用Animal::delete()方法。例如，要删除id为1的记录，可以这样写：12345678910use sea_orm::{Database, EntityTrait, FromQueryResult};let database_url = \"mysql://root:password@localhost:3306/animals\";let db = Database::connect(database_url).await.unwrap();let deleted_animal = Animal::delete() .filter(animal::Column::Id.eq(1)) .exec(&amp;db) .await .unwrap();这里我们使用Animal::delete()方法删除了id为1的记录，使用filter()方法指定了要删除的记录，最后返回删除的记录。更新记录要更新一条记录，我们可以使用Animal::update()方法。例如，要将id为1的记录的年龄改为3岁，可以这样写：1234567891011use sea_orm::{Database, EntityTrait, FromQueryResult};let database_url = \"mysql://root:password@localhost:3306/animals\";let db = Database::connect(database_url).await.unwrap();let updated_animal = Animal::update() .set(animal::Column::Age, 3) .filter(animal::Column::Id.eq(1)) .exec(&amp;db) .await .unwrap();这里我们使用Animal::update()方法更新了id为1的记录，使用set()方法指定了要更新的字段，最后返回更新后的记录。查询记录要查询记录，我们可以使用Animal::find()方法。例如，要查询所有名字为“Tom”的动物，可以这样写：12345678910use sea_orm::{Database, EntityTrait, FromQueryResult};let database_url = \"mysql://root:password@localhost:3306/animals\";let db = Database::connect(database_url).await.unwrap();let animals = Animal::find() .filter(animal::Column::Name.eq(\"Tom\")) .all(&amp;db) .await .unwrap();这里我们使用Animal::find()方法查询了所有名字为“Tom”的动物，使用filter()方法指定了查询条件，最后返回查询结果。联表查询除了基本的增删改查操作之外，SeaORM还支持联表查询。例如，我们可以查询每个物种的平均年龄：1234567891011use sea_orm::{Database, EntityTrait, FromQueryResult};let database_url = \"mysql://root:password@localhost:3306/animals\";let db = Database::connect(database_url).await.unwrap();let avg_age_by_species = Animal::find() .group_by(animal::Column::Species) .select((animal::Column::Species, Avg(animal::Column::Age))) .all(&amp;db) .await .unwrap();这里我们使用Animal::find()方法查询了所有动物的信息，使用group_by()方法指定了分组条件，使用select()方法指定了要查询的字段和聚合函数，最后返回查询结果。总结本教程介绍了SeaORM的基本用法，包括创建实体、增删改查等操作。SeaORM提供了简单易用的API，可以帮助我们轻松地操作数据库。同时，SeaORM还支持多种数据库，包括MySQL、PostgreSQL、SQLite等等。在实际开发中，我们可以根据需要选择不同的数据库和ORM框架。SeaORM是一个不错的选择，它提供了很多有用的功能，可以帮助我们更加高效地开发应用程序。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - SQLx模块SQLite入门",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, SQLx",
      "url"         : "./rust/2023/05/30/rust_SQLx_003_Basic_SQLite.html",
      "date"        : "2023-05-30 00:00:00 +0800",
      "description" : "",
      "content"     : "SQLx是一个Rust语言的异步SQL数据库访问库，支持多种数据库，包括PostgreSQL、MySQL、SQLite等。本教程将以SQLite为例，介绍SQLx的基础用法和进阶用法。基础用法连接数据库首先，需要在Rust项目中添加SQLx库的依赖：12345[dependencies]sqlx = \"0.6\"sqlx-core = \"0.6\"sqlx-derive = \"0.6\"sqlx-macros = \"0.6\"然后，可以使用以下代码连接SQLite数据库：12345678910use sqlx::{SqlitePool, sqlite::SqliteConnectOptions};#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let database_url = \"sqlite:mydatabase.db\"; let options = SqliteConnectOptions::new() .filename(database_url); let pool = SqlitePool::connect_with(options).await?; Ok(())}这里使用了SqlitePool连接池，可以在多个线程中共享连接。SqliteConnectOptions用于配置连接选项，这里指定了SQLite数据库文件的路径。创建表下面的代码演示了如何使用SQLx创建一个名为users的表：123456789101112use sqlx::{query, SqlitePool};#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = SqlitePool::connect(\"sqlite:mydatabase.db\").await?; query(\"CREATE TABLE users ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, email TEXT NOT NULL UNIQUE )\").execute(&amp;pool).await?; Ok(())}这里使用了query宏执行SQL语句，execute方法用于执行语句。可以看到，SQL语句与普通的SQL语句没有太大区别。插入数据下面的代码演示了如何使用SQLx向users表中插入一条数据：123456789101112use sqlx::{query, SqlitePool};#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = SqlitePool::connect(\"sqlite:mydatabase.db\").await?; query(\"INSERT INTO users (name, email) VALUES (?, ?)\") .bind(\"Alice\") .bind(\"alice@example.com\") .execute(&amp;pool) .await?; Ok(())}这里使用了bind方法绑定参数，可以避免SQL注入攻击。查询数据下面的代码演示了如何使用SQLx查询users表中所有数据：123456789101112131415161718use sqlx::{query_as, SqlitePool};#[derive(Debug, sqlx::FromRow)]struct User { id: i32, name: String, email: String,}#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = SqlitePool::connect(\"sqlite:mydatabase.db\").await?; let users = query_as::&lt;_, User&gt;(\"SELECT * FROM users\") .fetch_all(&amp;pool) .await?; println!(\"{:?}\", users); Ok(())}这里使用了query_as宏查询数据，并使用FromRow特性将查询结果转换为User结构体。fetch_all方法用于获取所有查询结果。更新数据下面的代码演示了如何使用SQLx更新users表中的数据：123456789101112use sqlx::{query, SqlitePool};#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = SqlitePool::connect(\"sqlite:mydatabase.db\").await?; query(\"UPDATE users SET email = ? WHERE name = ?\") .bind(\"alice@example.org\") .bind(\"Alice\") .execute(&amp;pool) .await?; Ok(())}这里使用了UPDATE语句更新数据。删除数据下面的代码演示了如何使用SQLx删除users表中的数据：1234567891011use sqlx::{query, SqlitePool};#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = SqlitePool::connect(\"sqlite:mydatabase.db\").await?; query(\"DELETE FROM users WHERE name = ?\") .bind(\"Alice\") .execute(&amp;pool) .await?; Ok(())}这里使用了DELETE语句删除数据。进阶用法事务下面的代码演示了如何使用SQLx进行事务操作：12345678910111213141516171819use sqlx::{query, SqlitePool, SqliteTransaction};#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = SqlitePool::connect(\"sqlite:mydatabase.db\").await?; let mut tx = pool.begin().await?; query(\"INSERT INTO users (name, email) VALUES (?, ?)\") .bind(\"Alice\") .bind(\"alice@example.com\") .execute(&amp;mut tx) .await?; query(\"INSERT INTO users (name, email) VALUES (?, ?)\") .bind(\"Bob\") .bind(\"bob@example.com\") .execute(&amp;mut tx) .await?; tx.commit().await?; Ok(())}这里使用了begin方法开启一个事务，可以在事务中执行多条SQL语句。如果所有语句执行成功，可以使用commit方法提交事务，否则可以使用rollback方法回滚事务。批量插入下面的代码演示了如何使用SQLx进行批量插入操作：12345678910111213141516use sqlx::{query, SqlitePool};#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = SqlitePool::connect(\"sqlite:mydatabase.db\").await?; let users = vec![ (\"Alice\", \"alice@example.com\"), (\"Bob\", \"bob@example.com\"), (\"Charlie\", \"charlie@example.com\"), ]; query(\"INSERT INTO users (name, email) VALUES (?, ?)\") .bind_all(users) .execute(&amp;pool) .await?; Ok(())}这里使用了bind_all方法绑定多个参数，可以将多个参数一次性绑定到SQL语句中，避免了多次执行SQL语句的开销。总结本教程介绍了SQLx的基础用法和进阶用法，包括连接数据库、创建表、插入数据、查询数据、更新数据、删除数据、事务和批量插入。SQLx是一个非常方便的异步SQL数据库访问库，可以大大提高开发效率。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - SQLx模块PostgreSQL入门",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, SQLx",
      "url"         : "./rust/2023/05/30/rust_SQLx_002_Basic_PostgreSQL.html",
      "date"        : "2023-05-30 00:00:00 +0800",
      "description" : "",
      "content"     : "SQLx是一个Rust语言的异步SQL数据库连接库，支持PostgreSQL、MySQL和SQLite数据库。它提供了简单的API和异步执行查询的能力，使得Rust程序员可以轻松地与数据库交互。本教程将以PostgreSQL数据库为例，介绍SQLx的基础和进阶用法。基础用法安装SQLx首先，我们需要在Rust项目中添加SQLx依赖。在Cargo.toml文件中添加以下内容：1234[dependencies]sqlx = \"0.6\"sqlx-core = \"0.6\"sqlx-postgres = \"0.6\"其中，sqlx是SQLx的主要依赖，sqlx-core是SQLx的核心依赖，sqlx-postgres是SQLx连接PostgreSQL数据库的依赖。连接数据库在使用SQLx进行数据库操作之前，我们需要先连接到数据库。在这里，我们使用PostgreSQL数据库作为示例。首先，我们需要在环境变量中设置数据库连接字符串：1export DATABASE_URL=postgres://username:password@localhost:5432/database_name其中，username和password分别是数据库的用户名和密码，localhost是数据库所在的主机名或IP地址，5432是PostgreSQL默认的端口号，database_name是数据库的名称。然后，在Rust代码中使用connect方法连接到数据库：12345678use sqlx::postgres::PgPool;#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = PgPool::connect(&amp;std::env::var(\"DATABASE_URL\")?).await?; // ...}我们使用PgPool连接到PostgreSQL数据库，其中DATABASE_URL是环境变量中设置的数据库连接字符串。执行查询连接到数据库之后，我们可以使用SQLx执行SQL查询。SQLx提供了两种方式执行查询：一种是使用query方法返回一个结果集，另一种是使用execute方法执行一个SQL语句。使用query方法使用query方法可以执行一个查询语句，并返回一个结果集。在这里，我们查询PostgreSQL中的users表：123456789101112131415use sqlx::postgres::PgQueryAs;#[derive(Debug, sqlx::FromRow)]struct User { id: i32, name: String,}async fn get_users(pool: &amp;PgPool) -&gt; Result&lt;Vec&lt;User&gt;, sqlx::Error&gt; { let users = sqlx::query_as::&lt;_, User&gt;(\"SELECT id, name FROM users\") .fetch_all(pool) .await?; Ok(users)}我们使用query_as方法执行查询语句，并将结果集映射为User结构体。fetch_all方法将结果集转换为Vec类型，并返回查询结果。使用execute方法使用execute方法可以执行一个SQL语句，并返回受影响的行数。在这里，我们向PostgreSQL中的users表插入一条记录：12345678async fn add_user(pool: &amp;PgPool, name: &amp;str) -&gt; Result&lt;u64, sqlx::Error&gt; { let result = sqlx::query(\"INSERT INTO users (name) VALUES ($1)\") .bind(name) .execute(pool) .await?; Ok(result.rows_affected())}我们使用query方法执行SQL语句，并使用bind方法绑定参数。execute方法执行SQL语句，并返回受影响的行数。事务处理在数据库操作中，事务处理是非常重要的。SQLx提供了transaction方法，可以在事务中执行多个SQL操作。12345678910111213141516171819202122232425262728async fn transfer_money(pool: &amp;PgPool, from: i32, to: i32, amount: i32) -&gt; Result&lt;(), sqlx::Error&gt; { let mut tx = pool.begin().await?; let from_balance: i32 = sqlx::query_scalar(\"SELECT balance FROM accounts WHERE id = $1\") .bind(from) .fetch_one(&amp;mut tx) .await?; if from_balance &lt; amount { return Err(sqlx::Error::RowNotFound); } sqlx::query(\"UPDATE accounts SET balance = balance - $1 WHERE id = $2\") .bind(amount) .bind(from) .execute(&amp;mut tx) .await?; sqlx::query(\"UPDATE accounts SET balance = balance + $1 WHERE id = $2\") .bind(amount) .bind(to) .execute(&amp;mut tx) .await?; tx.commit().await?; Ok(())}我们使用begin方法开始一个事务，并在事务中执行多个SQL操作。如果所有操作都执行成功，我们使用commit方法提交事务。如果发生错误，我们使用rollback方法回滚事务。使用连接池在实际应用中，我们需要处理多个数据库连接。SQLx提供了连接池来管理多个数据库连接。在这里，我们使用PgPool连接池：1234567891011use sqlx::postgres::PgPoolOptions;#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = PgPoolOptions::new() .max_connections(5) .connect(&amp;std::env::var(\"DATABASE_URL\")?) .await?; // ...}我们使用PgPoolOptions创建一个连接池，并在连接池中设置最大连接数。然后，我们使用connect方法连接到数据库。使用SQLx宏SQLx提供了一组宏，可以在编译时检查SQL语句的正确性和类型安全性。在这里，我们使用sqlx::query!宏执行查询语句：12345678910use sqlx::postgres::PgRow;use sqlx::query;async fn get_user(pool: &amp;PgPool, id: i32) -&gt; Result&lt;Option&lt;PgRow&gt;, sqlx::Error&gt; { let user = query!(\"SELECT * FROM users WHERE id = $1\", id) .fetch_optional(pool) .await?; Ok(user)}我们使用query!宏执行查询语句，并使用$1占位符绑定参数。fetch_optional方法返回一个Option类型的结果集。进阶用法自定义类型映射SQLx默认支持一些常见的Rust类型和PostgreSQL数据类型的映射。但是，在某些情况下，我们需要自定义类型映射。在这里，我们自定义一个Json类型映射：12345678910111213141516171819202122232425262728293031323334353637383940use serde::{Deserialize, Serialize};use sqlx::postgres::{PgTypeInfo, PgValue, types::PgTypeMetadata};use sqlx::{Decode, Encode, Type};#[derive(Debug, Clone, Serialize, Deserialize)]struct Json&lt;T&gt;(pub T);impl&lt;'r, T&gt; Type&lt;'r&gt; for Json&lt;T&gt;where T: Serialize + Deserialize&lt;'r&gt;,{ fn type_info() -&gt; PgTypeInfo&lt;'r&gt; { PgTypeInfo::with_name(\"jsonb\") } fn compatible(ty: &amp;PgTypeMetadata&lt;'_&gt;) -&gt; bool { ty.name() == \"json\" || ty.name() == \"jsonb\" }}impl&lt;'q, 'r, T&gt; Encode&lt;'q, 'r&gt; for Json&lt;T&gt;where T: Serialize,{ fn encode(&amp;self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; sqlx::encode::Result&lt;()&gt; { let json = serde_json::to_string(&amp;self.0)?; PgValue::from(json).encode(buf) }}impl&lt;'r, T&gt; Decode&lt;'r&gt; for Json&lt;T&gt;where T: Deserialize&lt;'r&gt;,{ fn decode(value: PgValue&lt;'r&gt;) -&gt; Result&lt;Self, sqlx::Error&gt; { let json = value.try_get::&lt;&amp;str&gt;()?; let value = serde_json::from_str(json)?; Ok(Json(value)) }}我们定义了一个Json结构体，它包装了一个T类型的值。然后，我们实现了Type、Encode和Decode trait，将Json类型映射为PostgreSQL的jsonb类型。使用SQLx的连接池管理器在实际应用中，我们需要使用连接池管理器来管理多个数据库连接。SQLx提供了连接池管理器，可以方便地管理连接池和连接。在这里，我们使用r2d2连接池管理器：123456789101112131415use std::thread;use sqlx::postgres::PgConnection;use sqlx::pool::{Pool, PoolConnection};use r2d2_postgres::{postgres::NoTls, PostgresConnectionManager};#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let manager = PostgresConnectionManager::new( \"host=localhost user=postgres\".parse().unwrap(), NoTls, ); let pool = r2d2::Pool::new(manager).unwrap(); // ...}我们使用PostgresConnectionManager创建一个连接管理器，并在连接管理器中设置最大连接数。然后，我们使用Pool构建一个连接池，并在连接池中设置最大连接数。总结本教程介绍了SQLx的基础和进阶用法。我们学习了如何连接到PostgreSQL数据库，如何执行SQL查询和操作，如何处理事务，如何使用连接池和宏，以及如何自定义类型映射和使用连接池管理器。SQLx是一个强大的异步SQL数据库连接库，可以帮助Rust程序员轻松地与数据库交互。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - SQLx模块MySQL入门",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, SQLx",
      "url"         : "./rust/2023/05/30/rust_SQLx_001_Basic_MySQL.html",
      "date"        : "2023-05-30 00:00:00 +0800",
      "description" : "",
      "content"     : "SQLx是一个Rust语言的异步SQL执行库，它支持多种数据库，包括MySQL、PostgreSQL、SQLite等。本教程将以MySQL数据库为例，介绍SQLx在Rust语言中的基础用法和进阶用法。基础用法要使用SQLx，需要在Cargo.toml文件中添加以下依赖：123[dependencies]sqlx = { version = \"0.6\", features = [\"mysql\", \"runtime-tokio-rustls\"] }tokio = { version = \"1\", features = [\"full\"] }连接数据库在使用SQLx之前，需要先连接数据库。SQLx提供了两种方式连接MySQL数据库：使用URL连接和使用配置文件连接。URL连接使用URL连接时，需要在代码中指定连接字符串，例如：1234567891011use sqlx::mysql::MySqlPoolOptions;#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = MySqlPoolOptions::new() .max_connections(5) .connect(\"mysql://username:password@hostname:port/database\") .await?; // ... Ok(())}其中，username和password是数据库用户名和密码，hostname是数据库主机名，port是数据库端口号，database是要连接的数据库名。配置文件连接使用配置文件连接时，需要在项目根目录下创建一个名为.env的文件，并在其中指定连接信息，例如：DATABASE_URL=mysql://username:password@hostname:port/database然后在代码中使用dotenv库加载.env文件，并使用sqlx::MySqlPool::connect_dotenv()方法连接数据库，例如：123456789101112use sqlx::mysql::MySqlPoolOptions;#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { dotenv::dotenv().ok(); let pool = MySqlPoolOptions::new() .max_connections(5) .connect_dotenv() .await?; // ... Ok(())}查询数据连接成功后，就可以使用SQLx执行SQL查询语句了。SQLx提供了两种方式执行SQL查询语句：使用query()方法和使用query_as()方法。使用query()方法使用query()方法执行SQL查询语句时，需要手动指定返回结果的类型，例如：1234567891011121314151617181920212223242526272829use sqlx::{MySqlPool, Row};#[derive(Debug)]struct User { id: i32, name: String,}#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = MySqlPool::connect(\"mysql://username:password@hostname:port/database\").await?; let mut conn = pool.acquire().await?; let mut rows = sqlx::query(\"SELECT id, name FROM users\") .map(|row: sqlx::mysql::MySqlRow| { User { id: row.get(0), name: row.get(1), } }) .fetch_all(&amp;mut conn) .await?; for row in rows.iter() { println!(\"{:?}\", row); } Ok(())}使用query_as()方法使用query_as()方法执行SQL查询语句时，可以自动将返回结果转换为指定类型的结构体，例如：1234567891011121314151617181920212223use sqlx::{MySqlPool, FromRow};#[derive(Debug, FromRow)]struct User { id: i32, name: String,}#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = MySqlPool::connect(\"mysql://username:password@hostname:port/database\").await?; let mut conn = pool.acquire().await?; let mut rows = sqlx::query_as::&lt;_, User&gt;(\"SELECT id, name FROM users\") .fetch_all(&amp;mut conn) .await?; for row in rows.iter() { println!(\"{:?}\", row); } Ok(())}插入数据使用SQLx插入数据时，可以使用execute()方法或execute_with()方法。使用execute()方法使用execute()方法插入数据时，需要手动指定插入的数据，例如：12345678910111213141516171819202122232425use sqlx::{MySqlPool, Row};#[derive(Debug)]struct User { name: String,}#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = MySqlPool::connect(\"mysql://username:password@hostname:port/database\").await?; let mut conn = pool.acquire().await?; let user = User { name: \"John\".to_string(), }; let result = sqlx::query(\"INSERT INTO users (name) VALUES (?)\") .bind(user.name) .execute(&amp;mut conn) .await?; println!(\"{:?}\", result); Ok(())}使用execute_with()方法使用execute_with()方法插入数据时，可以使用结构体自动映射的特性，例如：123456789101112131415161718192021222324use sqlx::{MySqlPool, FromRow};#[derive(Debug, FromRow)]struct User { name: String,}#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = MySqlPool::connect(\"mysql://username:password@hostname:port/database\").await?; let mut conn = pool.acquire().await?; let user = User { name: \"John\".to_string(), }; let result = sqlx::query_with::&lt;_, User&gt;(\"INSERT INTO users (name) VALUES (?)\", user) .execute(&amp;mut conn) .await?; println!(\"{:?}\", result); Ok(())}更新数据使用SQLx更新数据时，可以使用execute()方法或execute_with()方法。使用execute()方法使用execute()方法更新数据时，需要手动指定更新的条件和更新的数据，例如：12345678910111213141516171819202122232425262728use sqlx::{MySqlPool, Row};#[derive(Debug)]struct User { id: i32, name: String,}#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = MySqlPool::connect(\"mysql://username:password@hostname:port/database\").await?; let mut conn = pool.acquire().await?; let user = User { id: 1, name: \"John\".to_string(), }; let result = sqlx::query(\"UPDATE users SET name = ? WHERE id = ?\") .bind(user.name) .bind(user.id) .execute(&amp;mut conn) .await?; println!(\"{:?}\", result); Ok(())}使用execute_with()方法使用execute_with()方法更新数据时，可以使用结构体自动映射的特性，例如：1234567891011121314151617181920212223242526use sqlx::{MySqlPool, FromRow};#[derive(Debug, FromRow)]struct User { id: i32, name: String,}#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = MySqlPool::connect(\"mysql://username:password@hostname:port/database\").await?; let mut conn = pool.acquire().await?; let user = User { id: 1, name: \"John\".to_string(), }; let result = sqlx::query_with::&lt;_, User&gt;(\"UPDATE users SET name = :name WHERE id = :id\", user) .execute(&amp;mut conn) .await?; println!(\"{:?}\", result); Ok(())}删除数据使用SQLx删除数据时，可以使用execute()方法或execute_with()方法。使用execute()方法使用execute()方法删除数据时，需要手动指定删除的条件，例如：12345678910111213141516use sqlx::{MySqlPool, Row};#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = MySqlPool::connect(\"mysql://username:password@hostname:port/database\").await?; let mut conn = pool.acquire().await?; let result = sqlx::query(\"DELETE FROM users WHERE id = ?\") .bind(1) .execute(&amp;mut conn) .await?; println!(\"{:?}\", result); Ok(())}使用execute_with()方法使用execute_with()方法删除数据时，可以使用结构体自动映射的特性，例如：123456789101112131415161718192021222324use sqlx::{MySqlPool, FromRow};#[derive(Debug, FromRow)]struct User { id: i32,}#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = MySqlPool::connect(\"mysql://username:password@hostname:port/database\").await?; let mut conn = pool.acquire().await?; let user = User { id: 1, }; let result = sqlx::query_with::&lt;_, User&gt;(\"DELETE FROM users WHERE id = :id\", user) .execute(&amp;mut conn) .await?; println!(\"{:?}\", result); Ok(())}进阶用法事务使用SQLx执行事务时，可以使用begin()方法开始事务，使用commit()方法提交事务，使用rollback()方法回滚事务。1234567891011121314151617181920212223242526272829use sqlx::{MySqlPool, Transaction};#[derive(Debug)]struct User { name: String,}#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = MySqlPool::connect(\"mysql://username:password@hostname:port/database\").await?; let mut conn = pool.acquire().await?; let mut tx = conn.begin().await?; let user = User { name: \"John\".to_string(), }; let result = sqlx::query(\"INSERT INTO users (name) VALUES (?)\") .bind(user.name) .execute(&amp;mut tx) .await?; println!(\"{:?}\", result); tx.commit().await?; Ok(())}连接池使用SQLx连接池时，可以使用PoolOptions::new()方法创建连接池，并使用acquire()方法获取连接。123456789101112131415161718use sqlx::{MySqlPool, PoolOptions};#[tokio::main]async fn main() -&gt; Result&lt;(), sqlx::Error&gt; { let pool = MySqlPool::connect(\"mysql://username:password@hostname:port/database\").await?; let mut conn = pool.acquire().await?; let pool = MySqlPool::builder() .max_size(5) .build(\"mysql://username:password@hostname:port/database\") .await?; let mut conn = pool.acquire().await?; // ... Ok(())}总结本教程介绍了SQLx在Rust语言中的基础用法和进阶用法，包括连接数据库、查询数据、插入数据、更新数据、删除数据、事务和连接池等。SQLx是一个简单易用的异步SQL执行库，可以帮助Rust开发者快速地与多种数据库进行交互。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 一文读懂MQTT的LWT特性",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, MQTT",
      "url"         : "./rust/2023/05/29/rust_MQTT_003_MQTT_5_Features.html",
      "date"        : "2023-05-29 00:00:00 +0800",
      "description" : "",
      "content"     : ""
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 一文读懂MQTT的LWT特性",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, MQTT",
      "url"         : "./rust/2023/05/29/rust_MQTT_002_LWT.html",
      "date"        : "2023-05-29 00:00:00 +0800",
      "description" : "",
      "content"     : "MQTT是一种轻量级的消息传输协议，它被广泛应用于物联网和机器对机器通信领域。Rust是一种安全、高效、并发的编程语言，它的生态系统也在不断壮大。本教程将介绍如何使用Rust语言和paho-mqtt模块实现MQTT协议，并重点介绍LWT特征。Rust是一种系统级编程语言，它的主要特点是安全、高效、并发。Rust编译器会在编译时进行内存安全检查，避免了很多常见的内存安全问题，如空指针、缓冲区溢出、数据竞争等。同时，Rust也提供了很多高级语言的特性，如闭包、泛型、模式匹配等，使得编写Rust程序更加方便和高效。什么是MQTT？MQTT是一种基于发布/订阅模式的消息传输协议。它是一种轻量级的协议，适用于低带宽、不稳定的网络环境。MQTT的核心思想是将消息发布到主题（Topic）上，订阅者可以通过订阅主题来接收消息。MQTT支持三种消息质量等级： QoS 0：最多一次传输，消息不可靠，可能会丢失或重复。 QoS 1：最少一次传输，消息可靠，至少传输一次，可能会重复。 QoS 2：只有一次传输，消息可靠，只传输一次，不会重复。MQTT协议的具体规范可以参考官方文档：MQTT Version 5.0 Specification。paho-mqtt模块paho-mqtt是一个MQTT客户端库，它提供了多种语言的实现，包括C、C++、Java、Python、Rust等。paho-mqtt-rs是paho-mqtt的Rust语言实现，它提供了一套简单易用的API，可以方便地实现MQTT协议。LWT特征LWT（Last Will and Testament）是MQTT协议中的一种特殊消息，它可以在客户端离线时自动发送。LWT消息包括一个主题和一个消息内容，当客户端离线时，服务器会自动将LWT消息发布到指定主题上。LWT特征可以用于检测客户端是否在线，也可以用于实现一些特殊的功能，如自动重连、状态监控等。示例代码下面是一个使用paho-mqtt-rs实现MQTT协议的示例代码。该代码实现了一个简单的MQTT客户端，可以连接到指定的MQTT服务器，订阅指定的主题，发送和接收消息，并支持LWT特征。1234567891011121314151617181920212223242526272829303132333435363738394041use paho_mqtt as mqtt;use std::time::Duration;fn main() { // 创建MQTT客户端 let cli = mqtt::Client::new(\"tcp://localhost:1883\").unwrap(); // 设置LWT特征 let lwt = mqtt::Message::new(\"lwt\", \"offline\", 0); let conn_opts = mqtt::ConnectOptionsBuilder::new() .will_message(lwt) .clean_session(false) .connect_timeout(Duration::from_secs(5)) .finalize(); // 连接MQTT服务器 let tok = cli.connect(conn_opts); tok.await.unwrap(); // 订阅主题 let topic = \"hello/world\"; let qos = 1; let tok = cli.subscribe(topic, qos); tok.await.unwrap(); // 发送消息 let payload = \"hello, world!\"; let msg = mqtt::Message::new(topic, payload, qos); let tok = cli.publish(msg); tok.await.unwrap(); // 接收消息 for _ in 0..10 { let msg = cli.await_message(Duration::from_secs(1)).unwrap(); println!(\"Received message: {:?}\", msg); } // 断开连接 let tok = cli.disconnect(None); tok.await.unwrap();}该代码首先创建一个MQTT客户端，然后设置LWT特征，连接到指定的MQTT服务器，订阅指定的主题，发送和接收消息，并最终断开连接。其中，LWT特征通过ConnectOptionsBuilder的will_message方法设置，订阅主题通过subscribe方法实现，发送消息通过publish方法实现，接收消息通过await_message方法实现。总结本教程介绍了如何使用Rust语言和paho-mqtt模块实现MQTT协议，并重点介绍了LWT特征。Rust语言的安全、高效、并发特性使得编写MQTT客户端更加方便和高效，paho-mqtt-rs提供了一套简单易用的API，可以方便地实现MQTT协议。LWT特征可以用于检测客户端是否在线，也可以用于实现一些特殊的功能，如自动重连、状态监控等。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - paho-mqtt模块实战(入门)",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, MQTT",
      "url"         : "./rust/2023/05/29/rust_MQTT_001_basic_overview.html",
      "date"        : "2023-05-29 00:00:00 +0800",
      "description" : "",
      "content"     : "MQTT（Message Queuing Telemetry Transport）是一种轻量级的消息传输协议，它被设计用于低带宽和不稳定网络环境下的物联网设备通信。Rust是一种安全、并发和高效的编程语言，它在系统编程和网络编程方面有着很好的表现。在本教程中，我们将介绍如何使用Rust语言和paho-mqtt模块实现MQTT协议的应用。 前面写过3篇介绍 rumqttc 的教程，本篇开始使用 paho-mqtt 模块是c库的封装, 支持v5协议，qos 2等更复杂的特性。环境准备我们需要先安装好相关的开发环境。在Cargo.toml中添加依赖：1paho-mqtt = \"0.12.1\"连接MQTT服务器在使用MQTT协议之前，我们需要先连接到MQTT服务器。以下是连接MQTT服务器的示例代码：123456789101112extern crate paho_mqtt as mqtt;fn main() { let host = \"tcp://localhost:1883\"; let cli = mqtt::Client::new(host).unwrap(); let conn_opts = mqtt::ConnectOptionsBuilder::new() .keep_alive_interval(std::time::Duration::from_secs(20)) .clean_session(false) .finalize(); let response = cli.connect(conn_opts).unwrap(); println!(\"Connected to MQTT server: {:?}\", response);}在上面的示例代码中，我们首先创建了一个MQTT客户端对象，并指定了MQTT服务器的地址。然后，我们创建了一个连接选项对象，并设置了心跳间隔和会话清除标志。最后，我们使用连接选项对象连接到MQTT服务器，并打印连接响应信息。发布MQTT消息在连接到MQTT服务器之后，我们可以使用MQTT客户端对象来发布消息。以下是发布MQTT消息的示例代码：12345678910111213141516171819202122extern crate paho_mqtt as mqtt;fn main() { let host = \"tcp://localhost:1883\"; let cli = mqtt::Client::new(host).unwrap(); let conn_opts = mqtt::ConnectOptionsBuilder::new() .keep_alive_interval(std::time::Duration::from_secs(20)) .clean_session(false) .finalize(); let response = cli.connect(conn_opts).unwrap(); println!(\"Connected to MQTT server: {:?}\", response); let topic = \"test/topic\"; let payload = \"Hello, MQTT!\"; let message = mqtt::MessageBuilder::new() .topic(topic) .payload(payload) .qos(mqtt::QOS_1) .finalize(); let response = cli.publish(message).unwrap(); println!(\"Published MQTT message: {:?}\", response);}在上面的示例代码中，我们首先连接到MQTT服务器，然后创建了一个MQTT消息对象，并设置了消息主题、消息负载和消息服务质量等级。最后，我们使用MQTT客户端对象来发布消息，并打印发布响应信息。订阅MQTT主题在使用MQTT协议之前，我们需要先订阅MQTT主题。以下是订阅MQTT主题的示例代码：1234567891011121314151617extern crate paho_mqtt as mqtt;fn main() { let host = \"tcp://localhost:1883\"; let cli = mqtt::Client::new(host).unwrap(); let conn_opts = mqtt::ConnectOptionsBuilder::new() .keep_alive_interval(std::time::Duration::from_secs(20)) .clean_session(false) .finalize(); let response = cli.connect(conn_opts).unwrap(); println!(\"Connected to MQTT server: {:?}\", response); let topic = \"test/topic\"; let qos = mqtt::QOS_1; let response = cli.subscribe(topic, qos).unwrap(); println!(\"Subscribed to MQTT topic: {:?}\", response);}在上面的示例代码中，我们首先连接到MQTT服务器，然后创建了一个MQTT订阅对象，并设置了订阅主题和服务质量等级。最后，我们使用MQTT客户端对象来订阅主题，并打印订阅响应信息。同时发布和订阅MQTT消息在使用MQTT协议时，我们通常需要同时发布和订阅MQTT消息。以下是同时发布和订阅MQTT消息的示例代码：123456789101112131415161718192021222324252627282930extern crate paho_mqtt as mqtt;fn main() { let host = \"tcp://localhost:1883\"; let cli = mqtt::Client::new(host).unwrap(); let conn_opts = mqtt::ConnectOptionsBuilder::new() .keep_alive_interval(std::time::Duration::from_secs(20)) .clean_session(false) .finalize(); let response = cli.connect(conn_opts).unwrap(); println!(\"Connected to MQTT server: {:?}\", response); let topic = \"test/topic\"; let qos = mqtt::QOS_1; let response = cli.subscribe(topic, qos).unwrap(); println!(\"Subscribed to MQTT topic: {:?}\", response); let payload = \"Hello, MQTT!\"; let message = mqtt::MessageBuilder::new() .topic(topic) .payload(payload) .qos(mqtt::QOS_1) .finalize(); let response = cli.publish(message).unwrap(); println!(\"Published MQTT message: {:?}\", response); for message in cli.start_consuming() { println!(\"Received MQTT message: {:?}\", message); }}在上面的示例代码中，我们首先连接到MQTT服务器，然后创建了一个MQTT订阅对象，并设置了订阅主题和服务质量等级。接着，我们创建了一个MQTT消息对象，并使用MQTT客户端对象来发布消息。最后，我们使用MQTT客户端对象来接收消息，并打印接收到的消息。断开MQTT服务器连接在使用MQTT协议之后，我们需要断开与MQTT服务器的连接。以下是断开MQTT服务器连接的示例代码：123456789101112131415extern crate paho_mqtt as mqtt;fn main() { let host = \"tcp://localhost:1883\"; let cli = mqtt::Client::new(host).unwrap(); let conn_opts = mqtt::ConnectOptionsBuilder::new() .keep_alive_interval(std::time::Duration::from_secs(20)) .clean_session(false) .finalize(); let response = cli.connect(conn_opts).unwrap(); println!(\"Connected to MQTT server: {:?}\", response); cli.disconnect(None).unwrap(); println!(\"Disconnected from MQTT server.\");}在上面的示例代码中，我们首先连接到MQTT服务器，然后使用MQTT客户端对象来断开与MQTT服务器的连接，并打印断开连接信息。进阶使用在本节中，我们将介绍如何使用Rust语言和paho-mqtt模块实现MQTT协议的进阶应用。我们将提供2个示例，分别是： 使用SSL/TLS连接MQTT服务器 使用认证机制连接MQTT服务器使用SSL/TLS连接MQTT服务器在使用MQTT协议时，我们通常需要使用SSL/TLS协议来保证通信安全。以下是使用SSL/TLS连接MQTT服务器的示例代码：123456789101112131415161718192021222324252627extern crate paho_mqtt as mqtt;extern crate rustls;use std::fs::File;use std::io::BufReader;use std::sync::Arc;fn main() { let host = \"ssl://localhost:8883\"; let cli = mqtt::Client::new(host).unwrap(); let mut config = rustls::ClientConfig::new(); let cert_file = &amp;mut BufReader::new(File::open(\"cert.pem\").unwrap()); config.root_store.add_pem_file(cert_file).unwrap(); let tls = Arc::new(rustls::ClientSession::new(&amp;Arc::new(config), host)); let conn_opts = mqtt::ConnectOptionsBuilder::new() .keep_alive_interval(std::time::Duration::from_secs(20)) .ssl_options(mqtt::SslOptionsBuilder::new() .ssl_version(mqtt::SslVersion::TlsV1_2) .server_name_indication(host) .build(tls)) .clean_session(false) .finalize(); let response = cli.connect(conn_opts).unwrap(); println!(\"Connected to MQTT server: {:?}\", response);}在上面的示例代码中，我们首先创建了一个MQTT客户端对象，并指定了使用SSL/TLS协议连接MQTT服务器的地址。然后，我们创建了一个SSL/TLS配置对象，并从PEM文件中加载证书。接着，我们创建了一个SSL/TLS会话对象，并使用SSL/TLS配置对象和MQTT服务器地址来初始化会话对象。最后，我们创建了一个连接选项对象，并设置了心跳间隔、SSL/TLS选项和会话清除标志。我们使用连接选项对象连接到MQTT服务器，并打印连接响应信息。使用认证机制连接MQTT服务器在使用MQTT协议时，我们通常需要使用认证机制来保证通信安全。以下是使用认证机制连接MQTT服务器的示例代码：1234567891011121314151617extern crate paho_mqtt as mqtt;fn main() { let host = \"tcp://localhost:1883\"; let cli = mqtt::Client::new(host).unwrap(); let username = \"user\"; let password = \"password\"; let conn_opts = mqtt::ConnectOptionsBuilder::new() .keep_alive_interval(std::time::Duration::from_secs(20)) .user_name(username) .password(password) .clean_session(false) .finalize(); let response = cli.connect(conn_opts).unwrap(); println!(\"Connected to MQTT server: {:?}\", response);}在上面的示例代码中，我们首先创建了一个MQTT客户端对象，并指定了MQTT服务器的地址。然后，我们创建了一个连接选项对象，并设置了心跳间隔、用户名、密码和会话清除标志。我们使用连接选项对象连接到MQTT服务器，并打印连接响应信息。总结在本教程中，我们介绍了如何使用Rust语言和paho-mqtt模块实现MQTT协议的应用。我们提供了几个基础应用的示例代码，包括连接MQTT服务器、发布MQTT消息、订阅MQTT主题、同时发布和订阅MQTT消息和断开MQTT服务器连接。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - MQTT协议异步API实战",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, MQTT",
      "url"         : "./rust/2023/05/16/rust_lang_tutorial_237_MQTT_tokio.html",
      "date"        : "2023-05-16 00:00:00 +0800",
      "description" : "",
      "content"     : "MQTT（Message Queuing Telemetry Transport）是一种轻量级的消息传输协议，适用于物联网设备和低带宽、不稳定网络环境下的数据传输。Rust语言是一种安全、高效、并发的系统编程语言，非常适合开发物联网设备和后端服务。本教程将介绍如何使用Rust语言和rumqttc模块实现MQTT协议的异步API，并提供相关的代码示例，最佳实践和教程总结。 本篇内容主要围绕 rumqttc模块的 AsyncClient 进行，讲解异步API相关的内容.在Cargo.toml文件中添加依赖：12[dependencies]rumqttc = \"0.21.0\"然后我们就可以开始编写代码了。连接和订阅首先需要连接到MQTT服务器，并订阅一个主题。可以使用rumqttc模块提供的异步API实现。以下是示例代码：1234567891011121314151617181920212223use rumqttc::{AsyncClient, Event, Incoming, MqttOptions, QoS};#[tokio::main]async fn main() { let mqtt_options = MqttOptions::new(\"test-async\", \"mqtt.eclipseprojects.io\", 1883); let (mut client, mut event_loop) = AsyncClient::new(mqtt_options, 10); // Connect to the broker client.connect().await.unwrap(); // Subscribe to a topic client.subscribe(\"test/topic\", QoS::AtMostOnce).await.unwrap(); // Handle incoming events while let Some(event) = event_loop.poll().await.unwrap() { match event { Event::Incoming(Incoming::Publish(p)) =&gt; { println!(\"Received message: {:?}\", p.payload); } _ =&gt; {} } }}该代码创建了一个异步客户端，连接到了MQTT服务器，并订阅了一个主题。在事件循环中处理接收到的消息，如果是Publish事件，则打印出消息内容。发布消息可以使用异步客户端的publish方法发布消息。以下是示例代码：12345678910111213use rumqttc::{AsyncClient, MqttOptions, QoS};#[tokio::main]async fn main() { let mqtt_options = MqttOptions::new(\"test-async\", \"mqtt.eclipseprojects.io\", 1883); let (mut client, _) = AsyncClient::new(mqtt_options, 10); // Connect to the broker client.connect().await.unwrap(); // Publish a message client.publish(\"test/topic\", QoS::AtMostOnce, false, b\"Hello, MQTT!\").await.unwrap();}该代码创建了一个异步客户端，连接到了MQTT服务器，并发布了一条消息到指定主题。断开连接可以使用异步客户端的disconnect方法断开连接。以下是示例代码：12345678910111213use rumqttc::{AsyncClient, MqttOptions};#[tokio::main]async fn main() { let mqtt_options = MqttOptions::new(\"test-async\", \"mqtt.eclipseprojects.io\", 1883); let (mut client, _) = AsyncClient::new(mqtt_options, 10); // Connect to the broker client.connect().await.unwrap(); // Disconnect from the broker client.disconnect().await.unwrap();}该代码创建了一个异步客户端，连接到了MQTT服务器，并断开了连接。处理连接错误在连接或订阅过程中可能会出现错误，需要进行错误处理。可以使用Rust语言提供的Result类型和match语句处理错误。以下是示例代码：1234567891011121314151617181920212223242526272829303132333435363738use rumqttc::{AsyncClient, MqttOptions, QoS};#[tokio::main]async fn main() { let mqtt_options = MqttOptions::new(\"test-async\", \"mqtt.eclipseprojects.io\", 1883); let (mut client, mut event_loop) = AsyncClient::new(mqtt_options, 10); // Connect to the broker if let Err(e) = client.connect().await { eprintln!(\"Failed to connect: {}\", e); return; } // Subscribe to a topic if let Err(e) = client.subscribe(\"test/topic\", QoS::AtMostOnce).await { eprintln!(\"Failed to subscribe: {}\", e); return; } // Handle incoming events while let Some(event) = event_loop.poll().await { match event { Ok(Event::Incoming(Incoming::Publish(p))) =&gt; { println!(\"Received message: {:?}\", p.payload); } Err(e) =&gt; { eprintln!(\"Error: {}\", e); break; } _ =&gt; {} } } // Disconnect from the broker if let Err(e) = client.disconnect().await { eprintln!(\"Failed to disconnect: {}\", e); }}该代码在连接或订阅失败时打印错误信息，并退出程序。使用TLS加密连接可以使用TLS加密连接来保护数据传输的安全性。可以使用MqttOptions的tls选项指定TLS配置。以下是示例代码：123456789101112131415161718192021222324252627use rumqttc::{AsyncClient, MqttOptions, QoS};#[tokio::main]async fn main() { let mqtt_options = MqttOptions::new(\"test-async\", \"mqtt.eclipseprojects.io\", 8883) .set_tls(rumqttc::TlsOptions::default()); let (mut client, mut event_loop) = AsyncClient::new(mqtt_options, 10); // Connect to the broker client.connect().await.unwrap(); // Subscribe to a topic client.subscribe(\"test/topic\", QoS::AtMostOnce).await.unwrap(); // Handle incoming events while let Some(event) = event_loop.poll().await.unwrap() { match event { Event::Incoming(Incoming::Publish(p)) =&gt; { println!(\"Received message: {:?}\", p.payload); } _ =&gt; {} } } // Disconnect from the broker client.disconnect().await.unwrap();}该代码使用TLS加密连接到了MQTT服务器。总结本教程介绍了如何使用Rust语言和rumqttc模块实现MQTT协议的异步API，并提供了代码示例，最佳实践和教程总结。使用异步API可以提高性能和并发处理能力，使用Result类型和match语句处理错误可以避免程序崩溃，使用TLS加密连接保护数据传输的安全性，使用QoS选项控制消息传输的可靠性和效率，使用subscribe方法订阅主题，使用publish方法发布消息，使用disconnect方法断开连接。Rust语言和rumqttc模块是开发物联网设备和后端服务的有力工具。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 物联网消息传输协议MQTT(进阶)",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, MQTT",
      "url"         : "./rust/2023/05/16/rust_lang_tutorial_236_MQTT_basic_2.html",
      "date"        : "2023-05-16 00:00:00 +0800",
      "description" : "",
      "content"     : "MQTT（Message Queuing Telemetry Transport）是一种轻量级的消息传输协议，用于在低带宽和不稳定的网络环境中传输消息。MQTT协议基于发布/订阅模式，包含了许多特性，如QoS，保留消息，遗嘱消息等，使得它非常适合物联网设备之间的通信。Rust是一种系统级编程语言，具有内存安全和高性能的特性。Rust语言的主要目标是提供一种安全、并发、实用的编程语言，使得开发者可以轻松地编写高性能的系统级应用程序。本教程将介绍如何使用Rust语言和rumqttc模块来实现MQTT协议的基础应用和进阶应用。rumqttc模块简介rumqttc是一个基于Rust语言实现的MQTT客户端库，它提供了连接MQTT服务器、订阅主题、发布消息等基本功能，并支持TLS加密连接。rumqttc的API简单易用，适合初学者和中级开发者使用。在Cargo.toml文件中添加rumqtt模块依赖, 示例配置如下：12[dependencies]rumqttc = \"0.21.0\"应用实践进阶使用QoS2传输消息这个示例演示如何使用rumqttc模块使用QoS2传输消息。1234567891011use rumqttc::{Client, MqttOptions, QoS};fn main() { let mqtt_options = MqttOptions::new(\"test-qos2\", \"localhost\", 1883); let (mut client, _) = Client::new(mqtt_options, 10); client .publish(\"test/topic\", QoS::ExactlyOnce, false, \"hello world\".to_owned()) .unwrap();}这个示例中，我们创建了一个MQTT客户端，连接到本地的MQTT服务器，然后发布了一条消息到test/topic主题。在调用publish方法时，我们指定了消息的QoS为ExactlyOnce，表示消息必须被传输一次，且只能被传输一次。使用连接池在实际应用中，我们通常需要同时处理多个MQTT客户端连接，这时候使用连接池可以提高性能和可靠性。rumqttc模块提供了一个ConnectionPool结构体，可以方便地管理多个MQTT客户端连接。12345678910111213141516use rumqttc::{Client, ConnectionPool, MqttOptions};fn main() { let mqtt_options = MqttOptions::new(\"test-pool\", \"localhost\", 1883); let pool = ConnectionPool::new(mqtt_options, 10); let mut clients = Vec::new(); for _ in 0..10 { let client = pool.connect().unwrap(); clients.push(client); } // Do something here}这个示例中，我们创建了一个MQTT连接池，连接到本地的MQTT服务器。然后我们使用循环创建了10个MQTT客户端连接，这些连接会自动被管理和回收。使用多线程在实际应用中，我们通常需要同时处理多个MQTT消息，这时候使用多线程可以提高性能和可靠性。Rust语言的多线程非常方便，可以使用标准库中的std::thread模块来创建线程。12345678910111213141516use rumqttc::{Client, MqttOptions, QoS};use std::thread;fn main() { let mqtt_options = MqttOptions::new(\"test-thread\", \"localhost\", 1883); let (mut client, _) = Client::new(mqtt_options, 10); let handle = thread::spawn(move || { client .publish(\"test/topic\", QoS::AtLeastOnce, false, \"hello world\".to_owned()) .unwrap(); }); handle.join().unwrap();}这个示例中，我们创建了一个MQTT客户端，连接到本地的MQTT服务器。然后我们使用std::thread::spawn方法创建了一个新线程，这个线程会在后台发布一条消息到test/topic主题。持久化存储消息通过持久化存储可以保证消息不会因为程序崩溃或网络故障而丢失。以下是一个使用SQLite数据库持久化存储消息的示例代码：12345678910111213141516171819202122232425262728293031323334353637use std::thread;use rumqttc::{Client, MqttOptions, QoS, Event, Packet, Publish, Subscriptions, Qos};fn main() { let mqtt_options = MqttOptions::new(\"test-7\", \"localhost\", 1883); let (mut client, mut connection) = Client::new(mqtt_options, 10); let subscriptions = vec![Subscriptions::new(\"test/topic\", QoS::AtLeastOnce)]; client.subscribe(subscriptions).unwrap(); let mut storage = Storage::new(\"mqtt.db\").unwrap(); for event in connection.iter() { match event.unwrap() { Event::Incoming(Packet::Publish(publish)) =&gt; { storage.insert_message(&amp;publish).unwrap(); println!(\"Received message: {} from topic: {}\", publish.payload, publish.topic_name); }, _ =&gt; {}, } }}struct Storage { conn: rusqlite::Connection,}impl Storage { fn new(path: &amp;str) -&gt; rusqlite::Result&lt;Self&gt; { let conn = rusqlite::Connection::open(path)?; conn.execute(\"CREATE TABLE IF NOT EXISTS messages (id INTEGER PRIMARY KEY, topic TEXT, payload TEXT, qos INTEGER)\", [])?; Ok(Self { conn }) } fn insert_message(&amp;mut self, publish: &amp;Publish) -&gt; rusqlite::Result&lt;()&gt; { let mut stmt = self.conn.prepare(\"INSERT INTO messages (topic, payload, qos) VALUES (?, ?, ?)\")?; stmt.execute(&amp;[&amp;publish.topic_name, &amp;publish.payload, &amp;publish.qos as &amp;i32])?; Ok(()) }}其中，Storage结构体使用SQLite数据库来持久化存储消息。在Event::Incoming(Packet::Publish(publish))分支中，将接收到的消息插入到数据库中。总结rumqttc模块是一个非常方便的MQTT客户端库，它提供了一系列API，可以方便地实现MQTT协议的功能。本教程作为前一篇的进阶补充提供了常见的实际应用场景的应用示例，希望对您进一步深入的了解和掌握物联网传输协议MQTT有所帮助。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 物联网消息传输协议MQTT(入门)",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, MQTT",
      "url"         : "./rust/2023/05/16/rust_lang_tutorial_235_MQTT_basic.html",
      "date"        : "2023-05-16 00:00:00 +0800",
      "description" : "",
      "content"     : "MQTT（Message Queuing Telemetry Transport）是一种轻量级的消息传输协议，用于在低带宽和不稳定的网络环境中传输消息。MQTT协议基于发布/订阅模式，包含了许多特性，如QoS，保留消息，遗嘱消息等，使得它非常适合物联网设备之间的通信。Rust是一种系统级编程语言，具有内存安全和高性能的特性。Rust语言的主要目标是提供一种安全、并发、实用的编程语言，使得开发者可以轻松地编写高性能的系统级应用程序。本教程将介绍如何使用Rust语言和rumqttc模块来实现MQTT协议的基础应用和进阶应用。rumqttc模块简介rumqttc是一个基于Rust语言实现的MQTT客户端库，它提供了连接MQTT服务器、订阅主题、发布消息等基本功能，并支持TLS加密连接。rumqttc的API简单易用，适合初学者和中级开发者使用。在Cargo.toml文件中添加rumqtt模块依赖, 示例配置如下：12[dependencies]rumqttc = \"0.21.0\"应用实践连接MQTT服务器使用rumqttc连接MQTT服务器非常简单，只需要指定服务器地址和端口号即可。以下是一个连接到本地MQTT服务器的示例代码：12345678910use rumqttc::{Client, MqttOptions};fn main() { let mqtt_options = MqttOptions::new(\"test-1\", \"localhost\", 1883); let (mut client, _) = Client::new(mqtt_options, 10); client .connect() .expect(\"Failed to connect to MQTT server\"); // ...}其中，test-1是客户端ID，可以自行定义。10是消息队列的大小，表示可以同时处理的未确认消息数量。订阅主题订阅MQTT主题可以接收来自其他客户端的消息。使用rumqttc订阅主题也非常简单，只需要指定主题名称和消息处理函数即可。以下是一个订阅主题的示例代码：1234567891011121314use rumqttc::{Client, MqttOptions, QoS};fn main() { let mqtt_options = MqttOptions::new(\"test-2\", \"localhost\", 1883); let (mut client, mut connection) = Client::new(mqtt_options, 10); client .subscribe(\"test/topic\", QoS::AtLeastOnce) .expect(\"Failed to subscribe to topic\"); for message in connection.iter() { if let Ok(message) = message { println!(\"{}\", message.payload_str()); } }}其中，test/topic是要订阅的主题名称，QoS::AtLeastOnce表示消息至少被处理一次，即使出现网络故障或客户端宕机也不会丢失。connection.iter()返回一个迭代器，可以用来不断接收来自服务器的消息。发布消息发布MQTT消息可以向其他客户端发送数据。使用rumqttc发布消息也非常简单，只需要指定主题名称和消息内容即可。以下是一个发布消息的示例代码：12345678910use rumqttc::{Client, MqttOptions, QoS, ReconnectOptions, Transport};fn main() { let mqtt_options = MqttOptions::new(\"test-3\", \"localhost\", 1883); let (mut client, mut connection) = Client::new(mqtt_options, 10); let reconnection_options = ReconnectOptions::Always(10); client .publish(\"test/topic\", QoS::AtLeastOnce, false, \"Hello, world!\") .expect(\"Failed to publish message\");}其中，\"Hello, world!\"是要发送的消息内容，可以是字符串、字节流或其他数据类型。保留消息这个示例演示如何使用rumqttc模块发送和接收保留消息。1234567891011121314use rumqttc::{Client, MqttOptions, QoS};fn main() { let mqtt_options = MqttOptions::new(\"test-retain\", \"localhost\", 1883); let (mut client, _) = Client::new(mqtt_options, 10); client .publish(\"test/topic\", QoS::AtLeastOnce, true, \"hello world\".to_owned()) .unwrap(); let message = client.get_retained(\"test/topic\").unwrap(); println!(\"Received message: {:?}\", message);}这个示例中，我们创建了一个MQTT客户端，连接到本地的MQTT服务器，然后发送了一条保留消息到test/topic主题。在调用publish方法时，我们指定了消息的QoS为AtLeastOnce，表示消息至少要被传输一次，但不保证只传输一次。第三个参数表示消息是否为保留消息。然后我们使用client.get_retained(\"test/topic\")方法获取到保留消息，这个方法会返回最新的保留消息。断开连接使用完rumqttc后，需要手动断开与MQTT服务器的连接。以下是一个断开连接的示例代码：1234567891011use rumqttc::{Client, MqttOptions};fn main() { let mqtt_options = MqttOptions::new(\"test-4\", \"localhost\", 1883); let (mut client, _) = Client::new(mqtt_options, 10); client .connect() .expect(\"Failed to connect to MQTT server\"); // ... client.disconnect().expect(\"Failed to disconnect from MQTT server\");}使用Last Will和Testament这个示例演示如何使用rumqttc模块设置Last Will和Testament。12345678910111213use rumqttc::{Client, LastWill, MqttOptions, QoS};fn main() { let mqtt_options = MqttOptions::new(\"test-lwt\", \"localhost\", 1883); let last_will = LastWill::new(\"test/topic\", QoS::AtLeastOnce, \"offline\".to_owned()); let (mut client, _) = Client::new(mqtt_options, 10); client.set_last_will(last_will).unwrap(); // Do something here}这个示例中，我们创建了一个MQTT客户端，连接到本地的MQTT服务器。然后我们使用LastWill::new方法创建了一个Last Will和Testament，指定了主题、QoS和消息内容。最后我们使用client.set_last_will方法设置了Last Will和Testament。TLS加密连接为了保护MQTT通信的安全性，可以使用TLS加密连接。使用rumqttc实现TLS加密连接也非常简单，只需要指定证书和私钥即可。以下是一个使用TLS加密连接的示例代码：12345678910111213141516use std::fs::File;use std::io::BufReader;use std::path::Path;use rumqttc::{Client, MqttOptions, SecurityOptions};fn main() { let mqtt_options = MqttOptions::new(\"test-5\", \"localhost\", 8883); let security_options = SecurityOptions::with_ca(File::open(Path::new(\"ca.crt\")).unwrap()) .with_client_cert(File::open(Path::new(\"client.crt\")).unwrap(), File::open(Path::new(\"client.key\")).unwrap()); let (mut client, _) = Client::new(mqtt_options, 10); client .set_security_opts(security_options) .connect() .expect(\"Failed to connect to MQTT server\"); // ...}其中，ca.crt是CA证书，client.crt和client.key是客户端证书和私钥。多线程处理消息使用多线程可以提高消息处理的效率和并发性。以下是一个使用多线程处理消息的示例代码：12345678910111213141516171819use std::thread;use rumqttc::{Client, MqttOptions, QoS};fn main() { let mqtt_options = MqttOptions::new(\"test-6\", \"localhost\", 1883); let (mut client, mut connection) = Client::new(mqtt_options, 10); client .subscribe(\"test/topic\", QoS::AtLeastOnce) .expect(\"Failed to subscribe to topic\"); for message in connection.iter() { if let Ok(message) = message { let payload = message.payload.clone(); let topic = message.topic.clone(); thread::spawn(move || { println!(\"Received message: {} from topic: {}\", payload, topic); }); } }}其中，thread::spawn()创建一个新线程来处理消息，可以使用闭包来捕获消息的内容。总结rumqttc模块是一个非常方便的MQTT客户端库，它提供了一系列API，可以方便地实现MQTT协议的功能。本教程提供了几个常见的基础应用示例，希望对您有所帮助。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Tonic RPC框架入门实战",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Tonic",
      "url"         : "./rust/2023/05/09/rust_tonic_tutorial_001_overview.html",
      "date"        : "2023-05-09 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust语言是一种系统级语言，被誉为“没有丧失性能的安全语言”。Rust语言的优势在于其内存安全机制，在编译时就能保证程序的内存安全。Tonic模块是Rust语言的一个RPC（Remote Procedure Call，远程过程调用）框架，它在性能、可靠性、框架友好程度以及可扩展性等方面表现卓越。 本系列 Tonic 篇将由浅入深的从基础到实战，以一个完整的 Rust 语言子系列讲解tonic模块。基础用法添加Tonic依赖在Rust项目的Cargo.toml文件中，加入以下依赖项：12[dependencies]tonic = \"0.9.2\"定义服务在Tonic中，我们需要定义一个服务（service），服务包含了多个方法（method）。下面是一个示例：12345678910111213use tonic::{Request, Response, Status};// 定义一个服务pub struct MyService {}// 为服务实现方法#[tonic::async_trait]impl MyService { async fn my_method(&amp;self, request: Request&lt;MyRequest&gt;) -&gt; Result&lt;Response&lt;MyResponse&gt;, Status&gt; { // 做一些操作 // 返回结果 }}启动服务我们使用tokio库来运行Tonic服务，示例代码如下：123456789101112131415161718use tokio::net::TcpListener;use tonic::transport::Server;#[tokio::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let addr = \"[::]:50051\".parse()?; let listener = TcpListener::bind(addr).await?; let my_service = MyService {}; println!(\"Server listening on {}\", addr); Server::builder() .add_service(MyServiceServer::new(my_service)) .serve_with_incoming(listener) .await?; Ok(())}这个服务绑定在本地的50051端口上，并等待连接。定义请求和响应结构体在Tonic中，我们需要定义请求和响应的结构体，示例代码如下：123456789#[derive(Debug)]pub struct MyRequest { pub name: String,}#[derive(Debug)]pub struct MyResponse { pub message: String,}实现方法我们在服务中，实现一些具体的方法。示例代码如下：123456789101112131415#[tonic::async_trait]impl MyService { async fn my_method(&amp;self, request: Request&lt;MyRequest&gt;) -&gt; Result&lt;Response&lt;MyResponse&gt;, Status&gt; { let req = request.into_inner(); println!(\"Request received: {:?}\", req); // 构造响应 let resp = MyResponse { message: format!(\"Hello, {}!\", req.name), }; Ok(Response::new(resp)) }}调用服务我们可以使用Tonic提供的客户端来调用服务。示例代码如下：123456789101112// 初始化客户端let mut my_service_client = MyServiceClient::connect(\"http://[::1]:50051\").await?;// 构造请求let request = Request::new(MyRequest { name: \"world\".into(),});// 发送请求let response = my_service_client.my_method(request).await?;println!(\"Response received: {:?}\", response);处理错误在Rust中，我们使用Result来处理错误。例如：1234567891011121314151617#[tonic::async_trait]impl MyService { async fn my_method(&amp;self, request: Request&lt;MyRequest&gt;) -&gt; Result&lt;Response&lt;MyResponse&gt;, Status&gt; { let req = request.into_inner(); if req.name == \"\" { return Err(Status::invalid_argument(\"name cannot be empty\")); } // 构造响应 let resp = MyResponse { message: format!(\"Hello, {}!\", req.name), }; Ok(Response::new(resp)) }}这个例子说明，如果请求的name字段是空字符串，将返回Status::invalid_argument错误。使用连接池Tonic提供了连接池的支持，通过这个机制，可以让我们复用连接，从而减少连接的创建和销毁。示例代码如下：123456789use tonic::transport::{Endpoint, Channel, security::ServerTlsOption, client::tls::rustls::RootCertStore};// 初始化连接池let channel = Endpoint::from_static(\"http://[::1]:50051\") .connect_lazy() .unwrap();// 使用连接池let mut my_service_client = MyServiceClient::new(channel);自定义认证Tonic提供了自定义认证机制，例如，我们可以在服务端自定义一段中间件，来进行认证。示例代码如下：123456789101112131415use tonic::{Interceptor, Request, Response, Status};struct AuthMiddleware {}#[tonic::async_trait]impl&lt;O: Send + 'static&gt; Interceptor&lt;O&gt; for AuthMiddleware { async fn call(&amp;mut self, req: Request&lt;O&gt;, next: tonic::interceptor::Next&lt;'_, O&gt;) -&gt; Result&lt;Response&lt;O&gt;, Status&gt; { // 检查用户是否已登录 if !is_user_logged_in() { return Err(Status::unauthenticated(\"user is not logged in\")); } next.run(req).await }}这个例子说明，我们可以利用Interceptor机制，在请求处理前，统一进行认证。支持SSL连接Tonic提供了SSL连接的支持，而且通过TLS选项配置加密和认证选项。示例代码如下：12345678910111213use tonic::{transport::Channel, client::tls::rustls::RootCertStore, transport::{Endpoint, Server}};use tonic::transport::server::TlsConfig;// 初始化SSL连接let root_ca = RootCertStore::from_path(\"ca.pem\").unwrap();let tls = ClientTlsConfig::new().root_ca_cert(root_ca).identity(...);let channel = Endpoint::from_static(\"https://[::1]:50051\") .tls_config(TlsConfig::new().client_tls_config(tls)) .connect() .await?;// 使用SSL连接访问let mut my_service_client = MyServiceClient::new(channel);这个例子说明，我们通过传递确切的TLS选项，在客户端连接时使用SSL。总结在本教程中，我们学习了如何使用Rust语言的Tonic模块创建一个简单的gRPC服务，并深入了解了一些高级功能。我们了解了如何支持TLS加密通信，如何支持自定义的拦截器，如何支持流式传输，以及如何支持异步/非阻塞I/O。我们还提供了一些最佳实践，以帮助您编写高质量的代码。"
    } ,
  
    {
      "title"       : "Python 3.x从基础到实战 - 文件相关操作",
      "category"    : "",
      "tags"        : "python3, python",
      "url"         : "./python3/2023/05/06/python_3x_203_file_operation.html",
      "date"        : "2023-05-06 12:00:00 +0800",
      "description" : "",
      "content"     : "Python是一种高级编程语言，可以轻松地处理各种文件。在Python中，我们可以使用内置的文件操作函数和模块来读取、写入、追加、创建、替换等各种文件操作。本教程将为您提供Python文件操作的详细指南，包括with语句的代码示例以及文件的高级应用示例。open()函数在Python中，我们使用open()函数来打开文件。open()函数返回一个文件对象，它可以用于读取、写入和追加文件。open()函数需要两个参数：文件名和模式。文件名是要打开的文件的名称和路径。模式是打开文件的方式，例如读取、写入、追加等。 file: 可以是文件路径或文件对象。如果是文件路径，需要提供文件的完整路径和文件名，如果是文件对象，可以是一个已经打开的文件对象或者是一个文件流对象。 mode: 打开文件的模式，可以是只读模式（’r’）、写入模式（’w’）、追加模式（’a’）、二进制模式（’b’）等。 buffering: 缓冲区大小，可以设置为0表示不使用缓冲区，设置为1表示使用行缓冲，设置为大于1的整数表示使用指定大小的缓冲区。 encoding: 文件编码，用于指定文件的编码格式，例如UTF-8、GBK等。 errors: 编码错误处理方式，用于指定当读取文件时遇到编码错误时的处理方式，例如忽略错误、替换错误字符等。 newline: 行结束符，用于指定写入文件时使用的行结束符，例如’\\n’表示使用换行符作为行结束符。mode模式的常用参数及注释。 模式 描述 ‘r’ 读取模式，打开文件用于读取（默认值） ‘w’ 写入模式，打开文件用于写入，如果文件已存在，将会覆盖文件 ‘x’ 独占模式，打开文件用于独占写入，如果文件已存在，会抛出FileExistsError异常 ‘a’ 追加模式，打开文件用于追加写入，如果文件不存在，将会创建文件 ‘b’ 二进制模式，打开文件用于二进制读取或写入 ‘t’ 文本模式，打开文件用于文本读取或写入（默认值） ’+’ 读写模式，打开文件用于同时读取和写入 基础文件操作读取文件要读取文件，我们使用模式’r’来打开文件。在这种模式下，文件指针位于文件的开头。我们可以使用read()函数来读取文件的内容。read()函数返回文件的全部内容，或者如果指定了参数，则返回指定数量的字符。123with open('file.txt', 'r') as file: data = file.read() print(data)在上面的代码中，我们打开了一个名为’file.txt’的文件，并将其赋值给变量’file’。然后，我们使用read()函数读取文件的全部内容，并将其赋值给变量’data’。最后，我们使用print()函数输出文件的内容。写入文件要写入文件，我们使用模式’w’来打开文件。在这种模式下，如果文件不存在，则会创建一个新文件。如果文件已经存在，则会覆盖文件的内容。我们可以使用write()函数将数据写入文件。12with open('file.txt', 'w') as file: file.write('Hello, world!')在上面的代码中，我们打开了一个名为’file.txt’的文件，并将其赋值给变量’file’。然后，我们使用write()函数将字符串’Hello, world!’写入文件。追加文件要追加文件，我们使用模式’a’来打开文件。在这种模式下，文件指针位于文件的末尾。我们可以使用write()函数将数据追加到文件的末尾。12with open('file.txt', 'a') as file: file.write('\\nHello, again!')在上面的代码中，我们打开了一个名为’file.txt’的文件，并将其赋值给变量’file’。然后，我们使用write()函数将字符串’\\nHello, again!’追加到文件的末尾。创建文件要创建文件，我们使用模式’x’来打开文件。在这种模式下，如果文件已经存在，则会引发FileExistsError异常。如果文件不存在，则会创建一个新文件。我们可以使用write()函数将数据写入文件。12with open('file.txt', 'x') as file: file.write('Hello, world!')在上面的代码中，我们打开了一个名为’file.txt’的文件，并将其赋值给变量’file’。然后，我们使用write()函数将字符串’Hello, world!’写入文件。如果文件已经存在，则会引发FileExistsError异常。关闭文件在Python中，打开文件后，我们必须关闭文件，以释放资源并保存文件更改。我们可以使用close()函数来关闭文件。123file = open('file.txt', 'r')data = file.read()file.close()在上面的代码中，我们打开了一个名为’file.txt’的文件，并将其赋值给变量’file’。然后，我们使用read()函数读取文件的全部内容，并将其赋值给变量’data’。最后，我们使用close()函数关闭文件。但是，如果在使用文件后忘记关闭文件，则可能会导致资源泄漏和文件损坏。为了避免这种情况，我们可以使用with语句来自动关闭文件。12with open('file.txt', 'r') as file: data = file.read()在上面的代码中，我们使用with语句打开一个名为’file.txt’的文件，并将其赋值给变量’file’。然后，我们使用read()函数读取文件的全部内容，并将其赋值给变量’data’。最后，with语句自动关闭文件。文件相关场景用法除了基本的文件读取、写入、追加和创建操作外，Python还提供了许多高级文件操作。在本节中，我们将介绍四个高级文件应用示例。逐行读取文件在Python中，我们可以使用for循环逐行读取文件。这对于大型文件非常有用，因为它允许我们一次只读取一行，而不是将整个文件读入内存。123with open('file.txt', 'r') as file: for line in file: print(line)在上面的代码中，我们使用with语句打开一个名为’file.txt’的文件，并将其赋值给变量’file’。然后，我们使用for循环逐行读取文件，并将每一行打印到屏幕上。使用json格式读写文件JSON是一种轻量级数据交换格式，通常用于Web应用程序的数据交换。在Python中，我们可以使用json模块来读取和写入JSON格式的文件。1234567891011import json# 写入JSON格式的文件data = {'name': 'John', 'age': 30, 'city': 'New York'}with open('data.json', 'w') as file: json.dump(data, file)# 读取JSON格式的文件with open('data.json', 'r') as file: data = json.load(file) print(data)在上面的代码中，我们导入了json模块。然后，我们使用字典对象创建一个名为’data’的变量。接下来，我们使用json.dump()函数将’data’写入一个名为’data.json’的文件中。最后，我们使用json.load()函数从’data.json’文件中读取数据，并将其赋值给变量’data’。然后，我们使用print()函数输出变量’data’。压缩和解压文件在Python中，我们可以使用gzip模块来压缩和解压文件。gzip模块提供了GzipFile类，它允许我们打开压缩文件，并在其中读取和写入数据。1234567891011import gzip# 压缩文件with open('file.txt', 'rb') as file_in: with gzip.open('file.txt.gz', 'wb') as file_out: file_out.write(file_in.read())# 解压文件with gzip.open('file.txt.gz', 'rb') as file_in: with open('file.txt', 'wb') as file_out: file_out.write(file_in.read())在上面的代码中，我们导入了gzip模块。然后，我们使用with语句打开一个名为’file.txt’的文件，并将其赋值给变量’file_in’。接下来，我们使用with语句打开一个名为’file.txt.gz’的压缩文件，并将其赋值给变量’file_out’。然后，我们使用write()函数将’file_in’中的数据写入’file_out’中。最后，我们使用with语句打开一个名为’file.txt.gz’的压缩文件，并将其赋值给变量’file_in’。接下来，我们使用with语句打开一个名为’file.txt’的文件，并将其赋值给变量’file_out’。然后，我们使用write()函数将’file_in’中的数据写入’file_out’中。使用CSV格式读写文件CSV是一种常用的电子表格文件格式，通常用于数据交换。在Python中，我们可以使用csv模块来读取和写入CSV格式的文件。12345678910111213import csv# 写入CSV格式的文件data = [['name', 'age', 'city'], ['John', '30', 'New York'], ['Mary', '25', 'Los Angeles']]with open('data.csv', 'w', newline='') as file: writer = csv.writer(file) writer.writerows(data)# 读取CSV格式的文件with open('data.csv', 'r') as file: reader = csv.reader(file) for row in reader: print(row)在上面的代码中，我们导入了csv模块。然后，我们使用一个名为’data’的列表对象创建一个CSV格式的数据。接下来，我们使用csv.writer()函数将’data’写入一个名为’data.csv’的文件中。注意，我们需要使用newline=’‘参数来避免在写入文件时出现空行。最后，我们使用csv.reader()函数从’data.csv’文件中读取数据，并使用for循环逐行打印数据。结论在本教程中，我们学习了Python文件操作的基础知识，包括打开、关闭、读取、写入、追加和创建文件。我们还介绍了with语句的使用，以及文件的高级应用示例，包括逐行读取文件、使用json格式读写文件、压缩和解压文件以及使用CSV格式读写文件。这些知识将帮助您在Python中处理各种文件，使您的编程更加高效和有趣。"
    } ,
  
    {
      "title"       : "Struct Util 权威指南 - 配置文件的热重载",
      "category"    : "",
      "tags"        : "JAVA, StructUtil",
      "url"         : "./java/structutil/2023/05/01/Struct_Util_05_File_Hot_Reload.html",
      "date"        : "2023-05-01 00:29:00 +0800",
      "description" : "",
      "content"     : "Struct Util 是一个 Java 语言开发的结构化数据映射处理工具。Struct Util 主要解决两个方面的问题。第一个方面将*.xls, *.csv 等配置友好型数据源转换为业务侧友好型的 bean 结构，对配置数据和使用数据进行解耦，让开发和运营、策划三方实现共赢。第二方面解决了数据表热重载，数据有条件过滤，表结构跨表引用等等应用相关的问题。 StructUtil是博主个人作品, 稍微有自吹自擂的嫌疑, 欢迎:star:收藏。哈哈, 因为是个人作品，应该是足够”权威”了。嘻嘻~~WatchService 注册监听文件变动在 WatchService 注册需要监听的目录路径或文件路径，并指定仅关注 ENTRY_MODIFY 事件，路径相关的全部变动的事件通过 WatchKey#pollEvents()方法获取。核心实现业务代码如下：12345678910111213141516171819202122232425262728293031323334public FileWatcherService register(String dir) throws IOException { return this.register(Paths.get(Objects.requireNonNull(dir, \"dir\")));}public FileWatcherService register(Path dir) throws IOException { Objects.requireNonNull(dir, \"dir\"); WatchKey key = dir.register(ws, StandardWatchEventKinds.ENTRY_MODIFY); Path p = keys.putIfAbsent(key, dir); if (null == p) { LOGGER.info(\"Register file watcher service. path: {}\", dir.toAbsolutePath()); } return this;}public FileWatcherService registerAll(String path) throws IOException { return this.registerAll(Paths.get(path));}/** * Register the given directory, and all its sub-directories, with the * WatchService. */public FileWatcherService registerAll(final Path start) throws IOException { Objects.requireNonNull(start, \"start\"); // register directory and sub-directories Files.walkFileTree(start, new SimpleFileVisitor&lt;&gt;() { @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException { register(dir); return FileVisitResult.CONTINUE; } }); return this;}注册文件变动钩子将路径和文件变动注册到 WatchService 之后，我们还可以注册自定义的 Hook，为了实现 StructStore 的 reload 热重载，我们再 Hook 中调用 reload，当然，也可以执行多个其他自定义方法。1234567891011121314151617181920212223public FileWatcherService registerHook(String fileName, Runnable hook) { return this.registerHook(Paths.get(fileName), hook);}public FileWatcherService registerHook(Path path, Runnable hook) { List&lt;Runnable&gt; list = this.hooksMap.computeIfAbsent(path, p -&gt; Collections.synchronizedList(new ArrayList&lt;&gt;())); list.add(hook); LOGGER.info(\"Register file hook. path: {}\", path.toAbsolutePath()); return this;}public FileWatcherService deregisterHook(String fileName) { return this.deregisterHook(Paths.get(fileName));}public FileWatcherService deregisterHook(Path path) { List&lt;Runnable&gt; l = this.hooksMap.remove(path); if (null != l) { LOGGER.info(\"Deregister file hook. path: {}\", path.toAbsolutePath()); } return this;}示例12345678910111213141516@Testpublic void test() throws IOException { FileWatcherService service = FileWatcherService.newBuilder().setWatchService(mockMs) .setScheduleInitialDelay(10L) .setScheduleTimeUnit(TimeUnit.DAYS) .setScheduleDelay(999L) .setExecutor(Executors.newScheduledThreadPool(1, r -&gt; new Thread(r, \"test\"))) .build(); service.bootstrap(); service.register(\"./\"); service.registerHook(\"./\", () -&gt; { }); // service.deregisterHook(\"./\"); service.run();}核心业务代码解析实现热重载的第一步就是要监听文件的变动，在文件变动时，调用 reload 方法对 Struct 数据进行重加载。Struct Util 中使用 JDK 内置的 WatchService 实现对文件系统的监听。1234567891011121314151617181920212223242526272829303132333435363738/*** Schedule process the file watch events.*/private void process() { try { WatchKey key; Path dir; if ((key = ws.poll()) == null || (dir = keys.get(key)) == null) { LOGGER.debug(\"watch key not registered. key:{}\", key); return; } for (WatchEvent&lt;?&gt; event : key.pollEvents()) { WatchEvent.Kind&lt;?&gt; kind = event.kind(); if (kind == StandardWatchEventKinds.OVERFLOW) { continue; } WatchEvent&lt;Path&gt; ev = (WatchEvent&lt;Path&gt;) event; Path name = ev.context(); Path child = dir.resolve(name); List&lt;Runnable&gt; l = hooksMap.get(child); if (l != null) { try { l.forEach(Runnable::run); } catch (Exception e) { LOGGER.error(\"process data file failure. file:{}\", child.toAbsolutePath(), e); throw e; } } } boolean valid = key.reset(); if (!valid) { this.keys.remove(key); } } catch (Throwable e) { LOGGER.error(\"file watcher service throw an unknown exception.\", e); }}WatchService 的 poll 方法拉取新的文件变动事件，假如没有我们注册的的 WatchKey 则退出。否则使用 WatchKey#pollEvents()获取文件变动事件。StandardWatchEventKind 主要由四个事件组成，分别为： OVERFLOW：事件丢失或失去 ENTRY_CREATE：目录内实体创建或本目录重命名 ENTRY_MODIFY：目录内实体修改 ENTRY_DELETE：目录内实体删除或重命名OVERFLOW 基本上忽略不处理，主要处理 ENTRY_CREATE 和 ENTRY_MODIFY 两种文件变动事件，ENTRY_DELETE 在游戏行业处理的比较少。总结本文讲解了 StructUtil 使用 WatchService 实现文件和目录路径监听，并监听文件变动事件，注册文件变动 Hook，并使用 Hook 实现文件的业务热重载功能。"
    } ,
  
    {
      "title"       : "Struct Util 权威指南 - 通过 SPI 实现自定义扩展",
      "category"    : "",
      "tags"        : "JAVA, StructUtil",
      "url"         : "./java/structutil/2023/05/01/Struct_Util_04_SPI_Custom_Extension.html",
      "date"        : "2023-05-01 00:29:00 +0800",
      "description" : "",
      "content"     : "Struct Util 是一个 Java 语言开发的结构化数据映射处理工具。Struct Util 主要解决两个方面的问题。第一个方面将*.xls, *.csv 等配置友好型数据源转换为业务侧友好型的 bean 结构，对配置数据和使用数据进行解耦，让开发和运营、策划三方实现共赢。第二方面解决了数据表热重载，数据有条件过滤，表结构跨表引用等等应用相关的问题。 StructUtil是博主个人作品, 稍微有自吹自擂的嫌疑, 欢迎:star:收藏。哈哈, 因为是个人作品，应该是足够”权威”了。嘻嘻~~SPI 扩展Struct Util 提供了 Converters, Converter, StructFactoryBean, StructHandler四个扩展点，允许用户进行功能扩展。EnhancedServiceLoader相比于 JDK 内置的 SPI 功能解决了加载异常处理，懒加载等问题。核心加载代码如下：123456789101112131415161718192021222324252627282930313233343536void handleDefinitionFile(String dir, ClassLoader classLoader, List&lt;ExtensionDefinition&gt; output) throws IOException { String fileName = dir + this.service.getName(); Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(fileName) : ClassLoader.getSystemResources(fileName); while (urls.hasMoreElements()) { URL url = urls.nextElement(); try (BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), StandardCharsets.UTF_8))) { String line = null; while (null != (line = reader.readLine())) { line = line.trim(); if (line.length() &gt; 0) { try { output.add(this.createExtensionDefinition(line, classLoader)); } catch (LinkageError | ClassNotFoundException e) { LOGGER.warn(\"load [{}] class failure. {}\", line, e.getMessage()); } } } } catch (Throwable e) { LOGGER.warn(\"handle extension definition file error.\", e); } }}ExtensionDefinition createExtensionDefinition(String clzName, ClassLoader loader) throws ClassNotFoundException { Class&lt;?&gt; clzOfService = Class.forName(clzName, true, loader); String name = null; int order = 0; SPI anno = AnnotationUtils.findAnnotation(SPI.class, clzOfService); if (anno != null) { name = anno.name(); order = anno.order(); } return new ExtensionDefinition(name, clzOfService, order);}自定义 ConverterStruct Util内置了常用的类型转换器, 当用户有特殊转换需求时，可以通过扩展 Converter 接口实现转换业务，并通过 SPI 机制自动注册到系统中。以下是一个简单的字符串转数组的转换器实例。1234567891011121314151617181920212223public class StringToArrayConverter implements Converter { @Override public Object convert(Object originValue, Class&lt;?&gt; targetType) { if (!targetType.isArray() || String.class != originValue.getClass()) { return null; } String content = (String) originValue; Class&lt;?&gt; componentType = targetType.getComponentType(); String[] data = content.split(separator); if (exceptBlank) { data = Arrays.stream(data) .map(String::trim) .filter(s -&gt; !s.isEmpty()) .toArray(String[]::new); } Object array = Array.newInstance(componentType, data.length); for (int i = 0; i &lt; data.length; i++) { Array.set(array, i, ConverterUtil.covert(data[i], componentType)); } return array; }}"
    } ,
  
    {
      "title"       : "Struct Util 权威指南 - 集成到Spring Boot全家桶",
      "category"    : "",
      "tags"        : "JAVA, StructUtil",
      "url"         : "./java/structutil/2023/05/01/Struct_Util_03_Spring_Boot.html",
      "date"        : "2023-05-01 00:29:00 +0800",
      "description" : "",
      "content"     : "Struct Util 是一个 Java 语言开发的结构化数据映射处理工具。Struct Util 主要解决两个方面的问题。第一个方面将*.xls, *.csv 等配置友好型数据源转换为业务侧友好型的 bean 结构，对配置数据和使用数据进行解耦，让开发和运营、策划三方实现共赢。第二方面解决了数据表热重载，数据有条件过滤，表结构跨表引用等等应用相关的问题。 StructUtil是博主个人作品, 稍微有自吹自擂的嫌疑, 欢迎:star:收藏。哈哈, 因为是个人作品，应该是足够”权威”了。嘻嘻~~struct-spring-boot-starter 模块struct-spring-boot-starter 主要是针对 struct-spring 的扩展，用于支持 Spring Boot 框架，通过自动化配置，降低 struct-spring 的使用门槛。 模块依赖 Spring Boot 2.5.x 版本, 更高版本未经过测试.首先引入依赖包1implementation('org.structutil:struct-spring-boot-starter:{VERSION}')前缀 struct 配置 注解名称 缺省值 可选字段 备注 structRequiredDefault false Y 字段依赖缺省值, 字段必须不为null ignoreEmptyRow true Y 是否忽略数据源中的空行 arrayConverter.stringSeparator ’|’ Y 数组转换器的分隔符 arrayConverter.stringTrim true Y 是否调用trim方法处理字符串 arrayConverter.ignoreBlank false Y 是否忽略空字符串 前缀 struct.store.service 配置定义数据文件的结构. 注解名称 缺省值 可选字段 备注 workspace ’./data/’ N 工作空间根目录路径 lazyLoad true Y 是否按需加载，异步加载. watchFile true Y 是否启用文件变动监听 scheduleInitialDelay 10000 Y watchFile为true时有效，初始定时检查任务的时间. scheduleDelay 5000 Y watchFile为true时有效，定时检查任务的间隔时间. scheduleTimeUnit SECONDS Y watchFile为true时有效，定时检查任务的时间单位. banner true Y 打印Struct Util的Banner. Spring 框架 缺省配置12345678910111213141516171819#===================================== Struct Util Configuration ======================================# 是否启用spring-boot-starter自动配置. 默认:truestruct.store.enable=true# 是否开启StructStoreService服务. 默认:truestruct.store.service.enable=true# 工作空间struct.store.service.workspace=./data/# StructStore是否通过懒加载方式初始化. 默认:truestruct.store.service.lazy-load=false# 是否启用FileWatchService监控文件变更. 默认:truestruct.store.service.watch-file=true# 文件变更监控的扫描定时任务初始间隔. 默认:10struct.store.service.schedule-initial-delay=10# 文件变更监控的扫描间隔. 默认:5struct.store.service.schedule-delay=5# 文件变更监控的扫描间隔时间单位. 默认:秒struct.store.service.schedule-time-unit=SECONDS# 懒加载模式下，在读取数据时, StructStore为初始化完成时，是否同步等待加载完成. 魔人:truestruct.store.service.sync-wait-for-init=true"
    } ,
  
    {
      "title"       : "Struct Util 权威指南 - 与Spring Framework框架集成",
      "category"    : "",
      "tags"        : "JAVA, StructUtil",
      "url"         : "./java/structutil/2023/05/01/Struct_Util_02_Spring_Framework.html",
      "date"        : "2023-05-01 00:29:00 +0800",
      "description" : "",
      "content"     : "Struct Util 是一个 Java 语言开发的结构化数据映射处理工具。Struct Util 主要解决两个方面的问题。第一个方面将*.xls, *.csv 等配置友好型数据源转换为业务侧友好型的 bean 结构，对配置数据和使用数据进行解耦，让开发和运营、策划三方实现共赢。第二方面解决了数据表热重载，数据有条件过滤，表结构跨表引用等等应用相关的问题。 StructUtil是博主个人作品, 稍微有自吹自擂的嫌疑, 欢迎:star:收藏。哈哈, 因为是个人作品，应该是足够”权威”了。嘻嘻~~struct-spring 模块struct-spring 主要是针对 struct-core 的扩展，用于支持 Spring Framework，并利用 Spring 框架的众多特性扩展增强 struct-core 功能。新增了@AutoStruct @StructScan @StructStoreOptions 三个注解。首先引入依赖包1implementation('org.structutil:struct-spring:{VERSION}')@AutoStruct结构体自动托管注解, 显示的指明这个类是一个 Struct，并且需要托管给 Spring Framework 容器。 属性 缺省值 可选字段 备注 clzOfStore ’’ Y 数据结构存储的集合类型 ListStructStore MapStructStore 或者其他 StructStore 接口的自定义实现 mapKey ’’ Y 当 MapStructStore 结构时, 用于解决键值对的 key keyResolverBeanName ’’ Y 当 MapStructStore 结构时, 用于解决键值对的 key 的 容器中 resolver 的名称 keyResolverBeanClass StructKeyResolver.class Y 当 MapStructStore 结构时, 用于解决键值对的 key 的类对象 示例代码如下：12345@AutoStruct(keyResolverBeanName = \"dataStructKeyResolver\")@StructSheet(fileName = \"cfg_animal.xlsx\", sheetName = \"Sheet1\")public class Animal {// ...}或者 XML 风格1234&lt;bean id=\"store_1\" class=\"org.struct.spring.support.MapStructStore\"&gt; &lt;property name=\"clzOfBean\" value=\"org.struct.examples.Animal\"/&gt; &lt;property name=\"keyResolverBeanName\" value=\"dataStructKeyResolver\"/&gt;&lt;/bean&gt;@StructScan托管数据结构扫描器。集成到 Spring Framework 框架中，再启动时扫描类路径并处理托管的 Struct 示例。1234567891011121314151617181920212223242526272829303132333435363738394041public @interface StructScan { /** * Alias for {@link #basePackages}. * &lt;p&gt;Allows for more concise annotation declarations if no other attributes * are needed &amp;mdash; for example, {@code @ComponentScan(\"org.my.pkg\")} * instead of {@code @ComponentScan(basePackages = \"org.my.pkg\")}. */ String[] value() default {}; /** * Base packages to scan for annotated components. * &lt;p&gt;{@link #value} is an alias for (and mutually exclusive with) this * attribute. * &lt;p&gt;Use {@link #basePackageClasses} for a type-safe alternative to * String-based package names. */ String[] basePackages() default {}; /** * Type-safe alternative to {@link #basePackages} for specifying the packages * to scan for annotated components. The package of each class specified will be scanned. * &lt;p&gt;Consider creating a special no-op marker class or interface in each package * that serves no purpose other than being referenced by this attribute. */ Class&lt;?&gt;[] basePackageClasses() default {}; /** * The {@link BeanNameGenerator} class to be used for naming detected components * within the Spring container. * &lt;p&gt;The default value of the {@link BeanNameGenerator} interface itself indicates * that the scanner used to process this {@code @ComponentScan} annotation should * use its inherited bean name generator, e.g. the default * {@link AnnotationBeanNameGenerator} or any custom instance supplied to the * application context at bootstrap time. * * @see AnnotationConfigApplicationContext#setBeanNameGenerator(BeanNameGenerator) */ Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class;}@StructStoreOptions 配置 属性 缺省值 可选字段 备注 workspace ’./data/’ Y 配置数据的根目录 lazyLoad false Y 是否允许异步加载配置数据 waitForInit false Y 当其他线程正在加载数据时，是否同步等待初始化完成 Struct 数据管理集成到 Spring Framework 的最大一点好处就是可以托管给 Spring 容器管理我们的配置数据，并使用 IOC 特性和业务解耦。Struct 数据管理服务 StructStoreService123public class StructStoreService implements BeanPostProcessor, SmartInitializingSingleton, DisposableBean { // ....}StructStoreService 类实现了三个 Spring 框架的接口 BeanPostProcessor, SmartInitializingSingleton, DisposableBean，用于管理 StructStore 的初始化和完整的生命周期。Service 中总结和内置博主业务中常用的一些方法。列表如下： 方法 备注 void initialize(Class clzOfBean) 初始化 void reload(Class clzOfBean) 重加载 void dispose(Class clzOfBean) 销毁 List getAll(Class clzOfBean) 获取全部 Struct 实例 B get(Class clzOfBean, K key) 根据 key 获取 Struct 实例 B getOrDefault(Class clzOfBean, K key, B dv) 根据 key 获取 Struct 实例，不存在时返回缺省值 Optional tryGet(Class clzOfBean, K key) 尝试根据 key 获取 Struct 实例 List lookup(Class clzOfBean, K… keys) 根据 key 列表获取 Struct 实例列表 List lookup(Class clzOfBean, Predicate filter) 根据条件筛选 Struct 实例列表 列表数据结构存储 ListStructStore以 List 的形式管理 Struct 数据。键值对数据结构存储 MapStructStore以 Map 的形式管理 Struct 数据。StructKeyResolver通过传入 Bean 并获取 MapStructStore 的 key 字段值。1234567891011/** * {@link MapStructStore} key's resolver. * * @author TinyZ. * @version 2020.07.17 */@FunctionalInterfacepublic interface StructKeyResolver&lt;K, B&gt; { K resolve(B bean);}"
    } ,
  
    {
      "title"       : "Struct Util 权威指南 - 基础应用入门实战",
      "category"    : "",
      "tags"        : "JAVA, StructUtil",
      "url"         : "./java/structutil/2023/05/01/Struct_Util_01_Usage.html",
      "date"        : "2023-05-01 00:29:00 +0800",
      "description" : "",
      "content"     : "Struct Util 是一个 Java 语言开发的结构化数据映射处理工具。Struct Util 主要解决两个方面的问题。第一个方面将*.xls, *.csv 等配置友好型数据源转换为业务侧友好型的 bean 结构，对配置数据和使用数据进行解耦，让开发和运营、策划三方实现共赢。第二方面解决了数据表热重载，数据有条件过滤，表结构跨表引用等等应用相关的问题。 StructUtil是博主个人作品, 稍微有自吹自擂的嫌疑, 欢迎:star:收藏。哈哈, 因为是个人作品，应该是足够”权威”了。嘻嘻~~基础入门框架核心由两个注解组成，业务代码也是围绕着两个注解实现的。下面我们根据注解中定义的属性学习一下 @StructSheet 和 @StructField 两个注解。@StructSheet 注解定义数据文件的结构. 注解名称 缺省值 可选字段 备注 fileName ’’ N 数据文件名称, 带文件的后缀名. e.g. struct.xlsx sheetName ‘Sheet1’ Y 表单名称. 针对 Excel 文件的包含多个 Sheet startOrder 1 Y 控制文件读取的开始. 缺省为: 1 从 excel 的 1 行(第一行为 0)或文件的第一行开始 endOrder -1 Y 控制文件读取的结束. 缺省为:-1 matcher WorkerMatcher.class Y 自定义 WorkHandler, 可以根据条件指定处理的 StructHandler. filter StructBeanFilter.class Y 过滤、筛选符合条件的数据结构. @StructField 注解定义列结构. 注解名称 缺省值 可选字段 备注 name ’’ Y 数据文件中的列名, 当设置非空字符串时，使用注解的值替代类文件中的字段名 ref Object.class Y 引用其他结构 refGroupBy {} Y 当 ref 值有效时, 引用的结构数据根据字段进行分组 refUniqueKey {} Y 当 ref 值有效时, 引用的结构数据根据字段转换为 Map aggregateBy ’’ Y 根据父结构中的字段值，对子结构进行聚合. 类似于 groupBy 的功能. aggregateType Object.class Y 当 aggregateBy 生效时，聚合的集合类型. 不支持 Map required false Y 字段值非空检查. 设置为 True 时, 字段值必须为非 null 的值. converter 无 Y 将数据文件中的数据转换为期望的 JO ref, refGroupBy, refUniqueKey 引用关系，groupby 将子数据集进行分组，uniqueKey 将子数据集的键值对的 key，主要是根据子数据集的字段进行数据划分和处理。aggregateBy, aggregateType 使用父集合中的数据进行聚合处理，类型进支持数组和 List，暂时不支持聚合键值对。converter 支持可扩展的字段类型转换器。定义 Animal 类型定义一个 Animal 的 Struct 结构，包含 name age weight 三个字段。结构对应的数据文件为”cfg_animal.xlsx”。1234567@StructSheet(fileName = \"../cfg_animal.xlsx\")public class Animal { private String name; private int age; private int weight;}使用 StructWorker 进行数据加载。123456@Testpublic void test() { StructWorker&lt;Animal&gt; worker = WorkerUtil.newWorker(\"./data/\", Animal.class); ArrayList&lt;Animal&gt; list = worker.load(ArrayList::new); // ...}使用 @StructOptional 注解聚合异构对象某些业务场景中我们可能需要聚合不同数据结构的类型到同一个表中。123456789101112@StructSheet(fileName = \"../cfg_animal.xlsx\")public class Animal { private String name; private int age; private int weight; @StructOptional(value = { @StructField(ref = ExtraData1.class, refUniqueKey = \"id\"), @StructField(ref = ExtraData2.class, refUniqueKey = \"id\") }) private Object extra;}根据 value 的 @StructField 顺序尝试解析引用数据，一直到找到某个值为止。例如动物的科属目信息，每个动物皆不相同，需要在总 Animal 信息集成。"
    } ,
  
    {
      "title"       : "Struct Util 权威指南 - 框架简介",
      "category"    : "",
      "tags"        : "JAVA, StructUtil",
      "url"         : "./java/structutil/2023/05/01/Struct_Util_00_Overview.html",
      "date"        : "2023-05-01 00:29:00 +0800",
      "description" : "",
      "content"     : "Struct Util 是一个 Java 语言开发的结构化数据映射处理工具。Struct Util 主要解决两个方面的问题。第一个方面将*.xls, *.csv 等配置友好型数据源转换为业务侧友好型的 bean 结构，对配置数据和使用数据进行解耦，让开发和运营实现共赢。第二方面解决了数据表热重载，数据有条件过滤，表结构跨表引用等等应用相关的问题。 StructUtil是博主个人作品, 稍微有自吹自擂的嫌疑, 欢迎:star:收藏。哈哈, 因为是个人作品，应该是足够”权威”了。嘻嘻~~ 由于包名和包路径不符合 maven repo 的管理要求，没有推送到 maven repo，有兴趣尝试的同学可以尝试 github 下载或者自行编译发布本地。功能特性 低侵入。对已有的代码仅需使用 StructField 和 StructSheet 两个注解 高性能、低内存占用。使用增量或 Stream API 的方式避免大文件读取带来的低性能、高内存占用的问题 扩展性。提供 WorkerMatcher、StructHandler、Converter 等扩展点供用户实现自定义扩展功能 结构化数据自动校验和检查。自动检查校验结构化数据及依赖之间的关系。避免出现循环依赖等问题 丰富的内置解析器。内置提供 .xls、.xlsx、.json、.xml 四种常见结构化数据的解析器（扩展中） 丰富的 JDK 原生类的类型转换支持 自定义类型转换器{Converter} 灵活的结构化数据整理机制。输出的结果支持 Array、List、Map、Vector、Set 等 JDK 内置或自定义的集合容器 灵活的文件变更监听和结构化数据文件动态加载能力 支持 Record 类型(JDK 16+).架构设计参考资料"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Tokio进行优雅的停机",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, tokio",
      "url"         : "./rust/2023/04/30/rust_tokio_tutorial_010_shutdown.html",
      "date"        : "2023-04-30 00:00:00 +0800",
      "description" : "",
      "content"     : "在进行高并发、网络编程时，优雅停机是一个非常重要的问题。在 Rust 语言中，Tokio 是一个非常流行的异步编程框架，它提供了一些优雅停机的机制，本文将围绕 Tokio 模块的优雅停机进行详细的讲解。Tokio 模块简介Tokio 是 Rust 语言中的异步编程框架，它提供了一些基础的异步编程工具，如异步 IO、任务调度等。Tokio 的异步编程模型基于 Future 和 Task，其中 Future 代表异步计算的结果，而 Task 则代表异步计算的执行上下文。Tokio 的任务调度器会负责管理所有的 Task，并在 Future 完成时将其推入相应的 Task 中执行。优雅停机的意义在进行网络编程时，服务器需要处理大量的请求，而在某些情况下，服务器需要停止服务。如果直接关闭服务器，会导致正在处理的请求被中断，可能会导致数据丢失或者服务不可用。因此，在关闭服务器时，需要进行优雅停机，即在关闭服务器之前，需要等待所有请求处理完毕，并且不再接受新的请求。Tokio 模块的优雅停机在 Tokio 模块中，提供了一些优雅停机的机制，包括： 优雅停机信号 优雅停机超时 优雅停机任务下面将详细介绍这些机制。优雅停机信号优雅停机信号是一种通知服务器进行优雅停机的机制。在 Unix 系统中，常用的优雅停机信号是 SIGTERM 和 SIGINT。当收到这些信号时，服务器应该停止接受新的请求，并等待正在处理的请求完成。在 Tokio 模块中，可以使用 tokio_signal 模块来监听优雅停机信号。下面是一个示例代码：1234567891011121314151617181920use tokio::signal::unix::{Signal, SIGTERM, SIGINT};#[tokio::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { // 创建信号监听器 let mut sigterm = Signal::new(SIGTERM)?; let mut sigint = Signal::new(SIGINT)?; // 等待信号 tokio::select! { _ = sigterm.recv() =&gt; { println!(\"Received SIGTERM, shutting down gracefully...\"); } _ = sigint.recv() =&gt; { println!(\"Received SIGINT, shutting down gracefully...\"); } } Ok(())}在上面的代码中，我们使用 Signal::new 函数创建了两个信号监听器，分别监听 SIGTERM 和 SIGINT 信号。然后使用 tokio::select!宏来等待信号的到来，如果收到信号，则输出相应的日志信息。优雅停机超时在等待正在处理的请求完成时，可能会出现请求处理时间过长的情况。为了避免服务停机时间过长，需要设置一个优雅停机的超时时间。如果在超时时间内，请求还没有处理完成，则直接关闭服务器。在 Tokio 模块中，可以使用 tokio::time 模块来设置超时时间。下面是一个示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142use tokio::signal::unix::{Signal, SIGTERM, SIGINT};use tokio::time::{sleep, Duration};const GRACEFUL_SHUTDOWN_TIMEOUT: u64 = 30;#[tokio::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { // 创建信号监听器 let mut sigterm = Signal::new(SIGTERM)?; let mut sigint = Signal::new(SIGINT)?; // 等待信号 tokio::select! { _ = sigterm.recv() =&gt; { println!(\"Received SIGTERM, shutting down gracefully...\"); } _ = sigint.recv() =&gt; { println!(\"Received SIGINT, shutting down gracefully...\"); } } // 等待请求处理完成 let start_time = std::time::Instant::now(); while start_time.elapsed().as_secs() &lt; GRACEFUL_SHUTDOWN_TIMEOUT { if is_all_request_completed() { break; } sleep(Duration::from_secs(1)).await; } // 如果请求还没有处理完成，则直接关闭服务器 if !is_all_request_completed() { println!(\"Graceful shutdown timeout, closing server...\"); } Ok(())}fn is_all_request_completed() -&gt; bool { // 判断是否所有请求都已经处理完成 true}在上面的代码中，我们使用 tokio::time::sleep 函数来等待请求处理完成，并设置了一个超时时间。如果在超时时间内，请求还没有处理完成，则直接关闭服务器。优雅停机任务在等待正在处理的请求完成时，可能需要执行一些清理操作，如关闭数据库连接、释放资源等。为了避免这些清理操作被中断，需要将它们封装成一个优雅停机任务，在服务器关闭之前执行。在 Tokio 模块中，可以使用 tokio::task::spawn_blocking 函数来创建一个优雅停机任务。下面是一个示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556use tokio::signal::unix::{Signal, SIGTERM, SIGINT};use tokio::time::{sleep, Duration};use tokio::task::spawn_blocking;const GRACEFUL_SHUTDOWN_TIMEOUT: u64 = 30;#[tokio::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { // 创建信号监听器 let mut sigterm = Signal::new(SIGTERM)?; let mut sigint = Signal::new(SIGINT)?; // 等待信号 tokio::select! { _ = sigterm.recv() =&gt; { println!(\"Received SIGTERM, shutting down gracefully...\"); } _ = sigint.recv() =&gt; { println!(\"Received SIGINT, shutting down gracefully...\"); } } // 执行优雅停机任务 let graceful_shutdown_task = spawn_blocking(|| { // 执行清理操作 cleanup(); }); // 等待请求处理完成 let start_time = std::time::Instant::now(); while start_time.elapsed().as_secs() &lt; GRACEFUL_SHUTDOWN_TIMEOUT { if is_all_request_completed() { break; } sleep(Duration::from_secs(1)).await; } // 等待优雅停机任务完成 graceful_shutdown_task.await.unwrap(); // 如果请求还没有处理完成，则直接关闭服务器 if !is_all_request_completed() { println!(\"Graceful shutdown timeout, closing server...\"); } Ok(())}fn is_all_request_completed() -&gt; bool { // 判断是否所有请求都已经处理完成 true}fn cleanup() { // 执行清理操作}在上面的代码中，我们使用 tokio::task::spawn_blocking 函数创建了一个优雅停机任务，用于执行清理操作。在等待请求处理完成时，我们等待这个任务完成，并在关闭服务器之前执行清理操作。总结在本文中，我们介绍了 Tokio 模块的优雅停机机制，包括优雅停机信号、优雅停机超时和优雅停机任务。这些机制可以帮助我们在服务器关闭时，避免数据丢失和服务不可用的问题。在实际应用中，我们应该根据具体情况选择合适的优雅停机机制，并且在优雅停机任务中执行必要的清理操作。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Tokio结合tracing模块实践",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, tokio",
      "url"         : "./rust/2023/04/30/rust_tokio_tutorial_009_tracing.html",
      "date"        : "2023-04-30 00:00:00 +0800",
      "description" : "",
      "content"     : "在 Rust 语言中，Tokio 是一个非常流行的异步运行时，它提供了高效的异步 I/O 操作和任务调度。而 Tracing 则是一个用于应用程序跟踪的框架，它可以帮助我们理解应用程序的行为和性能，并在调试和故障排除时提供有用的信息。在本教程中，我们将介绍如何使用 Tokio 和 Tracing 模块来构建一个异步的网络应用程序，并使用 Tracing 来记录应用程序的行为和性能。我们将从安装和配置开始，然后介绍如何使用 Tokio 和 Tracing 来编写异步网络代码，最后提供一些示例代码来帮助您开始构建自己的应用程序。安装和配置在使用 Tokio 和 Tracing 之前，我们需要安装它们并配置我们的 Rust 开发环境。首先，我们需要确保我们的 Rust 版本是最新的，并且我们已经安装了 Cargo。接下来，我们需要将 Tokio 和 Tracing 添加到我们的 Cargo.toml 文件中：12345[dependencies]tokio = { version = \"1\", features = [\"full\"] }tracing = \"0.1\"tracing-futures = \"0.2\"tracing-attributes = \"0.1\"这将使 Cargo 下载并安装 Tokio 和 Tracing 及其相关依赖项。使用 Tokio 和 Tracing 编写异步网络代码现在，我们已经安装了 Tokio 和 Tracing，让我们开始编写异步网络代码。首先，我们需要导入 Tokio 和 Tracing 模块：1234use tokio::net::TcpListener;use tokio::prelude::*;use tracing::{debug, error, info, span, Level};use tracing_futures::Instrument;接下来，我们需要编写一个异步函数来处理客户端连接。这个函数将接受一个 TcpStream 作为参数，并将客户端的数据读取到一个缓冲区中，然后将响应写回客户端。12345678910111213async fn handle_client(mut stream: TcpStream) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let mut buf = [0; 1024]; loop { let n = stream.read(&amp;mut buf).await?; if n == 0 { return Ok(()); } stream.write_all(&amp;buf[0..n]).await?; }}现在，我们需要编写一个异步函数来监听传入的连接。这个函数将创建一个 TcpListener 并循环接受传入的连接。对于每个新连接，它将使用 handle_client 函数处理它。123456789101112131415161718192021async fn run_server() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let listener = TcpListener::bind(\"127.0.0.1:8080\").await?; let mut incoming = listener.incoming(); while let Some(stream) = incoming.next().await { let stream = stream?; let span = span!(Level::INFO, \"client\", remote_addr = %stream.peer_addr()?); let _enter = span.enter(); debug!(\"accepted connection\"); tokio::spawn(async move { handle_client(stream) .instrument(span!(Level::INFO, \"handle_client\")) .await .unwrap_or_else(|e| error!(\"error: {:?}\", e)); }); } Ok(())}在这个函数中，我们使用 tokio::spawn 来启动一个新的异步任务来处理每个客户端连接。我们还使用 Tracing 来记录我们的应用程序行为和性能。示例代码下面是一个完整的示例代码，演示如何使用 Tokio 和 Tracing 来构建一个异步的网络应用程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051use tokio::net::TcpListener;use tokio::prelude::*;use tracing::{debug, error, info, span, Level};use tracing_futures::Instrument;async fn handle_client(mut stream: TcpStream) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let mut buf = [0; 1024]; loop { let n = stream.read(&amp;mut buf).await?; if n == 0 { return Ok(()); } stream.write_all(&amp;buf[0..n]).await?; }}async fn run_server() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let listener = TcpListener::bind(\"127.0.0.1:8080\").await?; let mut incoming = listener.incoming(); while let Some(stream) = incoming.next().await { let stream = stream?; let span = span!(Level::INFO, \"client\", remote_addr = %stream.peer_addr()?); let _enter = span.enter(); debug!(\"accepted connection\"); tokio::spawn(async move { handle_client(stream) .instrument(span!(Level::INFO, \"handle_client\")) .await .unwrap_or_else(|e| error!(\"error: {:?}\", e)); }); } Ok(())}#[tokio::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { tracing_subscriber::fmt::init(); info!(\"starting server\"); run_server().await?; Ok(())}在这个示例代码中，我们使用 tokio::main 宏来启动我们的异步应用程序。我们还使用 Tracing 的 fmt 订阅者来记录应用程序的行为和性能。结论在本教程中，我们介绍了如何使用 Tokio 和 Tracing 模块来构建一个异步的网络应用程序，并使用 Tracing 来记录应用程序的行为和性能。我们还提供了一些示例代码来帮助您开始构建自己的应用程序。如果您想深入了解 Tokio 和 Tracing，可以查看官方文档和示例代码，以及其他开发者的博客和文章。祝您在 Rust 语言中编写高效的异步应用程序！"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 深入理解Tokio的Stream",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, tokio",
      "url"         : "./rust/2023/04/30/rust_tokio_tutorial_008_stream.html",
      "date"        : "2023-04-30 00:00:00 +0800",
      "description" : "",
      "content"     : "在 Rust 语言中，Tokio 是一个非常流行的异步编程框架。它提供了一系列的模块，其中最常用的就是 Stream 模块。Stream 模块允许我们以异步的方式处理数据流，这在很多情况下非常有用。在本教程中，我们将介绍 Stream 模块的基础用法和进阶用法，并提供示例。基础用法在本节中，我们将介绍 Stream 模块的基础用法，并提供基础示例。从 Vec 中创建 Stream首先，我们将从一个 Vec 中创建一个 Stream。假设我们有一个包含数字 1 到 10 的 Vec，我们可以使用stream::iter函数来创建一个 Stream。1234567891011use tokio::stream::StreamExt;#[tokio::main]async fn main() { let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; let mut stream = tokio::stream::iter(vec); while let Some(num) = stream.next().await { println!(\"{}\", num); }}在上面的代码中，我们使用了StreamExt trait 中的next方法来遍历 Stream 中的每个元素。注意，我们需要使用await关键字来等待每个元素的到来。从文件中创建 Stream接下来，我们将介绍如何从文件中创建一个 Stream。假设我们有一个名为data.txt的文件，其中包含一些文本行。我们可以使用tokio::fs::File::open方法来打开文件，并使用tokio::io::BufReader来读取文件中的每一行。123456789101112use tokio::io::{AsyncBufReadExt, BufReader};use tokio::fs::File;#[tokio::main]async fn main() { let file = File::open(\"data.txt\").await.unwrap(); let mut reader = BufReader::new(file).lines(); while let Some(line) = reader.next_line().await.unwrap() { println!(\"{}\", line); }}在上面的代码中，我们使用了AsyncBufReadExt trait 中的next_line方法来遍历 Stream 中的每个元素。注意，我们需要使用await关键字来等待每个元素的到来。使用 Stream 的 map 方法接下来，我们将介绍如何使用 Stream 的map方法来对 Stream 中的元素进行转换。假设我们有一个包含数字 1 到 10 的 Vec，我们可以使用stream::iter函数来创建一个 Stream，并使用map方法将每个数字乘以 2。1234567891011use tokio::stream::StreamExt;#[tokio::main]async fn main() { let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; let mut stream = tokio::stream::iter(vec).map(|x| x * 2); while let Some(num) = stream.next().await { println!(\"{}\", num); }}在上面的代码中，我们使用了map方法将每个数字乘以 2。这种方式非常适合对 Stream 中的元素进行转换。使用 Stream 的 filter 方法接下来，我们将介绍如何使用 Stream 的filter方法来过滤 Stream 中的元素。假设我们有一个包含数字 1 到 10 的 Vec，我们可以使用stream::iter函数来创建一个 Stream，并使用filter方法将大于 5 的数字过滤出来。1234567891011use tokio::stream::StreamExt;#[tokio::main]async fn main() { let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; let mut stream = tokio::stream::iter(vec).filter(|x| *x &gt; 5); while let Some(num) = stream.next().await { println!(\"{}\", num); }}在上面的代码中，我们使用了filter方法将大于 5 的数字过滤出来。这种方式非常适合对 Stream 中的元素进行过滤。使用 Stream 的 take 方法接下来，我们将介绍如何使用 Stream 的take方法来限制 Stream 中的元素数量。假设我们有一个包含数字 1 到 10 的 Vec，我们可以使用stream::iter函数来创建一个 Stream，并使用take方法限制只输出前 3 个数字。1234567891011use tokio::stream::StreamExt;#[tokio::main]async fn main() { let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; let mut stream = tokio::stream::iter(vec).take(3); while let Some(num) = stream.next().await { println!(\"{}\", num); }}在上面的代码中，我们使用了take方法限制只输出前 3 个数字。这种方式非常适合对 Stream 中的元素数量进行限制。使用 Stream 的 fold 方法最后，我们将介绍如何使用 Stream 的fold方法来对 Stream 中的元素进行累加。假设我们有一个包含数字 1 到 10 的 Vec，我们可以使用stream::iter函数来创建一个 Stream，并使用fold方法将每个数字相加。123456789use tokio::stream::StreamExt;#[tokio::main]async fn main() { let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; let sum = tokio::stream::iter(vec).fold(0, |acc, x| async move { acc + x }).await; println!(\"{}\", sum);}在上面的代码中，我们使用了fold方法将每个数字相加。注意，我们需要使用async move关键字来让闭包具有异步能力。进阶用法在本节中，我们将介绍 Stream 模块的进阶用法，并提供进阶示例。使用 Stream 的 buffer_unordered 方法首先，我们将介绍如何使用 Stream 的buffer_unordered方法来并发处理 Stream 中的元素。假设我们有一个包含数字 1 到 10 的 Vec，我们可以使用stream::iter函数来创建一个 Stream，并使用buffer_unordered方法并发处理每个数字。1234567891011use tokio::stream::StreamExt;#[tokio::main]async fn main() { let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; let mut stream = tokio::stream::iter(vec).buffer_unordered(4); while let Some(num) = stream.next().await { println!(\"{}\", num); }}在上面的代码中，我们使用了buffer_unordered方法并发处理每个数字。注意，我们需要使用await关键字来等待每个元素的到来。使用 Stream 的 zip 方法接下来，我们将介绍如何使用 Stream 的zip方法将两个 Stream 合并为一个 Stream。假设我们有两个包含数字 1 到 5 的 Vec，我们可以使用stream::iter函数来创建两个 Stream，并使用zip方法将它们合并为一个 Stream。1234567891011121314use tokio::stream::StreamExt;#[tokio::main]async fn main() { let vec1 = vec![1, 2, 3, 4, 5]; let vec2 = vec![6, 7, 8, 9, 10]; let mut stream1 = tokio::stream::iter(vec1); let mut stream2 = tokio::stream::iter(vec2); let mut stream = stream1.zip(stream2); while let Some((num1, num2)) = stream.next().await { println!(\"{} {}\", num1, num2); }}在上面的代码中，我们使用了zip方法将两个 Stream 合并为一个 Stream。注意，我们需要使用await关键字来等待每个元素的到来。使用 Stream 的 forward 方法最后，我们将介绍如何使用 Stream 的forward方法将一个 Stream 转发到另一个 Stream。假设我们有一个名为data.txt的文件，其中包含一些文本行。我们可以使用tokio::fs::File::open方法来打开文件，并使用tokio::io::BufReader来读取文件中的每一行。然后，我们可以使用forward方法将读取的每一行转发到标准输出。12345678910111213use tokio::io::{AsyncBufReadExt, BufReader};use tokio::fs::File;use tokio::stream::StreamExt;#[tokio::main]async fn main() { let file = File::open(\"data.txt\").await.unwrap(); let mut reader = BufReader::new(file).lines(); let stdout = tokio::io::stdout(); let mut writer = tokio::io::BufWriter::new(stdout); reader.forward(&amp;mut writer).await.unwrap();}在上面的代码中，我们使用了forward方法将读取的每一行转发到标准输出。注意，我们需要使用await关键字来等待每个元素的到来。结论在本教程中，我们介绍了 Rust 语言中的 Tokio 模块 Stream 的基础用法和进阶用法。Stream 模块提供了一种非常方便的方式来处理数据流，这在异步编程中非常有用。我们希望这个教程可以帮助你更好地理解 Stream 模块的用法和特性。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 深入理解Tokio的select!宏(下)",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, tokio",
      "url"         : "./rust/2023/04/30/rust_tokio_tutorial_007_select_1.html",
      "date"        : "2023-04-30 00:00:00 +0800",
      "description" : "",
      "content"     : "Tokio 是一个基于 Rust 语言的异步编程框架，它提供了一组工具和库，使得异步编程变得更加容易和高效。其中最重要的组件之一就是 select!宏。select!宏是 Tokio 中的一个核心宏，它可以让我们同时监听多个异步事件，一旦其中一个事件触发，就可以立即执行相应的代码。在本教程中，我们将详细介绍 select!宏的进阶用法，并提供多个示例来帮助您更好地理解和掌握这个宏的使用方法。进阶用法除了基础用法之外，select!宏还有一些进阶用法，可以帮助我们更好地利用这个宏的强大功能。下面让我们来介绍一些进阶用法，并提供相应的示例。使用 select!宏的循环select!宏可以嵌套在循环语句中，以便我们可以持续监听异步事件的状态。下面是一个示例，它演示了如何使用 select!宏在循环中持续监听两个 Future 的状态：12345678910111213141516171819202122232425use tokio::time::{sleep, Duration};async fn future1() -&gt; String { sleep(Duration::from_secs(1)).await; String::from(\"future1\")}async fn future2() -&gt; String { sleep(Duration::from_secs(2)).await; String::from(\"future2\")}#[tokio::main]async fn main() { loop { select! { result1 = future1().fuse() =&gt; { println!(\"future1 completed with result: {}\", result1); } result2 = future2().fuse() =&gt; { println!(\"future2 completed with result: {}\", result2); } } }}在这个示例中，我们使用 select!宏在一个无限循环中持续监听 future1 和 future2 的状态。这样，无论何时其中一个 Future 完成，我们都可以立即处理其结果。使用 select!宏的复合模式 select!宏还支持使用复合模式来匹配多个事件。复合模式由多个简单模式组成，它们之间使用 运算符连接。下面是一个示例，它演示了如何使用复合模式来监听多个 Future 的状态： 123456789101112131415161718192021222324252627use tokio::time::{sleep, Duration};async fn future1() -&gt; String { sleep(Duration::from_secs(1)).await; String::from(\"future1\")}async fn future2() -&gt; String { sleep(Duration::from_secs(2)).await; String::from(\"future2\")}#[tokio::main]async fn main() { loop { select! { result1 = future1().fuse() | result2 = future2().fuse() =&gt; { if let Some(result) = result1 { println!(\"future1 completed with result: {}\", result); } if let Some(result) = result2 { println!(\"future2 completed with result: {}\", result); } } } }}在这个示例中，我们使用复合模式来监听 future1 和 future2 的状态。如果其中一个 Future 完成，我们就可以在代码块中处理其结果。使用 loop 和 break 来实现多次选择假设我们有一个异步任务task，我们希望在它完成之前等待一段时间，如果这段时间内它还没有完成，就认为它已经超时了。但是，我们希望在超时之后再等待一段时间，如果这段时间内它还没有完成，就再次认为它已经超时了。这时，我们可以使用 loop 和 break 来实现多次选择：123456789101112131415161718192021222324use tokio::select;use tokio::time::{Duration, sleep};#[tokio::main]async fn main() { let mut task = async { // 异步任务的代码 }; loop { let result = select! { result = task =&gt; result, _ = sleep(Duration::from_secs(5)) =&gt; { println!(\"task timeout\"); None } }; if let Some(result) = result { println!(\"completed task result: {}\", result); break; } }}在这个示例中，我们定义了一个异步任务task，并使用select!宏来等待它完成。同时，我们还使用了sleep函数来等待 5 秒钟。当task完成时，我们会返回它的结果；当 5 秒钟过去后，我们会返回一个None。在loop中，我们会不断地使用select!宏来等待task的完成或超时，并根据返回值来决定是否跳出循环。使用 if let 来处理多个异步任务的结果假设我们有多个异步任务task1、task2和task3，我们希望在它们全部完成后对它们的结果进行处理。这时，我们可以使用 if let 来处理多个异步任务的结果：12345678910111213141516171819202122232425262728293031323334353637use tokio::select;#[tokio::main]async fn main() { let mut task1 = async { // 异步任务1的代码 Ok(\"task1 result\") }; let mut task2 = async { // 异步任务2的代码 Ok(\"task2 result\") }; let mut task3 = async { // 异步任务3的代码 Ok(\"task3 result\") }; let mut result1 = None; let mut result2 = None; let mut result3 = None; select! { r = task1 =&gt; { result1 = Some(r); }, r = task2 =&gt; { result2 = Some(r); }, r = task3 =&gt; { result3 = Some(r); } } if let (Some(result1), Some(result2), Some(result3)) = (result1, result2, result3) { println!(\"completed task results: {}, {}, {}\", result1, result2, result3); }}在这个示例中，我们定义了多个异步任务，并使用select!宏来等待它们全部完成。同时，我们使用了三个变量result1、result2和result3来存储它们的结果。在if let中，我们会判断这三个变量是否都有值，如果都有值，就打印出它们的结果。使用 select!宏来实现异步任务的取消假设我们有一个异步任务task，我们希望在它完成之前等待一段时间，如果这段时间内它还没有完成，就取消它。这时，我们可以使用 select!宏来实现异步任务的取消：12345678910111213141516171819202122use tokio::select;use tokio::time::{Duration, sleep};#[tokio::main]async fn main() { let mut task = async { // 异步任务的代码 }; let result = select! { result = task =&gt; result, _ = sleep(Duration::from_secs(5)) =&gt; { task.abort(); None } }; match result { Some(result) =&gt; println!(\"completed task result: {}\", result), None =&gt; println!(\"task cancelled\") }}在这个示例中，我们定义了一个异步任务task，并使用select!宏来等待它完成。同时，我们还使用了sleep函数来等待 5 秒钟。当task完成时，我们会返回它的结果；当 5 秒钟过去后，我们会取消task。最后，我们会根据result的值来打印出完成的任务的结果或取消信息。结语在本篇教程中，我们介绍了 Rust 语言中的 Tokio 模块 select!宏的进阶用法，并提供了一些示例代码。通过学习这些内容，我们可以更好地掌握这个宏的使用，从而编写出更加高效和高质量的异步代码。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 深入理解Tokio的select!宏(上)",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, tokio",
      "url"         : "./rust/2023/04/30/rust_tokio_tutorial_006_select.html",
      "date"        : "2023-04-30 00:00:00 +0800",
      "description" : "",
      "content"     : "Tokio 是一个基于 Rust 语言的异步编程框架，它提供了一组工具和库，使得异步编程变得更加容易和高效。其中最重要的组件之一就是 select!宏。select!宏是 Tokio 中的一个核心宏，它可以让我们同时监听多个异步事件，一旦其中一个事件触发，就可以立即执行相应的代码。在本教程中，我们将详细介绍 select!宏的基础用法和进阶用法，并提供多个示例来帮助您更好地理解和掌握这个宏的使用方法。基础用法在介绍 select!宏的基础用法之前，我们需要先了解一下 Tokio 中的 Future 和 Task。FutureFuture 是 Tokio 中的一个重要概念，它代表了一个异步操作的未来结果。在 Rust 中，Future 是一个 trait，它定义了异步操作的执行过程和返回值。我们可以通过实现 Future trait 来定义自己的异步操作。例如，下面的代码定义了一个简单的 Future，它返回一个字符串：12345678910111213use std::future::Future;use std::pin::Pin;use std::task::{Context, Poll};struct MyFuture;impl Future for MyFuture { type Output = String; fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; { Poll::Ready(String::from(\"Hello, world!\")) }}在这个例子中，我们实现了 Future trait，并在 poll 函数中返回了一个包含字符串“Hello, world!”的 Ready 枚举值。这个 Future 的类型是 MyFuture，它的 Output 类型是 String。TaskTask 是 Tokio 中的另一个重要概念，它代表了一个异步操作的执行上下文。每个 Task 都有一个关联的 Future，它负责执行 Future 中定义的异步操作，并在操作完成时返回结果。在 Tokio 中，每个 Task 都由一个 Executor 来管理。Executor 是一个可以执行异步操作的线程池，它负责调度和执行所有的异步操作。当我们创建一个 Task 时，它会被分配到 Executor 中的一个线程上，并在该线程上执行异步操作。现在我们已经了解了 Future 和 Task 的基本概念，下面让我们来介绍 select!宏的基础用法。基本语法select!宏的基本语法如下：123456789select! { pattern1 =&gt; { // 处理pattern1的代码 } pattern2 =&gt; { // 处理pattern2的代码 } // ...}其中，pattern1、pattern2 等是一组用于匹配异步事件的模式。每个模式都可以与一个关联的 Future 相关联，如果该 Future 的状态与模式匹配，则执行相应的代码块。下面是一个简单的示例，它演示了如何使用 select!宏同时监听两个 Future 的状态：1234567891011121314151617181920212223use tokio::time::{sleep, Duration};async fn future1() -&gt; String { sleep(Duration::from_secs(1)).await; String::from(\"future1\")}async fn future2() -&gt; String { sleep(Duration::from_secs(2)).await; String::from(\"future2\")}#[tokio::main]async fn main() { select! { result1 = future1().fuse() =&gt; { println!(\"future1 completed with result: {}\", result1); } result2 = future2().fuse() =&gt; { println!(\"future2 completed with result: {}\", result2); } }}在这个示例中，我们定义了两个 Future：future1 和 future2。future1 会在 1 秒后返回一个字符串“future1”，而 future2 会在 2 秒后返回一个字符串“future2”。在 main 函数中，我们使用 select!宏同时监听这两个 Future 的状态，并在其中一个 Future 完成时打印出其返回值。同时监听多个 Futureselect!宏最常用的场景之一就是同时监听多个 Future 的状态。下面是一个示例，它演示了如何使用 select!宏同时监听三个 Future 的状态：12345678910111213141516171819202122232425262728293031use tokio::time::{sleep, Duration};async fn future1() -&gt; String { sleep(Duration::from_secs(1)).await; String::from(\"future1\")}async fn future2() -&gt; String { sleep(Duration::from_secs(2)).await; String::from(\"future2\")}async fn future3() -&gt; String { sleep(Duration::from_secs(3)).await; String::from(\"future3\")}#[tokio::main]async fn main() { select! { result1 = future1().fuse() =&gt; { println!(\"future1 completed with result: {}\", result1); } result2 = future2().fuse() =&gt; { println!(\"future2 completed with result: {}\", result2); } result3 = future3().fuse() =&gt; { println!(\"future3 completed with result: {}\", result3); } }}在这个示例中，我们定义了三个 Future：future1、future2 和 future3。它们分别在 1 秒、2 秒和 3 秒后返回一个字符串。在 main 函数中，我们使用 select!宏同时监听这三个 Future 的状态，并在其中一个 Future 完成时打印出其返回值。同时监听 Future 和 Channel除了监听多个 Future 的状态，select!宏还可以同时监听 Future 和 Channel 的状态。下面是一个示例，它演示了如何使用 select!宏同时监听一个 Future 和一个 Channel 的状态：12345678910111213141516171819202122232425262728use tokio::sync::mpsc;use tokio::time::{sleep, Duration};async fn future1() -&gt; String { sleep(Duration::from_secs(1)).await; String::from(\"future1\")}#[tokio::main]async fn main() { let (tx, mut rx) = mpsc::channel(10); tokio::spawn(async move { for i in 1..=5 { tx.send(i).await.unwrap(); sleep(Duration::from_secs(1)).await; } }); select! { result1 = future1().fuse() =&gt; { println!(\"future1 completed with result: {}\", result1); } msg = rx.recv() =&gt; { println!(\"received message: {:?}\", msg); } }}在这个示例中，我们定义了一个 Future：future1，它会在 1 秒后返回一个字符串。我们还创建了一个 Channel，它可以用于在异步任务之间传递消息。在 main 函数中，我们使用 select!宏同时监听 future1 和 Channel 的状态，并在其中一个事件触发时打印出相应的信息。同时监听多个 Channelselect!宏还可以同时监听多个 Channel 的状态。下面是一个示例，它演示了如何使用 select!宏同时监听两个 Channel 的状态：12345678910111213141516171819202122232425262728293031use tokio::sync::mpsc;use tokio::time::{sleep, Duration};#[tokio::main]async fn main() { let (tx1, mut rx1) = mpsc::channel(10); let (tx2, mut rx2) = mpsc::channel(10); tokio::spawn(async move { for i in 1..=5 { tx1.send(i).await.unwrap(); sleep(Duration::from_secs(1)).await; } }); tokio::spawn(async move { for i in 1..=5 { tx2.send(i * 2).await.unwrap(); sleep(Duration::from_secs(2)).await; } }); select! { msg1 = rx1.recv() =&gt; { println!(\"received message from channel 1: {:?}\", msg1); } msg2 = rx2.recv() =&gt; { println!(\"received message from channel 2: {:?}\", msg2); } }}在这个示例中，我们创建了两个 Channel：rx1 和 rx2。它们分别在 1 秒和 2 秒后发送一系列整数。在 main 函数中，我们使用 select!宏同时监听这两个 Channel 的状态，并在其中一个 Channel 有消息到达时打印出相应的信息。同时监听多个 Future 和 Channelselect!宏还可以同时监听多个 Future 和 Channel 的状态。下面是一个示例，它演示了如何使用 select!宏同时监听两个 Future 和两个 Channel 的状态：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647use tokio::sync::mpsc;use tokio::time::{sleep, Duration};async fn future1() -&gt; String { sleep(Duration::from_secs(1)).await; String::from(\"future1\")}async fn future2() -&gt; String { sleep(Duration::from_secs(2)).await; String::from(\"future2\")}#[tokio::main]async fn main() { let (tx1, mut rx1) = mpsc::channel(10); let (tx2, mut rx2) = mpsc::channel(10); tokio::spawn(async move { for i in 1..=5 { tx1.send(i).await.unwrap(); sleep(Duration::from_secs(1)).await; } }); tokio::spawn(async move { for i in 1..=5 { tx2.send(i * 2).await.unwrap(); sleep(Duration::from_secs(2)).await; } }); select! { result1 = future1().fuse() =&gt; { println!(\"future1 completed with result: {}\", result1); } result2 = future2().fuse() =&gt; { println!(\"future2 completed with result: {}\", result2); } msg1 = rx1.recv() =&gt; { println!(\"received message from channel 1: {:?}\", msg1); } msg2 = rx2.recv() =&gt; { println!(\"received message from channel 2: {:?}\", msg2); } }}在这个示例中，我们创建了两个 Future：future1 和 future2，以及两个 Channel：rx1 和 rx2。它们分别在不同的时间发送一系列整数和字符串。在 main 函数中，我们使用 select!宏同时监听这四个事件的状态，并在其中一个事件触发时打印出相应的信息。使用 timeoutselect!宏还支持使用 timeout 来限制异步操作的执行时间。下面是一个示例，它演示了如何使用 select!宏和 timeout 来限制异步操作的执行时间：123456789101112131415161718use tokio::time::{sleep, Duration};async fn future1() -&gt; String { sleep(Duration::from_secs(1)).await; String::from(\"future1\")}#[tokio::main]async fn main() { select! { result1 = future1().fuse() =&gt; { println!(\"future1 completed with result: {}\", result1); } _ = sleep(Duration::from_secs(2)).fuse() =&gt; { println!(\"timeout\"); } }}在这个示例中，我们定义了一个 Future：future1，它会在 1 秒后返回一个字符串。在 main 函数中，我们使用 select!宏同时监听 future1 和一个 2 秒的 timeout。如果 future1 在 2 秒内完成，就会打印出其返回值；否则，会打印出“timeout”。使用 select!宏的默认分支最后一个基础用法示例演示了如何使用 select!宏的默认分支。默认分支可以用于处理所有未匹配的事件，这样我们就可以在一个 select!宏中同时监听多个异步事件，而不需要为每个事件都提供一个匹配模式。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647use tokio::time::{sleep, Duration};async fn future1() -&gt; String { sleep(Duration::from_secs(1)).await; String::from(\"future1\")}async fn future2() -&gt; String { sleep(Duration::from_secs(2)).await; String::from(\"future2\")}#[tokio::main]async fn main() { select! { result1 = future1().fuse() =&gt; { println!(\"future1 completed with result: {}\", result1); } result2 = future2().fuse() =&gt; { println!(\"future2 completed with result: {}\", result2); } _ = tokio::time::sleep(Duration::from_secs(3)).fuse() =&gt; { println!(\"timeout\"); } _ = futures::future::pending().fuse() =&gt; { println!(\"pending\"); } _ = tokio::signal::ctrl_c().fuse() =&gt; { println!(\"ctrl-c\"); } _ = tokio::io::stdin().read_line(&amp;mut String::new()).fuse() =&gt; { println!(\"stdin\"); } _ = tokio::net::TcpListener::bind(\"127.0.0.1:8080\").unwrap().accept().fuse() =&gt; { println!(\"tcp listener\"); } _ = tokio::fs::File::open(\"test.txt\").await.fuse() =&gt; { println!(\"file open\"); } _ = tokio::process::Command::new(\"ls\").spawn().unwrap().fuse() =&gt; { println!(\"command\"); } _ =&gt; { println!(\"default\"); } }}在这个示例中，我们使用 select!宏同时监听多个异步事件，包括两个 Future、一个 timeout、一个 pending、一个 ctrl-c 信号、一个 stdin 读取、一个 TCP 监听、一个文件打开和一个命令执行。在这些事件中，我们只为前面两个 Future 提供了匹配模式，而其他事件都使用了默认分支来处理。结语在本篇教程中，我们介绍了 Rust 语言中的 Tokio 模块 select!宏的基础用法，并提供了一些示例代码。通过学习这些内容，我们可以更好地掌握这个宏的使用，从而编写出更加高效和高质量的异步代码。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 深入理解Tokio的AsyncRead和AsyncWrite",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, tokio",
      "url"         : "./rust/2023/04/30/rust_tokio_tutorial_005_AsyncRead_AsyncWrite.html",
      "date"        : "2023-04-30 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 语言是一门高性能、安全、并发的编程语言，越来越受到开发者的关注和喜爱。而 Tokio 是 Rust 语言中一个非常流行的异步运行时，它提供了一系列的异步 I/O 操作，其中包括 AsyncRead 和 AsyncWrite 模块。这两个模块是非常重要的，它们可以让我们在异步编程中更加方便地读写数据。本教程将围绕这两个模块，提供基础和进阶用法的示例，帮助读者更好地理解和使用它们。基础用法从文件中读取数据1234567891011use tokio::fs::File;use tokio::io::{self, AsyncReadExt};#[tokio::main]async fn main() -&gt; io::Result&lt;()&gt; { let mut file = File::open(\"test.txt\").await?; let mut buffer = [0; 10]; let n = file.read(&amp;mut buffer).await?; println!(\"The bytes read: {:?}\", &amp;buffer[..n]); Ok(())}这个示例演示了如何使用 AsyncRead 模块从文件中读取数据。首先，我们使用File::open函数打开文件，然后使用read方法从文件中读取数据。在这个示例中，我们读取了 10 个字节的数据，并将其存储在一个长度为 10 的缓冲区中。最后，我们打印出读取的字节。从 TCP 连接中读取数据1234567891011use tokio::net::TcpStream;use tokio::io::{self, AsyncReadExt};#[tokio::main]async fn main() -&gt; io::Result&lt;()&gt; { let mut stream = TcpStream::connect(\"127.0.0.1:8080\").await?; let mut buffer = [0; 10]; let n = stream.read(&amp;mut buffer).await?; println!(\"The bytes read: {:?}\", &amp;buffer[..n]); Ok(())}这个示例演示了如何使用 AsyncRead 模块从 TCP 连接中读取数据。首先，我们使用TcpStream::connect函数连接到一个 TCP 服务器，然后使用read方法从连接中读取数据。在这个示例中，我们读取了 10 个字节的数据，并将其存储在一个长度为 10 的缓冲区中。最后，我们打印出读取的字节。向文件中写入数据12345678910use tokio::fs::File;use tokio::io::{self, AsyncWriteExt};#[tokio::main]async fn main() -&gt; io::Result&lt;()&gt; { let mut file = File::create(\"test.txt\").await?; let buffer = b\"Hello, world!\"; file.write_all(buffer).await?; Ok(())}这个示例演示了如何使用 AsyncWrite 模块向文件中写入数据。首先，我们使用File::create函数创建一个新的文件，然后使用write_all方法将数据写入文件中。在这个示例中，我们向文件中写入了一个字符串”Hello, world!”。向 TCP 连接中写入数据12345678910use tokio::net::TcpStream;use tokio::io::{self, AsyncWriteExt};#[tokio::main]async fn main() -&gt; io::Result&lt;()&gt; { let mut stream = TcpStream::connect(\"127.0.0.1:8080\").await?; let buffer = b\"Hello, world!\"; stream.write_all(buffer).await?; Ok(())}这个示例演示了如何使用 AsyncWrite 模块向 TCP 连接中写入数据。首先，我们使用TcpStream::connect函数连接到一个 TCP 服务器，然后使用write_all方法将数据写入连接中。在这个示例中，我们向连接中写入了一个字符串”Hello, world!”。读取文件中的全部数据1234567891011use tokio::fs::File;use tokio::io::{self, AsyncReadExt};#[tokio::main]async fn main() -&gt; io::Result&lt;()&gt; { let mut file = File::open(\"test.txt\").await?; let mut buffer = Vec::new(); file.read_to_end(&amp;mut buffer).await?; println!(\"The bytes read: {:?}\", buffer); Ok(())}这个示例演示了如何使用 AsyncRead 模块读取文件中的全部数据。首先，我们使用File::open函数打开文件，然后使用read_to_end方法读取文件中的全部数据。在这个示例中，我们将读取到的数据存储在一个动态数组中，并打印出读取的字节。复制文件1234567891011121314151617use tokio::fs::{self, File};use tokio::io::{self, AsyncReadExt, AsyncWriteExt};#[tokio::main]async fn main() -&gt; io::Result&lt;()&gt; { let mut source_file = File::open(\"source.txt\").await?; let mut dest_file = File::create(\"dest.txt\").await?; let mut buffer = [0; 1024]; loop { let n = source_file.read(&amp;mut buffer).await?; if n == 0 { break; } dest_file.write_all(&amp;buffer[..n]).await?; } Ok(())}这个示例演示了如何使用 AsyncRead 和 AsyncWrite 模块复制文件。首先，我们使用File::open函数打开源文件，使用File::create函数创建目标文件。然后，我们使用一个循环，每次读取 1024 字节的数据，并将其写入目标文件中，直到源文件读取完毕。在这个示例中，我们使用了read和write_all方法。使用 BufReader 和 BufWriter12345678910111213141516171819use tokio::fs::File;use tokio::io::{self, AsyncBufReadExt, AsyncWriteExt, BufReader, BufWriter};#[tokio::main]async fn main() -&gt; io::Result&lt;()&gt; { let mut file = File::open(\"test.txt\").await?; let mut reader = BufReader::new(file); let mut writer = BufWriter::new(io::stdout()); let mut line = String::new(); loop { let n = reader.read_line(&amp;mut line).await?; if n == 0 { break; } writer.write_all(line.as_bytes()).await?; line.clear(); } Ok(())}这个示例演示了如何使用 BufReader 和 BufWriter 来进行异步读写。首先，我们使用File::open函数打开文件，然后使用BufReader::new函数将文件包装成一个缓冲读取器，使用BufWriter::new函数将标准输出包装成一个缓冲写入器。然后，我们使用一个循环，每次读取一行数据，并将其写入标准输出中。在这个示例中，我们使用了read_line和write_all方法。使用 split 和 join1234567891011121314151617181920212223use tokio::fs::File;use tokio::io::{self, AsyncReadExt, AsyncWriteExt};#[tokio::main]async fn main() -&gt; io::Result&lt;()&gt; { let mut file = File::open(\"test.txt\").await?; let mut buffer = Vec::new(); file.read_to_end(&amp;mut buffer).await?; let mut parts = buffer.split(|&amp;b| b == b'\\n'); let mut tasks = Vec::new(); while let Some(part) = parts.next() { let task = tokio::spawn(async move { let mut file = File::create(\"output.txt\").await?; file.write_all(part).await?; Ok(()) }); tasks.push(task); } for task in tasks { task.await?; } Ok(())}这个示例演示了如何使用 split 和 join 来进行异步读写。首先，我们使用File::open函数打开文件，然后使用read_to_end方法读取文件中的全部数据，并将其存储在一个动态数组中。然后，我们使用split方法将数据按照换行符分割成多个部分。接着，我们使用一个循环，每次将一个部分异步地写入一个新的文件中，并使用tokio::spawn函数创建一个异步任务。最后，我们使用join函数等待所有的异步任务完成。在这个示例中，我们使用了write_all方法。使用 timeout1234567891011use tokio::net::TcpStream;use tokio::io::{self, AsyncReadExt};#[tokio::main]async fn main() -&gt; io::Result&lt;()&gt; { let mut stream = TcpStream::connect(\"127.0.0.1:8080\").await?; let mut buffer = [0; 10]; let n = tokio::time::timeout(std::time::Duration::from_secs(5), stream.read(&amp;mut buffer)).await??; println!(\"The bytes read: {:?}\", &amp;buffer[..n]); Ok(())}这个示例演示了如何使用 timeout 来设置异步读取的超时时间。首先，我们使用TcpStream::connect函数连接到一个 TCP 服务器，然后使用read方法从连接中读取数据。在这个示例中，我们使用了timeout函数来设置读取的超时时间为 5 秒。如果在 5 秒内没有读取到数据，将返回一个错误。在这个示例中，我们使用了time::timeout函数。总结本教程围绕 Tokio 模块的 AsyncRead 和 AsyncWrite 模块，提供了基础和进阶用法的示例。通过学习这些示例，读者可以更好地理解和使用这两个模块，从而更加方便地进行异步读写操作。当然，这些示例只是冰山一角，读者可以通过进一步的学习和实践，掌握更多的异步编程技巧。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 深入理解Tokio的Channel(下)",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, tokio",
      "url"         : "./rust/2023/04/30/rust_tokio_tutorial_004_mspc_channel_3.html",
      "date"        : "2023-04-30 00:00:00 +0800",
      "description" : "",
      "content"     : "Channel 是一种在多线程环境下进行通信的机制，可以让线程之间互相发送消息和共享数据。Rust 语言中的 Tokio 模块提供了一种异步的 Channel 实现，使得我们可以在异步程序中方便地进行消息传递和数据共享。在本教程是 Channel 的下篇，我们将介绍如何使用 Tokio 模块的 Channel，包括如何使用异步 Channel 和如何使用标准库中的同步 Channel 来扩展 Tokio 的 Channel。我们还将讨论背压和有界队列的概念，并提供相关的实践和示例代码。异步 Channel异步 Channel 是 Tokio 模块中的一种实现，它使用了 async/await 语法和 futures-rs 库来实现异步通信。在使用异步 Channel 之前，我们需要在项目的 Cargo.toml 文件中添加 tokio 和 futures-rs 的依赖：123[dependencies]tokio = { version = \"1.28.0\", features = [\"full\"] }futures = \"0.3.17\"接下来，我们可以使用 tokio::sync::mpsc 模块中的 unbounded_channel 函数来创建一个异步 Channel：1234567use tokio::sync::mpsc;#[tokio::main]async fn main() { let (mut tx, mut rx) = mpsc::unbounded_channel(); // ...}在上面的代码中，我们使用了 tokio::main 宏来启动异步运行时，并使用 mpsc::unbounded_channel 函数创建了一个异步 Channel。该函数返回了两个值，一个是发送端（tx），一个是接收端（rx）。接下来，我们可以使用 tx.send 方法向 Channel 中发送消息，使用 rx.recv 方法从 Channel 中接收消息。这些方法都是异步的，因此我们需要在使用它们时使用 await 关键字。1234567891011use tokio::sync::mpsc;#[tokio::main]async fn main() { let (mut tx, mut rx) = mpsc::unbounded_channel(); tokio::spawn(async move { tx.send(\"hello\").await.unwrap(); }); let msg = rx.recv().await.unwrap(); println!(\"{}\", msg);}在上面的代码中，我们使用了 tokio::spawn 函数创建了一个异步任务，该任务向 Channel 中发送了一条消息。接着，我们使用 rx.recv 方法从 Channel 中接收消息，并将消息打印出来。扩展异步 Channel异步 Channel 在 Tokio 中是一个非常有用的工具，但是它有一些限制。例如，它只支持无界队列，这意味着当发送者发送消息时，如果接收者没有及时接收消息，那么消息将一直积累在队列中，直到内存耗尽。为了解决这个问题，我们可以使用 async-channel 模块来扩展 Tokio 的异步 Channel。async-channel 是一个基于 futures-rs 的异步通信库，它提供了有界队列和背压功能。在使用 async-channel 之前，我们需要在项目的 Cargo.toml 文件中添加 async-channel 的依赖：1234[dependencies]tokio = { version = \"1.28.0\", features = [\"full\"] }futures = \"0.3.17\"async-channel = \"1.7.3\"接下来，我们可以使用 async_channel::bounded 函数来创建一个有界队列的异步 Channel：1234567use async_channel::{bounded, Sender, Receiver};#[tokio::main]async fn main() { let (tx, rx) = bounded(10); // ...}在上面的代码中，我们使用了 async_channel::bounded 函数创建了一个有界队列的异步 Channel。该函数返回了两个值，一个是发送端（tx），一个是接收端（rx）。在这个例子中，我们创建了一个容量为 10 的有界队列。接下来，我们可以使用 tx.send 方法向 Channel 中发送消息，使用 rx.recv 方法从 Channel 中接收消息。这些方法都是异步的，因此我们需要在使用它们时使用 await 关键字。1234567891011use async_channel::{bounded, Sender, Receiver};#[tokio::main]async fn main() { let (tx, rx) = bounded(10); tokio::spawn(async move { tx.send(\"hello\").await.unwrap(); }); let msg = rx.recv().await.unwrap(); println!(\"{}\", msg);}在上面的代码中，我们使用了 tokio::spawn 函数创建了一个异步任务，该任务向 Channel 中发送了一条消息。接着，我们使用 rx.recv 方法从 Channel 中接收消息，并将消息打印出来。同步 Channel除了异步 Channel 之外，我们还可以使用标准库中的同步 Channel 来扩展 Tokio 的 Channel。标准库中的同步 Channel 使用了 std::sync::mpsc 模块来实现多线程之间的通信。在使用同步 Channel 之前，我们需要在项目的 Cargo.toml 文件中添加 tokio 的依赖：12[dependencies]tokio = { version = \"1.14.0\", features = [\"full\"] }接下来，我们可以使用 std::sync::mpsc 模块中的 channel 函数来创建一个同步 Channel：123456use std::sync::mpsc;fn main() { let (tx, rx) = mpsc::channel(); // ...}在上面的代码中，我们使用了 mpsc::channel 函数创建了一个同步 Channel。该函数返回了两个值，一个是发送端（tx），一个是接收端（rx）。接下来，我们可以使用 tx.send 方法向 Channel 中发送消息，使用 rx.recv 方法从 Channel 中接收消息。这些方法都是阻塞的，因此我们不需要使用 await 关键字。12345678910use std::sync::mpsc;fn main() { let (tx, rx) = mpsc::channel(); std::thread::spawn(move || { tx.send(\"hello\").unwrap(); }); let msg = rx.recv().unwrap(); println!(\"{}\", msg);}在上面的代码中，我们使用了 std::thread::spawn 函数创建了一个线程，该线程向 Channel 中发送了一条消息。接着，我们使用 rx.recv 方法从 Channel 中接收消息，并将消息打印出来。扩展同步 Channel同步 Channel 在标准库中是一个非常有用的工具，但是它也有一些限制。例如，它只支持阻塞式的消息传递，这意味着当发送者发送消息时，如果接收者没有及时接收消息，那么发送者将一直阻塞，直到消息被接收。为了解决这个问题，我们可以使用有界队列和背压来扩展同步 Channel。有界队列和背压可以使用 crossbeam-channel 模块来实现。在使用 crossbeam-channel 之前，我们需要在项目的 Cargo.toml 文件中添加 crossbeam-channel 的依赖：12[dependencies]crossbeam-channel = \"0.5.1\"接下来，我们可以使用 crossbeam_channel::bounded 函数来创建一个有界队列的同步 Channel：123456use crossbeam_channel::{bounded, Sender, Receiver};fn main() { let (tx, rx) = bounded(10); // ...}在上面的代码中，我们使用了 crossbeam_channel::bounded 函数创建了一个有界队列的同步 Channel。该函数返回了两个值，一个是发送端（tx），一个是接收端（rx）。在这个例子中，我们创建了一个容量为 10 的有界队列。接下来，我们可以使用 tx.send 方法向 Channel 中发送消息，使用 rx.recv 方法从 Channel 中接收消息。这些方法都是阻塞的，因此我们不需要使用 await 关键字。12345678910use crossbeam_channel::{bounded, Sender, Receiver};fn main() { let (tx, rx) = bounded(10); std::thread::spawn(move || { tx.send(\"hello\").unwrap(); }); let msg = rx.recv().unwrap(); println!(\"{}\", msg);}在上面的代码中，我们使用了 std::thread::spawn 函数创建了一个线程，该线程向 Channel 中发送了一条消息。接着，我们使用 rx.recv 方法从 Channel 中接收消息，并将消息打印出来。背压和有界队列在异步编程中，背压和有界队列是非常重要的概念。背压是一种流量控制机制，用于控制消息发送的速度，以避免消息积压和内存耗尽。有界队列是一种限制队列长度的机制，用于控制消息的数量，以避免队列溢出和内存耗尽。在 Tokio 中，我们可以使用 async-channel 模块和 crossbeam-channel 模块来实现背压和有界队列。使用 async-channel 实现背压和有界队列在 async-channel 中，我们可以使用 Sender::try_send 方法来实现背压和有界队列。try_send 方法尝试向 Channel 中发送一条消息，如果 Channel 已满，则返回错误。这样，我们就可以在发送消息时进行流量控制和队列长度控制。123456789101112131415161718use async_channel::{bounded, Sender, Receiver};#[tokio::main]async fn main() { let (tx, rx) = bounded(10); tokio::spawn(async move { loop { if let Err(_) = tx.try_send(\"hello\") { // Channel is full, wait for a moment tokio::time::sleep(std::time::Duration::from_secs(1)).await; } } }); loop { let msg = rx.recv().await.unwrap(); // Process the message }}在上面的代码中，我们使用了 tx.try_send 方法向 Channel 中发送消息，如果 Channel 已满，则等待 1 秒钟。接下来，我们使用 rx.recv 方法从 Channel 中接收消息，并进行处理。使用 crossbeam-channel 实现背压和有界队列在 crossbeam-channel 中，我们可以使用 Sender::try_send 方法和 Receiver::recv_timeout 方法来实现背压和有界队列。try_send 方法尝试向 Channel 中发送一条消息，如果 Channel 已满，则返回错误。recv_timeout 方法尝试从 Channel 中接收一条消息，如果 Channel 为空，则等待一段时间后返回错误。这样，我们就可以在发送消息时进行流量控制和队列长度控制。1234567891011121314151617181920212223use crossbeam_channel::{bounded, Sender, Receiver};fn main() { let (tx, rx) = bounded(10); std::thread::spawn(move || { loop { if let Err(_) = tx.try_send(\"hello\") { // Channel is full, wait for a moment std::thread::sleep(std::time::Duration::from_secs(1)); } } }); loop { match rx.recv_timeout(std::time::Duration::from_secs(1)) { Ok(msg) =&gt; { // Process the message } Err(_) =&gt; { // Channel is empty, wait for a moment } } }}在上面的代码中，我们使用了 tx.try_send 方法向 Channel 中发送消息，如果 Channel 已满，则等待 1 秒钟。接下来，我们使用 rx.recv_timeout 方法从 Channel 中接收消息，并进行处理。如果 Channel 为空，则等待 1 秒钟后继续尝试接收消息。总结在本教程中，我们介绍了如何使用 Tokio 模块的 Channel，包括如何使用异步 Channel 和如何使用标准库中的同步 Channel 来扩展 Tokio 的 Channel。我们还讨论了背压和有界队列的概念，并提供了相关的实践和示例代码。异步 Channel 是 Tokio 中非常有用的工具，它可以帮助我们在异步程序中方便地进行消息传递和数据共享。然而，由于它只支持无界队列，因此在某些情况下可能会导致内存耗尽。为了解决这个问题，我们可以使用 async-channel 模块来扩展 Tokio 的异步 Channel，实现有界队列和背压功能。同步 Channel 在标准库中是一个非常有用的工具，它可以帮助我们在多线程程序中方便地进行消息传递和数据共享。然而，由于它只支持阻塞式的消息传递，因此在某些情况下可能会导致发送者一直阻塞，直到消息被接收。为了解决这个问题，我们可以使用 crossbeam-channel 模块来扩展同步 Channel，实现有界队列和背压功能。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 深入理解Tokio的Channel(中)",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, tokio",
      "url"         : "./rust/2023/04/30/rust_tokio_tutorial_003_mspc_channel_2.html",
      "date"        : "2023-04-30 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 语言的 tokio 模块提供了一种高效的异步编程方式，其中的 channel 模块是其核心组件之一。本教程将介绍 tokio 模块 channel 的除了上文提到的 mspc::Channel 之外，还有三种类型，分别为：oneshot、broadcast 和 watch，本文分别分析它们的使用场景、业务特点和优缺点。Channel 是一种用于在不同线程之间传递数据的通信机制。它可以让不同的线程之间通过发送和接收消息来传递数据，从而实现线程之间的协作和同步。在 Rust 语言中，tokio 模块的 channel 组件提供了一种异步的、高效的、类型安全的 channel 实现。它支持多种类型的 channel，包括 oneshot、broadcast 和 watch。oneshot channeloneshot channel 是一种只能发送一次消息的 channel。它的特点是发送端只能发送一次消息，接收端只能接收一次消息。一旦消息被发送或接收，channel 就会被关闭。oneshot channel 适用于以下场景： 线程之间需要传递一次性的消息。 线程之间需要传递一个返回值。 线程之间需要传递一个事件通知。oneshot channel 的业务特点如下： 只能发送一次消息，保证了消息的唯一性。 只能接收一次消息，保证了消息的完整性。 发送和接收操作都是非阻塞的，可以提高程序的并发性能。oneshot channel 的优点包括： 简单易用，只需要发送和接收消息即可。 安全可靠，保证了消息的唯一性和完整性。 高效性能，发送和接收操作都是非阻塞的。缺点包括： 只能发送一次消息，不适用于需要多次传递消息的场景。 无法处理多个接收端的情况。示例代码下面是一个使用 oneshot channel 传递返回值的示例代码：12345678910111213141516171819202122use tokio::sync::oneshot;async fn do_something() -&gt; i32 { // 创建一个oneshot channel let (tx, rx) = oneshot::channel(); // 在一个异步任务中发送消息 tokio::spawn(async move { let result = 42; tx.send(result).unwrap(); }); // 在当前任务中接收消息 let result = rx.await.unwrap(); result}#[tokio::main]async fn main() { let result = do_something().await; println!(\"result = {}\", result);}broadcast channelbroadcast channel 是一种可以发送多次消息的 channel。它的特点是可以有多个接收端，每个接收端都可以接收到发送端发送的所有消息。broadcast channel 适用于以下场景： 线程之间需要传递多次消息。 线程之间需要广播消息。broadcast channel 的业务特点如下： 可以发送多次消息，适用于需要多次传递消息的场景。 可以有多个接收端，适用于需要广播消息的场景。 发送和接收操作都是非阻塞的，可以提高程序的并发性能。broadcast channel 的优点包括： 可以发送多次消息，适用于需要多次传递消息的场景。 可以有多个接收端，适用于需要广播消息的场景。 高效性能，发送和接收操作都是非阻塞的。缺点包括： 无法保证消息的顺序性。 需要额外的处理逻辑来处理多个接收端的情况。示例代码下面是一个使用 broadcast channel 广播消息的示例代码：1234567891011121314151617181920212223242526272829303132use tokio::sync::broadcast;async fn do_something() { // 创建一个broadcast channel let (tx, mut rx) = broadcast::channel(10); // 在一个异步任务中发送消息 tokio::spawn(async move { for i in 0..10 { tx.send(i).unwrap(); tokio::time::sleep(std::time::Duration::from_secs(1)).await; } }); // 在多个异步任务中接收消息 for _ in 0..3 { let mut rx = rx.clone(); tokio::spawn(async move { loop { match rx.recv().await { Ok(msg) =&gt; println!(\"recv msg = {}\", msg), Err(_) =&gt; break, } } }); }}#[tokio::main]async fn main() { do_something().await;}watch channelwatch channel 是一种可以发送多次消息的 channel。它的特点是可以有多个接收端，每个接收端都可以接收到发送端发送的最新消息。watch channel 适用于以下场景： 线程之间需要传递多次消息。 线程之间需要订阅最新消息。watch channel 的业务特点如下： 可以发送多次消息，适用于需要多次传递消息的场景。 可以有多个接收端，适用于需要订阅最新消息的场景。 发送和接收操作都是非阻塞的，可以提高程序的并发性能。watch channel 的优点包括： 可以发送多次消息，适用于需要多次传递消息的场景。 可以有多个接收端，适用于需要订阅最新消息的场景。 高效性能，发送和接收操作都是非阻塞的。缺点包括： 无法保证消息的顺序性。 需要额外的处理逻辑来处理多个接收端的情况。示例代码下面是一个使用 watch channel 订阅最新消息的示例代码：123456789101112131415161718192021222324252627282930use tokio::sync::watch;async fn do_something() { // 创建一个watch channel let (tx, mut rx) = watch::channel(0); // 在一个异步任务中发送消息 tokio::spawn(async move { for i in 0..10 { tx.send(i).unwrap(); tokio::time::sleep(std::time::Duration::from_secs(1)).await; } }); // 在多个异步任务中接收消息 for _ in 0..3 { let mut rx = rx.clone(); tokio::spawn(async move { loop { let msg = rx.recv().await.unwrap(); println!(\"recv msg = {}\", msg); } }); }}#[tokio::main]async fn main() { do_something().await;}总结tokio 模块的 channel 组件是一种高效的异步通信机制，可以用于线程之间的协作和同步。其中的 oneshot、broadcast 和 watch 三种类型的 channel 各有特点，适用于不同的场景。在实际开发中，需要根据业务需求选择合适的类型，并进行合理的使用和处理。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 深入理解Tokio的Channel(上)",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, tokio",
      "url"         : "./rust/2023/04/30/rust_tokio_tutorial_002_mspc_channel.html",
      "date"        : "2023-04-30 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 语言是一种系统级编程语言，它具有强类型和内存安全性。Rust 语言中的 Tokio 模块是一个异步编程库，它提供了一种高效的方式来处理异步任务。其中，channel 是 Tokio 模块中的一个重要组成部分，它可以用于在异步任务之间传递数据。在本教程中，我们将介绍 Rust 语言中的 Tokio 模块 channel，并提供几个示例，以帮助您更好地理解它的使用方法。什么是 Tokio 模块 Channel？Tokio 模块中的 channel 是一种用于在异步任务之间传递数据的机制。它类似于操作系统中的管道，可以在不同的异步任务之间传递数据。Tokio 模块中的 channel 具有以下特点： 可以在异步任务之间传递任何类型的数据。 支持多个生产者和消费者。 支持异步操作。Tokio 模块中的 channel 分为两种类型：mpsc 和 oneshot。其中，mpsc 是多个生产者和单个消费者的 channel，而 oneshot 是单个生产者和单个消费者的 channel。创建一个 mpsc channel在 Rust 语言中，使用 Tokio 模块创建一个 mpsc channel 非常简单。首先，需要在 Cargo.toml 文件中添加 Tokio 模块的依赖：12[dependencies]tokio = { version = \"1.28.0\", features = [\"full\"] }然后，在代码中导入 Tokio 模块和 mpsc channel：1use tokio::sync::mpsc;接下来，可以使用 mpsc::channel()函数创建一个 mpsc channel：1let (tx, rx) = mpsc::channel(32);在这个例子中，我们创建了一个大小为 32 的 mpsc channel，并返回了两个对象：tx 和 rx。tx 是一个发送者对象，它可以用于向 channel 中发送数据，而 rx 是一个接收者对象，它可以用于从 channel 中接收数据。发送和接收字符串下面是一个简单的示例，演示如何在异步任务之间发送和接收字符串：123456789101112131415use tokio::sync::mpsc;#[tokio::main]async fn main() { let (mut tx, mut rx) = mpsc::channel(32); tokio::spawn(async move { tx.send(\"hello\".to_string()).await.unwrap(); tx.send(\"world\".to_string()).await.unwrap(); }); while let Some(msg) = rx.recv().await { println!(\"{}\", msg); }}在这个例子中，我们首先创建了一个大小为 32 的 mpsc channel。然后，我们使用 tokio::spawn()函数创建了一个异步任务，该任务向 channel 中发送了两个字符串。最后，我们使用 while 循环从 channel 中接收数据，并打印出来。发送和接收数字下面是一个示例，演示如何在异步任务之间发送和接收数字：12345678910111213141516use tokio::sync::mpsc;#[tokio::main]async fn main() { let (mut tx, mut rx) = mpsc::channel(32); tokio::spawn(async move { tx.send(1).await.unwrap(); tx.send(2).await.unwrap(); tx.send(3).await.unwrap(); }); while let Some(msg) = rx.recv().await { println!(\"{}\", msg); }}在这个例子中，我们创建了一个大小为 32 的 mpsc channel。然后，我们使用 tokio::spawn()函数创建了一个异步任务，该任务向 channel 中发送了三个数字。最后，我们使用 while 循环从 channel 中接收数据，并打印出来。发送和接收结构体下面是一个示例，演示如何在异步任务之间发送和接收结构体：123456789101112131415161718192021use tokio::sync::mpsc;#[derive(Debug)]struct Point { x: i32, y: i32,}#[tokio::main]async fn main() { let (mut tx, mut rx) = mpsc::channel(32); tokio::spawn(async move { tx.send(Point { x: 1, y: 2 }).await.unwrap(); tx.send(Point { x: 3, y: 4 }).await.unwrap(); }); while let Some(msg) = rx.recv().await { println!(\"{:?}\", msg); }}在这个例子中，我们创建了一个大小为 32 的 mpsc channel。然后，我们使用 tokio::spawn()函数创建了一个异步任务，该任务向 channel 中发送了两个结构体。最后，我们使用 while 循环从 channel 中接收数据，并打印出来。发送和接收元组下面是一个示例，演示如何在异步任务之间发送和接收元组：123456789101112131415use tokio::sync::mpsc;#[tokio::main]async fn main() { let (mut tx, mut rx) = mpsc::channel(32); tokio::spawn(async move { tx.send((1, 2)).await.unwrap(); tx.send((3, 4)).await.unwrap(); }); while let Some(msg) = rx.recv().await { println!(\"{:?}\", msg); }}在这个例子中，我们创建了一个大小为 32 的 mpsc channel。然后，我们使用 tokio::spawn()函数创建了一个异步任务，该任务向 channel 中发送了两个元组。最后，我们使用 while 循环从 channel 中接收数据，并打印出来。发送和接收枚举下面是一个示例，演示如何在异步任务之间发送和接收枚举：1234567891011121314151617181920212223use tokio::sync::mpsc;enum Message { Text(String), Number(i32),}#[tokio::main]async fn main() { let (mut tx, mut rx) = mpsc::channel(32); tokio::spawn(async move { tx.send(Message::Text(\"hello\".to_string())).await.unwrap(); tx.send(Message::Number(123)).await.unwrap(); }); while let Some(msg) = rx.recv().await { match msg { Message::Text(s) =&gt; println!(\"{}\", s), Message::Number(n) =&gt; println!(\"{}\", n), } }}在这个例子中，我们创建了一个大小为 32 的 mpsc channel。然后，我们使用 tokio::spawn()函数创建了一个异步任务，该任务向 channel 中发送了两个枚举。最后，我们使用 match 语句从 channel 中接收数据，并打印出来。多个生产者和单个消费者下面是一个示例，演示如何在异步任务之间使用多个生产者和单个消费者：123456789101112131415161718192021222324use tokio::sync::mpsc;#[tokio::main]async fn main() { let (tx1, mut rx) = mpsc::channel(32); let tx2 = tx1.clone(); let tx3 = tx1.clone(); tokio::spawn(async move { tx1.send(\"hello\".to_string()).await.unwrap(); }); tokio::spawn(async move { tx2.send(\"world\".to_string()).await.unwrap(); }); tokio::spawn(async move { tx3.send(\"!\".to_string()).await.unwrap(); }); while let Some(msg) = rx.recv().await { println!(\"{}\", msg); }}在这个例子中，我们创建了一个大小为 32 的 mpsc channel，并使用 tx1.clone()函数创建了两个新的发送者对象：tx2 和 tx3。然后，我们使用 tokio::spawn()函数创建了三个异步任务，每个任务向 channel 中发送一个字符串。最后，我们使用 while 循环从 channel 中接收数据，并打印出来。使用 BufferedSink 发送数据下面是一个示例，演示如何使用 BufferedSink 发送数据：12345678910111213141516171819use std::io::Write;use tokio::io::BufWriter;use tokio::sync::mpsc;#[tokio::main]async fn main() { let (mut tx, mut rx) = mpsc::channel(32); tokio::spawn(async move { let mut writer = BufWriter::new(std::io::stdout()); while let Some(msg) = rx.recv().await { writer.write_all(msg.as_bytes()).unwrap(); writer.flush().unwrap(); } }); tx.send(\"hello\\n\".to_string()).await.unwrap(); tx.send(\"world\\n\".to_string()).await.unwrap();}在这个例子中，我们创建了一个大小为 32 的 mpsc channel。然后，我们使用 tokio::spawn()函数创建了一个异步任务，该任务使用 BufferedSink 将数据写入标准输出。最后，我们使用 tx.send()函数向 channel 中发送两个字符串。使用 select!宏选择最先到达的消息下面是一个示例，演示如何使用 select!宏选择最先到达的消息：1234567891011121314151617181920212223use tokio::sync::mpsc;#[tokio::main]async fn main() { let (mut tx1, mut rx1) = mpsc::channel(32); let (mut tx2, mut rx2) = mpsc::channel(32); tokio::spawn(async move { tx1.send(\"hello\".to_string()).await.unwrap(); }); tokio::spawn(async move { tx2.send(\"world\".to_string()).await.unwrap(); }); loop { tokio::select! { Some(msg) = rx1.recv() =&gt; println!(\"{}\", msg), Some(msg) = rx2.recv() =&gt; println!(\"{}\", msg), else =&gt; break, } }}在这个例子中，我们创建了两个大小为 32 的 mpsc channel。然后，我们使用 tokio::spawn()函数创建了两个异步任务，每个任务向 channel 中发送一个字符串。最后，我们使用 tokio::select!宏选择最先到达的消息，并打印出来。结论在本教程中，我们介绍了 Rust 语言中的 Tokio 模块 channel，并提供了 8 个示例，以帮助您更好地理解它的使用方法。无论您是新手还是有经验的 Rust 开发人员，都可以从这些示例中学习到有用的知识。如果您想深入了解 Tokio 模块的其他功能，请查看 Tokio 模块的官方文档。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 从Ping-Pong示例入门Tokio模块",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, tokio",
      "url"         : "./rust/2023/04/30/rust_tokio_tutorial_001_overview.html",
      "date"        : "2023-04-30 00:00:00 +0800",
      "description" : "",
      "content"     : "Tokio 是一个异步 I/O 框架，它提供了一种高效的方式来编写异步代码。它使用 Rust 语言的 Futures 库来管理异步任务，并使用 Reactor 模式来处理 I/O 事件。 本系列 Tokio 篇将由浅入深的从基础到实战，以一个完整的 Rust 语言子系列讲述网络编程。为什么要使用 Tokio？在 Rust 中，使用异步编程可以提高程序的性能和响应速度，但是异步编程往往需要编写大量的样板代码和复杂的控制流程。Tokio 提供了一种简单的方式来编写异步代码，它使用 Futures 库来管理异步任务，并提供了一组工具来处理异步 I/O 事件。如何使用 Tokio？使用 Tokio 编写异步代码需要掌握以下几个概念： Future：表示一个异步任务，可以理解为一个异步函数的返回值； Task：表示一个异步任务的执行上下文，可以理解为一个异步函数的执行环境； Reactor：表示一个 I/O 事件的处理器，可以理解为一个事件循环； Runtime：表示一个异步任务的执行环境，可以理解为一个异步函数的运行时环境。下面我们将使用 Tokio 编写一个最基础的服务器和客户端程序，以便了解 Tokio 的基本用法。编写服务器我们将编写一个简单的 PingPong 服务器，它接收客户端的 Ping 请求，并返回 Pong 响应。首先，我们需要创建一个异步任务来处理客户端的请求。我们可以使用 Tokio 提供的async关键字来定义一个异步函数：123async fn handle_client(mut stream: TcpStream) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { // ...}这个异步函数接收一个TcpStream对象，表示一个客户端连接。我们可以在函数内部处理客户端的请求，并返回一个Result对象表示异步任务的执行结果。在处理客户端请求之前，我们需要先向客户端发送一个欢迎消息：12345678async fn handle_client(mut stream: TcpStream) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { println!(\"new client connected\"); let mut buf = [0; 1024]; stream.write_all(b\"Welcome to the PingPong server!\\n\").await?; // ...}在发送欢迎消息之后，我们需要不断地从客户端读取数据，并返回 Pong 响应。我们可以使用一个无限循环来实现这个功能：1234567891011121314151617async fn handle_client(mut stream: TcpStream) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { println!(\"new client connected\"); let mut buf = [0; 1024]; stream.write_all(b\"Welcome to the PingPong server!\\n\").await?; loop { let n = stream.read(&amp;mut buf).await?; if n == 0 { break; } stream.write_all(b\"Pong\\n\").await?; } println!(\"client disconnected\"); Ok(())}在循环中，我们使用stream.read()方法从客户端读取数据，并使用stream.write_all()方法向客户端发送 Pong 响应。如果客户端关闭了连接，我们就退出循环并返回Ok(())表示异步任务执行成功。现在我们已经编写了一个异步任务来处理客户端请求，接下来我们需要创建一个 Reactor 来处理 I/O 事件。我们可以使用 Tokio 提供的TcpListener对象来监听客户端连接：123456789101112131415#[tokio::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let addr = \"127.0.0.1:8080\"; let listener = TcpListener::bind(addr).await?; println!(\"listening on {}\", addr); loop { let (stream, _) = listener.accept().await?; tokio::spawn(async move { if let Err(e) = handle_client(stream).await { eprintln!(\"error: {}\", e); } }); }}在main函数中，我们首先创建一个TcpListener对象来监听客户端连接。然后我们使用一个无限循环来等待客户端连接，并使用listener.accept()方法来接收客户端连接。当有新的客户端连接时，我们就创建一个新的异步任务来处理客户端请求，并使用tokio::spawn()方法将任务提交到 Reactor 中执行。现在我们已经完成了一个最基础的 PingPong 服务器，可以使用cargo run命令来运行程序，并使用 telnet 命令来测试服务器：1234$ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.08s Running `target/debug/pingpong`listening on 127.0.0.1:8080123456789101112$ telnet localhost 8080Trying 127.0.0.1...Connected to localhost.Escape character is '^]'.Welcome to the PingPong server!pingPongpingPong^]telnet&gt; quitConnection closed.编写客户端现在我们已经编写了一个最基础的 PingPong 服务器，接下来我们将编写一个客户端程序来连接服务器并发送 Ping 请求。首先，我们需要创建一个异步任务来连接服务器：1234567async fn connect() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let addr = \"127.0.0.1:8080\"; let mut stream = TcpStream::connect(addr).await?; println!(\"connected to {}\", addr); // ...}这个异步任务使用TcpStream::connect()方法来连接服务器，并返回一个Result对象表示连接结果。在连接成功之后，我们可以向服务器发送一个 Ping 请求：12345678910111213async fn connect() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let addr = \"127.0.0.1:8080\"; let mut stream = TcpStream::connect(addr).await?; println!(\"connected to {}\", addr); stream.write_all(b\"Ping\\n\").await?; let mut buf = [0; 1024]; let n = stream.read(&amp;mut buf).await?; let pong = std::str::from_utf8(&amp;buf[..n])?; println!(\"{}\", pong); Ok(())}在发送 Ping 请求之后，我们使用stream.read()方法从服务器读取响应，并使用std::str::from_utf8()方法将响应转换为字符串。最后，我们将响应打印到控制台上，并返回Ok(())表示异步任务执行成功。现在我们已经编写了一个异步任务来连接服务器并发送 Ping 请求，接下来我们需要在main函数中启动这个任务：12345#[tokio::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { connect().await?; Ok(())}现在我们已经完成了一个最基础的 PingPong 客户端，可以使用cargo run命令来运行程序，并查看控制台输出：12345$ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.08s Running `target/debug/pingpong`connected to 127.0.0.1:8080Pong完整代码最后，我们将完整的服务器和客户端代码放在一起，以便读者参考：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657use std::error::Error;use tokio::io::{AsyncReadExt, AsyncWriteExt};use tokio::net::{TcpListener, TcpStream};async fn handle_client(mut stream: TcpStream) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { println!(\"new client connected\"); let mut buf = [0; 1024]; stream.write_all(b\"Welcome to the PingPong server!\\n\").await?; loop { let n = stream.read(&amp;mut buf).await?; if n == 0 { break; } stream.write_all(b\"Pong\\n\").await?; } println!(\"client disconnected\"); Ok(())}#[tokio::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let addr = \"127.0.0.1:8080\"; let listener = TcpListener::bind(addr).await?; println!(\"listening on {}\", addr); loop { let (stream, _) = listener.accept().await?; tokio::spawn(async move { if let Err(e) = handle_client(stream).await { eprintln!(\"error: {}\", e); } }); }}async fn connect() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let addr = \"127.0.0.1:8080\"; let mut stream = TcpStream::connect(addr).await?; println!(\"connected to {}\", addr); stream.write_all(b\"Ping\\n\").await?; let mut buf = [0; 1024]; let n = stream.read(&amp;mut buf).await?; let pong = std::str::from_utf8(&amp;buf[..n])?; println!(\"{}\", pong); Ok(())}#[tokio::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { connect().await?; Ok(())}总结通过本文的介绍，我们了解了 Tokio 的基本用法，并编写了一个最基础的 PingPong 服务器和客户端程序。Tokio 提供了一种简单的方式来编写异步代码，可以帮助我们提高程序的性能和响应速度。在实际开发中，我们可以根据需要使用 Tokio 提供的各种工具来编写更加复杂的异步程序。"
    } ,
  
    {
      "title"       : "Python 3.x从基础到实战 - 检查内存可用大小",
      "category"    : "",
      "tags"        : "python3, python",
      "url"         : "./python3/2023/04/27/python_3x_202_memory_usage.html",
      "date"        : "2023-04-27 12:00:00 +0800",
      "description" : "",
      "content"     : "在Linux服务器管理中，内存是一个非常重要的资源。如果服务器的内存不足，可能会导致服务器崩溃或者无法正常工作。因此，检查Linux服务器内存可用大小是非常必要的。本文将介绍如何使用Python 3实现检查Linux服务器内存可用大小的方法，包括使用Python标准库实现和使用Linux命令实现两种方式。使用 psutil 标准库实现Python标准库中有一个psutil模块，它提供了一个跨平台的API，可以用来获取系统信息，包括CPU、内存、磁盘、网络等。我们可以使用psutil模块来获取Linux服务器的内存信息。首先，我们需要安装psutil模块。在Linux服务器上，可以使用以下命令来安装：1pip3 install psutil安装完成后，我们可以开始编写Python代码。以下是一个示例代码，它可以获取Linux服务器的内存信息，并计算可用内存的大小：12345678910import psutil# 获取内存信息mem = psutil.virtual_memory()# 计算可用内存大小available_mem = mem.available / (1024 * 1024)# 打印可用内存大小print(\"可用内存大小：%.2f MB\" % available_mem)在上面的代码中，我们使用psutil.virtual_memory()函数来获取内存信息。这个函数返回一个namedtuple对象，包含了各种内存信息，包括总内存、可用内存、已使用内存、缓冲区等。我们可以通过访问这个对象的属性来获取相应的内存信息。在上面的示例代码中，我们获取了可用内存的大小，然后将其转换为MB单位，并打印出来。使用Linux free 命令实现除了使用Python标准库外，我们还可以使用Linux命令来获取Linux服务器的内存信息。Linux系统中有一个free命令，可以用来查看内存使用情况。我们可以使用Python的subprocess模块来执行free命令，并解析命令的输出结果来获取内存信息。以下是一个示例代码，它可以使用free命令获取Linux服务器的内存信息，并计算可用内存的大小：1234567891011121314151617import subprocess# 执行free命令，获取内存信息output = subprocess.check_output([\"free\", \"-m\"]).decode()# 解析输出结果，获取可用内存大小for line in output.split(\"\\n\"): if \"Mem\" in line: mem_info = line.split() total_mem = int(mem_info[1]) used_mem = int(mem_info[2]) free_mem = int(mem_info[3]) available_mem = free_mem + int(mem_info[6]) break# 打印可用内存大小print(\"可用内存大小：{} MB\".format(available_mem))在上面的代码中，我们使用subprocess.check_output()函数执行free -m命令，并将命令的输出结果转换为字符串类型。然后，我们遍历输出结果的每一行，找到包含Mem关键字的行，解析这一行的内容，获取总内存、已使用内存、空闲内存、可用内存等信息。最后，我们计算可用内存的大小，并打印出来。总结本文介绍了两种方法，使用Python 3实现检查Linux服务器内存可用大小。第一种方法是使用Python标准库中的psutil模块，它提供了一个跨平台的API，可以用来获取系统信息。第二种方法是使用Linux命令free，并使用Python的subprocess模块来执行命令并解析命令的输出结果。无论是哪种方法，都可以方便地获取Linux服务器的内存信息，并计算可用内存的大小。"
    } ,
  
    {
      "title"       : "Python 3.x从基础到实战 - 检查内存可用大小",
      "category"    : "",
      "tags"        : "python3, python",
      "url"         : "./python3/2023/04/27/python_3x_201_memory_usage.html",
      "date"        : "2023-04-27 12:00:00 +0800",
      "description" : "",
      "content"     : "在Linux服务器管理中，内存是一个非常重要的资源。如果服务器的内存不足，可能会导致服务器崩溃或者无法正常工作。因此，检查Linux服务器内存可用大小是非常必要的。本文将介绍如何使用Python 3实现检查Linux服务器内存可用大小的方法，包括使用Python标准库实现和使用Linux命令实现两种方式。使用 psutil 标准库实现Python标准库中有一个psutil模块，它提供了一个跨平台的API，可以用来获取系统信息，包括CPU、内存、磁盘、网络等。我们可以使用psutil模块来获取Linux服务器的内存信息。首先，我们需要安装psutil模块。在Linux服务器上，可以使用以下命令来安装：1pip3 install psutil安装完成后，我们可以开始编写Python代码。以下是一个示例代码，它可以获取Linux服务器的内存信息，并计算可用内存的大小：12345678910import psutil# 获取内存信息mem = psutil.virtual_memory()# 计算可用内存大小available_mem = mem.available / (1024 * 1024)# 打印可用内存大小print(\"可用内存大小：%.2f MB\" % available_mem)在上面的代码中，我们使用psutil.virtual_memory()函数来获取内存信息。这个函数返回一个namedtuple对象，包含了各种内存信息，包括总内存、可用内存、已使用内存、缓冲区等。我们可以通过访问这个对象的属性来获取相应的内存信息。在上面的示例代码中，我们获取了可用内存的大小，然后将其转换为MB单位，并打印出来。使用Linux free 命令实现除了使用Python标准库外，我们还可以使用Linux命令来获取Linux服务器的内存信息。Linux系统中有一个free命令，可以用来查看内存使用情况。我们可以使用Python的subprocess模块来执行free命令，并解析命令的输出结果来获取内存信息。以下是一个示例代码，它可以使用free命令获取Linux服务器的内存信息，并计算可用内存的大小：1234567891011121314151617import subprocess# 执行free命令，获取内存信息output = subprocess.check_output([\"free\", \"-m\"]).decode()# 解析输出结果，获取可用内存大小for line in output.split(\"\\n\"): if \"Mem\" in line: mem_info = line.split() total_mem = int(mem_info[1]) used_mem = int(mem_info[2]) free_mem = int(mem_info[3]) available_mem = free_mem + int(mem_info[6]) break# 打印可用内存大小print(\"可用内存大小：{} MB\".format(available_mem))在上面的代码中，我们使用subprocess.check_output()函数执行free -m命令，并将命令的输出结果转换为字符串类型。然后，我们遍历输出结果的每一行，找到包含Mem关键字的行，解析这一行的内容，获取总内存、已使用内存、空闲内存、可用内存等信息。最后，我们计算可用内存的大小，并打印出来。总结本文介绍了两种方法，使用Python 3实现检查Linux服务器内存可用大小。第一种方法是使用Python标准库中的psutil模块，它提供了一个跨平台的API，可以用来获取系统信息。第二种方法是使用Linux命令free，并使用Python的subprocess模块来执行命令并解析命令的输出结果。无论是哪种方法，都可以方便地获取Linux服务器的内存信息，并计算可用内存的大小。"
    } ,
  
    {
      "title"       : "Python 3.x从基础到实战 - 检查磁盘可用空间",
      "category"    : "",
      "tags"        : "python3, python",
      "url"         : "./python3/2023/04/27/python_3x_200_disk_usage.html",
      "date"        : "2023-04-27 12:00:00 +0800",
      "description" : "",
      "content"     : "在 Linux 服务器上，磁盘空间的使用情况是一个非常重要的指标。如果服务器上的磁盘空间不足，可能会导致服务器崩溃，影响网站的正常运行。为了避免这种情况的发生，我们需要定期检查服务器上的磁盘空间，并及时清理不必要的文件。本文将介绍如何使用 Python 3脚本检查 Linux 服务器上的磁盘空间。使用psutil模块实现首先，我们需要安装psutil模块。psutil是一个跨平台的库，用于获取系统信息，包括磁盘使用情况、CPU使用情况等。我们可以使用以下命令来安装psutil：1pip3 install psutil获取磁盘使用情况我们将使用psutil模块来获取磁盘使用情况。以下是获取磁盘使用情况的示例代码：123456789import psutil# 获取磁盘使用情况disk_usage = psutil.disk_usage('/')# 打印磁盘使用情况print(f\"Total: {disk_usage.total / (1024*1024*1024):.2f} GB\")print(f\"Used: {disk_usage.used / (1024*1024*1024):.2f} GB\")print(f\"Free: {disk_usage.free / (1024*1024*1024):.2f} GB\")在这个示例中，我们使用psutil.disk_usage()函数来获取磁盘使用情况。该函数需要传递一个参数，即要获取使用情况的磁盘路径。在这个示例中，我们传递了根目录/作为参数。psutil.disk_usage()函数返回一个namedtuple对象，其中包含总容量、已用容量和可用容量等信息。获取磁盘挂载点在Linux系统中，磁盘可以挂载到不同的目录下。如果您的系统中有多个磁盘，您可能需要检查每个磁盘的可用空间。以下是获取磁盘挂载点的示例代码：1234567891011import psutil# 获取磁盘挂载点disk_partitions = psutil.disk_partitions()# 打印磁盘挂载点for partition in disk_partitions: print(f\"Device: {partition.device}\") print(f\"Mountpoint: {partition.mountpoint}\") print(f\"File system type: {partition.fstype}\") print()在这个示例中，我们使用psutil.disk_partitions()函数来获取磁盘挂载点。该函数返回一个列表，其中包含每个挂载点的信息，包括设备、挂载点和文件系统类型等。检查磁盘可用空间现在我们已经了解了如何获取磁盘使用情况和磁盘挂载点，让我们编写一个脚本来检查磁盘的可用空间。以下是检查磁盘可用空间的示例代码：12345678910111213141516171819202122232425import psutilimport os# 获取磁盘挂载点disk_partitions = psutil.disk_partitions()# 遍历每个挂载点for partition in disk_partitions: # 获取磁盘使用情况 disk_usage = psutil.disk_usage(partition.mountpoint) # 计算磁盘可用空间的百分比 free_percent = disk_usage.free / disk_usage.total * 100 # 如果磁盘可用空间小于10%，发送警告邮件 if free_percent &lt; 10: # 获取主机名 hostname = os.uname()[1] # 构造邮件内容 subject = f\"Disk space warning on {hostname}\" message = f\"The disk {partition.device} ({partition.mountpoint}) is running out of space ({free_percent:.2f}% free).\" # 发送邮件 send_email(subject, message)在这个示例中，我们遍历了每个磁盘挂载点，并使用psutil.disk_usage()函数获取了每个挂载点的使用情况。然后，我们计算了每个挂载点的可用空间百分比，并检查了是否小于10%。如果是，我们将发送一封警告邮件。使用 du 命令实现使用 du 命令检查磁盘空间du 命令是 Linux 系统中一个非常有用的命令，可以用来查看当前目录或文件的磁盘使用情况。在 Python 3 中，我们可以使用 subprocess 模块来执行 du 命令，并将其输出解析为 Python 对象。以下是一个简单的 Python 3 脚本，用于检查服务器上特定目录的磁盘使用情况：12345678910111213import subprocessdef get_directory_size(path): \"\"\"Return the total size of the files in the given directory and subdirectories.\"\"\" cmd = [\"du\", \"-sh\", path] result = subprocess.run(cmd, stdout=subprocess.PIPE) output = result.stdout.decode(\"utf-8\").strip() size = output.split()[0] return size# Example usage:size = get_directory_size(\"/var/www/html\")print(\"Size of /var/www/html: {}\".format(size))在上面的示例中，我们定义了一个名为 get_directory_size 的函数，该函数接受一个路径作为参数，并返回该目录及其子目录中文件的总大小。该函数使用 subprocess.run 函数来执行 du 命令，并将其输出解析为 Python 对象。然后，我们从输出中提取出目录的大小，并将其作为字符串返回。要使用此函数，只需调用 get_directory_size 并传递要检查的目录的路径即可。在上面的示例中，我们检查了 /var/www/html 目录的大小，并将结果打印到控制台上。检查多个目录的磁盘空间如果您需要检查多个目录的磁盘使用情况，可以使用一个简单的循环来遍历目录列表，并调用 get_directory_size 函数来获取每个目录的大小。以下是一个示例脚本，用于检查多个目录的磁盘使用情况：1234567891011121314151617import subprocessdef get_directory_size(path): \"\"\"Return the total size of the files in the given directory and subdirectories.\"\"\" cmd = [\"du\", \"-sh\", path] result = subprocess.run(cmd, stdout=subprocess.PIPE) output = result.stdout.decode(\"utf-8\").strip() size = output.split()[0] return size# List of directories to checkdirectories = [\"/var/www/html\", \"/var/log\", \"/etc\"]# Loop through directories and print their sizesfor directory in directories: size = get_directory_size(directory) print(\"Size of {}: {}\".format(directory, size))在上面的示例中，我们定义了一个名为 directories 的列表，其中包含要检查的目录的路径。然后，我们使用一个简单的循环遍历该列表，并调用 get_directory_size 函数来获取每个目录的大小。检查磁盘空间使用率除了检查单个目录或多个目录的磁盘使用情况之外，我们还可以使用 Python 3 来检查整个磁盘的使用情况。以下是一个示例脚本，用于检查磁盘使用率：12345678910111213import subprocessdef get_disk_usage(): \"\"\"Return the disk usage of the root filesystem in percent.\"\"\" cmd = [\"df\", \"-h\", \"/\"] result = subprocess.run(cmd, stdout=subprocess.PIPE) output = result.stdout.decode(\"utf-8\").strip() usage = int(output.split(\"\\n\")[1].split()[4].replace(\"%\", \"\")) return usage# Example usage:usage = get_disk_usage()print(\"Disk usage: {}%\".format(usage))在上面的示例中，我们定义了一个名为 get_disk_usage 的函数，该函数返回根文件系统的磁盘使用率。该函数使用 subprocess.run 函数来执行 df 命令，并将其输出解析为 Python 对象。然后，我们从输出中提取出磁盘使用率，并将其作为整数返回。要使用此函数，只需调用 get_disk_usage 并将其结果打印到控制台上即可。发送邮件在上面的示例中，我们调用了一个名为send_email()的函数来发送邮件。这个函数需要进行自定义实现。以下是一个简单的send_email()函数的示例代码：123456789101112131415161718import smtplibfrom email.mime.text import MIMETextfrom email.header import Headerdef send_email(subject, message): # 邮件发送者和接收者 sender = 'sender@example.com' receiver = 'receiver@example.com' # 邮件主题和内容 msg = MIMEText(message, 'plain', 'utf-8') msg['Subject'] = Header(subject, 'utf-8') # 发送邮件 smtp = smtplib.SMTP('smtp.example.com') smtp.login(sender, 'password') smtp.sendmail(sender, receiver, msg.as_string()) smtp.quit()在这个示例中，我们使用smtplib模块来发送邮件。首先，我们指定了邮件发送者和接收者的地址。然后，我们使用MIMEText类创建了一个邮件对象，并指定了邮件的主题和内容。最后，我们使用SMTP类连接到邮件服务器，并使用login()方法进行身份验证。然后，我们使用sendmail()方法发送邮件，并使用quit()方法关闭连接。结论在这篇教程中，我们使用Python 3编写了一个脚本来检查Linux服务器的磁盘可用空间。我们使用了psutil和os模块来获取磁盘信息，并编写了一个简单的函数来发送警告邮件。这个脚本可以帮助您在磁盘空间不足时及时采取措施，避免系统崩溃。"
    } ,
  
    {
      "title"       : "简单的Golang泛型教程",
      "category"    : "",
      "tags"        : "golang, python",
      "url"         : "./golang/python/2023/04/27/python_3x_001_Hello_World.html",
      "date"        : "2023-04-27 12:00:00 +0800",
      "description" : "",
      "content"     : ""
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 深入理解image图片处理模块",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, image",
      "url"         : "./rust/2023/04/23/rust_lang_tutorial_234_image.html",
      "date"        : "2023-04-23 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种内存安全和并发性强的编程语言，它被广泛应用于系统编程、Web 开发、游戏开发等领域。而 image 模块则是 Rust 语言中用于图像处理的库，它提供了丰富的图像处理功能，包括图像读取、写入、缩放、裁剪、旋转等等。在本教程中，我们将介绍 Rust 语言中的 image 模块，并提供基础用法和进阶用法的示例，帮助读者了解如何使用这个强大的图像处理库。基础用法1. 读取图像使用 image 模块可以很方便地读取图像文件。下面是一个简单的示例：123456use image::GenericImageView;fn main() { let img = image::open(\"test.png\").unwrap(); println!(\"Image dimensions: {:?}\", img.dimensions());}这个示例中，我们使用image::open函数来打开一个名为test.png的图像文件，并使用unwrap方法来处理可能的错误。然后，我们调用dimensions方法来获取图像的尺寸信息。2. 写入图像同样，使用 image 模块也可以很方便地写入图像文件。下面是一个简单的示例：123456use image::GenericImageView;fn main() { let img = image::open(\"test.png\").unwrap(); let _ = img.save(\"output.png\");}这个示例中，我们首先使用image::open函数打开一个名为test.png的图像文件。然后，我们调用save方法将图像写入名为output.png的文件中。3. 裁剪图像使用 image 模块可以很方便地裁剪图像。下面是一个简单的示例：1234567use image::GenericImageView;fn main() { let img = image::open(\"test.png\").unwrap(); let cropped = img.crop(10, 10, 100, 100); let _ = cropped.save(\"output.png\");}这个示例中，我们首先使用image::open函数打开一个名为test.png的图像文件。然后，我们调用crop方法来裁剪图像，该方法接受四个参数：左上角的 x 坐标、y 坐标、裁剪区域的宽度和高度。最后，我们将裁剪后的图像写入名为output.png的文件中。4. 缩放图像使用 image 模块可以很方便地缩放图像。下面是一个简单的示例：1234567use image::GenericImageView;fn main() { let img = image::open(\"test.png\").unwrap(); let scaled = img.resize(200, 200, image::imageops::FilterType::Lanczos3); let _ = scaled.save(\"output.png\");}这个示例中，我们首先使用image::open函数打开一个名为test.png的图像文件。然后，我们调用resize方法来缩放图像，该方法接受三个参数：缩放后的宽度、高度和缩放算法。最后，我们将缩放后的图像写入名为output.png的文件中。5. 旋转图像使用 image 模块可以很方便地旋转图像。下面是一个简单的示例：1234567use image::GenericImageView;fn main() { let img = image::open(\"test.png\").unwrap(); let rotated = img.rotate90(); let _ = rotated.save(\"output.png\");}这个示例中，我们首先使用image::open函数打开一个名为test.png的图像文件。然后，我们调用rotate90方法来将图像逆时针旋转 90 度。最后，我们将旋转后的图像写入名为output.png的文件中。6. 转换图像格式使用 image 模块可以很方便地转换图像格式。下面是一个简单的示例：1234567use image::GenericImageView;fn main() { let img = image::open(\"test.png\").unwrap(); let converted = img.into_rgba(); let _ = converted.save(\"output.png\");}这个示例中，我们首先使用image::open函数打开一个名为test.png的图像文件。然后，我们调用into_rgba方法将图像转换为 RGBA 格式。最后，我们将转换后的图像写入名为output.png的文件中。7. 操作像素使用 image 模块可以很方便地操作图像像素。下面是一个简单的示例：123456789101112use image::{GenericImageView, RgbaImage};fn main() { let img = image::open(\"test.png\").unwrap(); let mut pixels = img.to_rgba().pixels_mut(); for pixel in pixels { let (r, g, b, a) = pixel.2.channels(); let gray = (0.3 * r as f32 + 0.59 * g as f32 + 0.11 * b as f32) as u8; pixel.2 = image::Rgba([gray, gray, gray, a]); } let _ = img.save(\"output.png\");}这个示例中，我们首先使用image::open函数打开一个名为test.png的图像文件。然后，我们调用to_rgba方法将图像转换为 RGBA 格式，并使用pixels_mut方法获取图像像素的可变引用。接着，我们遍历每个像素，并将其转换为灰度图像。最后，我们将转换后的图像写入名为output.png的文件中。8. 绘制图像使用 image 模块可以很方便地绘制图像。下面是一个简单的示例：1234567891011121314use image::{GenericImageView, RgbaImage, Rgba};fn main() { let mut img = RgbaImage::new(200, 200); for x in 0..200 { for y in 0..200 { let r = (x as f32 / 200.0 * 255.0) as u8; let g = (y as f32 / 200.0 * 255.0) as u8; let b = ((x + y) as f32 / 400.0 * 255.0) as u8; img.put_pixel(x, y, Rgba([r, g, b, 255])); } } let _ = img.save(\"output.png\");}这个示例中，我们首先创建一个 200x200 的 RGBA 图像。然后，我们遍历每个像素，并计算其颜色值。最后，我们使用put_pixel方法将像素绘制到图像上，并将图像写入名为output.png的文件中。进阶用法1. 模糊图像使用 image 模块可以很方便地对图像进行模糊处理。下面是一个简单的示例：1234567use image::{GenericImageView, DynamicImage};fn main() { let img = image::open(\"test.png\").unwrap(); let blurred = img.blur(5.0); let _ = blurred.save(\"output.png\");}这个示例中，我们首先使用image::open函数打开一个名为test.png的图像文件。然后，我们调用blur方法对图像进行模糊处理，该方法接受一个参数，表示模糊半径。最后，我们将模糊后的图像写入名为output.png的文件中。2. 图像直方图均衡化使用 image 模块可以很方便地对图像进行直方图均衡化。下面是一个简单的示例：1234567use image::{GenericImageView, DynamicImage};fn main() { let img = image::open(\"test.png\").unwrap(); let equalized = img.equalize(); let _ = equalized.save(\"output.png\");}这个示例中，我们首先使用image::open函数打开一个名为test.png的图像文件。然后，我们调用equalize方法对图像进行直方图均衡化。最后，我们将均衡化后的图像写入名为output.png的文件中。3. 图像二值化使用 image 模块可以很方便地对图像进行二值化处理。下面是一个简单的示例：1234567891011121314151617use image::{GenericImageView, DynamicImage, GrayImage};fn main() { let img = image::open(\"test.png\").unwrap(); let gray = img.to_luma(); let threshold = 128; let mut binary = GrayImage::new(gray.width(), gray.height()); for (x, y, pixel) in binary.enumerate_pixels_mut() { let value = gray.get_pixel(x, y)[0]; if value &gt; threshold { *pixel = image::Luma([255]); } else { *pixel = image::Luma([0]); } } let _ = binary.save(\"output.png\");}这个示例中，我们首先使用image::open函数打开一个名为test.png的图像文件。然后，我们调用to_luma方法将图像转换为灰度图像。接着，我们指定一个阈值，并遍历每个像素，将其转换为二值图像。最后，我们将二值化后的图像写入名为output.png的文件中。4. 图像插值使用 image 模块可以很方便地对图像进行插值处理。下面是一个简单的示例：12345678910111213141516use image::{GenericImageView, DynamicImage, RgbaImage, imageops};fn main() { let img = image::open(\"test.png\").unwrap(); let scaled = imageops::resize(&amp;img, 200, 200, imageops::FilterType::Lanczos3); let mut interpolated = RgbaImage::new(400, 400); for x in 0..400 { for y in 0..400 { let u = x as f32 / 2.0; let v = y as f32 / 2.0; let pixel = scaled.get_pixel(u as u32, v as u32); interpolated.put_pixel(x, y, *pixel); } } let _ = interpolated.save(\"output.png\");}这个示例中，我们首先使用image::open函数打开一个名为test.png的图像文件。然后，我们调用resize方法将图像缩放为 200x200 的大小。接着，我们创建一个 400x400 的 RGBA 图像，并遍历每个像素。对于每个像素，我们使用插值方法从缩放后的图像中获取其颜色值，并将其绘制到新的图像中。最后，我们将插值后的图像写入名为output.png的文件中。最佳实践在使用 image 模块时，我们需要注意以下几点： 需要处理可能的错误，如文件读写错误、图像格式错误等等。 需要注意图像的尺寸和格式，以便正确地使用各种图像处理方法。 需要注意图像的像素类型和通道顺序，以便正确地操作像素。 需要选择合适的图像处理方法和参数，以便达到预期的处理效果。下面是一个综合示例，演示了如何使用 image 模块对图像进行灰度化、二值化、插值和保存：123456789101112131415161718192021222324252627use image::{GenericImageView, DynamicImage, RgbaImage, GrayImage, imageops};fn main() { let img = image::open(\"test.png\").unwrap(); let gray = img.to_luma(); let threshold = 128; let mut binary = GrayImage::new(gray.width(), gray.height()); for (x, y, pixel) in binary.enumerate_pixels_mut() { let value = gray.get_pixel(x, y)[0]; if value &gt; threshold { *pixel = image::Luma([255]); } else { *pixel = image::Luma([0]); } } let scaled = imageops::resize(&amp;img, 200, 200, imageops::FilterType::Lanczos3); let mut interpolated = RgbaImage::new(400, 400); for x in 0..400 { for y in 0..400 { let u = x as f32 / 2.0; let v = y as f32 / 2.0; let pixel = scaled.get_pixel(u as u32, v as u32); interpolated.put_pixel(x, y, *pixel); } } let _ = interpolated.save(\"output.png\");}这个示例中，我们首先使用image::open函数打开一个名为test.png的图像文件。然后，我们调用to_luma方法将图像转换为灰度图像。接着，我们指定一个阈值，并遍历每个像素，将其转换为二值图像。然后，我们使用resize方法将图像缩放为 200x200 的大小。接着，我们创建一个 400x400 的 RGBA 图像，并遍历每个像素。对于每个像素，我们使用插值方法从缩放后的图像中获取其颜色值，并将其绘制到新的图像中。最后，我们将插值后的图像写入名为output.png的文件中。总结在本教程中，我们介绍了 Rust 语言中的 image 模块，并提供了基础用法和进阶用法的示例。我们还讨论了使用 image 模块的最佳实践。希望本教程能够帮助读者掌握使用这个强大的图像处理库的技巧。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 主打安全隐私的虚拟文件系统zbox",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, zbox",
      "url"         : "./rust/2023/04/23/rust_lang_tutorial_233_zbox.html",
      "date"        : "2023-04-23 00:00:00 +0800",
      "description" : "",
      "content"     : "«««&lt; Updated upstreamzbox 是一个基于 Rust 语言的轻量级分布式存储库，它提供了高效、安全、可靠的数据存储和访问。zbox 的设计目的是提供简单易用的 API，使得开发者能够快速构建分布式存储系统。zbox 采用了 Zero-copy、Copy-on-write、引用计数等技术，使得数据访问更加高效。=======zbox是一个基于Rust语言的轻量级分布式存储库，它提供了高效、安全、可靠的数据存储和访问。zbox的设计目的是提供简单易用的API，使得开发者能够快速构建分布式存储系统。zbox采用了Zero-copy、Copy-on-write、引用计数等技术，使得数据访问更加高效。 Stashed changes 基础用法安装在使用 zbox 之前，需要先安装 Rust 编程语言。可以通过以下命令安装：1curl https://sh.rustup.rs -sSf | sh安装完成后，需要在终端运行以下命令安装 zbox：1cargo install zbox初始化在使用 zbox 之前，需要先初始化 zbox 库。可以通过以下代码实现：123456789use zbox::{init_env, RepoOpener};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap();}创建文件可以通过以下代码创建一个文件：12345678910111213141516use std::io::Write;use zbox::{init_env, RepoOpener};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap(); // 创建文件 let mut file = repo.create_file(\"/my_file.txt\").unwrap(); // 写入数据 file.write_all(b\"Hello, world!\").unwrap();}读取文件可以通过以下代码读取一个文件：12345678910111213141516171819use std::io::Read;use zbox::{init_env, RepoOpener};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap(); // 打开文件 let mut file = repo.open_file(\"/my_file.txt\").unwrap(); // 读取数据 let mut buf = Vec::new(); file.read_to_end(&amp;mut buf).unwrap(); println!(\"{}\", String::from_utf8_lossy(&amp;buf));}创建目录可以通过以下代码创建一个目录：123456789101112use zbox::{init_env, RepoOpener};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap(); // 创建目录 repo.create_dir(\"/my_dir\").unwrap();}列出目录可以通过以下代码列出一个目录下的所有文件和目录：123456789101112131415use zbox::{init_env, RepoOpener};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap(); // 列出目录 let entries = repo.read_dir(\"/\").unwrap(); for entry in entries { println!(\"{}\", entry.path().display()); }}删除文件或目录可以通过以下代码删除一个文件或目录：123456789101112131415use zbox::{init_env, RepoOpener};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap(); // 删除文件 repo.remove_file(\"/my_file.txt\").unwrap(); // 删除目录 repo.remove_dir(\"/my_dir\").unwrap();}复制文件或目录可以通过以下代码复制一个文件或目录：123456789101112131415use zbox::{init_env, RepoOpener};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap(); // 复制文件 repo.copy_file(\"/my_file.txt\", \"/my_file_copy.txt\").unwrap(); // 复制目录 repo.copy_dir(\"/my_dir\", \"/my_dir_copy\").unwrap();}移动文件或目录可以通过以下代码移动一个文件或目录：123456789101112131415use zbox::{init_env, RepoOpener};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap(); // 移动文件 repo.rename(\"/my_file.txt\", \"/my_file_new.txt\").unwrap(); // 移动目录 repo.rename(\"/my_dir\", \"/my_dir_new\").unwrap();}进阶用法文件加密可以通过以下代码将一个文件加密：123456789101112131415161718use std::io::Write;use zbox::{init_env, RepoOpener, OpenOptions};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap(); // 创建加密文件 let mut options = OpenOptions::new(); options.create(true).encrypt(true); let mut file = repo.open_file_with_options(\"/my_file.txt\", &amp;options).unwrap(); // 写入数据 file.write_all(b\"Hello, world!\").unwrap();}文件版本控制可以通过以下代码实现文件版本控制：123456789101112131415161718192021use std::io::Write;use zbox::{init_env, RepoOpener, OpenOptions};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap(); // 创建加密文件 let mut options = OpenOptions::new(); options.create(true).version_limit(10); let mut file = repo.open_file_with_options(\"/my_file.txt\", &amp;options).unwrap(); // 写入数据 file.write_all(b\"Hello, world!\").unwrap(); // 写入新版本 file.write_all(b\"Hello, Rust!\").unwrap();}文件共享可以通过以下代码实现文件共享：123456789101112131415161718use std::io::Write;use zbox::{init_env, RepoOpener, OpenOptions};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap(); // 创建加密文件 let mut options = OpenOptions::new(); options.create(true).share(true); let mut file = repo.open_file_with_options(\"/my_file.txt\", &amp;options).unwrap(); // 写入数据 file.write_all(b\"Hello, world!\").unwrap();}文件缓存可以通过以下代码实现文件缓存：123456789101112131415161718use std::io::Write;use zbox::{init_env, RepoOpener, OpenOptions};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap(); // 创建加密文件 let mut options = OpenOptions::new(); options.create(true).cache_size(1024); let mut file = repo.open_file_with_options(\"/my_file.txt\", &amp;options).unwrap(); // 写入数据 file.write_all(b\"Hello, world!\").unwrap();}最佳实践多线程使用在多线程环境下使用 zbox，需要使用线程安全的 Repo 对象。可以通过以下代码实现：12345678910111213141516171819202122232425use std::sync::{Arc, RwLock};use zbox::{init_env, RepoOpener};fn main() { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = Arc::new(RwLock::new(RepoOpener::new().create(true).open(\"zbox://./my_repo\").unwrap())); // 多线程使用repo { let repo = repo.read().unwrap(); let mut file = repo.create_file(\"/my_file.txt\").unwrap(); file.write_all(b\"Hello, world!\").unwrap(); } { let repo = repo.read().unwrap(); let mut file = repo.open_file(\"/my_file.txt\").unwrap(); let mut buf = Vec::new(); file.read_to_end(&amp;mut buf).unwrap(); println!(\"{}\", String::from_utf8_lossy(&amp;buf)); }}错误处理在使用 zbox 时，需要注意错误处理。可以通过以下代码实现：123456789101112131415161718192021222324use std::io::{Read, Write};use zbox::{Error, init_env, RepoOpener};fn main() -&gt; Result&lt;(), Error&gt; { // 初始化zbox库 init_env(); // 打开或创建存储库 let repo = RepoOpener::new().create(true).open(\"zbox://./my_repo\")?; // 创建文件 let mut file = repo.create_file(\"/my_file.txt\")?; // 写入数据 file.write_all(b\"Hello, world!\")?; // 读取数据 let mut buf = Vec::new(); file.read_to_end(&amp;mut buf)?; println!(\"{}\", String::from_utf8_lossy(&amp;buf)); Ok(())}性能优化在使用 zbox 时，可以通过以下方法进行性能优化： 使用 Zero-copy 技术，避免不必要的内存拷贝； 使用 Copy-on-write 技术，避免不必要的数据复制； 使用引用计数技术，避免不必要的内存分配和释放； 使用缓存技术，加快数据访问速度。总结本教程介绍了 Rust 语言 zbox 模块的基础用法和进阶用法，并提供了最佳实践。zbox 是一个高效、安全、可靠的分布式存储库，可以帮助开发者快速构建分布式存储系统。在使用 zbox 时，需要注意错误处理和性能优化。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 二进制自压缩序列化bincode模块",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, bincode",
      "url"         : "./rust/2023/04/23/rust_lang_tutorial_232_serde_bincode.html",
      "date"        : "2023-04-23 00:00:00 +0800",
      "description" : "",
      "content"     : "Bincode 是一个用于 Rust 语言的二进制编码库，用于将 Rust 结构体序列化为二进制格式，或者将二进制格式反序列化为 Rust 结构体。它支持大多数 Rust 原生类型和自定义类型，并且可以高效地处理大型数据结构。Bincode 还支持压缩和解压缩，以减小序列化后的数据大小。基础用法序列化和反序列化一个简单的结构体12345678910111213141516171819202122use bincode::{serialize, deserialize};#[derive(Serialize, Deserialize, Debug, PartialEq)]struct Person { name: String, age: u8,}fn main() { let person = Person { name: \"Alice\".to_string(), age: 25, }; // Serialize let encoded: Vec&lt;u8&gt; = serialize(&amp;person).unwrap(); // Deserialize let decoded: Person = deserialize(&amp;encoded[..]).unwrap(); assert_eq!(person, decoded);}在这个示例中，我们定义了一个Person结构体，它有一个name字段和一个age字段。我们将其序列化为一个字节数组，然后将其反序列化回Person结构体，并将其与原始结构体进行比较。序列化和反序列化一个嵌套结构体1234567891011121314151617181920212223242526272829303132333435use bincode::{serialize, deserialize};#[derive(Serialize, Deserialize, Debug, PartialEq)]struct Address { street: String, city: String, zip: String,}#[derive(Serialize, Deserialize, Debug, PartialEq)]struct Person { name: String, age: u8, address: Address,}fn main() { let person = Person { name: \"Alice\".to_string(), age: 25, address: Address { street: \"123 Main St\".to_string(), city: \"Anytown\".to_string(), zip: \"12345\".to_string(), }, }; // Serialize let encoded: Vec&lt;u8&gt; = serialize(&amp;person).unwrap(); // Deserialize let decoded: Person = deserialize(&amp;encoded[..]).unwrap(); assert_eq!(person, decoded);}这个示例中，我们定义了一个Person结构体，它包含一个嵌套的Address结构体。我们将其序列化为一个字节数组，然后将其反序列化回Person结构体，并将其与原始结构体进行比较。序列化和反序列化一个向量12345678910111213use bincode::{serialize, deserialize};fn main() { let numbers = vec![1, 2, 3, 4, 5]; // Serialize let encoded: Vec&lt;u8&gt; = serialize(&amp;numbers).unwrap(); // Deserialize let decoded: Vec&lt;i32&gt; = deserialize(&amp;encoded[..]).unwrap(); assert_eq!(numbers, decoded);}在这个示例中，我们定义了一个包含整数的向量。我们将其序列化为一个字节数组，然后将其反序列化回一个整数向量，并将其与原始向量进行比较。序列化和反序列化一个哈希表1234567891011121314151617use std::collections::HashMap;use bincode::{serialize, deserialize};fn main() { let mut map = HashMap::new(); map.insert(\"Alice\", 25); map.insert(\"Bob\", 30); map.insert(\"Charlie\", 35); // Serialize let encoded: Vec&lt;u8&gt; = serialize(&amp;map).unwrap(); // Deserialize let decoded: HashMap&lt;&amp;str, i32&gt; = deserialize(&amp;encoded[..]).unwrap(); assert_eq!(map, decoded);}在这个示例中，我们定义了一个包含键值对的哈希表。我们将其序列化为一个字节数组，然后将其反序列化回一个哈希表，并将其与原始哈希表进行比较。序列化和反序列化一个枚举1234567891011121314151617181920use bincode::{serialize, deserialize};#[derive(Serialize, Deserialize, Debug, PartialEq)]enum Color { Red, Green, Blue,}fn main() { let color = Color::Green; // Serialize let encoded: Vec&lt;u8&gt; = serialize(&amp;color).unwrap(); // Deserialize let decoded: Color = deserialize(&amp;encoded[..]).unwrap(); assert_eq!(color, decoded);}在这个示例中，我们定义了一个枚举类型Color，它有三个可能的值。我们将其序列化为一个字节数组，然后将其反序列化回一个Color枚举，并将其与原始枚举进行比较。序列化和反序列化一个字符串12345678910111213use bincode::{serialize, deserialize};fn main() { let message = \"Hello, world!\".to_string(); // Serialize let encoded: Vec&lt;u8&gt; = serialize(&amp;message).unwrap(); // Deserialize let decoded: String = deserialize(&amp;encoded[..]).unwrap(); assert_eq!(message, decoded);}在这个示例中，我们定义了一个字符串。我们将其序列化为一个字节数组，然后将其反序列化回一个字符串，并将其与原始字符串进行比较。压缩和解压缩序列化后的数据123456789101112131415161718192021222324use bincode::{serialize, deserialize, config};use flate2::{Compression, read::DeflateEncoder, write::DeflateDecoder};fn main() { let numbers = vec![1, 2, 3, 4, 5]; // Serialize let encoded: Vec&lt;u8&gt; = serialize(&amp;numbers).unwrap(); // Compress let mut compressed = Vec::new(); let mut encoder = DeflateEncoder::new(&amp;encoded[..], Compression::default()); encoder.read_to_end(&amp;mut compressed).unwrap(); // Decompress let mut decompressed = Vec::new(); let mut decoder = DeflateDecoder::new(&amp;compressed[..]); decoder.read_to_end(&amp;mut decompressed).unwrap(); // Deserialize let decoded: Vec&lt;i32&gt; = deserialize(&amp;decompressed[..]).unwrap(); assert_eq!(numbers, decoded);}在这个示例中，我们定义了一个包含整数的向量。我们将其序列化为一个字节数组，然后将其压缩为另一个字节数组。我们将压缩后的字节数组解压缩为另一个字节数组，然后将其反序列化回一个整数向量，并将其与原始向量进行比较。使用自定义配置序列化和反序列化1234567891011121314151617181920212223242526use bincode::{serialize_with, deserialize_from, config};use std::io::{Cursor, Write};#[derive(Debug, PartialEq)]struct Person { name: String, age: u8,}fn main() { let person = Person { name: \"Alice\".to_string(), age: 25, }; // Serialize let mut buffer = Cursor::new(Vec::new()); serialize_with(&amp;mut buffer, &amp;person, config().big_endian()).unwrap(); let encoded = buffer.into_inner(); // Deserialize let mut cursor = Cursor::new(encoded); let decoded: Person = deserialize_from(&amp;mut cursor, config().big_endian()).unwrap(); assert_eq!(person, decoded);}在这个示例中，我们定义了一个Person结构体，它有一个name字段和一个age字段。我们将其序列化为一个字节数组，并使用自定义配置将其编码为大端字节序。我们将编码后的字节数组反序列化回Person结构体，并使用相同的自定义配置来解码它。进阶用法自定义序列化和反序列化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152use bincode::{serialize, deserialize, Error, ErrorKind};use std::io::{Cursor, Write, Read};#[derive(Debug, PartialEq)]struct Person { name: String, age: u8,}impl Person { fn serialize&lt;W: Write&gt;(&amp;self, writer: &amp;mut W) -&gt; Result&lt;(), Error&gt; { let name_bytes = self.name.as_bytes(); if name_bytes.len() &gt; 255 { return Err(Error::new(ErrorKind::Custom(\"name too long\".to_string()))); } writer.write_all(&amp;(name_bytes.len() as u8).to_le_bytes())?; writer.write_all(name_bytes)?; writer.write_all(&amp;self.age.to_le_bytes())?; Ok(()) } fn deserialize&lt;R: Read&gt;(reader: &amp;mut R) -&gt; Result&lt;Self, Error&gt; { let mut name_len_bytes = [0; 1]; reader.read_exact(&amp;mut name_len_bytes)?; let name_len = name_len_bytes[0] as usize; let mut name_bytes = vec![0; name_len]; reader.read_exact(&amp;mut name_bytes)?; let name = String::from_utf8(name_bytes)?; let mut age_bytes = [0; 1]; reader.read_exact(&amp;mut age_bytes)?; let age = age_bytes[0]; Ok(Person { name, age }) }}fn main() { let person = Person { name: \"Alice\".to_string(), age: 25, }; // Serialize let mut buffer = Cursor::new(Vec::new()); person.serialize(&amp;mut buffer).unwrap(); let encoded = buffer.into_inner(); // Deserialize let mut cursor = Cursor::new(encoded); let decoded: Person = Person::deserialize(&amp;mut cursor).unwrap(); assert_eq!(person, decoded);}在这个示例中，我们定义了一个Person结构体，并实现了自定义的序列化和反序列化方法。在序列化方法中，我们将名称长度编码为一个字节，然后将名称和年龄编码为字节数组。在反序列化方法中，我们首先读取名称长度字节，然后读取名称和年龄字节，并将它们解码为一个Person结构体。自定义大小端序列化和反序列化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162use bincode::{serialize, deserialize, Error, ErrorKind};use std::io::{Cursor, Write, Read};#[derive(Debug, PartialEq)]struct Person { name: String, age: u8,}impl Person { fn serialize&lt;W: Write&gt;(&amp;self, writer: &amp;mut W, big_endian: bool) -&gt; Result&lt;(), Error&gt; { let name_bytes = self.name.as_bytes(); if name_bytes.len() &gt; 255 { return Err(Error::new(ErrorKind::Custom(\"name too long\".to_string()))); } let mut name_len_bytes = [0; 1]; name_len_bytes[0] = name_bytes.len() as u8; if big_endian { writer.write_all(&amp;name_len_bytes[..].reverse())?; } else { writer.write_all(&amp;name_len_bytes[..])?; } writer.write_all(name_bytes)?; writer.write_all(&amp;self.age.to_le_bytes())?; Ok(()) } fn deserialize&lt;R: Read&gt;(reader: &amp;mut R, big_endian: bool) -&gt; Result&lt;Self, Error&gt; { let mut name_len_bytes = [0; 1]; reader.read_exact(&amp;mut name_len_bytes)?; let name_len = if big_endian { u8::from_be_bytes(name_len_bytes) } else { u8::from_le_bytes(name_len_bytes) } as usize; let mut name_bytes = vec![0; name_len]; reader.read_exact(&amp;mut name_bytes)?; let name = String::from_utf8(name_bytes)?; let mut age_bytes = [0; 1]; reader.read_exact(&amp;mut age_bytes)?; let age = age_bytes[0]; Ok(Person { name, age }) }}fn main() { let person = Person { name: \"Alice\".to_string(), age: 25, }; // Serialize let mut buffer = Cursor::new(Vec::new()); person.serialize(&amp;mut buffer, true).unwrap(); let encoded = buffer.into_inner(); // Deserialize let mut cursor = Cursor::new(encoded); let decoded: Person = Person::deserialize(&amp;mut cursor, true).unwrap(); assert_eq!(person, decoded);}在这个示例中，我们定义了一个Person结构体，并实现了自定义的大小端序列化和反序列化方法。在序列化方法中，我们将名称长度编码为一个字节，并根据big_endian参数决定字节序。在反序列化方法中，我们首先读取名称长度字节，并根据big_endian参数解码字节序。然后，我们读取名称和年龄字节，并将它们解码为一个Person结构体。序列化和反序列化一个动态数组1234567891011121314151617181920212223242526272829303132use bincode::{serialize, deserialize};#[derive(Serialize, Deserialize, Debug, PartialEq)]struct Person { name: String, age: u8,}fn main() { let people = vec![ Person { name: \"Alice\".to_string(), age: 25, }, Person { name: \"Bob\".to_string(), age: 30, }, Person { name: \"Charlie\".to_string(), age: 35, }, ]; // Serialize let encoded: Vec&lt;u8&gt; = serialize(&amp;people).unwrap(); // Deserialize let decoded: Vec&lt;Person&gt; = deserialize(&amp;encoded[..]).unwrap(); assert_eq!(people, decoded);}在这个示例中，我们定义了一个包含Person结构体的动态数组。我们将其序列化为一个字节数组，然后将其反序列化回一个Person结构体的动态数组，并将其与原始数组进行比较。序列化和反序列化一个结构体的子集1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859use bincode::{serialize, deserialize};#[derive(Serialize, Deserialize, Debug, PartialEq)]struct Person { name: String, age: u8, address: String,}#[derive(Serialize, Deserialize, Debug, PartialEq)]struct PersonSubset { name: String, age: u8,}fn main() { let person = Person { name: \"Alice\".to_string(), age: 25, address: \"123 Main St\".to_string(), }; // Serialize subset let encoded: Vec&lt;u8&gt; = serialize(&amp;PersonSubset { name: person.name.clone(), age: person.age, }) .unwrap(); // Deserialize subset let decoded: PersonSubset = deserialize(&amp;encoded[..]).unwrap(); assert_eq!( decoded, PersonSubset { name: \"Alice\".to_string(), age: 25 } ); // Deserialize full struct from subset bytes let decoded_full: Person = deserialize(&amp;encoded[..]).unwrap(); assert_eq!( decoded_full, Person { name: \"Alice\".to_string(), age: 25, address: \"\".to_string() } ); // Serialize full struct to subset bytes let encoded_subset: Vec&lt;u8&gt; = serialize(&amp;PersonSubset { name: person.name.clone(), age: person.age, }) .unwrap(); assert_eq!(encoded, encoded_subset);}在这个示例中，我们定义了一个Person结构体，它有一个name字段、一个age字段和一个address字段。我们将其序列化为一个字节数组，然后将其反序列化回一个PersonSubset结构体的字节数组，该结构体只包含name和age字段。我们还演示了如何从子集字节数组反序列化回完整的结构体，以及如何将完整的结构体序列化为子集字节数组。使用自定义配置在某些情况下，您可能需要使用自定义配置来序列化和反序列化数据。例如，您可能需要使用大端字节序而不是默认的小端字节序。您可以使用bincode::config()函数创建一个默认配置，然后使用bincode::serialize_with()和bincode::deserialize_from()函数序列化和反序列化数据。例如：12345678910111213141516use bincode::{serialize_with, deserialize_from, config};use std::io::{Cursor, Write};let person = Person { name: \"Alice\".to_string(), age: 25,};// Serialize with big endian byte orderlet mut buffer = Cursor::new(Vec::new());serialize_with(&amp;mut buffer, &amp;person, config().big_endian()).unwrap();let encoded = buffer.into_inner();// Deserialize with big endian byte orderlet mut cursor = Cursor::new(encoded);let decoded: Person = deserialize_from(&amp;mut cursor, config().big_endian()).unwrap();优化序列化和反序列化性能为了优化序列化和反序列化性能，可以使用bincode::config模块中的DefaultOptions和Options结构体，调整序列化和反序列化的选项。以下是一个优化性能的示例：123456789101112use bincode::{serialize_with_options, deserialize_with_options, DefaultOptions};// 优化性能let mut options = DefaultOptions::new();options.limit = bincode::Bounded(1024); // 限制序列化和反序列化的最大字节数let data = vec![0; 1024 * 1024 * 1024]; // 1GB数据// 序列化大数据量let encoded: Vec&lt;u8&gt; = serialize_with_options(&amp;data, options).unwrap();// 反序列化大数据量let decoded: Vec&lt;u8&gt; = deserialize_with_options(&amp;encoded[..], options).unwrap();处理序列化和反序列化错误在序列化和反序列化过程中，可能会出现错误。为了处理这些错误，可以使用Result类型和bincode::Error枚举类型。以下是一个处理错误的示例：12345678910111213141516use bincode::{serialize, deserialize, Error};// 处理错误let num = \"abc\";let encoded: Result&lt;Vec&lt;u8&gt;, Error&gt; = serialize(&amp;num);match encoded { Ok(v) =&gt; println!(\"Encoded: {:?}\", v), Err(e) =&gt; println!(\"Error: {:?}\", e),}let encoded = vec![1, 2, 3];let decoded: Result&lt;String, Error&gt; = deserialize(&amp;encoded[..]);match decoded { Ok(v) =&gt; println!(\"Decoded: {:?}\", v), Err(e) =&gt; println!(\"Error: {:?}\", e),}总结Bincode 是 Rust 语言中的一个二进制编码库，可以将 Rust 的数据结构序列化为二进制格式，以便于存储和传输。使用 Bincode 可以方便地将数据序列化为二进制格式，也可以反序列化二进制数据为 Rust 数据结构。Bincode 支持大部分 Rust 的数据类型，包括基本类型、结构体、枚举、数组、元组等。在序列化和反序列化过程中，Bincode 会自动进行类型检查和字节对齐，保证数据的正确性和兼容性。同时，Bincode 还支持自定义序列化和反序列化方法，以满足特殊需求。为了优化序列化和反序列化性能，可以使用bincode::config模块中的DefaultOptions和Options结构体，调整序列化和反序列化的选项。在序列化和反序列化过程中，可能会出现错误，可以使用Result类型和bincode::Error枚举类型来处理这些错误。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 轻量级Http客户端Hyper",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Plotters",
      "url"         : "./rust/2023/04/23/rust_lang_tutorial_231_http_Hyper.html",
      "date"        : "2023-04-23 00:00:00 +0800",
      "description" : "",
      "content"     : "Hyper 是一个用于构建 HTTP 客户端和服务器的 Rust 语言库。它提供了一个简单易用的 API，使得开发者可以轻松地构建高性能、可靠的 HTTP 应用程序。Hyper 的设计目标是安全、高效和易于使用。Hyper 的主要特点包括： 支持 HTTP/1 和 HTTP/2 协议 纯 Rust 实现，无需外部依赖 支持异步 I/O 和多线程 提供简单易用的 API在本教程中，我们将介绍 Hyper 的基础用法和进阶用法，并提供一些最佳实践。 相比于系列文章中介绍的 reqwest, Hyper 设计的更底层，模块化的设计，可以最大限度的允许用户在硬件配置较低的嵌入式设备上使用。假如只是需要一个“好用”的 Http 客户端，推荐使用 reqwest 模块基础用法发送 HTTP 请求使用 Hyper 发送 HTTP 请求非常简单。下面是一个简单的示例，它使用 Hyper 发送一个 GET 请求并打印响应的内容：123456789use hyper::Client;fn main() { let client = Client::new(); let res = client.get(\"http://example.com\").send().unwrap(); println!(\"{}\", res.status()); println!(\"{}\", res.headers()); println!(\"{}\", res.text().unwrap());}在这个示例中，我们首先创建了一个 Hyper 客户端。然后，我们使用get()方法发送一个 GET 请求，并使用send()方法发送请求。最后，我们打印响应的状态码、头和内容。发送 POST 请求Hyper 还支持发送 POST 请求。下面是一个简单的示例，它使用 Hyper 发送一个 POST 请求并打印响应的内容：123456789101112use hyper::{Client, Request, Body};fn main() { let client = Client::new(); let req = Request::post(\"http://example.com\") .body(Body::from(\"hello world\")) .unwrap(); let res = client.request(req).unwrap(); println!(\"{}\", res.status()); println!(\"{}\", res.headers()); println!(\"{}\", res.text().unwrap());}在这个示例中，我们首先创建了一个 Hyper 客户端。然后，我们使用Request::post()方法创建一个 POST 请求，并使用Body::from()方法设置请求体。最后，我们使用request()方法发送请求，并打印响应的状态码、头和内容。使用代理服务器Hyper 还支持使用代理服务器发送 HTTP 请求。下面是一个简单的示例，它使用 Hyper 发送一个通过代理服务器的 HTTP 请求并打印响应的内容：123456789101112use hyper::{Client, Uri};fn main() { let client = Client::builder() .proxy(Uri::from_static(\"http://proxy.example.com\")) .build() .unwrap(); let res = client.get(\"http://example.com\").send().unwrap(); println!(\"{}\", res.status()); println!(\"{}\", res.headers()); println!(\"{}\", res.text().unwrap());}在这个示例中，我们使用Client::builder()方法创建一个 Hyper 客户端，并使用proxy()方法设置代理服务器的地址。然后，我们使用get()方法发送一个 GET 请求，并使用send()方法发送请求。最后，我们打印响应的状态码、头和内容。使用自定义头Hyper 还支持使用自定义头发送 HTTP 请求。下面是一个简单的示例，它使用 Hyper 发送一个带有自定义头的 HTTP 请求并打印响应的内容：1234567891011use hyper::{Client, header};fn main() { let client = Client::new(); let mut req = client.get(\"http://example.com\").unwrap(); req.headers_mut().insert(header::USER_AGENT, header::HeaderValue::from_static(\"my-user-agent\")); let res = client.execute(req).unwrap(); println!(\"{}\", res.status()); println!(\"{}\", res.headers()); println!(\"{}\", res.text().unwrap());}在这个示例中，我们首先创建了一个 Hyper 客户端。然后，我们使用get()方法创建一个 GET 请求，并使用headers_mut()方法插入一个自定义头。最后，我们使用execute()方法发送请求，并打印响应的状态码、头和内容。使用异步 I/OHyper 支持异步 I/O，这使得它可以处理大量的并发请求。下面是一个简单的示例，它使用 Hyper 异步发送 HTTP 请求并打印响应的内容：12345678910111213use hyper::{Client, Uri};#[tokio::main]async fn main() { let client = Client::new(); let uri = Uri::from_static(\"http://example.com\"); let res = client.get(uri).await.unwrap(); println!(\"{}\", res.status()); println!(\"{}\", res.headers()); let body = res.into_body(); let bytes = hyper::body::to_bytes(body).await.unwrap(); println!(\"{}\", String::from_utf8_lossy(&amp;bytes));}在这个示例中，我们首先创建了一个 Hyper 客户端。然后，我们使用Uri::from_static()方法创建一个 URI，并使用get()方法发送一个 GET 请求。由于我们使用了tokio::main宏，因此我们可以使用await关键字等待异步请求的完成。最后，我们打印响应的状态码、头和内容。使用 CookiesHyper 还支持使用 Cookies 发送 HTTP 请求。下面是一个简单的示例，它使用 Hyper 发送一个带有 Cookies 的 HTTP 请求并打印响应的内容：12345678910111213141516use hyper::{Client, Uri};use hyper::header::{COOKIE, SET_COOKIE};fn main() { let client = Client::new(); let uri = Uri::from_static(\"http://example.com\"); let mut req = client.get(uri).unwrap(); req.headers_mut().insert(COOKIE, header::HeaderValue::from_static(\"name=value\")); let res = client.execute(req).unwrap(); println!(\"{}\", res.status()); println!(\"{}\", res.headers()); if let Some(cookie) = res.headers().get(SET_COOKIE) { println!(\"{}\", cookie.to_str().unwrap()); } println!(\"{}\", res.text().unwrap());}在这个示例中，我们首先创建了一个 Hyper 客户端。然后，我们使用Uri::from_static()方法创建一个 URI，并使用get()方法创建一个 GET 请求。然后，我们使用headers_mut()方法插入一个 Cookie 头。最后，我们使用execute()方法发送请求，并打印响应的状态码、头、设置的 Cookie 和内容。处理错误Hyper 的 API 返回的结果类型是Result，因此我们可以使用标准的 Rust 错误处理机制来处理错误。下面是一个简单的示例，它使用 Hyper 发送一个 HTTP 请求并处理错误：123456789101112use hyper::{Client, Uri};use std::error::Error;fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let client = Client::new(); let uri = Uri::from_static(\"http://example.com\"); let res = client.get(uri)?.send()?; println!(\"{}\", res.status()); println!(\"{}\", res.headers()); println!(\"{}\", res.text()?); Ok(())}在这个示例中，我们首先创建了一个 Hyper 客户端。然后，我们使用Uri::from_static()方法创建一个 URI，并使用get()方法创建一个 GET 请求。然后，我们使用send()方法发送请求，并使用?操作符处理可能的错误。最后，我们打印响应的状态码、头和内容，并返回一个Result类型的空值。进阶用法使用连接池Hyper 支持使用连接池来提高 HTTP 请求的性能。下面是一个简单的示例，它使用 Hyper 连接池发送 HTTP 请求并打印响应的内容：1234567891011121314151617181920use hyper::{Client, Uri};use hyper::client::HttpConnector;use hyper::rt::{self, Future, Stream};use hyper_tls::HttpsConnector;use std::sync::Arc;fn main() { let https = HttpsConnector::new(4).unwrap(); let client = Client::builder() .build::&lt;_, hyper::Body&gt;(https); let uri = Uri::from_static(\"https://example.com\"); let req = client.get(uri).and_then(|res| { println!(\"{}\", res.status()); println!(\"{}\", res.headers()); res.into_body().concat2() }).map(|body| { println!(\"{}\", String::from_utf8_lossy(&amp;body)); }); rt::run(req);}在这个示例中，我们首先创建了一个 Hyper 连接池。然后，我们使用Client::builder()方法创建一个 Hyper 客户端，并使用build()方法设置连接池。然后，我们使用get()方法创建一个 GET 请求，并使用and_then()方法处理响应。最后，我们使用concat2()方法将响应体连接起来，并使用map()方法打印响应的内容。使用 WebSocketHyper 还支持使用 WebSocket 协议。下面是一个简单的示例，它使用 Hyper 创建一个 WebSocket 连接并发送消息：12345678910111213141516171819use hyper::{Client, Uri};use tokio::runtime::Runtime;use tokio_tungstenite::tungstenite::Message;use tokio_tungstenite::WebSocketStream;fn main() { let mut rt = Runtime::new().unwrap(); rt.block_on(async { let client = Client::new(); let uri = Uri::from_static(\"ws://example.com\"); let (ws_stream, _) = client.websocket(uri).await.unwrap(); let (mut write, mut read) = WebSocketStream::new(ws_stream).split(); write.send(Message::Text(\"hello world\".to_string())).await.unwrap(); while let Some(msg) = read.next().await { let msg = msg.unwrap(); println!(\"{}\", msg.to_text().unwrap()); } });}在这个示例中，我们首先创建了一个 Tokio 运行时。然后，我们使用Client::new()方法创建一个 Hyper 客户端。然后，我们使用Uri::from_static()方法创建一个 URI，并使用websocket()方法创建一个 WebSocket 连接。然后，我们使用split()方法将 WebSocket 流拆分为读取和写入两个部分。然后，我们使用send()方法发送一个文本消息，并使用next()方法等待接收消息。最后，我们打印接收到的消息。处理连接超时Hyper 支持设置连接和请求的超时时间。下面是一个简单的示例，它使用 Hyper 发送一个 HTTP 请求，并设置连接和请求的超时时间：12345678910111213141516171819use hyper::{Client, Uri};use std::time::Duration;fn main() { let client = Client::builder() .keep_alive_timeout(Duration::from_secs(30)) .build() .unwrap(); let uri = Uri::from_static(\"http://example.com\"); let req = client.get(uri) .timeout(Duration::from_secs(10)) .send() .map(|res| { println!(\"{}\", res.status()); println!(\"{}\", res.headers()); println!(\"{}\", res.text().unwrap()); }); tokio::run(req);}在这个示例中，我们首先使用Client::builder()方法创建一个 Hyper 客户端，并使用keep_alive_timeout()方法设置连接的超时时间。然后，我们使用timeout()方法设置请求的超时时间。最后，我们使用send()方法发送请求，并使用map()方法处理响应。使用自定义 TLS 配置Hyper 支持使用自定义的 TLS 配置来发送 HTTPS 请求。下面是一个简单的示例，它使用 Hyper 发送一个带有自定义 TLS 配置的 HTTPS 请求并打印响应的内容：12345678910111213141516171819202122232425use hyper::{Client, Uri};use hyper_tls::HttpsConnector;use std::error::Error;use std::fs::File;use std::io::Read;use std::path::Path;use tokio::runtime::Runtime;fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let mut rt = Runtime::new()?; rt.block_on(async { let mut buf = Vec::new(); let mut file = File::open(Path::new(\"cert.pem\"))?; file.read_to_end(&amp;mut buf)?; let https = HttpsConnector::with_connector(HttpsConnector::new(4)?, &amp;buf)?; let client = Client::builder() .build::&lt;_, hyper::Body&gt;(https); let uri = Uri::from_static(\"https://example.com\"); let res = client.get(uri).await?; println!(\"{}\", res.status()); println!(\"{}\", res.headers()); println!(\"{}\", res.text().await?); Ok(()) })}在这个示例中，我们首先创建了一个 Tokio 运行时。然后，我们使用File::open()方法打开一个证书文件，并使用read_to_end()方法读取证书内容。然后，我们使用HttpsConnector::with_connector()方法创建一个自定义的 HTTPS 连接器，并使用Client::builder()方法创建一个 Hyper 客户端。然后，我们使用get()方法创建一个 GET 请求，并使用await关键字等待异步请求的完成。最后，我们打印响应的状态码、头和内容，并返回一个Result类型的空值。最佳实践 使用连接池提高性能Hyper 提供了连接池的功能，可以有效地提高 HTTP 请求的性能。在实际开发中，我们应该尽可能地使用连接池来发送 HTTP 请求，以提高性能和减少资源消耗。 使用异步 I/O 提高并发性能Hyper 使用异步 I/O 实现了高性能的 HTTP 客户端和服务器端，我们应该尽可能地使用异步 I/O 来提高并发性能。 使用 HTTPS 保证安全性在发送 HTTP 请求时，我们应该尽可能地使用 HTTPS 来保证通信的安全性。Hyper 提供了对 HTTPS 的支持，可以轻松地实现 HTTPS 通信。 使用请求/响应拦截器进行处理Hyper 提供了请求/响应拦截器的功能，可以对 HTTP 请求和响应进行处理。在实际开发中，我们应该尽可能地使用请求/响应拦截器来实现一些通用的处理逻辑，例如日志记录、错误处理等。总结Hyper 是 Rust 语言中一个非常流行的 HTTP 客户端和服务器端开发库，它提供了一套简单易用的 API，可以轻松地构建高性能的 Web 应用程序。在本教程中，我们介绍了 Hyper 的基础用法和进阶用法，并提供了一些最佳实践和示例代码。希望这个教程能够帮助你更好地了解 Hyper，并在实际开发中使用它。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 支持WASM的高性能绘图库Plotters",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Plotters",
      "url"         : "./rust/2023/04/23/rust_lang_tutorial_230_charts_plotters.html",
      "date"        : "2023-04-23 00:00:00 +0800",
      "description" : "",
      "content"     : "Plotters 是一个基于 Rust 语言的绘图库，由 Eonil 和其他贡献者开发。它的目标是提供一个简单易用的 API，可以轻松地创建各种类型的图表，并支持多种输出格式。Plotters 使用 Rust 语言的强类型系统和高性能，可以生成高质量的图表。Plotters 提供了多种类型的图表，包括线图、柱状图、散点图等等。它还支持多种输出格式，包括 PNG、SVG、PDF 等等。使用 Plotters 可以轻松地创建高质量的图表，同时还可以自定义图表的样式和布局。用法实战安装 Plotters在使用 Plotters 之前，需要安装 Plotters。可以通过以下命令安装 Plotters：1cargo install plotters绘制折线图下面是一个简单的例子，演示如何使用 Plotters 绘制折线图：1234567891011121314151617181920212223use plotters::prelude::*;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let root = BitMapBackend::new(\"plot.png\", (640, 480)).into_drawing_area(); root.fill(&amp;WHITE)?; let mut chart = ChartBuilder::on(&amp;root) .caption(\"折线图\", (\"sans-serif\", 30)) .set_label_area_size(LabelAreaPosition::Left, 40) .set_label_area_size(LabelAreaPosition::Bottom, 40) .build_cartesian_2d(0..10, 0..10)?; chart.configure_mesh().draw()?; chart.draw_series(LineSeries::new( vec![(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9)] .iter() .map(|x| (*x, *x)), &amp;BLUE, ))?; Ok(())}这个例子中，我们首先创建了一个BitMapBackend对象，用于输出 PNG 格式的图片。然后，我们创建了一个ChartBuilder对象，用于构建图表。在ChartBuilder对象上，我们设置了标题、坐标轴标签和网格线。最后，我们使用LineSeries对象绘制了一条折线。LineSeries对象需要一个元组列表作为输入，每个元组包含一个 x 坐标和一个 y 坐标。在这个例子中，我们绘制了一条从(0,0)到(9,9)的折线。绘制柱状图下面是一个简单的例子，演示如何使用 Plotters 绘制柱状图：1234567891011121314151617181920212223use plotters::prelude::*;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let root = BitMapBackend::new(\"plot.png\", (640, 480)).into_drawing_area(); root.fill(&amp;WHITE)?; let mut chart = ChartBuilder::on(&amp;root) .caption(\"柱状图\", (\"sans-serif\", 30)) .set_label_area_size(LabelAreaPosition::Left, 40) .set_label_area_size(LabelAreaPosition::Bottom, 40) .build_cartesian_2d(0..10, 0..10)?; chart.configure_mesh().draw()?; chart.draw_series( Histogram::vertical(&amp;chart) .margin(5) .style(GREEN.filled()) .data(vec![2, 3, 4, 5, 6, 7, 8, 9]), )?; Ok(())}这个例子中，我们首先创建了一个BitMapBackend对象，用于输出 PNG 格式的图片。然后，我们创建了一个ChartBuilder对象，用于构建图表。在ChartBuilder对象上，我们设置了标题、坐标轴标签和网格线。最后，我们使用Histogram对象绘制了一组柱状。Histogram对象需要一个整数向量作为输入，每个整数表示一个柱状的高度。在这个例子中，我们绘制了一组高度为 2 到 9 的柱状。绘制散点图下面是一个简单的例子，演示如何使用 Plotters 绘制散点图：123456789101112131415161718192021222324252627use plotters::prelude::*;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let root = BitMapBackend::new(\"plot.png\", (640, 480)).into_drawing_area(); root.fill(&amp;WHITE)?; let mut chart = ChartBuilder::on(&amp;root) .caption(\"散点图\", (\"sans-serif\", 30)) .set_label_area_size(LabelAreaPosition::Left, 40) .set_label_area_size(LabelAreaPosition::Bottom, 40) .build_cartesian_2d(0..10, 0..10)?; chart.configure_mesh().draw()?; chart.draw_series( PointSeries::of_element( [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9)], 5, &amp;BLUE, &amp;|c, s, st| { return EmptyElement::at(c) + Circle::new((0, 0), s, st.filled()); }, ), )?; Ok(())}这个例子中，我们首先创建了一个BitMapBackend对象，用于输出 PNG 格式的图片。然后，我们创建了一个ChartBuilder对象，用于构建图表。在ChartBuilder对象上，我们设置了标题、坐标轴标签和网格线。最后，我们使用PointSeries对象绘制了一组散点。PointSeries对象需要一个元组列表作为输入，每个元组包含一个 x 坐标和一个 y 坐标。在这个例子中，我们绘制了一组从(0,0)到(9,9)的散点。绘制饼图下面是一个简单的例子，演示如何使用 Plotters 绘制饼图：12345678910111213141516171819202122232425262728293031323334use plotters::prelude::*;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let root = BitMapBackend::new(\"plot.png\", (640, 480)).into_drawing_area(); root.fill(&amp;WHITE)?; let data = vec![(\"A\", 10), (\"B\", 20), (\"C\", 30), (\"D\", 40)]; let sum = data.iter().map(|(_, v)| v).sum::&lt;i32&gt;() as f64; let mut chart = ChartBuilder::on(&amp;root) .caption(\"饼图\", (\"sans-serif\", 30)) .build_ranged(0.0..1.0, 0.0..1.0)?; chart.draw_series( data.iter() .map(|(label, value)| { let value = *value as f64 / sum; Sector::new( (0.5, 0.5), value, (0.0, 0.0), (HSLColor(0.0, 1.0, 0.5), BLACK), ) .label(label) .legend(move |(x, y)| { Rectangle::new([(x - 5, y - 5), (x + 5, y + 5)], HSLColor(0.0, 1.0, 0.5).filled()) }) }) .collect::&lt;Vec&lt;_&gt;&gt;(), )?; Ok(())}这个例子中，我们首先创建了一个BitMapBackend对象，用于输出 PNG 格式的图片。然后，我们创建了一个ChartBuilder对象，用于构建图表。在ChartBuilder对象上，我们设置了标题。最后，我们使用Sector对象绘制了一组扇形。Sector对象需要一个位置、角度、半径、颜色和标签等参数。在这个例子中，我们绘制了一组占比为 10%、20%、30%和 40%的扇形。绘制等高线图下面是一个简单的例子，演示如何使用 Plotters 绘制等高线图：1234567891011121314151617181920212223242526272829303132use plotters::prelude::*;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let root = BitMapBackend::new(\"plot.png\", (640, 480)).into_drawing_area(); root.fill(&amp;WHITE)?; let mut chart = ChartBuilder::on(&amp;root) .caption(\"等高线图\", (\"sans-serif\", 30)) .set_label_area_size(LabelAreaPosition::Left, 40) .set_label_area_size(LabelAreaPosition::Bottom, 40) .build_cartesian_2d(0..10, 0..10)?; chart.configure_mesh().draw()?; let data = (0..=100).map(|i| { let x = i as f64 / 10.0; let y = i as f64 / 10.0; (x, y, (x * x + y * y).sin()) }); chart.draw_series( ContourSeries::new( data, (0..=10).map(|i| i as f64), (0..=10).map(|i| i as f64), &amp;Palette::viridis(), ) .levels(20), )?; Ok(())}这个例子中，我们首先创建了一个BitMapBackend对象，用于输出 PNG 格式的图片。然后，我们创建了一个ChartBuilder对象，用于构建图表。在ChartBuilder对象上，我们设置了标题、坐标轴标签和网格线。最后，我们使用ContourSeries对象绘制了一组等高线。ContourSeries对象需要一个元组列表作为输入，每个元组包含一个 x 坐标、一个 y 坐标和一个高度。在这个例子中，我们绘制了一个以(0,0)为中心的高斯分布等高线。绘制热力图下面是一个简单的例子，演示如何使用 Plotters 绘制热力图：12345678910111213141516171819202122232425262728use plotters::prelude::*;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let root = BitMapBackend::new(\"plot.png\", (640, 480)).into_drawing_area(); root.fill(&amp;WHITE)?; let mut chart = ChartBuilder::on(&amp;root) .caption(\"热力图\", (\"sans-serif\", 30)) .set_label_area_size(LabelAreaPosition::Left, 40) .set_label_area_size(LabelAreaPosition::Bottom, 40) .build_cartesian_2d(0..10, 0..10)?; chart.configure_mesh().draw()?; let data = (0..=100).map(|i| { let x = i as f64 / 10.0; let y = i as f64 / 10.0; (x, y, (x * x + y * y).sin()) }); chart.draw_series( Heatmap::new(data, &amp;Palette::viridis()) .x_label(\"X\") .y_label(\"Y\"), )?; Ok(())}这个例子中，我们首先创建了一个BitMapBackend对象，用于输出 PNG 格式的图片。然后，我们创建了一个ChartBuilder对象，用于构建图表。在ChartBuilder对象上，我们设置了标题、坐标轴标签和网格线。最后，我们使用Heatmap对象绘制了一个热力图。Heatmap对象需要一个元组列表作为输入，每个元组包含一个 x 坐标、一个 y 坐标和一个高度。在这个例子中，我们绘制了一个以(0,0)为中心的高斯分布热力图。绘制箱线图下面是一个简单的例子，演示如何使用 Plotters 绘制箱线图：12345678910111213141516171819202122232425262728293031323334353637use plotters::prelude::*;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let root = BitMapBackend::new(\"plot.png\", (640, 480)).into_drawing_area(); root.fill(&amp;WHITE)?; let mut chart = ChartBuilder::on(&amp;root) .caption(\"箱线图\", (\"sans-serif\", 30)) .set_label_area_size(LabelAreaPosition::Left, 40) .set_label_area_size(LabelAreaPosition::Bottom, 40) .build_cartesian_2d(0..10, 0..10)?; chart.configure_mesh().draw()?; let data = vec![ (\"A\", vec![2, 3, 4, 5, 6, 7, 8, 9]), (\"B\", vec![3, 4, 5, 6, 7, 8, 9, 10]), (\"C\", vec![4, 5, 6, 7, 8, 9, 10, 11]), (\"D\", vec![5, 6, 7, 8, 9, 10, 11, 12]), ]; chart.draw_series( data.iter() .enumerate() .map(|(i, (label, values))| { BoxPlot::new_horizontal( values.iter().map(|&amp;v| (v - 2) as f64), i as f64, &amp;BLACK, ) .label(label) }) .collect::&lt;Vec&lt;_&gt;&gt;(), )?; Ok(())}这个例子中，我们首先创建了一个BitMapBackend对象，用于输出 PNG 格式的图片。然后，我们创建了一个ChartBuilder对象，用于构建图表。在ChartBuilder对象上，我们设置了标题、坐标轴标签和网格线。最后，我们使用BoxPlot对象绘制了一组箱线。BoxPlot对象需要一个浮点数向量作为输入，每个浮点数表示一个箱线的高度。在这个例子中，我们绘制了一组包含四个箱线的箱线图。绘制极坐标图下面是一个简单的例子，演示如何使用 Plotters 绘制极坐标图：123456789101112131415161718192021222324use plotters::prelude::*;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let root = BitMapBackend::new(\"plot.png\", (640, 480)).into_drawing_area(); root.fill(&amp;WHITE)?; let mut chart = ChartBuilder::on(&amp;root) .caption(\"极坐标图\", (\"sans-serif\", 30)) .build_cartesian_2d(-1.2..1.2, -1.2..1.2)?; chart.configure_mesh().draw()?; chart.draw_series(LineSeries::new( (-100..=100) .map(|i| { let t = i as f64 / 100.0 * std::f64::consts::PI * 2.0; (t.cos(), t.sin()) }) .take(101), &amp;RED, ))?; Ok(())}这个例子中，我们首先创建了一个BitMapBackend对象，用于输出 PNG 格式的图片。然后，我们创建了一个ChartBuilder对象，用于构建图表。在ChartBuilder对象上，我们设置了标题。最后，我们使用LineSeries对象绘制了一条极坐标线。LineSeries对象需要一个元组列表作为输入，每个元组包含一个角度和一个半径。在这个例子中，我们绘制了一条从 0 度到 360 度的极坐标线。自定义样式123456789101112131415161718192021222324252627282930313233343536use plotters::prelude::*;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let root = BitMapBackend::new(\"plot.png\", (640, 480)).into_drawing_area(); root.fill(&amp;WHITE)?; let mut chart = ChartBuilder::on(&amp;root) .caption(\"Custom Style Chart\", (\"sans-serif\", 20)) .x_label_area_size(30) .y_label_area_size(30) .build_cartesian_2d(0f32..10f32, 0f32..10f32)?; chart.configure_mesh().draw()?; chart .draw_series(LineSeries::new( (0..10).map(|x| (x as f32, (x as f32).powf(2.0))), &amp;RED.stroke_width(2), ))? .label(\"y=x^2\"); chart .draw_series(LineSeries::new( (0..10).map(|x| (x as f32, (x as f32).powf(2.0) + 2.0)), &amp;BLUE.stroke_width(2), ))? .label(\"y=x^2+2\"); chart .configure_series_labels() .background_style(&amp;WHITE.mix(0.8)) .border_style(&amp;BLACK) .draw()?; Ok(())}这个示例创建了一个自定义样式的图表。我们使用stroke_width方法设置了线段的宽度，使用mix方法设置了标签的背景色。我们还使用border_style方法设置了标签的边框颜色。使用 CSV 文件绘制线图下面是一个使用 CSV 文件绘制线图的示例代码：12345678910111213141516171819202122232425262728293031323334use plotters::prelude::*;use std::fs::File;use std::io::{BufRead, BufReader};fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let root = BitMapBackend::new(\"line_csv.png\", (640, 480)).into_drawing_area(); root.fill(&amp;WHITE)?; let mut chart = ChartBuilder::on(&amp;root) .caption(\"Line Chart with CSV\", (\"sans-serif\", 40)) .set_label_area_size(LabelAreaPosition::Left, 50) .set_label_area_size(LabelAreaPosition::Bottom, 50) .build_cartesian_2d(0..10, 0..10)?; chart.configure_mesh().draw()?; let file = File::open(\"data.csv\").unwrap(); let reader = BufReader::new(file); let data: Vec&lt;(i32, i32)&gt; = reader .lines() .map(|line| { let line = line.unwrap(); let parts: Vec&lt;&amp;str&gt; = line.split(',').collect(); let x = parts[0].parse::&lt;i32&gt;().unwrap(); let y = parts[1].parse::&lt;i32&gt;().unwrap(); (x, y) }) .collect(); chart.draw_series(LineSeries::new(data, &amp;RED))?; Ok(())}在上述代码中，我们首先创建了一个BitMapBackend对象，用于指定输出格式和大小。然后，我们创建了一个ChartBuilder对象，用于指定图表的标题和坐标轴等属性。接着，我们读取了一个名为data.csv的 CSV 文件，并将其转换为一个包含(i32, i32)元组的向量。最后，我们通过chart.draw_series方法将线图绘制到图表中。绘制带有标签的散点图下面是一个绘制带有标签的散点图的示例代码：12345678910111213141516171819202122232425262728293031323334353637383940use plotters::prelude::*;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let root = BitMapBackend::new(\"scatter.png\", (640, 480)).into_drawing_area(); root.fill(&amp;WHITE)?; let mut chart = ChartBuilder::on(&amp;root) .caption(\"Scatter Chart with Labels\", (\"sans-serif\", 40)) .set_label_area_size(LabelAreaPosition::Left, 50) .set_label_area_size(LabelAreaPosition::Bottom, 50) .build_cartesian_2d(0..10, 0..10)?; chart.configure_mesh().draw()?; let data = [ (\"A\", (1, 2)), (\"B\", (2, 3)), (\"C\", (3, 4)), (\"D\", (4, 5)), (\"E\", (5, 6)), ]; chart.draw_series( data.iter() .map(|(label, (x, y))| { Circle::new((*x, *y), 5, BLUE.filled()) .label(*label) .legend(*label) }) .collect::&lt;Vec&lt;_&gt;&gt;(), )?; chart .configure_series_labels() .background_style(&amp;WHITE.mix(0.8)) .border_style(&amp;BLACK) .draw()?; Ok(())}在上述代码中，我们首先创建了一个BitMapBackend对象，用于指定输出格式和大小。然后，我们创建了一个ChartBuilder对象，用于指定图表的标题和坐标轴等属性。接着，我们创建了一个包含标签的散点数据，并使用Circle对象绘制散点图。最后，我们通过chart.configure_series_labels方法绘制标签。绘制堆叠柱状图下面是一个绘制堆叠柱状图的示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445use plotters::prelude::*;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let root = BitMapBackend::new(\"stacked_bar.png\", (640, 480)).into_drawing_area(); root.fill(&amp;WHITE)?; let mut chart = ChartBuilder::on(&amp;root) .caption(\"Stacked Bar Chart\", (\"sans-serif\", 40)) .set_label_area_size(LabelAreaPosition::Left, 50) .set_label_area_size(LabelAreaPosition::Bottom, 50) .build_cartesian_2d(0..10, 0..10)?; chart.configure_mesh().draw()?; let data = vec![ (\"A\", vec![2, 3, 1, 4, 2]), (\"B\", vec![1, 4, 3, 2, 1]), (\"C\", vec![3, 2, 4, 1, 3]), ]; chart.draw_series( data.iter() .enumerate() .map(|(i, (label, values))| { let color = Palette99::pick(i); let values = values.iter().map(|v| *v as i64).collect::&lt;Vec&lt;_&gt;&gt;(); let sum = values.iter().sum::&lt;i64&gt;(); let offset = if i == 0 { 0 } else { data[i - 1].1.iter().sum::&lt;i32&gt;() }; let data = values.iter().enumerate().map(|(j, v)| (j as i32 + offset, *v)).collect::&lt;Vec&lt;_&gt;&gt;(); BarChart::new(data, 0.5) .style(color.filled()) .label(label) .legend(format!(\"{} ({}%)\", label, v as f64 / sum as f64 * 100.0)) }) .collect::&lt;Vec&lt;_&gt;&gt;(), )?; chart .configure_series_labels() .background_style(&amp;WHITE.mix(0.8)) .border_style(&amp;BLACK) .draw()?; Ok(())}在上述代码中，我们首先创建了一个BitMapBackend对象，用于指定输出格式和大小。然后，我们创建了一个ChartBuilder对象，用于指定图表的标题和坐标轴等属性。接着，我们创建了一个包含堆叠柱状数据，并使用BarChart对象绘制堆叠柱状图。最后，我们通过chart.configure_series_labels方法绘制标签。总结Plotters 是一个强大的绘图库，可以用于创建各种类型的图表。它提供了易于使用的 API，可以轻松地创建高质量的图表，并支持多种输出格式。在使用 Plotters 时，我们可以遵循最佳实践，以提高代码的可读性和可维护性。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 开发你的专属输入法",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, winapi, 键盘",
      "url"         : "./rust/2023/04/21/rust_lang_tutorial_229_Winapi_Keybroad.html",
      "date"        : "2023-04-21 00:00:00 +0800",
      "description" : "",
      "content"     : "在本文中，我们将介绍如何使用 Rust 编程语言和 WinAPI 库来获取鼠标光标的位置并监听键盘事件。我们将在 Windows 操作系统上实现这个功能，并且将使用 Rust 的 winapi 模块来访问 Windows API。我们将首先介绍如何获取鼠标光标的位置，然后我们将介绍如何监听键盘事件。最后，我们将把这些知识结合起来，实现在光标位置接收用户输入的功能。获取鼠标光标位置要获取鼠标光标的位置，需要使用 Windows API 函数 GetCursorPos。该函数返回一个 POINT 结构体，其中包含鼠标光标的 x 和 y 坐标。以下是获取鼠标光标位置的示例代码：12345678910use winapi::um::winuser::GetCursorPos;use winapi::shared::windef::POINT;fn main() { let mut point = POINT { x: 0, y: 0 }; unsafe { GetCursorPos(&amp;mut point); } println!(\"x: {}, y: {}\", point.x, point.y);}在上面的代码中，我们首先导入了 winapi 模块中的 GetCursorPos 函数和 POINT 结构体。然后，我们创建了一个 POINT 结构体实例，并将其传递给 GetCursorPos 函数。最后，我们打印出鼠标光标的 x 和 y 坐标。监听键盘事件在 Rust 语言中，可以使用 winapi 模块中的 SetWindowsHookEx 函数来监听键盘事件。该函数的定义如下：123456pub fn SetWindowsHookExW( idHook: c_int, lpfn: Option&lt;unsafe extern \"system\" fn(c_int, WPARAM, LPARAM) -&gt; LRESULT&gt;, hmod: HINSTANCE, dwThreadId: DWORD,) -&gt; HHOOK;该函数的参数 idHook 表示要监听的事件类型，可以使用 WH_KEYBOARD_LL 常量来表示监听键盘事件。lpfn 是一个回调函数，用于处理键盘事件。hmod 表示当前模块的句柄，可以使用 GetModuleHandleW 函数获取。dwThreadId 表示要监听的线程 ID，可以使用 0 表示监听所有线程。在回调函数中，可以使用 GetAsyncKeyState 函数获取键盘状态。该函数的定义如下：1pub fn GetAsyncKeyState(vKey: c_int) -&gt; SHORT;该函数的参数 vKey 表示要查询的键盘键码，返回值为 SHORT 类型，表示键盘状态。如果返回值的最高位为 1，表示键盘按键处于按下状态，否则表示键盘按键处于弹起状态。钩子函数是一个回调函数，用于处理截获的事件。在 Rust 中，我们可以使用 extern “system” 语法来定义钩子函数。这个语法用于指定函数的调用约定，以便它可以与 Windows API 进行交互。我们将在下面的代码中看到它的用法。使用 winapi::um::winuser 模块中的 SetWindowsHookEx 函数来调用 Windows API。代码如下：12345678910111213141516171819202122232425262728293031use winapi::um::winuser::{SetWindowsHookExW, UnhookWindowsHookEx, CallNextHookEx};use winapi::shared::windef::HHOOK;use winapi::shared::minwindef::{LPARAM, WPARAM, LRESULT, DWORD};unsafe extern \"system\" fn keyboard_proc(nCode: i32, wParam: WPARAM, lParam: LPARAM) -&gt; LRESULT { if nCode &gt;= 0 { println!(\"Key pressed: {}\", wParam); } CallNextHookEx(0 as HHOOK, nCode, wParam, lParam)}fn main() { unsafe { let hook = SetWindowsHookExW( winapi::um::winuser::WH_KEYBOARD_LL, Some(keyboard_proc), std::ptr::null_mut(), 0 ); loop { let msg = winapi::um::winuser::GetMessageW(std::ptr::null_mut(), 0, 0, 0); if msg == 0 { break; } else { winapi::um::winuser::TranslateMessage(&amp;msg); winapi::um::winuser::DispatchMessageW(&amp;msg); } } UnhookWindowsHookEx(hook); }}在上面的代码中，我们首先定义了一个钩子函数 keyboard_proc。它接受三个参数：nCode、wParam 和 lParam。nCode 是一个钩子代码，用于指示事件类型。如果 nCode 大于等于 0，则表示该事件是一个键盘输入事件。wParam 是一个 WPARAM 类型的参数，用于指示按下或释放的键的虚拟键码。lParam 是一个 LPARAM 类型的参数，用于指示键盘状态和扫描码。在钩子函数中，我们首先检查 nCode 是否大于等于 0。如果是，我们打印出按下的键的虚拟键码。然后我们调用 CallNextHookEx 函数，将事件传递给下一个钩子或目标窗口过程。在 main 函数中，我们首先调用 SetWindowsHookExW 函数，将钩子函数注册到 WH_KEYBOARD_LL 钩子类型上。然后我们进入一个无限循环，等待消息。在每次循环中，我们调用 GetMessageW 函数来获取消息。如果 GetMessageW 函数返回 0，则表示程序应该退出。否则，我们调用 TranslateMessage 函数和 DispatchMessageW 函数，以便将消息传递给窗口过程。最后，我们调用 UnhookWindowsHookEx 函数，将钩子函数从 WH_KEYBOARD_LL 钩子类型上注销。在光标位置接收用户输入现在我们已经知道如何获取鼠标光标的位置和监听键盘事件。我们可以将这些知识结合起来，实现在光标位置接收用户输入的功能。具体来说，我们将在光标位置创建一个文本框，并在用户输入时将其添加到文本框中。在 Windows 操作系统中，我们可以使用 CreateWindowEx 函数来创建一个窗口。这个函数的原型如下：1234567891011121314HWND CreateWindowExW( DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);在 Rust 中，我们可以使用 winapi::um::winuser 模块中的 CreateWindowEx 函数来调用 Windows API。然后我们可以使用以下代码来创建一个文本框：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798use winapi::um::winuser::{CreateWindowExW, DefWindowProcW, RegisterClassW, WS_EX_CLIENTEDGE, WS_CHILD, WS_VISIBLE, WM_SIZE, WM_DESTROY, WM_SETFOCUS, WM_CHAR, HWND, HMENU, HINSTANCE, WNDCLASSW, MSG};use winapi::shared::windef::{HWND__, RECT};use winapi::shared::minwindef::{UINT, WPARAM, LPARAM, LRESULT, DWORD};use winapi::um::libloaderapi::GetModuleHandleW;use std::ffi::OsStr;use std::iter::once;use std::os::windows::ffi::OsStrExt;unsafe extern \"system\" fn wnd_proc(hwnd: HWND, msg: UINT, wparam: WPARAM, lparam: LPARAM) -&gt; LRESULT { match msg { WM_SIZE =&gt; { let mut rect: RECT = std::mem::zeroed(); winapi::um::winuser::GetClientRect(hwnd, &amp;mut rect); let edit_hwnd = winapi::um::winuser::GetDlgItem(hwnd, 100); winapi::um::winuser::SetWindowPos(edit_hwnd, std::ptr::null_mut(), rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, 0); }, WM_DESTROY =&gt; { winapi::um::winuser::PostQuitMessage(0); }, WM_SETFOCUS =&gt; { let edit_hwnd = winapi::um::winuser::GetDlgItem(hwnd, 100); winapi::um::winuser::SetFocus(edit_hwnd); }, WM_CHAR =&gt; { let edit_hwnd = winapi::um::winuser::GetDlgItem(hwnd, 100); let mut text: [u16; 2] = [0; 2]; let len = winapi::um::winuser::GetWindowTextW(edit_hwnd, text.as_mut_ptr(), 2); if len == 0 { winapi::um::winuser::SetWindowTextW(edit_hwnd, &amp;wparam as *const _ as *const u16); } else { let mut buffer: Vec&lt;u16&gt; = Vec::with_capacity(len as usize + 1); buffer.set_len(len as usize); winapi::um::winuser::GetWindowTextW(edit_hwnd, buffer.as_mut_ptr(), len + 1); buffer.push(wparam as u16); winapi::um::winuser::SetWindowTextW(edit_hwnd, buffer.as_ptr()); } }, _ =&gt; return DefWindowProcW(hwnd, msg, wparam, lparam), } 0}fn main() { unsafe { let hinstance = GetModuleHandleW(std::ptr::null()); let class_name: Vec&lt;u16&gt; = OsStr::new(\"my_window_class\").encode_wide().chain(once(0)).collect(); let wndclass = WNDCLASSW { style: 0, lpfnWndProc: Some(wnd_proc), hInstance: hinstance, lpszClassName: class_name.as_ptr(), cbClsExtra: 0, cbWndExtra: 0, hIcon: std::ptr::null_mut(), hCursor: std::ptr::null_mut(), hbrBackground: winapi::um::winuser::COLOR_WINDOW as HINSTANCE, lpszMenuName: std::ptr::null_mut(), }; RegisterClassW(&amp;wndclass); let hwnd = CreateWindowExW( WS_EX_CLIENTEDGE, class_name.as_ptr(), OsStr::new(\"My Window\").encode_wide().chain(once(0)).collect().as_ptr(), WS_CHILD | WS_VISIBLE, 0, 0, 0, 0, std::ptr::null_mut(), std::ptr::null_mut(), hinstance, std::ptr::null_mut(), ); let edit_hwnd = CreateWindowExW( 0, OsStr::new(\"EDIT\").encode_wide().chain(once(0)).collect().as_ptr(), std::ptr::null_mut(), WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL | 0x800, 0, 0, 0, 0, hwnd, 100 as HMENU, hinstance, std::ptr::null_mut(), ); loop { let mut msg: MSG = std::mem::zeroed(); if winapi::um::winuser::GetMessageW(&amp;mut msg, std::ptr::null_mut(), 0, 0) &gt; 0 { winapi::um::winuser::TranslateMessage(&amp;msg); winapi::um::winuser::DispatchMessageW(&amp;msg); } else { break; } } }}在上面的代码中，我们首先定义了一个窗口过程 wnd_proc。它接受四个参数：hwnd、msg、wparam 和 lparam。hwnd 是窗口句柄，msg 是消息类型，wparam 和 lparam 是消息参数。在窗口过程中，我们处理了四个消息：WM_SIZE、WM_DESTROY、WM_SETFOCUS 和 WM_CHAR。在 WM_SIZE 消息中，我们获取客户区的大小，并将文本框的大小设置为与客户区相同。在 WM_DESTROY 消息中，我们调用 PostQuitMessage 函数，以便在窗口关闭时退出程序。在 WM_SETFOCUS 消息中，我们获取文本框的句柄，并将焦点设置为文本框。在 WM_CHAR 消息中，我们获取文本框的句柄，并将用户输入添加到文本框中。在 main 函数中，我们首先获取模块句柄。然后我们定义一个 WNDCLASSW 结构体，并将其注册到系统中。这个结构体包含了窗口过程和窗口类名。然后我们调用 CreateWindowExW 函数，创建一个窗口。在这个窗口中，我们创建了一个文本框，并将其添加到窗口中。最后，我们进入一个无限循环，等待消息。在每次循环中，我们调用 GetMessageW 函数来获取消息。如果 GetMessageW 函数返回 0，则表示程序应该退出。否则，我们调用 TranslateMessage 函数和 DispatchMessageW 函数，以便将消息传递给窗口过程。总结在本文中，我们介绍了如何使用 Rust 编程语言和 WinAPI 库来获取鼠标光标的位置并监听键盘事件。我们首先介绍了如何获取鼠标光标的位置，然后我们介绍了如何监听键盘事件。最后，我们将这些知识结合起来，实现了在光标位置接收用户输入的功能。这个功能可以用于许多应用程序，例如屏幕取词工具、虚拟键盘等。我们希望这篇文章能够帮助你了解如何在 Rust 中使用 WinAPI 库来实现这些功能。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 深入理解进程间共享内存通信",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, winapi, IPC",
      "url"         : "./rust/2023/04/21/rust_lang_tutorial_228_Winapi_Share_Memory.html",
      "date"        : "2023-04-21 00:00:00 +0800",
      "description" : "",
      "content"     : "进程间通信（IPC）是操作系统中非常重要的一部分，它使得不同的进程可以在不同的计算机上进行通信。在 Windows 操作系统中，共享内存是一种常见的 IPC 机制，它可以在不同的进程之间共享数据，以便它们可以相互通信。在本教程中，我们将使用 Rust 语言的 WinAPI 模块来实现共享内存，以便两个进程可以进行通信。共享内存的概念共享内存是一种 IPC 机制，它允许不同的进程共享同一块内存区域。这样，一个进程可以将数据写入共享内存区域，而其他进程可以读取这些数据。共享内存通常比其他 IPC 机制（如管道或消息队列）更快，因为它不涉及操作系统内核的介入。共享内存通常由以下三个部分组成： 内存区域：共享内存的实际数据存储区域。 锁：用于控制对共享内存的访问，以确保同一时间只有一个进程可以访问它。 信号量：用于通知其他进程共享内存中的数据已被修改。在 Windows 操作系统中，共享内存是由内核对象来管理的。这些内核对象包括共享内存段、互斥体和信号量。Rust 语言的 WinAPI 模块Rust 语言提供了一个 WinAPI 模块，它允许我们在 Rust 中使用 Windows API。这个模块提供了许多函数和类型，可以用于创建 Windows 应用程序和系统级别的程序。在本教程中，我们将使用 WinAPI 模块中的函数来创建共享内存段、互斥体和信号量。创建共享内存段在 Windows 操作系统中，共享内存段是由内核对象来管理的。我们可以使用 WinAPI 模块中的函数来创建共享内存段。以下是创建共享内存段的步骤： 使用CreateFileMapping()函数创建一个共享内存段。123456789101112use winapi::um::memoryapi::CreateFileMappingW;let handle = unsafe { CreateFileMappingW( INVALID_HANDLE_VALUE, ptr::null_mut(), PAGE_READWRITE, 0, size, name )};在这个函数中，我们传递了以下参数： INVALID_HANDLE_VALUE：表示使用系统页面文件作为物理存储器。 ptr::null_mut()：表示不使用现有文件作为物理存储器。 PAGE_READWRITE：表示共享内存段可读可写。 0：表示共享内存段的大小。 name：共享内存段的名称。 使用MapViewOfFile()函数将共享内存段映射到进程的地址空间中。1234567891011use winapi::um::memoryapi::MapViewOfFile;let ptr = unsafe { MapViewOfFile( handle, FILE_MAP_ALL_ACCESS, 0, 0, size )};在这个函数中，我们传递了以下参数： handle：共享内存段的句柄。 FILE_MAP_ALL_ACCESS：表示进程可以读取和写入共享内存段。 0：表示共享内存段的偏移量。 0：表示共享内存段的起始地址。 size：表示共享内存段的大小。现在，我们已经创建了一个共享内存段，并将其映射到了进程的地址空间中。创建互斥体互斥体是一种同步原语，用于控制对共享资源的访问。在 Windows 操作系统中，互斥体是由内核对象来管理的。我们可以使用 WinAPI 模块中的函数来创建互斥体。以下是创建互斥体的步骤： 使用CreateMutexW()函数创建一个互斥体。123456789use winapi::um::synchapi::CreateMutexW;let handle = unsafe { CreateMutexW( ptr::null_mut(), FALSE, name )};在这个函数中，我们传递了以下参数： ptr::null_mut()：表示使用默认的安全描述符。 FALSE：表示互斥体未被占用。 name：互斥体的名称。 使用WaitForSingleObject()函数等待互斥体。12345678use winapi::um::synchapi::WaitForSingleObject;let result = unsafe { WaitForSingleObject( handle, INFINITE )};在这个函数中，我们传递了以下参数： handle：互斥体的句柄。 INFINITE：表示无限等待互斥体。现在，我们已经创建了一个互斥体，并等待了它。创建信号量信号量是一种同步原语，用于控制对共享资源的访问。在 Windows 操作系统中，信号量是由内核对象来管理的。我们可以使用 WinAPI 模块中的函数来创建信号量。以下是创建信号量的步骤： 使用CreateSemaphoreW()函数创建一个信号量。12345678910use winapi::um::synchapi::CreateSemaphoreW;let handle = unsafe { CreateSemaphoreW( ptr::null_mut(), initial_count, max_count, name )};在这个函数中，我们传递了以下参数： ptr::null_mut()：表示使用默认的安全描述符。 initial_count：表示信号量的初始计数。 max_count：表示信号量的最大计数。 name：信号量的名称。 使用WaitForSingleObject()函数等待信号量。12345678use winapi::um::synchapi::WaitForSingleObject;let result = unsafe { WaitForSingleObject( handle, INFINITE )};在这个函数中，我们传递了以下参数： handle：信号量的句柄。 INFINITE：表示无限等待信号量。现在，我们已经创建了一个信号量，并等待了它。完整示例代码下面是一个使用共享内存进行进程间通信的示例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273use std::ffi::OsStr;use std::os::windows::ffi::OsStrExt;use std::ptr;use winapi::shared::minwindef::{FALSE, TRUE};use winapi::um::handleapi::INVALID_HANDLE_VALUE;use winapi::um::memoryapi::{CreateFileMappingW, MapViewOfFile};use winapi::um::synchapi::{CreateMutexW, CreateSemaphoreW, ReleaseMutex, ReleaseSemaphore, WaitForSingleObject};use winapi::um::winnt::{HANDLE, PAGE_READWRITE};fn main() { let name: Vec&lt;u16&gt; = OsStr::new(\"MySharedMemory\").encode_wide().chain(Some(0).into_iter()).collect(); let size = 1024 * 1024; // 1MB // Create shared memory segment let handle = unsafe { CreateFileMappingW( INVALID_HANDLE_VALUE, ptr::null_mut(), PAGE_READWRITE, 0, size, name.as_ptr() ) }; let ptr = unsafe { MapViewOfFile( handle, FILE_MAP_ALL_ACCESS, 0, 0, size ) }; // Create mutex let mutex_name: Vec&lt;u16&gt; = OsStr::new(\"MyMutex\").encode_wide().chain(Some(0).into_iter()).collect(); let mutex_handle = unsafe { CreateMutexW( ptr::null_mut(), FALSE, mutex_name.as_ptr() ) }; // Create semaphore let semaphore_name: Vec&lt;u16&gt; = OsStr::new(\"MySemaphore\").encode_wide().chain(Some(0).into_iter()).collect(); let semaphore_handle = unsafe { CreateSemaphoreW( ptr::null_mut(), 0, 1, semaphore_name.as_ptr() ) }; // Write data to shared memory let data = [1, 2, 3, 4, 5]; unsafe { WaitForSingleObject(mutex_handle, INFINITE); ptr::copy_nonoverlapping(data.as_ptr() as *const _, ptr as *mut _, data.len()); ReleaseMutex(mutex_handle); ReleaseSemaphore(semaphore_handle, 1, ptr::null_mut()); } // Read data from shared memory let mut result = [0; 5]; unsafe { WaitForSingleObject(semaphore_handle, INFINITE); ptr::copy_nonoverlapping(ptr as *const _, result.as_mut_ptr() as *mut _, result.len()); } println!(\"{:?}\", result);}在这个示例代码中，我们创建了一个名为”MySharedMemory”的共享内存段，并将其映射到了进程的地址空间中。我们还创建了一个名为”MyMutex”的互斥体和一个名为”MySemaphore”的信号量。然后，我们将数据写入共享内存段，并使用互斥体来确保同一时间只有一个进程可以访问共享内存段。我们还使用信号量来通知另一个进程共享内存段中的数据已被修改。最后，我们从共享内存段中读取数据，并使用信号量来等待另一个进程修改共享内存段中的数据。常见问题及解决方法在使用共享内存进行进程间通信时，可能会遇到以下常见问题： 内存泄漏在使用共享内存时，必须确保在不再需要它时释放共享内存。如果没有正确释放共享内存，可能会导致内存泄漏，这会降低系统的性能并可能导致系统崩溃。使用共享内存时，应该确保在不再需要它时释放共享内存。可以使用UnmapViewOfFile()函数释放共享内存段，并使用CloseHandle()函数释放互斥体和信号量。 竞争条件在使用共享内存时，可能会发生竞争条件，这是由于多个进程同时访问共享内存而引起的。如果没有正确处理竞争条件，可能会导致数据损坏或其他问题。使用互斥体来控制对共享内存的访问，以确保同一时间只有一个进程可以访问共享内存。可以使用信号量来通知其他进程共享内存中的数据已被修改。 数据同步在使用共享内存时，必须确保多个进程之间的数据同步。如果没有正确处理数据同步，可能会导致数据损坏或其他问题。使用信号量来通知其他进程共享内存中的数据已被修改。可以使用互斥体来控制对共享内存的访问，以确保同一时间只有一个进程可以访问共享内存。 安全性在使用共享内存时，必须确保数据的安全性。如果没有正确处理数据的安全性，可能会导致数据泄露或其他安全问题。使用安全描述符来控制对共享内存的访问。可以使用安全描述符来限制哪些进程可以访问共享内存，并限制它们可以执行的操作。总结在本教程中，我们使用 Rust 语言的 WinAPI 模块来实现共享内存，以便两个进程可以进行通信。我们学习了如何创建共享内存段、互斥体和信号量，并提供了示例代码。我们还总结了共享内存的常见问题以及如何避免和解决这些问题。共享内存是一种非常有用的 IPC 机制，它可以在不同的进程之间共享数据。在使用共享内存时，必须确保正确处理内存泄漏、竞争条件、数据同步和安全性等问题。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 发布你的跨平台二进制文件",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Cargo",
      "url"         : "./rust/2023/04/21/rust_lang_tutorial_227_Release_binary_package.html",
      "date"        : "2023-04-21 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种系统级编程语言，具有高效、安全、并发等特点，因此在一些领域得到了广泛的应用。但是，Rust 语言本身并不提供跨平台编译的支持，这对于需要在不同操作系统上运行的项目来说是一个不小的挑战。为了解决这个问题，我们可以使用 Cross 工具，它可以帮助我们轻松地将 Rust 程序编译成各种平台的可执行文件。在本教程中，我们将使用 Cross 工具来编译一个简单的加、减、乘、除 四则运算的计算器，并将其发布到 Windows、Mac 和 Linux 等平台。安装 Rust 和 Cargo具体的安装步骤本篇文章不再赘述，请参考系列的前面的 Cargo 篇和 Hello World 篇。输入以下命令，确认编译环境是否准备就绪。12rustc --versioncargo --version如果输出版本号，则说明环境正常。安装 Cross接下来，我们需要安装 Cross 工具。在终端中输入以下命令进行安装：cargo install cross安装完成后，同样，在终端使用cross --version命令来验证安装是否成功。创建项目接下来，我们需要创建一个新的 Rust 项目。在终端中进入你想要创建项目的目录，然后运行以下命令：1cargo new calculator --bin这将创建一个名为calculator的新项目，并且告诉 Cargo 这是一个二进制文件（--bin）。在项目目录中，你会看到一个src文件夹和一个Cargo.toml文件。编写代码现在，我们可以开始编写代码了。在src/main.rs文件中，输入以下代码：12345678910111213141516171819use std::io::{self, Write};fn main() { let mut input = String::new(); print!(\"Enter an expression: \"); io::stdout().flush().unwrap(); io::stdin().read_line(&amp;mut input).unwrap(); let tokens: Vec&lt;&amp;str&gt; = input.trim().split(' ').collect(); let num1 = tokens[0].parse::&lt;f64&gt;().unwrap(); let num2 = tokens[2].parse::&lt;f64&gt;().unwrap(); let operator = tokens[1]; match operator { \"+\" =&gt; println!(\"{} + {} = {}\", num1, num2, num1 + num2), \"-\" =&gt; println!(\"{} - {} = {}\", num1, num2, num1 - num2), \"*\" =&gt; println!(\"{} * {} = {}\", num1, num2, num1 * num2), \"/\" =&gt; println!(\"{} / {} = {}\", num1, num2, num1 / num2), _ =&gt; println!(\"Invalid operator\"), }}这是一个简单的计算器程序，它可以让用户输入一个操作，然后对两个数字执行该操作。如果操作无效，程序将提示用户重新输入。构建项目现在，我们可以使用 Cargo 来构建我们的项目。在终端中进入项目目录，然后运行以下命令：1cargo build --release这将使用 Rust 编译器将我们的代码编译成一个二进制文件。--release标志将优化代码以提高性能。构建完成后，你将在target/release目录中找到一个名为calculator的二进制文件。发布二进制文件现在，我们可以将二进制文件发布到各种平台上，让用户可以使用我们的计算器程序。在 Rust 中，我们可以使用 Cross 工具来跨平台构建二进制文件。首先，我们需要安装 Cross。在终端中运行以下命令：1cargo install cross安装完成后，我们可以使用 Cross 来构建二进制文件。运行以下命令：123cross build --release --target x86_64-pc-windows-gnucross build --release --target x86_64-apple-darwincross build --release --target x86_64-unknown-linux-gnu这将分别构建 Windows、Mac 和 Linux 上的二进制文件。构建完成后，你将在target/x86_64-pc-windows-gnu/release、target/x86_64-apple-darwin/release和target/x86_64-unknown-linux-gnu/release目录中找到三个二进制文件。测试二进制文件现在，我们可以测试我们的二进制文件了。在 Windows 上，双击calculator.exe文件即可运行程序。在 Mac 和 Linux 上，打开终端并进入二进制文件所在的目录，然后运行以下命令：1./calculator程序将启动并提示用户输入操作。输入操作后，程序将执行该操作并输出结果。总结在本教程中，我们学习了如何使用 Rust 编写一个简单的加减乘除计算器，并将其发布为二进制文件。我们使用 Cargo 来管理依赖和构建项目，使用 Cross 工具来跨平台构建二进制文件。通过这个例子，你可以学习如何使用 Rust 编写实用的命令行工具，并将其发布到各种平台上。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 零基础入门Win32 API开发(下)",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, winapi",
      "url"         : "./rust/2023/04/21/rust_lang_tutorial_226_Winapi_2.html",
      "date"        : "2023-04-21 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 语言是一种快速、安全、并发的系统编程语言。它的设计目标是为了提供更好的内存安全和线程安全，同时保持高性能。而 winapi 模块则是 Rust 语言的一个重要组成部分，它提供了与 Windows 操作系统 API 的交互能力。本教程将介绍 winapi 模块的基础用法和进阶用法，以及最佳实践。上一篇 Rust语言从入门到精通系列 - 零基础入门Win32 API开发(上) 介绍了 Win32 API 的一些基础用法，本篇主要介绍一些进阶用法。进阶用法使用 Rust 风格的 COM 组件12345678910111213141516171819202122232425262728293031323334353637383940414243use std::ptr::null_mut;use winapi::um::combaseapi::{CoInitializeEx, CoCreateInstance, CoUninitialize};use winapi::um::objbase::COINIT_APARTMENTTHREADED;use winapi::um::winuser::MessageBoxW;use winapi::Interface;#[com_interface(\"87654321-4321-4321-4321-434343434343\")]trait IMyInterface { fn my_method(&amp;self);}#[com_class(\"12345678-1234-1234-1234-123412341234\", IMyInterface)]struct MyClass;impl IMyInterface for MyClass { fn my_method(&amp;self) { MessageBoxW( null_mut(), \"My method is called!\".to_wide_null().as_ptr(), \"Success\\0\".to_wide_null().as_ptr(), 0, ); }}fn main() { unsafe { CoInitializeEx(null_mut(), COINIT_APARTMENTTHREADED); let mut p_my_interface: *mut IMyInterface = null_mut(); let hr = CoCreateInstance( &amp;MyClass::uuidof(), null_mut(), winapi::um::combaseapi::CLSCTX_INPROC_SERVER, &amp;IMyInterface::uuidof(), &amp;mut p_my_interface as *mut _ as *mut *mut _, ); if hr == winapi::S_OK { (*p_my_interface).my_method(); (*p_my_interface).release(); } CoUninitialize(); }}打印屏幕截图以下代码使用 winapi 模块的函数和结构体，实现在 Windows 操作系统下截取屏幕并打印。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162use winapi::um::winuser::{GetDC, GetSystemMetrics, ReleaseDC, CreateCompatibleDC, CreateCompatibleBitmap, SelectObject, BitBlt, DeleteDC, DeleteObject, SM_CXSCREEN, SM_CYSCREEN, SRCCOPY};use winapi::um::wingdi::{BITMAPINFO, BITMAPINFOHEADER, BI_RGB, RGBQUAD, GetDIBits, SetDIBitsToDevice};use winapi::shared::windef::{HDC, HWND, HBITMAP, RECT};use winapi::shared::minwindef::{DWORD, UINT};use std::ptr::null_mut;use std::mem::{size_of, zeroed};fn main() { let mut rect: RECT = unsafe { zeroed() }; unsafe { let hwnd = GetDesktopWindow(); GetWindowRect(hwnd, &amp;mut rect); let hdc_screen = GetDC(null_mut()); let hdc = CreateCompatibleDC(hdc_screen); let hbitmap = CreateCompatibleBitmap(hdc_screen, rect.right, rect.bottom); let hbitmap_old = SelectObject(hdc, hbitmap as *mut _); BitBlt(hdc, 0, 0, rect.right, rect.bottom, hdc_screen, 0, 0, SRCCOPY); SelectObject(hdc, hbitmap_old as *mut _); DeleteDC(hdc); ReleaseDC(null_mut(), hdc_screen); let mut bmi: BITMAPINFO = zeroed(); bmi.bmiHeader.biSize = size_of::&lt;BITMAPINFOHEADER&gt;() as DWORD; bmi.bmiHeader.biWidth = rect.right; bmi.bmiHeader.biHeight = -rect.bottom; bmi.bmiHeader.biPlanes = 1; bmi.bmiHeader.biBitCount = 32; bmi.bmiHeader.biCompression = BI_RGB; bmi.bmiHeader.biSizeImage = 0; bmi.bmiHeader.biXPelsPerMeter = 0; bmi.bmiHeader.biYPelsPerMeter = 0; bmi.bmiHeader.biClrUsed = 0; bmi.bmiHeader.biClrImportant = 0; let mut bits = Vec::with_capacity(rect.right as usize * rect.bottom as usize); GetDIBits( hdc_screen, hbitmap, 0, rect.bottom as UINT, bits.as_mut_ptr() as *mut _, &amp;mut bmi, DIB_RGB_COLORS, ); bits.set_len(rect.right as usize * rect.bottom as usize); SetDIBitsToDevice( hdc_screen, 0, 0, rect.right, rect.bottom, 0, 0, 0, rect.bottom, bits.as_ptr() as *mut _, &amp;bmi, DIB_RGB_COLORS, ); DeleteObject(hbitmap as *mut _); }}上述代码使用了许多 winapi 模块中的函数和结构体，包括 GetDC、GetSystemMetrics、ReleaseDC、CreateCompatibleDC、CreateCompatibleBitmap、SelectObject、BitBlt、DeleteDC、DeleteObject、BITMAPINFO、BITMAPINFOHEADER、BI_RGB、RGBQUAD、GetDIBits、SetDIBitsToDevice、GetDesktopWindow、GetWindowRect、SRCCOPY、DIB_RGB_COLORS 等。获取硬件信息以下代码使用 winapi 模块的函数和结构体，实现在 Windows 操作系统下获取硬件信息。1234567891011121314151617181920212223242526272829303132use winapi::um::winbase::{GetSystemFirmwareTable, SYSTEM_FIRMWARE_TABLE_PROVIDER_ACPI, SYSTEM_FIRMWARE_TABLE_ACPI, SYSTEM_FIRMWARE_TABLE_ACTION_READ};use winapi::um::winnt::{HANDLE, PVOID, ULONG};use std::ptr::null_mut;use std::mem::size_of;fn main() { let mut buffer_size: ULONG = 0; let mut buffer: Vec&lt;u8&gt; = Vec::new(); unsafe { GetSystemFirmwareTable( SYSTEM_FIRMWARE_TABLE_PROVIDER_ACPI, SYSTEM_FIRMWARE_TABLE_ACPI, null_mut(), 0, ); buffer_size = GetSystemFirmwareTable( SYSTEM_FIRMWARE_TABLE_PROVIDER_ACPI, SYSTEM_FIRMWARE_TABLE_ACPI, null_mut(), 0, ); buffer = Vec::with_capacity(buffer_size as usize); GetSystemFirmwareTable( SYSTEM_FIRMWARE_TABLE_PROVIDER_ACPI, SYSTEM_FIRMWARE_TABLE_ACPI, buffer.as_mut_ptr() as PVOID, buffer_size, ); buffer.set_len(buffer_size as usize); println!(\"ACPI table size: {}\", buffer_size); }}上述代码使用了 winapi 模块中的函数和结构体，包括 GetSystemFirmwareTable、SYSTEM_FIRMWARE_TABLE_PROVIDER_ACPI、SYSTEM_FIRMWARE_TABLE_ACPI、SYSTEM_FIRMWARE_TABLE_ACTION_READ、HANDLE、PVOID 和 ULONG 等。获取系统信息以下代码使用 winapi 模块的函数和结构体，实现在 Windows 操作系统下获取系统信息。123456789101112use winapi::um::sysinfoapi::{GetSystemInfo, SYSTEM_INFO};use std::mem::zeroed;fn main() { let mut system_info: SYSTEM_INFO = unsafe { zeroed() }; unsafe { GetSystemInfo(&amp;mut system_info); println!(\"Number of processors: {}\", system_info.dwNumberOfProcessors); println!(\"Page size: {}\", system_info.dwPageSize); println!(\"Processor architecture: {}\", system_info.wProcessorArchitecture); }}上述代码使用了 winapi 模块中的函数和结构体，包括 GetSystemInfo 和 SYSTEM_INFO 等。获取网络信息以下代码使用 winapi 模块的函数和结构体，实现在 Windows 操作系统下获取网络信息。1234567891011121314use winapi::um::iphlpapi::{GetAdaptersInfo, PIP_ADAPTER_INFO};use std::ptr::null_mut;use std::mem::size_of;fn main() { let mut adapter_info: PIP_ADAPTER_INFO = null_mut(); let mut buffer_size: u32 = 0; unsafe { GetAdaptersInfo(null_mut(), &amp;mut buffer_size); adapter_info = std::mem::zeroed(); GetAdaptersInfo(adapter_info, &amp;mut buffer_size); println!(\"Adapter name: {:?}\", std::ffi::CStr::from_ptr((*adapter_info).AdapterName.as_ptr() as *const i8)); }}上述代码使用了 winapi 模块中的函数和结构体，包括 GetAdaptersInfo 和 PIP_ADAPTER_INFO 等。使用 Windows API 发送邮件发送邮件是一种常见的网络操作，可以用于发送电子邮件、短信等。下面是一个使用 winapi 模块发送邮件的示例：1234567891011121314151617181920212223242526272829use winapi::um::mapi::{MAPISendMailW, MapiMessage, MapiFileDesc, MapiRecipDesc, MAPI_LOGON_UI, MAPI_DIALOG};use std::os::windows::ffi::OsStrExt;use std::ffi::OsStr;use std::ptr::null_mut;use std::mem::MaybeUninit;fn main() { let mut msg: MapiMessage = MaybeUninit::uninit().assume_init(); msg.lpszSubject = OsStr::new(\"Test Email\").encode_wide().chain(Some(0)).collect::&lt;Vec&lt;_&gt;&gt;().as_ptr(); msg.lpszNoteText = OsStr::new(\"This is a test email.\").encode_wide().chain(Some(0)).collect::&lt;Vec&lt;_&gt;&gt;().as_ptr(); msg.nRecipCount = 1; let mut recip: MapiRecipDesc = MaybeUninit::uninit().assume_init(); recip.ulRecipClass = 1; recip.lpszName = OsStr::new(\"John Smith\").encode_wide().chain(Some(0)).collect::&lt;Vec&lt;_&gt;&gt;().as_ptr(); recip.lpszAddress = OsStr::new(\"john.smith@example.com\").encode_wide().chain(Some(0)).collect::&lt;Vec&lt;_&gt;&gt;().as_ptr(); msg.lpRecips = &amp;mut recip as *mut MapiRecipDesc; msg.nFileCount = 1; let mut file: MapiFileDesc = MaybeUninit::uninit().assume_init(); file.nPosition = 0xFFFFFFFF; file.lpszPathName = OsStr::new(\"test.txt\").encode_wide().chain(Some(0)).collect::&lt;Vec&lt;_&gt;&gt;().as_ptr(); file.lpszFileName = OsStr::new(\"test.txt\").encode_wide().chain(Some(0)).collect::&lt;Vec&lt;_&gt;&gt;().as_ptr(); msg.lpFiles = &amp;mut file as *mut MapiFileDesc; unsafe { let result = MAPISendMailW(null_mut(), null_mut(), &amp;mut msg as *mut MapiMessage, MAPI_LOGON_UI | MAPI_DIALOG, 0); if result != 0 { println!(\"Error: {}\", result); } }}在这个示例中，我们使用了 mapi 模块中的 MAPISendMailW 函数发送邮件。该函数的参数包括邮件消息、登录标志和对话框标志等。我们创建了一个 MapiMessage 结构体 msg，并设置了邮件主题、正文和收件人等信息。我们还创建了一个 MapiRecipDesc 结构体 recip，并设置了收件人姓名和地址。最后，我们创建了一个 MapiFileDesc 结构体 file，并设置了附件的路径和文件名。接着，我们将 msg.lpRecips 和 msg.lpFiles 分别设置为&amp;mut recip 和&amp;mut file，以便将收件人和附件信息添加到邮件消息中。最后，我们使用 MAPISendMailW 函数发送邮件，并使用 println!函数打印出错误信息（如果有）。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 零基础入门Win32 API开发(上)",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, winapi",
      "url"         : "./rust/2023/04/21/rust_lang_tutorial_225_Winapi_1.html",
      "date"        : "2023-04-21 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 语言是一种快速、安全、并发的系统编程语言。它的设计目标是为了提供更好的内存安全和线程安全，同时保持高性能。而 winapi 模块则是 Rust 语言的一个重要组成部分，它提供了与 Windows 操作系统 API 的交互能力。本教程将介绍 winapi 模块的基础用法和进阶用法，以及最佳实践。 本篇主要介绍 Win32 API 基础用法，进阶相关的内容在 Rust语言从入门到精通系列 - 零基础入门Win32 API开发(下)基础用法Cargo.toml 文件引入依赖。12[target.'cfg(windows)'.dependencies]winapi = { version = \"0.3.9\", features = [\"winuser\"] }获取系统错误信息123456use winapi::um::errhandlingapi::GetLastError;fn main() { let error_code = unsafe { GetLastError() }; println!(\"Error code: {}\", error_code);}获取桌面窗口句柄1234567use winapi::um::winuser::GetDesktopWindow;use winapi::um::winuser::HWND;fn main() { let hwnd: HWND = unsafe { GetDesktopWindow() }; println!(\"{:?}\", hwnd);}在代码中，使用 GetDesktopWindow 函数获取桌面窗口句柄。使用 unsafe 关键字调用该函数，因为该函数是一个裸指针函数，需要手动管理内存安全。创建窗口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849use std::ptr::null_mut;use winapi::um::winuser::{CreateWindowExW, DefWindowProcW, RegisterClassW, CW_USEDEFAULT, MSG, WM_DESTROY, WNDCLASSW};fn main() { let class_name = \"MyWindowClass\".to_wide_null(); let window_name = \"My Window\".to_wide_null(); let h_instance = unsafe { winapi::um::libloaderapi::GetModuleHandleW(null_mut()) }; let wnd_class = WNDCLASSW { style: 0, lpfnWndProc: Some(DefWindowProcW), hInstance: h_instance, lpszClassName: class_name.as_ptr(), cbClsExtra: 0, cbWndExtra: 0, hIcon: null_mut(), hCursor: null_mut(), hbrBackground: null_mut(), lpszMenuName: null_mut(), }; let class_atom = unsafe { RegisterClassW(&amp;wnd_class) }; let hwnd = unsafe { CreateWindowExW( 0, class_atom as *const _, window_name.as_ptr(), 0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, null_mut(), null_mut(), h_instance, null_mut(), ) }; let mut msg = MSG::default(); loop { let ret = unsafe { winapi::um::winuser::GetMessageW(&amp;mut msg, null_mut(), 0, 0) }; if ret &gt; 0 { unsafe { winapi::um::winuser::TranslateMessage(&amp;msg); winapi::um::winuser::DispatchMessageW(&amp;msg); } } else { break; } }}打开文件对话框123456789101112131415161718192021use std::ptr::null_mut;use winapi::um::commdlg::{GetOpenFileNameW, OPENFILENAMEW};use winapi::um::winuser::HWND;fn main() { let mut ofn = OPENFILENAMEW { lStructSize: std::mem::size_of::&lt;OPENFILENAMEW&gt;() as u32, hwndOwner: HWND(null_mut()), lpstrFilter: \"Text Files\\0*.txt\\0All Files\\0*.*\\0\\0\".to_wide_null().as_ptr(), lpstrFile: [0; 260].as_mut_ptr(), nMaxFile: 260, Flags: 0, lpstrDefExt: \"txt\\0\".to_wide_null().as_ptr(), ..Default::default() }; let ret = unsafe { GetOpenFileNameW(&amp;mut ofn) }; if ret != 0 { let file_name = ofn.lpstrFile.to_string_lossy(); println!(\"Selected file: {}\", file_name); }}读取注册表1234567891011121314151617181920212223242526272829use std::ptr::null_mut;use winapi::um::winreg::{RegCloseKey, RegOpenKeyExW, HKEY_LOCAL_MACHINE, KEY_READ, LPDWORD, REG_SZ};use widestring::U16CString;fn main() { let sub_key = \"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\".to_wide_null(); let mut h_key = null_mut(); let ret = unsafe { RegOpenKeyExW(HKEY_LOCAL_MACHINE, sub_key.as_ptr(), 0, KEY_READ, &amp;mut h_key) }; if ret == 0 { let mut buffer = [0u16; 1024]; let mut buffer_size = (buffer.len() * 2) as u32; let mut value_type = REG_SZ; let ret = unsafe { winapi::um::winreg::RegQueryValueExW( h_key, \"ProductName\".to_wide_null().as_ptr(), null_mut(), &amp;mut value_type, buffer.as_mut_ptr() as *mut _, &amp;mut buffer_size, ) }; if ret == 0 { let value = U16CString::from_vec_with_nul(&amp;buffer[..(buffer_size as usize)]).unwrap(); println!(\"Product name: {}\", value.to_string_lossy()); } unsafe { RegCloseKey(h_key) }; }}注册热键1234567891011121314151617181920212223242526272829use winapi::um::winuser::{RegisterHotKey, UnregisterHotKey};use winapi::um::winuser::{HWND, WM_HOTKEY};fn main() { let hwnd: HWND = std::ptr::null_mut(); let id: i32 = 1; let modifiers: u32 = 0x0002; // MOD_CONTROL let vk: u32 = 0x43; // 'C' let result: i32 = unsafe { RegisterHotKey(hwnd, id, modifiers, vk) }; if result == 0 { println!(\"Failed to register hotkey.\"); return; } loop { let mut msg = std::mem::zeroed(); let result = unsafe { winapi::um::winuser::GetMessageW(&amp;mut msg, hwnd, 0, 0) }; if result == -1 { println!(\"Failed to get message.\"); break; } if msg.message == WM_HOTKEY { println!(\"Hotkey pressed.\"); break; } unsafe { winapi::um::winuser::TranslateMessage(&amp;msg) }; unsafe { winapi::um::winuser::DispatchMessageW(&amp;msg) }; } unsafe { UnregisterHotKey(hwnd, id) };}在代码中，使用 RegisterHotKey 函数注册一个热键，当用户按下 Ctrl+C 时，会收到 WM_HOTKEY 消息。使用 GetMessageW 函数获取消息，使用 TranslateMessage 函数翻译消息，使用 DispatchMessageW 函数分发消息。使用 UnregisterHotKey 函数注销热键。创建进程在 Windows 系统中，可以使用 CreateProcess 函数创建一个进程。使用 winapi 模块可以方便地调用 CreateProcess 函数。1234567891011121314151617181920212223242526272829303132use winapi::um::processthreadsapi::CreateProcessA;use winapi::um::winbase::CREATE_NEW_CONSOLE;use winapi::um::winnt::{PROCESS_INFORMATION, STARTUPINFOA};use std::ffi::CString;use std::mem::{size_of, zeroed};use std::ptr::null_mut;fn main() { let command_line = CString::new(\"notepad.exe\").unwrap(); let mut startup_info: STARTUPINFOA = unsafe { zeroed() }; startup_info.cb = size_of::&lt;STARTUPINFOA&gt;() as u32; let mut process_info: PROCESS_INFORMATION = unsafe { zeroed() }; let result = unsafe { CreateProcessA( null_mut(), command_line.as_ptr() as *mut _, null_mut(), null_mut(), 0, CREATE_NEW_CONSOLE, null_mut(), null_mut(), &amp;mut startup_info, &amp;mut process_info, ) }; if result == 0 { println!(\"Failed to create process\"); } else { println!(\"Process created successfully\"); }}上述代码中，首先使用 CString 将字符串转换为 C 类型的字符串，然后使用 CreateProcessA 函数创建进程。CreateProcessA 函数的第一个参数是可执行文件的路径，第二个参数是命令行参数，第三个参数是进程的安全属性，第四个参数是主线程的安全属性，第五个参数是是否继承句柄，第六个参数是创建进程的标志，第七个参数是环境变量，第八个参数是当前目录，第九个参数是启动信息，第十个参数是进程信息。在这个示例中，使用了 null_mut()表示不设置进程和主线程的安全属性，使用了 CREATE_NEW_CONSOLE 表示创建一个新的控制台窗口。如果 CreateProcessA 函数返回 0，则说明创建进程失败。否则，创建进程成功。创建线程123456789101112131415161718192021use std::ptr::null_mut;use std::thread;use winapi::um::processthreadsapi::{CreateThread, GetCurrentThreadId, GetExitCodeThread, TerminateThread};use winapi::um::synchapi::WaitForSingleObject;use winapi::um::winbase::{INFINITE, WAIT_OBJECT_0};fn thread_proc() -&gt; u32 { println!(\"Thread ID: {}\", unsafe { GetCurrentThreadId() }); 0}fn main() { let handle = unsafe { CreateThread(null_mut(), 0, Some(thread_proc), null_mut(), 0, null_mut()) }; let ret = unsafe { WaitForSingleObject(handle, INFINITE) }; if ret == WAIT_OBJECT_0 { let mut exit_code = 0; unsafe { GetExitCodeThread(handle, &amp;mut exit_code) }; println!(\"Exit code: {}\", exit_code); } unsafe { TerminateThread(handle, 0) };}创建共享内存1234567891011121314151617181920212223242526272829303132333435363738394041use std::ptr::null_mut;use winapi::um::handleapi::{CloseHandle, INVALID_HANDLE_VALUE};use winapi::um::memoryapi::{MapViewOfFile, UnmapViewOfFile, CreateFileMappingW, FILE_MAP_ALL_ACCESS};use winapi::um::winnt::{HANDLE, PAGE_READWRITE, SECTION_ALL_ACCESS};fn main() { let file_name = \"Global\\\\MySharedMemory\".to_wide_null(); let file_size = 4096; let h_file_mapping = unsafe { CreateFileMappingW( INVALID_HANDLE_VALUE, null_mut(), PAGE_READWRITE, 0, file_size, file_name.as_ptr(), ) }; let mut p_shared_memory = null_mut(); if !h_file_mapping.is_null() { p_shared_memory = unsafe { MapViewOfFile( h_file_mapping, FILE_MAP_ALL_ACCESS, 0, 0, file_size, ) }; } if !p_shared_memory.is_null() { let p_data = p_shared_memory as *mut u8; for i in 0..file_size { unsafe { *p_data.offset(i as isize) = i as u8 }; } unsafe { UnmapViewOfFile(p_shared_memory) }; } if !h_file_mapping.is_null() { unsafe { CloseHandle(h_file_mapping) }; }}获取系统时间获取系统时间是一个常见的操作，可以用于记录日志或计算时间差等。下面是一个使用 winapi 模块获取系统时间的示例：12345678910use winapi::um::sysinfoapi::GetSystemTime;use winapi::um::winbase::SYSTEMTIME;fn main() { unsafe { let mut st: SYSTEMTIME = std::mem::zeroed(); GetSystemTime(&amp;mut st as *mut SYSTEMTIME); println!(\"{}-{}-{} {}:{}:{}\", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond); }}在这个示例中，我们使用了 sysinfoapi 模块中的 GetSystemTime 函数来获取系统时间。该函数的参数为一个 SYSTEMTIME 结构体指针，用于存储系统时间。我们使用 std::mem::zeroed()创建了一个空的 SYSTEMTIME 结构体，然后将其地址传递给 GetSystemTime 函数。最后，我们将获取到的系统时间打印出来。使用 COM 组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263use std::ptr::null_mut;use winapi::um::combaseapi::{CoInitializeEx, CoCreateInstance, CoUninitialize};use winapi::um::objbase::COINIT_APARTMENTTHREADED;use winapi::um::objidl::ISequentialStream;use winapi::um::unknwnbase::IUnknown;use winapi::um::winnt::{HRESULT, S_OK};use winapi::um::winuser::MessageBoxW;use winapi::Interface;const CLSID_XMLHTTPREQUEST: winapi::CLSID = winapi::CLSID { Data1: 0xED8C108E, Data2: 0x4349, Data3: 0x11D2, Data4: [0x91, 0xA4, 0x00, 0xC0, 0x4F, 0x79, 0xF8, 0x06],};const IID_IUNKNOWN: winapi::IID = winapi::IID { Data1: 0x00000000, Data2: 0x0000, Data3: 0x0000, Data4: [0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46],};fn main() { unsafe { CoInitializeEx(null_mut(), COINIT_APARTMENTTHREADED); let mut p_xml_http_request: *mut IUnknown = null_mut(); let hr = CoCreateInstance( &amp;CLSID_XMLHTTPREQUEST, null_mut(), winapi::um::combaseapi::CLSCTX_INPROC_SERVER, &amp;IID_IUNKNOWN, &amp;mut p_xml_http_request as *mut _ as *mut *mut _, ); if hr == S_OK { let mut p_stream: *mut ISequentialStream = null_mut(); let hr = (*p_xml_http_request).QueryInterface( &amp;ISequentialStream::uuidof(), &amp;mut p_stream as *mut _ as *mut *mut _, ); if hr == S_OK { let message = \"Hello, world!\".to_wide_null(); let mut bytes_written = 0; let hr = (*p_stream).Write( message.as_ptr() as *const _, (message.len() * 2) as u32, &amp;mut bytes_written as *mut _, ); if hr == S_OK { MessageBoxW( null_mut(), \"Data written successfully!\".to_wide_null().as_ptr(), \"Success\\0\".to_wide_null().as_ptr(), 0, ); } } (*p_stream).Release(); } (*p_xml_http_request).Release(); CoUninitialize(); }}结论本教程介绍了 winapi 模块的基础用法和进阶用法，并提供了示例代码。在使用 winapi 模块时，需要注意数据类型、结构体、常量和指针类型的正确使用。通过使用 winapi 模块，Rust 程序可以访问 Windows 操作系统的核心功能，实现更加丰富的功能。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 数据库连接池r2d2模块",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 数据库连接池",
      "url"         : "./rust/2023/04/13/rust_lang_tutorial_224_Database_Connect_Pool.html",
      "date"        : "2023-04-13 00:00:00 +0800",
      "description" : "",
      "content"     : "r2d2 是 Rust 语言的一个连接池模块，可以用于管理和复用数据库连接。它可以与多种数据库进行交互，包括 MySQL、PostgreSQL、SQLite 等等。使用 r2d2 可以提高数据库操作的效率，避免频繁地创建和销毁连接，从而提高程序的性能。基础用法安装在使用 r2d2 之前，需要先在项目中添加 r2d2 的依赖。可以通过 Cargo.toml 文件来添加依赖：1234[dependencies]r2d2 = \"0.8.10\"r2d2_mysql = \"23.0.0\"mysql_async = \"0.32.0\"创建连接池在使用 r2d2 之前，需要先创建一个连接池。连接池的大小可以根据实际情况进行调整。下面是一个创建 MySQL 连接池的示例：1234567use r2d2::{Pool, PooledConnection};use r2d2_mysql::mysql::PoolOptions;fn main() { let manager = r2d2_mysql::MysqlConnectionManager::new(\"mysql://user:password@localhost:3306/database\").unwrap(); let pool = Pool::builder().build(manager).unwrap();}获取连接在创建连接池之后，可以通过连接池来获取数据库连接。获取连接时，需要使用get()方法。如果连接池中没有可用的连接，get()方法会阻塞等待，直到有可用的连接为止。下面是一个获取 MySQL 连接的示例：12345fn main() { let manager = r2d2_mysql::MysqlConnectionManager::new(\"mysql://user:password@localhost:3306/database\").unwrap(); let pool = Pool::builder().build(manager).unwrap(); let conn = pool.get().unwrap();}使用连接获取到连接之后，就可以使用连接来进行数据库操作了。下面是一个查询 MySQL 数据库中的数据的示例：12345678910fn main() { let manager = r2d2_mysql::MysqlConnectionManager::new(\"mysql://user:password@localhost:3306/database\").unwrap(); let pool = Pool::builder().build(manager).unwrap(); let conn = pool.get().unwrap(); let mut stmt = conn.prepare(\"SELECT * FROM table\").unwrap(); let rows = stmt.query_map([], |row| { // 处理查询结果 }).unwrap();}释放连接使用完连接之后，需要将连接返回给连接池，以便其他程序可以复用该连接。可以通过drop()方法来释放连接。下面是一个释放 MySQL 连接的示例：123456789fn main() { let manager = r2d2_mysql::MysqlConnectionManager::new(\"mysql://user:password@localhost:3306/database\").unwrap(); let pool = Pool::builder().build(manager).unwrap(); let conn = pool.get().unwrap(); // 使用连接进行数据库操作 drop(conn);}自定义连接池r2d2 提供了一些默认的连接池实现，但是也可以通过实现r2d2::ManageConnection和r2d2::Pool来自定义连接池。下面是一个自定义 MySQL 连接池的示例：1234567891011121314151617181920212223242526272829303132333435363738use r2d2::{Pool, PooledConnection, ManageConnection};use r2d2_mysql::mysql::{Opts, OptsBuilder, Pool as MysqlPool, PooledConn};struct MyMysqlConnectionManager { pool: MysqlPool,}impl MyMysqlConnectionManager { fn new(db_url: &amp;str) -&gt; MyMysqlConnectionManager { let opts = Opts::from_url(db_url).unwrap(); let builder = OptsBuilder::from_opts(opts); let pool = MysqlPool::new(builder).unwrap(); MyMysqlConnectionManager { pool } }}impl ManageConnection for MyMysqlConnectionManager { type Connection = PooledConn; type Error = r2d2_mysql::mysql::Error; fn connect(&amp;self) -&gt; Result&lt;Self::Connection, Self::Error&gt; { self.pool.get_conn() } fn is_valid(&amp;self, conn: &amp;mut Self::Connection) -&gt; Result&lt;(), Self::Error&gt; { conn.ping() } fn has_broken(&amp;self, conn: &amp;mut Self::Connection) -&gt; bool { conn.ping().is_err() }}fn main() { let manager = MyMysqlConnectionManager::new(\"mysql://user:password@localhost:3306/database\"); let pool = Pool::builder().build(manager).unwrap(); let conn = pool.get().unwrap();}自定义连接池配置可以通过Pool::builder()方法来创建连接池配置。连接池的配置可以包括最小连接数、最大连接数、连接超时时间等等。下面是一个自定义 MySQL 连接池配置的示例：1234567891011use std::time::Duration;fn main() { let manager = r2d2_mysql::MysqlConnectionManager::new(\"mysql://user:password@localhost:3306/database\").unwrap(); let pool = Pool::builder() .min_idle(Some(5)) .max_size(20) .connection_timeout(Duration::from_secs(30)) .build(manager) .unwrap();}连接池监控r2d2 提供了一些方法来监控连接池的状态。可以通过Pool::state()方法来获取连接池的状态，包括已经创建的连接数、正在使用的连接数、空闲的连接数等等。下面是一个获取 MySQL 连接池状态的示例：123456789fn main() { let manager = r2d2_mysql::MysqlConnectionManager::new(\"mysql://user:password@localhost:3306/database\").unwrap(); let pool = Pool::builder().build(manager).unwrap(); let state = pool.state(); println!(\"created connections: {}\", state.created_connections); println!(\"idle connections: {}\", state.idle_connections); println!(\"in use connections: {}\", state.in_use_connections);}自定义连接池事件处理器r2d2 提供了一些事件处理器，可以在连接池中的连接被创建、被借用、被归还、被销毁时触发事件。可以通过实现r2d2::HandleEvent来自定义事件处理器。下面是一个自定义 MySQL 连接池事件处理器的示例：12345678910111213141516171819202122232425262728293031323334use r2d2::{Pool, PooledConnection, ManageConnection, HandleEvent};use r2d2_mysql::mysql::PoolOptions;struct MyEventHandler;impl HandleEvent for MyEventHandler { fn on_acquire(&amp;self, conn: &amp;mut PooledConnection&lt;'_, MysqlConnectionManager&gt;) -&gt; Result&lt;(), r2d2::Error&gt; { println!(\"connection acquired\"); Ok(()) } fn on_release(&amp;self, conn: &amp;mut PooledConnection&lt;'_, MysqlConnectionManager&gt;) -&gt; Result&lt;(), r2d2::Error&gt; { println!(\"connection released\"); Ok(()) } fn on_check_out(&amp;self, conn: &amp;mut PooledConnection&lt;'_, MysqlConnectionManager&gt;) -&gt; Result&lt;(), r2d2::Error&gt; { println!(\"connection checked out\"); Ok(()) } fn on_check_in(&amp;self, conn: &amp;mut PooledConnection&lt;'_, MysqlConnectionManager&gt;) -&gt; Result&lt;(), r2d2::Error&gt; { println!(\"connection checked in\"); Ok(()) }}fn main() { let manager = r2d2_mysql::MysqlConnectionManager::new(\"mysql://user:password@localhost:3306/database\").unwrap(); let pool = Pool::builder() .event_handler(Box::new(MyEventHandler)) .build(manager) .unwrap();}自定义连接池超时处理器r2d2 提供了一个默认的连接池超时处理器，当连接池中没有可用的连接时，会等待一定的时间，如果仍然没有可用的连接，则会返回错误。可以通过实现r2d2::HandleError来自定义连接池超时处理器。下面是一个自定义 MySQL 连接池超时处理器的示例：1234567891011121314151617181920212223use std::time::Duration;use r2d2::{Pool, PooledConnection, ManageConnection, HandleError};use r2d2_mysql::mysql::PoolOptions;struct MyErrorHandler;impl HandleError&lt;r2d2_mysql::mysql::Error&gt; for MyErrorHandler { fn handle_error(&amp;self, error: r2d2_mysql::mysql::Error) -&gt; r2d2::Action { match error { r2d2_mysql::mysql::Error::Timeout =&gt; r2d2::Action::Retry(Duration::from_secs(5)), _ =&gt; r2d2::Action::Fail, } }}fn main() { let manager = r2d2_mysql::MysqlConnectionManager::new(\"mysql://user:password@localhost:3306/database\").unwrap(); let pool = Pool::builder() .connection_timeout(Duration::from_secs(30)) .error_handler(Box::new(MyErrorHandler)) .build(manager) .unwrap();}自定义连接池初始化器r2d2 提供了一个默认的连接池初始化器，当连接池中没有可用的连接时，会自动创建新的连接。可以通过实现r2d2::Initializer来自定义连接池初始化器。下面是一个自定义 MySQL 连接池初始化器的示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152use r2d2::{Pool, PooledConnection, ManageConnection, Initializer};use r2d2_mysql::mysql::{Opts, OptsBuilder, Pool as MysqlPool, PooledConn};struct MyMysqlConnectionManager { pool: MysqlPool,}impl MyMysqlConnectionManager { fn new(db_url: &amp;str) -&gt; MyMysqlConnectionManager { let opts = Opts::from_url(db_url).unwrap(); let builder = OptsBuilder::from_opts(opts); let pool = MysqlPool::new(builder).unwrap(); MyMysqlConnectionManager { pool } }}impl ManageConnection for MyMysqlConnectionManager { type Connection = PooledConn; type Error = r2d2_mysql::mysql::Error; fn connect(&amp;self) -&gt; Result&lt;Self::Connection, Self::Error&gt; { self.pool.get_conn() } fn is_valid(&amp;self, conn: &amp;mut Self::Connection) -&gt; Result&lt;(), Self::Error&gt; { conn.ping() } fn has_broken(&amp;self, conn: &amp;mut Self::Connection) -&gt; bool { conn.ping().is_err() }}struct MyInitializer;impl Initializer&lt;MyMysqlConnectionManager&gt; for MyInitializer { type Error = r2d2_mysql::mysql::Error; fn initialize(&amp;self, conn: &amp;mut PooledConnection&lt;'_, MyMysqlConnectionManager&gt;) -&gt; Result&lt;(), Self::Error&gt; { // 初始化连接 Ok(()) }}fn main() { let manager = MyMysqlConnectionManager::new(\"mysql://user:password@localhost:3306/database\"); let pool = Pool::builder() .initializer(Box::new(MyInitializer)) .build(manager) .unwrap(); let conn = pool.get().unwrap();}自定义连接池回收器r2d2 提供了一个默认的连接池回收器，当连接池中的连接空闲时间超过一定的时间时，会自动关闭连接。可以通过实现r2d2::ConnectionManager来自定义连接池回收器。下面是一个自定义 MySQL 连接池回收器的示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051use std::time::Duration;use r2d2::{Pool, PooledConnection, ManageConnection, ConnectionManager};use r2d2_mysql::mysql::{Opts, OptsBuilder, Pool as MysqlPool, PooledConn};struct MyMysqlConnectionManager { pool: MysqlPool,}impl MyMysqlConnectionManager { fn new(db_url: &amp;str) -&gt; MyMysqlConnectionManager { let opts = Opts::from_url(db_url).unwrap(); let builder = OptsBuilder::from_opts(opts); let pool = MysqlPool::new(builder).unwrap(); MyMysqlConnectionManager { pool } }}impl ManageConnection for MyMysqlConnectionManager { type Connection = PooledConn; type Error = r2d2_mysql::mysql::Error; fn connect(&amp;self) -&gt; Result&lt;Self::Connection, Self::Error&gt; { self.pool.get_conn() } fn is_valid(&amp;self, conn: &amp;mut Self::Connection) -&gt; Result&lt;(), Self::Error&gt; { conn.ping() } fn has_broken(&amp;self, conn: &amp;mut Self::Connection) -&gt; bool { conn.ping().is_err() }}struct MyConnectionManager;impl ConnectionManager&lt;MyMysqlConnectionManager&gt; for MyConnectionManager { fn recycle_check(&amp;self, conn: &amp;mut PooledConnection&lt;'_, MyMysqlConnectionManager&gt;) -&gt; Result&lt;(), r2d2::Error&gt; { // 回收连接 Ok(()) }}fn main() { let manager = MyMysqlConnectionManager::new(\"mysql://user:password@localhost:3306/database\"); let pool = Pool::builder() .connection_customizer(Box::new(MyConnectionManager)) .build(manager) .unwrap(); let conn = pool.get().unwrap();}自定义连接池失效检测操作r2d2 模块支持自定义连接池失效检测操作，例如在连接池中的连接失效时需要执行的操作。以下是自定义连接池失效检测操作的示例代码：123456789101112131415161718use r2d2::Pool;use r2d2_mysql::mysql::OptsBuilder;use r2d2_mysql::mysql::PoolOptions;fn main() { let mut builder = OptsBuilder::new(); builder.ip_or_hostname(Some(\"localhost\")) .user(Some(\"root\")) .pass(Some(\"password\")) .db_name(Some(\"test\")); let opts = builder.into(); let pool = Pool::builder() .test_on_acquire(true) .test_on_check_out(true) .max_lifetime(Duration::from_secs(60)) .build(PoolOptions::new(), opts) .unwrap();}在以上示例代码中，我们使用了 test_on_acquire 和 test_on_check_out 方法来设置连接池失效检测操作。在 test_on_acquire 和 test_on_check_out 方法中，我们可以执行任意的操作，例如检查连接是否失效等。最佳实践在使用 r2d2 模块时，我们需要遵循以下最佳实践： 将连接池作为全局对象，并在程序启动时初始化连接池。 在使用连接池获取连接时，需要使用连接池的 get 方法，并在使用完连接后及时释放连接。 在使用连接池执行 SQL 语句时，需要使用事务来保证数据的一致性。 在自定义连接池配置时，需要根据实际需求进行灵活配置，例如连接池的大小、超时时间、初始化操作等。 在多线程环境下使用连接池时，需要使用 Arc来共享连接池对象，并保证连接池的线程安全性。总结r2d2 是一个 Rust 语言的连接池模块，可以用于管理和重用数据库连接，避免了频繁地创建和销毁连接的开销，提高了数据库操作的效率和性能。在使用 r2d2 时，需要进行错误处理；可以根据具体需求进行自定义连接池的实现，以满足项目的需求。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 实战Chrome浏览器SQLite数据库",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, SQLite",
      "url"         : "./rust/2023/04/13/rust_lang_tutorial_223_Chrome_SQLite.html",
      "date"        : "2023-04-13 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种高性能、可靠性强的系统编程语言，它的出现为开发者提供了一种新的选择。Rust 的安全性和性能优势使得它成为了许多项目的首选语言，包括 Web 浏览器的开发。Chrome 浏览器是一款广受欢迎的浏览器，它使用 SQLite 数据库来存储浏览器的历史记录、书签、密码等数据。在本教程中，我们将介绍如何使用 Rust 语言操作 Chrome 浏览器的 SQLite 数据库。基础用法在开始之前，我们需要安装 Rust 和 Chrome 浏览器。我们将使用 rusqlite 库来操作 SQLite 数据库。首先，我们需要在项目的 Cargo.toml 文件中添加 rusqlite 依赖：12[dependencies]rusqlite = \"0.29.0\"接下来，我们将演示如何使用 Rust 语言连接 Chrome 浏览器的 SQLite 数据库，并执行基本的查询和更新操作。连接数据库1234567use rusqlite::{Connection, Result};fn main() -&gt; Result&lt;()&gt; { let path = \"/path/to/chrome/database\"; let conn = Connection::open(path)?; Ok(())}我们使用Connection::open方法打开 Chrome 浏览器的 SQLite 数据库，该方法返回一个Connection对象，我们可以使用该对象执行后续的查询和更新操作。查询数据1234567891011121314151617use rusqlite::{Connection, Result};fn main() -&gt; Result&lt;()&gt; { let path = \"/path/to/chrome/database\"; let conn = Connection::open(path)?; let mut stmt = conn.prepare(\"SELECT * FROM bookmarks\")?; let rows = stmt.query_map([], |row| { Ok((row.get(0)?, row.get(1)?)) })?; for row in rows { let (id, url): (i64, String) = row?; println!(\"{}: {}\", id, url); } Ok(())}我们使用conn.prepare方法准备一个查询语句，并使用stmt.query_map方法执行查询，并将结果映射为元组类型(i64, String)。在循环中，我们遍历查询结果，并打印每个书签的 ID 和 URL。插入数据123456789use rusqlite::{Connection, Result};fn main() -&gt; Result&lt;()&gt; { let path = \"/path/to/chrome/database\"; let conn = Connection::open(path)?; let mut stmt = conn.prepare(\"INSERT INTO bookmarks (url, title) VALUES (?, ?)\")?; stmt.execute(&amp;[\"https://www.rust-lang.org\", \"Rust Programming Language\"])?; Ok(())}我们使用conn.prepare方法准备一个插入语句，并使用stmt.execute方法执行插入操作。在这个例子中，我们插入了一个名为“Rust Programming Language”的书签。更新数据123456789use rusqlite::{Connection, Result};fn main() -&gt; Result&lt;()&gt; { let path = \"/path/to/chrome/database\"; let conn = Connection::open(path)?; let mut stmt = conn.prepare(\"UPDATE bookmarks SET title = ? WHERE url = ?\")?; stmt.execute(&amp;[\"Rust\", \"https://www.rust-lang.org\"])?; Ok(())}我们使用conn.prepare方法准备一个更新语句，并使用stmt.execute方法执行更新操作。在这个例子中，我们将名为“Rust Programming Language”的书签的标题更新为“Rust”。删除数据123456789use rusqlite::{Connection, Result};fn main() -&gt; Result&lt;()&gt; { let path = \"/path/to/chrome/database\"; let conn = Connection::open(path)?; let mut stmt = conn.prepare(\"DELETE FROM bookmarks WHERE url = ?\")?; stmt.execute(&amp;[\"https://www.rust-lang.org\"])?; Ok(())}我们使用conn.prepare方法准备一个删除语句，并使用stmt.execute方法执行删除操作。在这个例子中，我们删除了名为“Rust Programming Language”的书签。事务123456789101112use rusqlite::{Connection, Result};fn main() -&gt; Result&lt;()&gt; { let path = \"/path/to/chrome/database\"; let conn = Connection::open(path)?; let mut tx = conn.transaction()?; tx.execute(\"INSERT INTO bookmarks (url, title) VALUES (?, ?)\", &amp;[\"https://www.rust-lang.org\", \"Rust Programming Language\"])?; tx.execute(\"UPDATE bookmarks SET title = ? WHERE url = ?\", &amp;[\"Rust\", \"https://www.rust-lang.org\"])?; tx.execute(\"DELETE FROM bookmarks WHERE url = ?\", &amp;[\"https://www.rust-lang.org\"])?; tx.commit()?; Ok(())}我们使用conn.transaction方法创建一个事务，并在事务中执行多个查询操作。在这个例子中，我们插入了一个名为“Rust Programming Language”的书签，然后将其标题更新为“Rust”，最后删除该书签。在事务中执行这些操作可以确保它们要么全部执行成功，要么全部失败，从而保证数据的完整性。批量插入1234567891011121314use rusqlite::{Connection, Result};fn main() -&gt; Result&lt;()&gt; { let path = \"/path/to/chrome/database\"; let conn = Connection::open(path)?; let mut stmt = conn.prepare(\"INSERT INTO bookmarks (url, title) VALUES (?, ?)\")?; let data = [(\"https://www.rust-lang.org\", \"Rust Programming Language\"), (\"https://www.python.org\", \"Python Programming Language\")]; let mut tx = conn.transaction()?; for (url, title) in data.iter() { stmt.execute(&amp;[url, title])?; } tx.commit()?; Ok(())}我们使用conn.prepare方法准备一个插入语句，并使用stmt.execute方法在事务中插入多个书签。在这个例子中，我们插入了两个书签，一个是 Rust Programming Language，另一个是 Python Programming Language。批量更新1234567891011121314use rusqlite::{Connection, Result};fn main() -&gt; Result&lt;()&gt; { let path = \"/path/to/chrome/database\"; let conn = Connection::open(path)?; let mut stmt = conn.prepare(\"UPDATE bookmarks SET title = ? WHERE url = ?\")?; let data = [(\"Rust\", \"https://www.rust-lang.org\"), (\"Python\", \"https://www.python.org\")]; let mut tx = conn.transaction()?; for (title, url) in data.iter() { stmt.execute(&amp;[title, url])?; } tx.commit()?; Ok(())}我们使用conn.prepare方法准备一个更新语句，并使用stmt.execute方法在事务中更新多个书签的标题。在这个例子中，我们将 Rust Programming Language 的标题更新为 Rust，将 Python Programming Language 的标题更新为 Python。进阶用法在本节中，我们将介绍一些高级用法，包括使用预编译语句、使用自定义函数、使用自定义类型等。预编译语句12345678910111213141516use rusqlite::{Connection, Result};fn main() -&gt; Result&lt;()&gt; { let path = \"/path/to/chrome/database\"; let conn = Connection::open(path)?; let mut stmt = conn.prepare_cached(\"SELECT * FROM bookmarks WHERE url = ?\")?; let rows = stmt.query_map(&amp;[\"https://www.rust-lang.org\"], |row| { Ok((row.get(0)?, row.get(1)?)) })?; for row in rows { let (id, title): (i64, String) = row?; println!(\"{}: {}\", id, title); } Ok(())}我们使用conn.prepare_cached方法准备一个预编译语句，并使用stmt.query_map方法执行查询。在这个例子中，我们查询了 URL 为https://www.rust-lang.org的书签，并打印其ID和标题。使用异步 IO在处理大量数据时，使用异步 IO 可以提高程序的并发性能。例如，以下代码使用 tokio 库实现异步 IO 查询 Chrome 浏览器的所有书签：1234567891011121314151617181920use rusqlite::{Connection, Result};use tokio::runtime::Runtime;fn main() -&gt; Result&lt;()&gt; { let path = \"/path/to/chrome/database\"; let conn = Connection::open(path)?; let mut rt = Runtime::new()?; rt.block_on(async { let mut stmt = conn.prepare(\"SELECT * FROM bookmarks\")?; let rows = stmt.query([])?; while let Some(row) = rows.next().await { let title: String = row?.get(1)?; let url: String = row?.get(2)?; println!(\"{} - {}\", title, url); } Ok(()) })}在以上代码中，我们使用 tokio 库创建一个异步运行时，并在异步任务中执行查询操作。使用连接池在多线程环境下，使用连接池可以避免竞争条件和锁竞争。例如，以下代码使用 r2d2 和 rusqlite 库实现连接池查询 Chrome 浏览器的所有书签：1234567891011121314151617181920use rusqlite::{Connection, Result};use r2d2::Pool;use r2d2_sqlite::SqliteConnectionManager;fn main() -&gt; Result&lt;()&gt; { let path = \"/path/to/chrome/database\"; let manager = SqliteConnectionManager::file(path); let pool = Pool::builder().build(manager)?; let conn = pool.get()?; let mut stmt = conn.prepare(\"SELECT * FROM bookmarks\")?; let rows = stmt.query([])?; for row in rows { let title: String = row.get(1)?; let url: String = row.get(2)?; println!(\"{} - {}\", title, url); } Ok(())}在以上代码中，我们使用 r2d2 和 rusqlite 库创建一个连接池，并在连接池中获取数据库连接。最佳实践在使用 Rust 语言操作 Chrome 浏览器的 SQLite 数据库时，我们应该遵循以下最佳实践： 使用预编译语句和事务等技术来提高性能和保证数据一致性。 在多线程环境下，使用连接池来避免竞争条件和锁竞争。 在处理大量数据时，使用异步 IO 来提高程序的并发性能。 对于 Chrome 浏览器的 SQLite 数据库文件路径，应该使用环境变量或配置文件来管理，避免硬编码。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Rust GUI实践之Tarui模块",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Tarui",
      "url"         : "./rust/2023/04/13/rust_lang_tutorial_222_GUI_Rust_Tauri.html",
      "date"        : "2023-04-13 00:00:00 +0800",
      "description" : "",
      "content"     : "Tauri 是一个用于构建跨平台本地应用程序的工具包，它使用 Rust 语言作为主要开发语言，可以在 Windows，MacOS 和 Linux 等平台上运行。Tauri 基于 Web 技术栈，可以使用 HTML，CSS 和 JavaScript 构建应用程序的用户界面，同时使用 Rust 语言编写应用程序的后端逻辑。Tauri 可以使用 Electron 的 API，但是相比于 Electron，Tauri 具有更小的二进制文件大小和更快的启动速度。基础用法要使用 Tauri，您需要将其添加为项目的依赖项。在 Cargo.toml 文件中添加以下行：[dependencies]tauri = \"1.2.4\"创建一个窗口要创建一个窗口，请使用以下代码：1234567891011fn main() { tauri::Builder::default() .invoke_handler(tauri::generate_handler![handle]) .run(tauri::generate_context!()) .expect(\"error while running tauri application\");}#[tauri::command]fn handle() -&gt; Result&lt;String, String&gt; { Ok(String::from(\"Hello, world!\"))}这将创建一个简单的窗口，并在窗口中显示“Hello, world!”。与前端交互要与前端交互，请使用以下代码：12345#[tauri::command]fn handle(message: String) -&gt; Result&lt;String, String&gt; { println!(\"Received message: {}\", message); Ok(String::from(\"Success\"))}这将在后端处理程序中接收来自前端的消息，并在控制台中打印该消息。使用 Tauri API要使用 Tauri API，请使用以下代码：1tauri::api::dialog::info(\"Hello, world!\", \"This is an info message\");这将在应用程序中显示一个信息框，其中包含“Hello, world!”和“This is an info message”。添加菜单要向您的 Tauri 应用程序添加菜单，您可以使用tauri::menu::CustomMenuItem结构体。以下是一个示例：1234567891011use tauri::menu::{CustomMenuItem, Menu, MenuItem};fn main() { let menu = Menu::new() .add_item(MenuItem::About(\"My App\".to_string())) .add_submenu(\"File\", Menu::new() .add_item(CustomMenuItem::new(\"Open\", \"CmdOrCtrl+O\")) .add_item(CustomMenuItem::new(\"Save\", \"CmdOrCtrl+S\")) .add_item(MenuItem::Separator) .add_item(CustomMenuItem::new(\"Quit\", \"CmdOrCtrl+Q\")));}在这个示例中，我们创建了一个名为“File”的子菜单，并向其添加了三个自定义菜单项和一个分隔符。添加事件要向您的 Tauri 应用程序添加事件，您可以使用tauri::event::listen函数。以下是一个示例：123456789use tauri::event::{Event, Listener};use std::sync::Arc;fn main() { let listener = Arc::new(Listener::new(\"my-event\", move |event| { println!(\"Received event: {:?}\", event); })); tauri::event::listen(listener);}在这个示例中，我们创建了一个名为“my-event”的事件监听器，并在事件触发时打印出事件的内容。使用 Tauri 文件系统 API要使用 Tauri 文件系统 API，请使用以下代码：12let file_contents = tauri::api::fs::read_to_string(\"my_file.txt\").unwrap();println!(\"File contents: {}\", file_contents);这将读取名为“my_file.txt”的文件，并将其内容打印到控制台上。使用 Tauri 打开外部链接要在应用程序中打开外部链接，请使用以下代码：1tauri::api::command::spawn(\"open https://www.baidu.com\");这将在默认浏览器中打开 Baidu 网站。使用 Tauri 通知要在应用程序中显示通知，请使用以下代码：1234tauri::api::notification::Notification::new() .title(\"My Notification\") .body(\"This is a notification\") .show();这将在应用程序中显示一个名为“My Notification”的通知，并在通知中显示文本“This is a notification”。使用 Tauri 加密 API要使用 Tauri 加密 API，请使用以下代码：12let encrypted_data = tauri::api::encryption::encrypt(\"my secret data\", \"my secret key\").unwrap();println!(\"Encrypted data: {}\", encrypted_data);这将使用名为“my secret key”的密钥加密名为“my secret data”的数据，并将加密后的数据打印到控制台上。使用 Tauri 数据库 API要使用 Tauri 数据库 API，请使用以下代码：12let db = tauri::api::database::Database::open(\"my_database.db\").unwrap();db.execute(\"CREATE TABLE IF NOT EXISTS my_table (id INTEGER PRIMARY KEY, name TEXT)\").unwrap();这将创建一个名为“my_database.db”的 SQLite 数据库，并在其中创建一个名为“my_table”的表。使用 SQLite在 Tauri 中，您可以使用 SQLite 数据库来存储和管理数据。以下是一个示例：123456789101112131415161718use rusqlite::{params, Connection, Result};fn main() -&gt; Result&lt;()&gt; { let conn = Connection::open_in_memory()?; conn.execute( \"CREATE TABLE users ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, email TEXT NOT NULL )\", [], )?; conn.execute( \"INSERT INTO users (name, email) VALUES (?1, ?2)\", params![\"Alice\", \"alice@example.com\"], )?; Ok(())}在这个示例中，我们创建了一个名为“users”的表，并向其中插入了一条数据。使用 WebSocket在 Tauri 中，您可以使用 WebSocket 来实现实时通信。以下是一个示例：12345678910111213141516171819202122232425262728use std::thread;use ws::{listen, CloseCode, Handler, Handshake, Message, Result};struct WebSocketHandler;impl Handler for WebSocketHandler { fn on_open(&amp;mut self, _: Handshake) -&gt; Result&lt;()&gt; { println!(\"WebSocket connection opened\"); Ok(()) } fn on_message(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; { println!(\"Received message: {}\", message); Ok(()) } fn on_close(&amp;mut self, code: CloseCode, reason: &amp;str) { println!(\"WebSocket connection closed with code {:?} and reason '{}'\", code, reason); }}fn main() { thread::spawn(|| { listen(\"127.0.0.1:3012\", |out| { WebSocketHandler { out } }).unwrap(); });}在这个示例中，我们创建了一个 WebSocket 服务器，并在收到消息时打印出它。我们还在新线程中启动了服务器，以便我们可以继续运行我们的 Tauri 应用程序。使用 WebAssembly在 Tauri 中，您可以使用 WebAssembly 来提高性能和速度。以下是一个示例：12345678910use wasm_bindgen::prelude::*;#[wasm_bindgen]pub fn fibonacci(n: i32) -&gt; i32 { if n &lt;= 1 { n } else { fibonacci(n - 1) + fibonacci(n - 2) }}在这个示例中，我们使用 WebAssembly 实现了一个计算斐波那契数列的函数。我们可以将这个函数导出到 JavaScript 中，然后在 Tauri 应用程序中使用它。使用 OpenGL在 Tauri 中，您可以使用 OpenGL 来创建高性能的图形和渲染效果。以下是一个示例：1234567891011121314151617181920212223242526272829use glutin_window::GlutinWindow as Window;use graphics::{clear, rectangle, Transformed};use opengl_graphics::{GlGraphics, OpenGL};use piston::event_loop::{EventLoop, EventSettings, Events};use piston::input::{RenderEvent, UpdateEvent};fn main() { let opengl = OpenGL::V3_2; let mut window: Window = Window::new( opengl, piston_window::WindowSettings::new(\"My App\", [800, 600]) .exit_on_esc(true), ); let mut gl = GlGraphics::new(opengl); let mut events = Events::new(EventSettings::new()); while let Some(e) = events.next(&amp;mut window) { if let Some(args) = e.render_args() { gl.draw(args.viewport(), |c, gl| { clear([0.0, 0.0, 0.0, 1.0], gl); rectangle( [1.0, 0.0, 0.0, 1.0], [0.0, 0.0, 50.0, 50.0], c.transform, gl, ); }); } }}在这个示例中，我们使用 OpenGL 创建了一个简单的红色矩形，并在窗口中渲染它。最佳实践以下是一些使用 Tauri 的最佳实践： 将应用程序拆分为前端和后端代码，以便更好地组织代码并使其更易于维护。 使用 Tauri API 来处理应用程序的核心功能，例如文件系统访问，加密，通知等。 使用 Tauri 打包器将应用程序打包为可执行文件，并将其部署到目标平台。 使用 Tauri 的菜单和通知 API 来提高应用程序的用户体验。 使用 Tauri 的加密 API 来保护敏感数据，例如用户凭据和配置文件。 使用 Tauri 的数据库 API 来存储和检索数据，例如用户配置和应用程序状态。结论Tauri 是一个功能强大的工具包，可以帮助您构建跨平台本地应用程序。它使用 Rust 语言作为主要开发语言，并提供了丰富的 API 和工具来帮助您构建高质量的应用程序。无论您是新手还是经验丰富的开发人员，Tauri 都可以为您提供所需的工具和支持，帮助您构建出色的应用程序。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Rust GUI实践之Rust-Qt模块",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Rust-Qt",
      "url"         : "./rust/2023/04/13/rust_lang_tutorial_221_GUI_Rust_Qt.html",
      "date"        : "2023-04-13 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust-Qt 是 Rust 语言的一个 Qt 绑定库，它允许 Rust 开发者使用 Qt 框架来创建跨平台的图形界面应用程序。Qt 是一个跨平台的应用程序框架，它提供了一系列的工具和库，可以帮助开发者创建高质量的应用程序，包括图形界面、网络、数据库等方面。Rust-Qt 的优势在于 Rust 语言的安全性和高性能，以及 Qt 框架的强大功能和跨平台性。使用 Rust-Qt 可以让开发者更加轻松地创建跨平台的图形界面应用程序。基础用法创建一个简单的窗口123456789101112use qt_widgets::application::Application;use qt_widgets::widget::Widget;use qt_widgets::window::Window;fn main() { let mut app = Application::new(); let mut window = Window::new(); window.set_title(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.resize_2a(400, 300); window.show(); app.exec();}这个示例演示了如何使用 Rust-Qt 创建一个简单的窗口，并设置窗口的标题和大小。创建一个带有按钮的窗口12345678910111213141516use qt_widgets::application::Application;use qt_widgets::widget::Widget;use qt_widgets::window::Window;use qt_widgets::push_button::PushButton;fn main() { let mut app = Application::new(); let mut window = Window::new(); let mut button = PushButton::new(&amp;qt_core::string::String::from(\"Click me!\")); window.set_title(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.resize_2a(400, 300); button.move_2a(50, 50); button.set_parent(&amp;mut window); window.show(); app.exec();}这个示例演示了如何在窗口中添加一个按钮，并设置按钮的文本和位置。创建一个带有标签的窗口1234567891011121314151617181920use qt_widgets::application::Application;use qt_widgets::widget::Widget;use qt_widgets::window::Window;use qt_widgets::push_button::PushButton;use qt_widgets::label::Label;fn main() { let mut app = Application::new(); let mut window = Window::new(); let mut button = PushButton::new(&amp;qt_core::string::String::from(\"Click me!\")); let mut label = Label::new(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.set_title(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.resize_2a(400, 300); button.move_2a(50, 50); label.move_2a(50, 100); button.set_parent(&amp;mut window); label.set_parent(&amp;mut window); window.show(); app.exec();}这个示例演示了如何在窗口中添加一个标签，并设置标签的文本和位置。创建一个带有文本框的窗口1234567891011121314151617181920use qt_widgets::application::Application;use qt_widgets::widget::Widget;use qt_widgets::window::Window;use qt_widgets::push_button::PushButton;use qt_widgets::line_edit::LineEdit;fn main() { let mut app = Application::new(); let mut window = Window::new(); let mut button = PushButton::new(&amp;qt_core::string::String::from(\"Click me!\")); let mut line_edit = LineEdit::new(); window.set_title(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.resize_2a(400, 300); button.move_2a(50, 50); line_edit.move_2a(50, 100); button.set_parent(&amp;mut window); line_edit.set_parent(&amp;mut window); window.show(); app.exec();}这个示例演示了如何在窗口中添加一个文本框，并设置文本框的位置。创建一个带有菜单的窗口1234567891011121314151617181920use qt_widgets::application::Application;use qt_widgets::widget::Widget;use qt_widgets::window::Window;use qt_widgets::menu::Menu;use qt_widgets::menu_bar::MenuBar;use qt_widgets::action::Action;fn main() { let mut app = Application::new(); let mut window = Window::new(); let mut menu_bar = MenuBar::new(&amp;mut window); let mut file_menu = Menu::new(&amp;qt_core::string::String::from(\"File\"), &amp;mut menu_bar); let mut exit_action = Action::new(&amp;qt_core::string::String::from(\"Exit\"), &amp;mut window); window.set_title(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.resize_2a(400, 300); file_menu.add_action(&amp;mut exit_action); menu_bar.add_menu(&amp;mut file_menu); window.show(); app.exec();}这个示例演示了如何在窗口中添加一个菜单，并设置菜单的选项。创建一个带有复选框的窗口1234567891011121314151617use qt_widgets::application::Application;use qt_widgets::widget::Widget;use qt_widgets::window::Window;use qt_widgets::check_box::CheckBox;fn main() { let mut app = Application::new(); let mut window = Window::new(); let mut check_box = CheckBox::new(); window.set_title(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.resize_2a(400, 300); check_box.move_2a(50, 50); check_box.set_text(&amp;qt_core::string::String::from(\"Check me!\")); check_box.set_parent(&amp;mut window); window.show(); app.exec();}这个示例演示了如何在窗口中添加一个复选框，并设置复选框的文本和位置。创建一个带有单选框的窗口1234567891011121314151617use qt_widgets::application::Application;use qt_widgets::widget::Widget;use qt_widgets::window::Window;use qt_widgets::radio_button::RadioButton;fn main() { let mut app = Application::new(); let mut window = Window::new(); let mut radio_button = RadioButton::new(); window.set_title(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.resize_2a(400, 300); radio_button.move_2a(50, 50); radio_button.set_text(&amp;qt_core::string::String::from(\"Select me!\")); radio_button.set_parent(&amp;mut window); window.show(); app.exec();}这个示例演示了如何在窗口中添加一个单选框，并设置单选框的文本和位置。创建一个带有滑块的窗口12345678910111213141516use qt_widgets::application::Application;use qt_widgets::widget::Widget;use qt_widgets::window::Window;use qt_widgets::slider::Slider;fn main() { let mut app = Application::new(); let mut window = Window::new(); let mut slider = Slider::new(); window.set_title(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.resize_2a(400, 300); slider.move_2a(50, 50); slider.set_parent(&amp;mut window); window.show(); app.exec();}这个示例演示了如何在窗口中添加一个滑块，并设置滑块的位置。进阶用法创建一个带有表格的窗口123456789101112131415161718192021222324use qt_widgets::application::Application;use qt_widgets::widget::Widget;use qt_widgets::window::Window;use qt_widgets::table_widget::TableWidget;fn main() { let mut app = Application::new(); let mut window = Window::new(); let mut table_widget = TableWidget::new_2a(4, 2, &amp;mut window); window.set_title(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.resize_2a(400, 300); table_widget.move_2a(50, 50); table_widget.set_item(0, 0, &amp;qt_widgets::table_widget_item::TableWidgetItem::new(&amp;qt_core::string::String::from(\"Name\"))); table_widget.set_item(0, 1, &amp;qt_widgets::table_widget_item::TableWidgetItem::new(&amp;qt_core::string::String::from(\"Age\"))); table_widget.set_item(1, 0, &amp;qt_widgets::table_widget_item::TableWidgetItem::new(&amp;qt_core::string::String::from(\"Tom\"))); table_widget.set_item(1, 1, &amp;qt_widgets::table_widget_item::TableWidgetItem::new(&amp;qt_core::string::String::from(\"20\"))); table_widget.set_item(2, 0, &amp;qt_widgets::table_widget_item::TableWidgetItem::new(&amp;qt_core::string::String::from(\"Jerry\"))); table_widget.set_item(2, 1, &amp;qt_widgets::table_widget_item::TableWidgetItem::new(&amp;qt_core::string::String::from(\"30\"))); table_widget.set_item(3, 0, &amp;qt_widgets::table_widget_item::TableWidgetItem::new(&amp;qt_core::string::String::from(\"Bob\"))); table_widget.set_item(3, 1, &amp;qt_widgets::table_widget_item::TableWidgetItem::new(&amp;qt_core::string::String::from(\"25\"))); table_widget.set_parent(&amp;mut window); window.show(); app.exec();}这个示例演示了如何在窗口中添加一个表格，并设置表格的内容。创建一个带有进度条的窗口1234567891011121314151617181920212223242526use qt_widgets::application::Application;use qt_widgets::widget::Widget;use qt_widgets::window::Window;use qt_widgets::progress_bar::ProgressBar;use std::thread;use std::time::Duration;fn main() { let mut app = Application::new(); let mut window = Window::new(); let mut progress_bar = ProgressBar::new(); window.set_title(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.resize_2a(400, 300); progress_bar.move_2a(50, 50); progress_bar.set_range(0, 100); progress_bar.set_value(0); progress_bar.set_parent(&amp;mut window); window.show(); thread::spawn(move || { for i in 0..=100 { progress_bar.set_value(i); thread::sleep(Duration::from_millis(50)); } }); app.exec();}这个示例演示了如何在窗口中添加一个进度条，并设置进度条的范围和初始值。创建一个带有标签页的窗口123456789101112131415161718192021use qt_widgets::application::Application;use qt_widgets::widget::Widget;use qt_widgets::window::Window;use qt_widgets::tab_widget::TabWidget;use qt_widgets::widget::WidgetTrait;fn main() { let mut app = Application::new(); let mut window = Window::new(); let mut tab_widget = TabWidget::new(&amp;mut window); let mut tab1 = Widget::new().into_raw(); let mut tab2 = Widget::new().into_raw(); window.set_title(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.resize_2a(400, 300); tab_widget.move_2a(50, 50); tab_widget.set_parent(&amp;mut window); tab_widget.add_tab_2a(tab1, &amp;qt_core::string::String::from(\"Tab 1\")); tab_widget.add_tab_2a(tab2, &amp;qt_core::string::String::from(\"Tab 2\")); window.show(); app.exec();}这个示例演示了如何在窗口中添加一个标签页，并设置标签页的选项。创建一个带有滚动条的窗口12345678910111213141516171819202122232425262728use qt_widgets::application::Application;use qt_widgets::widget::Widget;use qt_widgets::window::Window;use qt_widgets::scroll_area::ScrollArea;use qt_widgets::label::Label;use qt_gui::pixmap::Pixmap;use qt_gui::image::Image;fn main() { let mut app = Application::new(); let mut window = Window::new(); let mut scroll_area = ScrollArea::new(&amp;mut window); let mut label = Label::new(&amp;mut scroll_area); let mut pixmap = Pixmap::new(); let mut image = Image::new(); window.set_title(&amp;qt_core::string::String::from(\"Hello, Rust-Qt!\")); window.resize_2a(400, 300); pixmap.load_2a(&amp;qt_core::string::String::from(\"image.jpg\"), &amp;qt_core::string::String::from(\"JPG\")); image.set_pixmap(&amp;pixmap); label.set_pixmap(&amp;pixmap); scroll_area.set_widget(&amp;mut label); scroll_area.move_2a(50, 50); scroll_area.set_widget(&amp;mut label); scroll_area.set_widget_resizable(true); scroll_area.set_widget(&amp;mut label); window.show(); app.exec();}这个示例演示了如何在窗口中添加一个滚动条，并设置滚动条的内容。最佳实践 尽可能使用 Rust-Qt 提供的 Rust 风格的 API，而不是直接使用 Qt 的 C++ 风格的 API。 在创建窗口之前，先创建应用程序对象 Application。 使用 set_parent 方法将控件添加到父控件中。 在创建菜单和工具栏时，使用 Action 类来创建菜单项和工具栏项。 在使用 Qt 的图形界面设计器时，将生成的代码放在单独的模块中，以便进行修改和维护。结论Rust-Qt 是一个强大的 Rust 语言的 Qt 绑定库，它允许开发者使用 Rust 语言来创建跨平台的图形界面应用程序。本教程提供了 Rust-Qt 的基础用法和进阶用法的示例，以及最佳实践建议，帮助开发者更加轻松地使用 Rust-Qt 创建高质量的应用程序。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Http客户端reqwest模块实战",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, reqwest",
      "url"         : "./rust/2023/04/13/rust_lang_tutorial_220_http_reqwest.html",
      "date"        : "2023-04-13 00:00:00 +0800",
      "description" : "",
      "content"     : "Reqwest 是一个 Rust 语言的 HTTP 客户端库，它提供了简单易用的 API，可以发送 HTTP 请求并处理响应。Reqwest 支持同步和异步操作，可以用于编写 Web 服务，爬虫，测试等应用。基础用法发送 GET 请求12345678use reqwest::blocking::Client;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::new(); let response = client.get(\"https://httpbin.org/get\").send()?; println!(\"{}\", response.text()?); Ok(())}这个例子中，我们使用 blocking 模块中的 Client 创建了一个 HTTP 客户端，然后使用 get 方法发送了一个 GET 请求，请求了 httpbin.org 的/get 接口，并使用 text 方法获取响应内容。发送 POST 请求12345678910use reqwest::blocking::Client;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::new(); let response = client.post(\"https://httpbin.org/post\") .body(\"hello world\") .send()?; println!(\"{}\", response.text()?); Ok(())}这个例子中，我们使用 post 方法发送了一个 POST 请求，请求了 httpbin.org 的/post 接口，并使用 body 方法设置请求体。发送 JSON 请求123456789101112131415use reqwest::blocking::Client;use serde_json::json;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::new(); let data = json!({ \"name\": \"Alice\", \"age\": 20 }); let response = client.post(\"https://httpbin.org/post\") .json(&amp;data) .send()?; println!(\"{}\", response.text()?); Ok(())}这个例子中，我们使用 json!宏创建了一个 JSON 对象，然后使用 json 方法设置请求体，发送了一个 POST 请求。发送表单请求1234567891011121314use reqwest::blocking::Client;use std::collections::HashMap;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::new(); let mut data = HashMap::new(); data.insert(\"name\", \"Alice\"); data.insert(\"age\", \"20\"); let response = client.post(\"https://httpbin.org/post\") .form(&amp;data) .send()?; println!(\"{}\", response.text()?); Ok(())}这个例子中，我们使用 HashMap 创建了一个表单数据，然后使用 form 方法设置请求体，发送了一个 POST 请求。发送带有 Header 的请求12345678910use reqwest::blocking::Client;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::new(); let response = client.get(\"https://httpbin.org/get\") .header(\"X-My-Header\", \"hello\") .send()?; println!(\"{}\", response.text()?); Ok(())}这个例子中，我们使用 header 方法设置了一个自定义的 Header，发送了一个 GET 请求。发送带有 Cookie 的请求123456789101112use reqwest::blocking::Client;use reqwest::cookie::Cookie;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::new(); let cookie = Cookie::new(\"name\", \"value\"); let response = client.get(\"https://httpbin.org/get\") .cookie(&amp;cookie) .send()?; println!(\"{}\", response.text()?); Ok(())}这个例子中，我们使用 Cookie 创建了一个 Cookie 对象，然后使用 cookie 方法设置了一个 Cookie，发送了一个 GET 请求。发送带有代理的请求1234567891011use reqwest::blocking::Client;use reqwest::Proxy;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::builder() .proxy(Proxy::http(\"http://localhost:8080\")?) .build()?; let response = client.get(\"https://httpbin.org/get\").send()?; println!(\"{}\", response.text()?); Ok(())}这个例子中，我们使用 builder 方法创建了一个 HTTP 客户端，使用 proxy 方法设置了一个代理服务器，发送了一个 GET 请求。下载文件1234567891011use reqwest::blocking::Client;use std::fs::File;use std::io::copy;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::new(); let mut response = client.get(\"https://httpbin.org/image/png\").send()?; let mut file = File::create(\"image.png\")?; copy(&amp;mut response, &amp;mut file)?; Ok(())}这个例子中，我们发送了一个 GET 请求，下载了一个 PNG 图片，并保存到本地文件。进阶用法异步操作123456789use reqwest::Client;#[tokio::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::new(); let response = client.get(\"https://httpbin.org/get\").send().await?; println!(\"{}\", response.text().await?); Ok(())}这个例子中，我们使用 async/await 语法，在异步上下文中发送了一个 GET 请求。自定义 SSL 证书12345678910111213use reqwest::blocking::Client;use std::path::Path;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::builder() .add_root_certificate(reqwest::Certificate::from_pem( &amp;std::fs::read(Path::new(\"cert.pem\"))?, )) .build()?; let response = client.get(\"https://httpbin.org/get\").send()?; println!(\"{}\", response.text()?); Ok(())}这个例子中，我们使用 builder 方法创建了一个 HTTP 客户端，并使用 add_root_certificate 方法设置了一个自定义的 SSL 证书，发送了一个 GET 请求。自定义连接池1234567891011use reqwest::blocking::Client;use std::time::Duration;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::builder() .pool_idle_timeout(Duration::from_secs(30)) .build()?; let response = client.get(\"https://httpbin.org/get\").send()?; println!(\"{}\", response.text()?); Ok(())}这个例子中，我们使用 builder 方法创建了一个 HTTP 客户端，并使用 pool_idle_timeout 方法设置了连接池的空闲超时时间，发送了一个 GET 请求。自定义重试策略123456789101112131415161718use reqwest::blocking::Client;use reqwest::Url;use std::time::Duration;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::builder() .retry(|attempt| { let url = Url::parse(\"https://httpbin.org/get\").unwrap(); if attempt &gt; 3 { return None; } Some(Duration::from_secs(attempt * 2) + url.host_str().unwrap().len() as u64) }) .build()?; let response = client.get(\"https://httpbin.org/get\").send()?; println!(\"{}\", response.text()?); Ok(())}这个例子中，我们使用 builder 方法创建了一个 HTTP 客户端，并使用 retry 方法设置了一个自定义的重试策略，发送了一个 GET 请求。最佳实践使用连接池在高并发场景下，使用连接池可以提高 HTTP 客户端的性能和稳定性。可以使用 builder 方法设置连接池的大小和空闲超时时间。123456789101112use reqwest::blocking::Client;use std::time::Duration;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::builder() .pool_idle_timeout(Duration::from_secs(30)) .pool_max_idle_per_host(10) .build()?; let response = client.get(\"https://httpbin.org/get\").send()?; println!(\"{}\", response.text()?); Ok(())}处理错误在发送 HTTP 请求时，可能会出现各种错误，如网络错误，服务器错误等。可以使用 Result 类型来处理错误，或者使用?运算符简化代码。123456789101112use reqwest::blocking::Client;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::new(); let response = client.get(\"https://httpbin.org/get\").send()?; if response.status().is_success() { println!(\"{}\", response.text()?); } else { println!(\"Error: {}\", response.status()); } Ok(())}使用代理在访问某些网站时，可能需要使用代理服务器。可以使用 builder 方法设置代理服务器的地址和端口。1234567891011use reqwest::blocking::Client;use reqwest::Proxy;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::builder() .proxy(Proxy::http(\"http://localhost:8080\")?) .build()?; let response = client.get(\"https://httpbin.org/get\").send()?; println!(\"{}\", response.text()?); Ok(())}使用 JSON在发送 HTTP 请求时，经常需要使用 JSON 格式的请求体。可以使用 serde_json 库来创建 JSON 对象，并使用 json 方法设置请求体。123456789101112131415use reqwest::blocking::Client;use serde_json::json;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::new(); let data = json!({ \"name\": \"Alice\", \"age\": 20 }); let response = client.post(\"https://httpbin.org/post\") .json(&amp;data) .send()?; println!(\"{}\", response.text()?); Ok(())}使用表单在发送 HTTP 请求时，经常需要使用表单格式的请求体。可以使用 HashMap 来创建表单数据，并使用 form 方法设置请求体。1234567891011121314use reqwest::blocking::Client;use std::collections::HashMap;fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let client = Client::new(); let mut data = HashMap::new(); data.insert(\"name\", \"Alice\"); data.insert(\"age\", \"20\"); let response = client.post(\"https://httpbin.org/post\") .form(&amp;data) .send()?; println!(\"{}\", response.text()?); Ok(())}结论在本教程中，我们介绍了 Rust 语言的 HTTP 客户端库 Reqwest 的基础用法和进阶用法，并提供了最佳实践和示例代码。使用 Reqwest 可以轻松地发送 HTTP 请求，并处理响应，满足各种应用场景的需求。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Memcached实战教程",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Memcached",
      "url"         : "./rust/2023/04/13/rust_lang_tutorial_219_Memcached.html",
      "date"        : "2023-04-13 00:00:00 +0800",
      "description" : "",
      "content"     : "Memcached 是一种高性能、分布式的内存对象缓存系统，可用于加速动态 Web 应用程序。Rust 是一种系统级编程语言，具有内存安全、高性能和并发性等特点。Rust 语言的 Memcached 库提供了 Memcached 协议的实现，使得开发者可以在 Rust 中使用 Memcached。基础用法创建连接使用 Rust 语言 Memcached 需要先创建一个连接。可以使用memcached::Client结构体来创建一个连接：12345use memcached::Client;fn main() { let client = Client::connect(\"localhost:11211\").unwrap();}存储数据使用Client::set方法可以将数据存储到 Memcached 中：123456use memcached::Client;fn main() { let client = Client::connect(\"localhost:11211\").unwrap(); client.set(\"key\", \"value\", 3600).unwrap();}获取数据使用Client::get方法可以从 Memcached 中获取数据：1234567use memcached::Client;fn main() { let client = Client::connect(\"localhost:11211\").unwrap(); let value: Option&lt;String&gt; = client.get(\"key\").unwrap(); println!(\"{:?}\", value);}删除数据使用Client::delete方法可以从 Memcached 中删除数据：123456use memcached::Client;fn main() { let client = Client::connect(\"localhost:11211\").unwrap(); client.delete(\"key\").unwrap();}替换数据使用Client::replace方法可以替换 Memcached 中的数据：1234567use memcached::Client;fn main() { let client = Client::connect(\"localhost:11211\").unwrap(); client.set(\"key\", \"value\", 3600).unwrap(); client.replace(\"key\", \"new value\", 3600).unwrap();}添加数据使用Client::add方法可以向 Memcached 中添加数据：123456use memcached::Client;fn main() { let client = Client::connect(\"localhost:11211\").unwrap(); client.add(\"key\", \"value\", 3600).unwrap();}自增和自减使用Client::increment方法可以将 Memcached 中的值自增：12345678use memcached::Client;fn main() { let client = Client::connect(\"localhost:11211\").unwrap(); client.set(\"counter\", \"1\", 3600).unwrap(); let new_value: Option&lt;u64&gt; = client.increment(\"counter\", 1).unwrap(); println!(\"{:?}\", new_value);}使用Client::decrement方法可以将 Memcached 中的值自减：12345678use memcached::Client;fn main() { let client = Client::connect(\"localhost:11211\").unwrap(); client.set(\"counter\", \"1\", 3600).unwrap(); let new_value: Option&lt;u64&gt; = client.decrement(\"counter\", 1).unwrap(); println!(\"{:?}\", new_value);}进阶用法自定义序列化和反序列化默认情况下，Rust 语言 Memcached 使用 JSON 格式进行序列化和反序列化。但是，开发者可以自定义序列化和反序列化方法。例如，可以使用 bincode 库进行序列化和反序列化：123456789101112131415161718use memcached::{Client, ProtoType};use bincode::{serialize, deserialize};#[derive(Serialize, Deserialize, Debug)]struct User { name: String, age: u8,}fn main() { let client = Client::connect(\"localhost:11211\").unwrap(); client.set_serializer(ProtoType::Bincode, |val| serialize(val).unwrap()); client.set_deserializer(ProtoType::Bincode, |bytes| deserialize(bytes).unwrap()); let user = User { name: \"Alice\".to_string(), age: 20 }; client.set(\"user\", &amp;user, 3600).unwrap(); let user: Option&lt;User&gt; = client.get(\"user\").unwrap(); println!(\"{:?}\", user);}自定义连接池默认情况下，Rust 语言 Memcached 使用单个连接。但是，开发者可以自定义连接池。例如，可以使用 r2d2 库进行连接池管理：12345678910111213use memcached::{Client, Connection};use r2d2::{Pool, PooledConnection};use r2d2_memcached::{MemcachedConnectionManager, MemcachedConnection};fn main() { let manager = MemcachedConnectionManager::new(\"localhost:11211\"); let pool = Pool::builder().max_size(10).build(manager).unwrap(); let client = Client::with_connection(|| { let conn: PooledConnection&lt;MemcachedConnectionManager&gt; = pool.get().unwrap(); Connection::new(conn) }); client.set(\"key\", \"value\", 3600).unwrap();}自定义哈希算法默认情况下，Rust 语言 Memcached 使用一致性哈希算法进行数据分片。但是，开发者可以自定义哈希算法。例如，可以使用 crc32 库进行哈希计算：123456789101112131415161718use memcached::{Client, ProtoType, HashType};use crc::{crc32, Hasher32};fn crc32_hash(key: &amp;[u8]) -&gt; u32 { let mut hasher = crc32::Digest::new(crc32::IEEE); hasher.write(key); hasher.sum32()}fn main() { let client = Client::connect(\"localhost:11211\").unwrap(); client.set_hash_fn(HashType::Custom(crc32_hash)); client.set_serializer(ProtoType::Raw, |val| val.to_vec()); client.set_deserializer(ProtoType::Raw, |bytes| bytes); client.set(b\"key\", b\"value\", 3600).unwrap(); let value: Option&lt;Vec&lt;u8&gt;&gt; = client.get(b\"key\").unwrap(); println!(\"{:?}\", value);}自定义协议默认情况下，Rust 语言 Memcached 使用 Memcached 协议进行通信。但是，开发者可以自定义协议。例如，可以使用 HTTP 协议进行通信：12345678910111213141516171819202122232425use memcached::{Client, Connection, ProtoType};use reqwest::blocking::Client as HttpClient;struct HttpConnection { client: HttpClient,}impl Connection for HttpConnection { fn send(&amp;mut self, request: &amp;[u8]) -&gt; Vec&lt;u8&gt; { let url = \"http://localhost:8080/memcached\".to_string(); let response = self.client.post(&amp;url).body(request.to_vec()).send().unwrap(); response.bytes().unwrap().to_vec() }}fn main() { let client = Client::with_connection(|| HttpConnection { client: HttpClient::new(), }); client.set_serializer(ProtoType::Raw, |val| val.to_vec()); client.set_deserializer(ProtoType::Raw, |bytes| bytes); client.set(b\"key\", b\"value\", 3600).unwrap(); let value: Option&lt;Vec&lt;u8&gt;&gt; = client.get(b\"key\").unwrap(); println!(\"{:?}\", value);}最佳实践 使用连接池在高并发场景下，使用连接池可以提高性能和稳定性。可以使用 r2d2 库进行连接池管理。 使用自定义哈希算法在分布式场景下，使用自定义哈希算法可以提高数据分片的灵活性和可控性。 使用自定义协议在特殊场景下，可以使用自定义协议进行通信，以满足特定的需求。 使用异步 IO在高并发场景下，使用异步 IO 可以提高性能和吞吐量。可以使用 tokio 库进行异步 IO 编程。总结Rust 语言 Memcached 提供了 Memcached 协议的实现，可以方便地在 Rust 中使用 Memcached。本教程介绍了 Rust 语言 Memcached 的基础用法和进阶用法，并提供了最佳实践。开发者可以根据自己的需求选择合适的用法。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Amazon DynamoDB实战教程",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Amazon DynamoDB",
      "url"         : "./rust/2023/04/13/rust_lang_tutorial_218_DynamoDB.html",
      "date"        : "2023-04-13 00:00:00 +0800",
      "description" : "",
      "content"     : ""
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - InfluxDB 2.x实战教程",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, InfluxDB",
      "url"         : "./rust/2023/04/13/rust_lang_tutorial_217_InfluxDB_2_X.html",
      "date"        : "2023-04-13 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种系统编程语言，它具有高性能、内存安全和并发性等特点。InfluxDB 是一个开源的时序数据库，它专门用于存储和查询时间序列数据。InfluxDB 2.x 是 InfluxDB 的新版本，它提供了更好的性能和更好的用户体验。Rust 语言提供了 InfluxDB 2.x 的官方客户端库，可以方便地在 Rust 项目中使用 InfluxDB 2.x。本教程将介绍如何在 Rust 项目中使用 InfluxDB 2.x，包括基础用法和进阶用法。我们将提供示例代码，帮助读者更好地理解和使用 InfluxDB 2.x。 InfluxDB 2.x 版本重写了查询系统, 引入了全新的 Flux 语言查询。相比于 SQL，个人感觉是一种退步。详细的 Flux 语法参考官方文档。基础用法创建数据库在使用 InfluxDB 2.x 之前，需要先创建一个数据库。可以使用 InfluxDB 2.x 的 Web 界面或命令行工具来创建数据库。在本教程中，我们将使用命令行工具来创建数据库。123456789use influxdb2::Client;use influxdb2::models::CreateDatabaseRequest;fn main() { let client = Client::new(\"http://localhost:8086\", \"my-token\"); let db_name = \"my-db\"; let request = CreateDatabaseRequest::new(db_name); client.create_database(request).unwrap();}写入数据写入数据是 InfluxDB 2.x 的主要功能之一。可以使用 InfluxDB 2.x 的客户端库来写入数据。在写入数据之前，需要先创建一个 Bucket。1234567891011121314151617use influxdb2::Client;use influxdb2::models::{CreateBucketRequest, WritePrecision, Point, FieldValue};fn main() { let client = Client::new(\"http://localhost:8086\", \"my-token\"); let bucket_name = \"my-bucket\"; let org_id = \"my-org\"; let request = CreateBucketRequest::new(bucket_name, org_id); client.create_bucket(request).unwrap(); let point = Point::new(\"my-measurement\") .add_field(\"my-field\", FieldValue::Integer(1)) .add_tag(\"my-tag\", \"my-value\") .timestamp(1626464400000, WritePrecision::Ms); let points = vec![point]; client.write_points(bucket_name, points).unwrap();}查询数据查询数据是 InfluxDB 2.x 的另一个主要功能。可以使用 InfluxDB 2.x 的客户端库来查询数据。在查询数据之前，需要先创建一个查询语句。12345678910use influxdb2::Client;use influxdb2::models::{QueryRequest, Query, QueryType};fn main() { let client = Client::new(\"http://localhost:8086\", \"my-token\"); let query = Query::new(\"SELECT * FROM my-measurement\"); let request = QueryRequest::new(query, QueryType::Flux); let result = client.query(request).unwrap(); println!(\"{:?}\", result);}删除数据删除数据是 InfluxDB 2.x 的另一个功能。可以使用 InfluxDB 2.x 的客户端库来删除数据。在删除数据之前，需要先创建一个删除语句。123456789use influxdb2::Client;use influxdb2::models::{DeleteRequest, Predicate};fn main() { let client = Client::new(\"http://localhost:8086\", \"my-token\"); let predicate = Predicate::new(\"my-tag\", \"my-value\"); let request = DeleteRequest::new(\"my-measurement\", predicate); client.delete(request).unwrap();}创建用户在使用 InfluxDB 2.x 之前，需要先创建一个用户。可以使用 InfluxDB 2.x 的 Web 界面或命令行工具来创建用户。在本教程中，我们将使用命令行工具来创建用户。12345678910111213use influxdb2::Client;use influxdb2::models::{CreateUserRequest, UserPermission};fn main() { let client = Client::new(\"http://localhost:8086\", \"my-token\"); let username = \"my-user\"; let password = \"my-password\"; let request = CreateUserRequest::new(username, password); client.create_user(request).unwrap(); let permission = UserPermission::new(\"my-bucket\", \"read\"); client.add_permission(username, permission).unwrap();}创建授权令牌在使用 InfluxDB 2.x 之前，需要先创建一个授权令牌。可以使用 InfluxDB 2.x 的 Web 界面或命令行工具来创建授权令牌。在本教程中，我们将使用命令行工具来创建授权令牌。123456789use influxdb2::Client;use influxdb2::models::{CreateTokenRequest, Permission};fn main() { let client = Client::new(\"http://localhost:8086\", \"my-token\"); let request = CreateTokenRequest::new(vec![Permission::new(\"my-bucket\", \"read\")]); let result = client.create_token(request).unwrap(); println!(\"{:?}\", result);}创建任务在 InfluxDB 2.x 中，任务是一种自动化的操作。可以使用 InfluxDB 2.x 的 Web 界面或命令行工具来创建任务。在本教程中，我们将使用命令行工具来创建任务。12345678910use influxdb2::Client;use influxdb2::models::{CreateTaskRequest, Cron};fn main() { let client = Client::new(\"http://localhost:8086\", \"my-token\"); let query = \"SELECT * FROM my-measurement\"; let cron = Cron::new(\"0 * * * * * *\"); let request = CreateTaskRequest::new(\"my-task\", query, cron); client.create_task(request).unwrap();}进阶用法使用 Flux 查询语言Flux 是 InfluxDB 2.x 的查询语言，它提供了更强大的查询功能。可以使用 InfluxDB 2.x 的客户端库来查询 Flux 语句。12345678910use influxdb2::Client;use influxdb2::models::{QueryRequest, Query, QueryType};fn main() { let client = Client::new(\"http://localhost:8086\", \"my-token\"); let query = Query::new(\"from(bucket:\\\"my-bucket\\\") |&gt; range(start: -1h) |&gt; filter(fn: (r) =&gt; r._measurement == \\\"my-measurement\\\") |&gt; limit(n: 10)\"); let request = QueryRequest::new(query, QueryType::Flux); let result = client.query(request).unwrap(); println!(\"{:?}\", result);}使用 Task API 创建任务可以使用 Task API 来创建任务，这样可以更方便地管理任务。可以使用 InfluxDB 2.x 的客户端库来创建任务。12345678910111213use influxdb2::Client;use influxdb2::models::{CreateTaskRequest, Cron, TaskStatus};fn main() { let client = Client::new(\"http://localhost:8086\", \"my-token\"); let query = \"SELECT * FROM my-measurement\"; let cron = Cron::new(\"0 * * * * * *\"); let request = CreateTaskRequest::new(\"my-task\", query, cron); client.create_task(request).unwrap(); let status = TaskStatus::Inactive; client.update_task_status(\"my-task\", status).unwrap();}使用 Write API 批量写入数据可以使用 Write API 来批量写入数据，这样可以提高写入数据的效率。可以使用 InfluxDB 2.x 的客户端库来批量写入数据。123456789101112131415161718use influxdb2::Client;use influxdb2::models::{WriteRequest, WritePrecision, Point, FieldValue};fn main() { let client = Client::new(\"http://localhost:8086\", \"my-token\"); let bucket_name = \"my-bucket\"; let point1 = Point::new(\"my-measurement\") .add_field(\"my-field\", FieldValue::Integer(1)) .add_tag(\"my-tag\", \"my-value\") .timestamp(1626464400000, WritePrecision::Ms); let point2 = Point::new(\"my-measurement\") .add_field(\"my-field\", FieldValue::Integer(2)) .add_tag(\"my-tag\", \"my-value\") .timestamp(1626464401000, WritePrecision::Ms); let points = vec![point1, point2]; let request = WriteRequest::new(points); client.write(request).unwrap();}使用 Query API 查询数据可以使用 Query API 来查询数据，这样可以更方便地查询数据。可以使用 InfluxDB 2.x 的客户端库来查询数据。12345678910use influxdb2::Client;use influxdb2::models::{QueryRequest, Query, QueryType};fn main() { let client = Client::new(\"http://localhost:8086\", \"my-token\"); let query = Query::new(\"from(bucket:\\\"my-bucket\\\") |&gt; range(start: -1h) |&gt; filter(fn: (r) =&gt; r._measurement == \\\"my-measurement\\\") |&gt; limit(n: 10)\"); let request = QueryRequest::new(query, QueryType::Flux); let result = client.query(request).unwrap(); println!(\"{:?}\", result);}最佳实践使用环境变量存储认证信息在实际应用中，通常不会将认证信息硬编码到代码中。可以使用环境变量来存储认证信息，这样可以更安全地管理认证信息。12345678910111213use influxdb2::Client;use influxdb2::models::CreateDatabaseRequest;use std::env;fn main() { let url = env::var(\"INFLUXDB_URL\").unwrap(); let token = env::var(\"INFLUXDB_TOKEN\").unwrap(); let client = Client::new(&amp;url, &amp;token); let db_name = \"my-db\"; let request = CreateDatabaseRequest::new(db_name); client.create_database(request).unwrap();}使用 Rust 的异步编程模型在实际应用中，通常需要处理大量的数据。可以使用 Rust 的异步编程模型来提高数据处理的效率。123456789101112131415161718192021222324252627use influxdb2::Client;use influxdb2::models::{WriteRequest, WritePrecision, Point, FieldValue};use futures::executor::block_on;async fn write_data(client: &amp;Client) { let bucket_name = \"my-bucket\"; let point1 = Point::new(\"my-measurement\") .add_field(\"my-field\", FieldValue::Integer(1)) .add_tag(\"my-tag\", \"my-value\") .timestamp(1626464400000, WritePrecision::Ms); let point2 = Point::new(\"my-measurement\") .add_field(\"my-field\", FieldValue::Integer(2)) .add_tag(\"my-tag\", \"my-value\") .timestamp(1626464401000, WritePrecision::Ms); let points = vec![point1, point2]; let request = WriteRequest::new(points); client.write(request).await.unwrap();}fn main() { let url = \"http://localhost:8086\"; let token = \"my-token\"; let client = Client::new(url, token); let future = write_data(&amp;client); block_on(future);}使用连接池提高效率在实际应用中，通常需要处理大量的请求。可以使用连接池来提高请求处理的效率。12345678910111213141516use influxdb2::Client;use influxdb2::models::CreateDatabaseRequest;use r2d2::Pool;use r2d2_influxdb2::InfluxDB2ConnectionManager;fn main() { let url = \"http://localhost:8086\"; let token = \"my-token\"; let manager = InfluxDB2ConnectionManager::new(url, token); let pool = Pool::builder().max_size(10).build(manager).unwrap(); let client = Client::new(pool); let db_name = \"my-db\"; let request = CreateDatabaseRequest::new(db_name); client.create_database(request).unwrap();}结论本教程介绍了如何在 Rust 项目中使用 InfluxDB 2.x，包括基础用法和进阶用法。我们提供了示例代码，帮助读者更好地理解和使用 InfluxDB 2.x。最后，我们提供了一些最佳实践，帮助读者更好地使用 InfluxDB 2.x。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - InfluxDB 1.x实战教程",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, InfluxDB",
      "url"         : "./rust/2023/04/13/rust_lang_tutorial_216_InfluxDB_1_X.html",
      "date"        : "2023-04-13 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种系统级编程语言，具有高性能和内存安全性。InfluxDB 是一个开源的时间序列数据库，用于存储、查询和可视化大规模数据集。Rust 语言可以与 InfluxDB 集成，提供高效的数据处理和存储能力。本教程将介绍 Rust 语言如何与 InfluxDB 集成，包括基础用法和进阶用法和完整的示例代码。基础用法安装 InfluxDB Rust 客户端首先，我们需要安装 InfluxDB Rust 客户端。可以在 Cargo.toml 文件中添加以下依赖项：12[dependencies]influxdb = \"0.14.0\"连接到 InfluxDB我们需要创建一个 InfluxDB 连接。可以使用以下代码创建一个连接：12345use influxdb::{Client, Query};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\");}这将创建一个名为“my_database”的数据库连接。插入数据可以使用以下代码将数据插入到 InfluxDB 中：1234567891011use influxdb::{Client, Query};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let query = Query::write_query(\"my_measurement\") .add_field(\"value\", 42) .build(); let _ = client.query(&amp;query);}这将在名为“my_measurement”的测量中插入一个名为“value”的字段，该字段的值为 42。查询数据可以使用以下代码从 InfluxDB 中查询数据：12345678910111213use influxdb::{Client, Query};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let query = Query::raw_read_query(\"SELECT * FROM my_measurement\"); let result = client.query(&amp;query); for row in result.unwrap().rows { println!(\"{:?}\", row); }}这将从名为“my_measurement”的测量中查询所有字段，并打印结果。删除数据可以使用以下代码从 InfluxDB 中删除数据：123456789use influxdb::{Client, Query};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let query = Query::raw_query(\"DELETE FROM my_measurement WHERE time &gt; now() - 1h\"); let _ = client.query(&amp;query);}这将从名为“my_measurement”的测量中删除 1 小时前的所有数据。创建数据库可以使用以下代码创建一个新的 InfluxDB 数据库：123456789use influxdb::{Client, Query};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let query = Query::raw_query(\"CREATE DATABASE my_new_database\"); let _ = client.query(&amp;query);}这将创建一个名为“my_new_database”的新数据库。删除数据库可以使用以下代码删除一个 InfluxDB 数据库：123456789use influxdb::{Client, Query};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let query = Query::raw_query(\"DROP DATABASE my_database\"); let _ = client.query(&amp;query);}这将删除名为“my_database”的数据库。创建测量可以使用以下代码创建一个新的 InfluxDB 测量：123456789use influxdb::{Client, Query};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let query = Query::raw_query(\"CREATE MEASUREMENT my_new_measurement\"); let _ = client.query(&amp;query);}这将创建一个名为“my_new_measurement”的新测量。删除测量可以使用以下代码删除一个 InfluxDB 测量：123456789use influxdb::{Client, Query};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let query = Query::raw_query(\"DROP MEASUREMENT my_measurement\"); let _ = client.query(&amp;query);}这将删除名为“my_measurement”的测量。进阶用法批量插入数据如果需要插入大量数据，可以使用以下代码批量插入数据：1234567891011121314151617181920use influxdb::{Client, Query, Timestamp};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let mut batch = Vec::new(); for i in 0..1000 { let point = Point::new(\"my_measurement\") .add_field(\"value\", i) .add_timestamp(Timestamp::Hours(i)) .to_owned(); batch.push(point); } let query = Query::write_query(&amp;batch).build(); let _ = client.query(&amp;query);}这将在名为“my_measurement”的测量中插入 1000 个数据点。使用标签可以使用标签来组织数据。以下代码演示如何在插入数据时使用标签：12345678910111213141516use influxdb::{Client, Point, Query, Timestamp};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let point = Point::new(\"my_measurement\") .add_field(\"value\", 42) .add_tag(\"region\", \"us-west\") .add_tag(\"host\", \"server1\") .add_timestamp(Timestamp::Now) .to_owned(); let query = Query::write_query(&amp;[point]).build(); let _ = client.query(&amp;query);}这将在名为“my_measurement”的测量中插入一个名为“value”的字段，以及两个标签“region”和“host”。使用时间戳可以使用不同的时间戳格式来插入数据。以下代码演示如何在插入数据时使用 Unix 时间戳：1234567891011121314use influxdb::{Client, Point, Query, Timestamp};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let point = Point::new(\"my_measurement\") .add_field(\"value\", 42) .add_timestamp(Timestamp::Seconds(1234567890)) .to_owned(); let query = Query::write_query(&amp;[point]).build(); let _ = client.query(&amp;query);}这将在名为“my_measurement”的测量中插入一个名为“value”的字段，并使用 Unix 时间戳 1234567890。使用持续时间可以使用持续时间来查询数据。以下代码演示如何查询最近 1 小时的数据：12345678910111213use influxdb::{Client, Query};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let query = Query::raw_read_query(\"SELECT * FROM my_measurement WHERE time &gt; now() - 1h\"); let result = client.query(&amp;query); for row in result.unwrap().rows { println!(\"{:?}\", row); }}这将从名为“my_measurement”的测量中查询最近 1 小时的所有数据。使用聚合函数可以使用聚合函数来查询数据。以下代码演示如何查询最近 1 小时的平均值：12345678910111213use influxdb::{Client, Query};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let query = Query::raw_read_query(\"SELECT MEAN(value) FROM my_measurement WHERE time &gt; now() - 1h\"); let result = client.query(&amp;query); for row in result.unwrap().rows { println!(\"{:?}\", row); }}这将从名为“my_measurement”的测量中查询最近 1 小时的平均值。使用限制可以使用限制来查询数据。以下代码演示如何查询最近 10 条数据：12345678910111213use influxdb::{Client, Query};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let query = Query::raw_read_query(\"SELECT * FROM my_measurement LIMIT 10\"); let result = client.query(&amp;query); for row in result.unwrap().rows { println!(\"{:?}\", row); }}这将从名为“my_measurement”的测量中查询最近 10 条数据。使用排序可以使用排序来查询数据。以下代码演示如何查询最近 1 小时的数据，并按时间戳排序：12345678910111213use influxdb::{Client, Query};fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let query = Query::raw_read_query(\"SELECT * FROM my_measurement WHERE time &gt; now() - 1h ORDER BY time\"); let result = client.query(&amp;query); for row in result.unwrap().rows { println!(\"{:?}\", row); }}这将从名为“my_measurement”的测量中查询最近 1 小时的所有数据，并按时间戳排序。最佳实践使用连接池为了提高性能，建议使用连接池来管理 InfluxDB 连接。以下代码演示如何使用连接池：123456789101112131415161718192021use influxdb::{Client, Query, Timestamp};use r2d2::{Pool, PooledConnection};use r2d2_influxdb::{ConnectionManager, Error};fn main() -&gt; Result&lt;(), Error&gt; { let manager = ConnectionManager::new(\"http://localhost:8086\", \"my_database\"); let pool = Pool::builder().max_size(10).build(manager)?; let client = Client::new_with_pool(pool); let point = Point::new(\"my_measurement\") .add_field(\"value\", 42) .add_timestamp(Timestamp::Now) .to_owned(); let query = Query::write_query(&amp;[point]).build(); let conn: PooledConnection&lt;ConnectionManager&gt; = client.get_conn()?; conn.query(&amp;query)?; Ok(())}这将创建一个连接池，最大连接数为 10，并使用连接池来管理 InfluxDB 连接。使用线程池为了提高并发性能，建议使用线程池来处理数据插入和查询。以下代码演示如何使用线程池：12345678910111213141516171819202122use influxdb::{Client, Point, Query, Timestamp};use std::sync::Arc;use rayon::prelude::*;fn main() { let client = Arc::new(Client::new(\"http://localhost:8086\", \"my_database\")); let points: Vec&lt;Point&gt; = (0..1000) .into_par_iter() .map(|i| { Point::new(\"my_measurement\") .add_field(\"value\", i) .add_timestamp(Timestamp::Hours(i)) .to_owned() }) .collect(); points.into_par_iter().for_each(|point| { let query = Query::write_query(&amp;[point]).build(); let _ = client.query(&amp;query); });}这将创建一个线程池，并使用线程池来处理 1000 个数据点的插入。使用缓存为了提高查询性能，建议使用缓存来缓存查询结果。以下代码演示如何使用缓存：123456789101112131415161718192021use influxdb::{Client, Query};use lru_cache::LruCache;fn main() { let client = Client::new(\"http://localhost:8086\", \"my_database\"); let mut cache = LruCache::new(100); let query = Query::raw_read_query(\"SELECT * FROM my_measurement WHERE time &gt; now() - 1h\"); let result = if let Some(result) = cache.get(&amp;query.to_string()) { result } else { let result = client.query(&amp;query).unwrap(); cache.put(query.to_string(), result.clone()); &amp;result }; for row in result.rows { println!(\"{:?}\", row); }}这将创建一个 LRU 缓存，最大容量为 100，并使用缓存来缓存查询结果。结论本教程介绍了如何在 Rust 语言中使用 InfluxDB，包括基础用法和进阶用法以及最佳实践和示例代码。希望这个教程对您有所帮助，让您更好地使用 Rust 语言和 InfluxDB。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - PostgreSQL实战教程",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, PostgreSQL",
      "url"         : "./rust/2023/04/13/rust_lang_tutorial_215_PostgreSQL.html",
      "date"        : "2023-04-13 00:00:00 +0800",
      "description" : "",
      "content"     : "PostgreSQL是一种开放源代码的对象-关系数据库管理系统(ORDBMS)，它强调在复杂应用程序中保持数据完整性和完整性。它可以在多个平台上运行，包括Linux，Unix，Windows和Mac OS X。同时，它支持许多流行的编程语言，如C，C++，Java，Python，Ruby和Rust。Rust是一种新兴的系统级编程语言。它的设计目标是提供更好的内存安全，同时保持高效性和可靠性。Rust与PostgreSQL的结合，是一个强大的数据处理工具，它可以帮助开发人员开发高性能的应用程序，同时提供数据存储方案。本教程将介绍如何使用Rust语言进行PostgreSQL开发。我们将深入了解PostgreSQL在Rust中的集成，并提供基础和进阶的示例。基础用法创建一个数据库，以便我们在接下来的教程中使用它。可以使用以下命令创建一个名为“mydb”的数据库：1CREATE DATABASE mydb;连接数据库在Rust中连接到PostgreSQL数据库的基本语法如下：1234567use postgres::{Client, NoTls};fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let mut client = Client::connect(\"postgresql://username:password@localhost/mydb\", NoTls)?; // ... Ok(())}其中，“username”和“password”是数据库登录凭据，“localhost”是数据库服务器地址，“mydb”是要连接的数据库名称。插入数据我们可以使用以下语法将数据插入PostgreSQL数据库中：123456789use postgres::{Client, NoTls};fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let mut client = Client::connect(\"postgresql://username:password@localhost/mydb\", NoTls)?; let query = client.query(\"INSERT INTO users (name, email) VALUES ($1, $2)\", &amp;[&amp;\"John\", &amp;\"john@example.com\"],)?; println!(\"{:?}\", query); Ok(())}这将向名为“users”的表中插入一行数据，包括两个字段：“name”和“email”。查询数据我们可以使用以下语法查询数据：12345678910111213use postgres::{Client, NoTls};fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let mut client = Client::connect(\"postgresql://username:password@localhost/mydb\", NoTls)?; let rows = client.query(\"SELECT * FROM users\", &amp;[])?; for row in &amp;rows { let name: String = row.get(0); let email: String = row.get(1); println!(\"{} {}\", name, email); } Ok(())}这将从名为“users”的表中检索所有行，并显示每一行数据的“name”和“email”字段。更新数据我们可以使用以下语法更新数据：123456789use postgres::{Client, NoTls};fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let mut client = Client::connect(\"postgresql://username:password@localhost/mydb\", NoTls)?; let query = client.query(\"UPDATE users SET email = $1 WHERE name = $2\", &amp;[&amp;\"john@newemail.com\", &amp;\"John\"],)?; println!(\"{:?}\", query); Ok(())}这将更新名为“users”的表中，名为“John”的行的“email”字段。删除数据我们可以使用以下语法删除数据：123456789use postgres::{Client, NoTls};fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let mut client = Client::connect(\"postgresql://username:password@localhost/mydb\", NoTls)?; let query = client.query(\"DELETE FROM users WHERE name = $1\", &amp;[&amp;\"John\"],)?; println!(\"{:?}\", query); Ok(())}这将删除名为“users”的表中名为“John”的行。执行事务我们可以使用以下语法执行事务：1234567891011121314use postgres::{Client, NoTls};fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let mut client = Client::connect(\"postgresql://username:password@localhost/mydb\", NoTls)?; let mut transaction = client.transaction()?; let query1 = transaction.query(\"INSERT INTO users (name, email) VALUES ($1, $2)\", &amp;[&amp;\"John\", &amp;\"john@example.com\"],)?; let query2 = transaction.query(\"INSERT INTO users (name, email) VALUES ($1, $2)\", &amp;[&amp;\"Jane\", &amp;\"jane@example.com\"],)?; println!(\"query1: {:?}\", query1); println!(\"query2: {:?}\", query2); transaction.commit()?; Ok(())}这将在名为“users”的表中插入两行数据，它们都包含字段：“name”和“email”。如果两个查询都正常完成，则它将提交事务。执行复杂查询我们可以使用以下语法执行复杂查询：1234567891011121314151617use postgres::{Client, NoTls};fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let mut client = Client::connect(\"postgresql://username:password@localhost/mydb\", NoTls)?; let rows = client.query( \"SELECT u.name, u.email, p.title FROM users u INNER JOIN posts p ON u.id = p.user_id WHERE u.name = $1\", &amp;[&amp;\"John\"], )?; for row in &amp;rows { let name: String = row.get(0); let email: String = row.get(1); let title: String = row.get(2); println!(\"{} {} {}\", name, email, title); } Ok(())}这将从“users”表和“posts”表中检索数据，包括符合条件的“name”、“email”和“title”。使用连接池连接池可以提高数据库连接的使用效率。我们可以使用以下语法设置连接池：1234567891011121314151617use postgres::{Client, NoTls};use r2d2::Pool;use r2d2_postgres::PostgresConnectionManager;fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let manager = PostgresConnectionManager::new(\"postgresql://username:password@localhost/mydb\", NoTls); let pool = Pool::builder().build(manager)?; let conn = pool.get()?; let rows = conn.query(\"SELECT * FROM users\", &amp;[])?; for row in &amp;rows { let name: String = row.get(0); let email: String = row.get(1); println!(\"{} {}\", name, email); } Ok(())}在这个例子中，我们创建一个连接池，并使用它从数据库中检索数据。进阶用法使用参数化查询语句参数化查询语句可以有效地防止SQL注入攻击。我们可以使用以下语法执行参数化查询：1234567891011121314use postgres::{Client, NoTls};fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let mut client = Client::connect(\"postgresql://username:password@localhost/mydb\", NoTls)?; let rows = client.query(\"SELECT * FROM users WHERE age &gt; $1 AND age &lt; $2\", &amp;[&amp;18, &amp;30])?; for row in &amp;rows { let name: String = row.get(0); let email: String = row.get(1); let age: String = row.get(2); println!(\"{} {} {}\", name, email, age); } Ok(())}在这个例子中，我们使用了两个参数化查询参数：“$1”和“$2”，并将它们分别赋值为18和30。这将检索年龄在18到30之间的所有用户。使用批量插入我们可以使用以下语法批量插入数据：1234567891011121314151617use postgres::{Client, NoTls};fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let mut client = Client::connect(\"postgresql://username:password@localhost/mydb\", NoTls)?; let rows = vec![ (\"john\",\"john@example.com\", 25), (\"jane\", \"jane@example.com\", 30), (\"jack\", \"jack@example.com\", 35), ]; let stmt = client.prepare(\"INSERT INTO users (name, email, age) VALUES ($1, $2, $3)\")?; for row in &amp;rows { client.execute(&amp;stmt, &amp;[&amp;row.0, &amp;row.1, &amp;row.2])?; } Ok(())}这将向名为“users”的表中插入三行数据，每行包括三个字段：“name”、“email”和“age”。使用JSON类型PostgreSQL支持JSON和JSONB类型。我们可以使用以下语法将数据插入JSONB字段中：1234567891011121314151617181920212223242526use postgres::{Client, NoTls};use serde::{Deserialize, Serialize};#[derive(Debug, Serialize, Deserialize)]struct User { name: String, email: String, age: i32,}fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let mut client = Client::connect(\"postgresql://username:password@localhost/mydb\", NoTls)?; let user = User { name: \"john\".to_string(), email: \"john@example.com\".to_string(), age: 25, }; let user_json = serde_json::to_string(&amp;user).unwrap(); client.execute( \"INSERT INTO users (name, email, data) VALUES ($1, $2, $3)\", &amp;[&amp;user.name, &amp;user.email, &amp;json::json!(&amp;user_json)], )?; Ok(())}在这个例子中，我们将用户对象编码为JSON字符串，然后使用JSONB类型将其插入到名为“users”的表中的“data”字段中。使用异步PostgreSQL客户端异步PostgreSQL客户端可以提高数据库操作的效率和性能。我们可以使用以下语法执行异步查询：12345678910111213141516171819202122232425use futures::TryStreamExt;use tokio_postgres::{NoTls, Row};#[tokio::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let (client, connection) = tokio_postgres::connect(\"host=localhost user=username password=password dbname=mydb\", NoTls) .await?; tokio::spawn(async move { if let Err(e) = connection.await { eprintln!(\"connection error: {}\", e); } }); let rows = client .query(\"SELECT * FROM users WHERE age &gt; $1 AND age &lt; $2\", &amp;[&amp;18, &amp;30]) .await?; for row in rows.iter() { let name: String = row.try_get(0)?; let email: String = row.try_get(1)?; let age: i32 = row.try_get(2)?; println!(\"{} {} {}\", name, email, age); } Ok(())}在这个例子中，我们使用异步PostgreSQL客户端查询年龄在18到30之间的所有用户，并使用Tokio运行时实现异步操作。使用异步连接池我们可以使用以下语法设置异步连接池：12345678910111213141516171819202122232425use tokio_postgres::{Config, NoTls};use bb8_postgres::{bb8::Pool, PostgresConnectionManager};#[tokio::main]async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let mut config = Config::new(); config.host(\"localhost\"); config.user(\"username\"); config.password(\"password\"); config.dbname(\"mydb\"); let manager = PostgresConnectionManager::new(config, NoTls); let pool = Pool::builder().max_size(15).build(manager).await?; let conn = pool.get().await?; let rows = conn .query(\"SELECT * FROM users WHERE age &gt; $1 AND age &lt; $2\", &amp;[&amp;18, &amp;30]) .await?; for row in rows.iter() { let name: String = row.try_get(0)?; let email: String = row.try_get(1)?; let age: i32 = row.try_get(2)?; println!(\"{} {} {}\", name, email, age); } Ok(())}在这个例子中，我们使用异步连接池从名为“users”的表中检索年龄在18到30之间的所有用户。使用ORMORM可以简化数据访问和管理。我们可以使用以下语法使用Diesel ORM查询数据：1234567891011121314151617181920212223use diesel::{prelude::*, pg::PgConnection, result::Error};#[derive(Queryable)]struct User { pub id: i32, pub name: String, pub email: String, pub age: i32,}fn main() -&gt; Result&lt;(), Error&gt; { let url = \"postgresql://username:password@localhost/mydb\"; let connection = PgConnection::establish(&amp;url).unwrap(); let results = users .filter(age.gt(18).and(age.lt(30))) .load::&lt;User&gt;(&amp;connection) .unwrap(); for user in results { println!(\"{} {} {}\", user.name, user.email, user.age); } Ok(())}在这个例子中，我们使用Diesel ORM查询名为“users”的表中年龄在18到30之间的所有用户。ORM将自动生成与查询相关的代码。最佳实践以下是在Rust中使用PostgreSQL数据库的一些最佳实践： 使用参数化查询语句防止SQL注入攻击。 使用连接池提高数据库连接的使用效率。 使用异步PostgreSQL客户端提高数据库访问的效率和性能。 使用ORM简化数据访问和管理。 将JSON数据存储为JSONB类型。结论PostgreSQL是一种强大的关系型数据库管理系统，可以与Rust编程语言无缝集成。在本教程中，我们介绍了如何在Rust中使用PostgreSQL并提供了基础和进阶的示例，同时讨论了一些最佳实践。使用Rust和PostgreSQL的组合，您可以开发高性能、可靠和安全的应用程序。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 零基础lru缓存模块实战",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, lru, Cache",
      "url"         : "./rust/2023/04/13/rust_lang_tutorial_214_LRU_Cache.html",
      "date"        : "2023-04-13 00:00:00 +0800",
      "description" : "",
      "content"     : "LRU（Least Recently Used）是一种缓存替换算法，它的核心思想是当缓存满时，替换最近最少使用的数据。在实际应用中，LRU算法被广泛应用于缓存、页面置换等领域。Rust语言提供了一个lru模块，可以方便地实现LRU缓存。基础用法Cargo.toml引入lru模块1lru = \"0.10.0\"创建一个LRU缓存123456789use lru::LruCache;fn main() { let mut cache = LruCache::new(2); cache.put(\"key1\", \"value1\"); cache.put(\"key2\", \"value2\"); assert_eq!(cache.get(&amp;\"key1\"), Some(&amp;\"value1\")); assert_eq!(cache.get(&amp;\"key2\"), Some(&amp;\"value2\"));}在这个示例中，我们创建了一个容量为2的LRU缓存，并添加了两个键值对。put方法可以添加键值对，get方法可以获取键对应的值。获取不存在的键1234567use lru::LruCache;fn main() { let mut cache = LruCache::new(2); cache.put(\"key1\", \"value1\"); assert_eq!(cache.get(&amp;\"key2\"), None);}在这个示例中，我们尝试获取一个不存在的键，返回值为None。更新缓存123456789use lru::LruCache;fn main() { let mut cache = LruCache::new(2); cache.put(\"key1\", \"value1\"); cache.put(\"key2\", \"value2\"); cache.put(\"key1\", \"new_value\"); assert_eq!(cache.get(&amp;\"key1\"), Some(&amp;\"new_value\"));}在这个示例中，我们先添加了key1和key2两个键值对，然后更新了key1对应的值。删除键值对123456789use lru::LruCache;fn main() { let mut cache = LruCache::new(2); cache.put(\"key1\", \"value1\"); cache.put(\"key2\", \"value2\"); cache.pop(&amp;\"key1\"); assert_eq!(cache.get(&amp;\"key1\"), None);}在这个示例中，我们先添加了key1和key2两个键值对，然后删除了key1对应的键值对。获取缓存容量123456use lru::LruCache;fn main() { let mut cache = LruCache::new(2); assert_eq!(cache.capacity(), 2);}在这个示例中，我们获取了LRU缓存的容量。获取缓存大小1234567use lru::LruCache;fn main() { let mut cache = LruCache::new(2); cache.put(\"key1\", \"value1\"); assert_eq!(cache.len(), 1);}在这个示例中，我们获取了LRU缓存的大小。清空缓存12345678use lru::LruCache;fn main() { let mut cache = LruCache::new(2); cache.put(\"key1\", \"value1\"); cache.clear(); assert_eq!(cache.len(), 0);}在这个示例中，我们清空了LRU缓存。遍历缓存12345678910use lru::LruCache;fn main() { let mut cache = LruCache::new(2); cache.put(\"key1\", \"value1\"); cache.put(\"key2\", \"value2\"); for (key, value) in cache.iter() { println!(\"{}: {}\", key, value); }}在这个示例中，我们遍历了LRU缓存中的所有键值对。进阶用法自定义缓存替换策略123456789use lru::{LruCache, DefaultCachePolicy};fn main() { let mut cache = LruCache::with_policy(DefaultCachePolicy::new().max_capacity(2)); cache.put(\"key1\", \"value1\"); cache.put(\"key2\", \"value2\"); cache.put(\"key3\", \"value3\"); assert_eq!(cache.get(&amp;\"key1\"), None);}在这个示例中，我们使用了DefaultCachePolicy自定义了LRU缓存的替换策略，将缓存容量设置为2。当缓存满时，会替换最近最少使用的数据。在这个示例中，我们添加了三个键值对，当缓存满时，key1对应的键值对被替换。自定义缓存等效性判断1234567891011121314151617use lru::{LruCache, DefaultCachePolicy};#[derive(PartialEq, Eq, Hash)]struct CustomKey { key1: String, key2: String,}fn main() { let mut cache = LruCache::with_policy(DefaultCachePolicy::new().max_capacity(2)); let key1 = CustomKey { key1: \"123\".to_string(), key2: \"456\".to_string(), }; cache.put(key1.clone(), \"value1\"); assert_eq!(cache.get(&amp;key1), Some(&amp;\"value1\"));}在这个示例中，我们自定义了一个CustomKey结构体，并实现了PartialEq、Eq和Hash三个trait。然后我们使用CustomKey作为LRU缓存的键，实现了自定义的缓存等效性判断。自定义缓存值类型12345678910111213141516use lru::{LruCache, DefaultCachePolicy};struct CustomValue { value1: String, value2: String,}fn main() { let mut cache = LruCache::with_policy(DefaultCachePolicy::new().max_capacity(2)); let value1 = CustomValue { value1: \"123\".to_string(), value2: \"456\".to_string(), }; cache.put(\"key1\", value1.clone()); assert_eq!(cache.get(&amp;\"key1\"), Some(&amp;value1));}在这个示例中，我们自定义了一个CustomValue结构体，并使用它作为LRU缓存的值类型。使用LRU缓存实现Fibonacci数列123456789101112131415161718192021use lru::{LruCache, DefaultCachePolicy};fn fibonacci(n: u32, cache: &amp;mut LruCache&lt;u32, u32&gt;) -&gt; u32 { if let Some(&amp;result) = cache.get(&amp;n) { return result; } let result = if n == 0 || n == 1 { n } else { fibonacci(n - 1, cache) + fibonacci(n - 2, cache) }; cache.put(n, result); result}fn main() { let mut cache = LruCache::with_policy(DefaultCachePolicy::new().max_capacity(10)); for i in 0..20 { println!(\"fibonacci({}) = {}\", i, fibonacci(i, &amp;mut cache)); }}在这个示例中，我们使用LRU缓存实现了Fibonacci数列的计算。在计算Fibonacci数列时，我们使用LRU缓存缓存已经计算过的结果，避免重复计算。最佳实践 避免频繁的缓存替换当LRU缓存满时，会替换最近最少使用的数据。如果缓存替换过于频繁，会导致缓存的效率降低。因此，在使用LRU缓存时，应该根据实际情况合理设置缓存容量，避免频繁的缓存替换。 合理选择缓存键和值类型LRU缓存的键和值类型可以是任意类型，但是为了提高缓存的效率，应该选择合适的类型。在选择缓存键和值类型时，应该考虑类型的大小、等效性判断等因素。 使用LRU缓存优化计算密集型任务LRU缓存可以缓存计算结果，避免重复计算，因此可以用于优化计算密集型任务。在使用LRU缓存优化计算密集型任务时，应该根据实际情况合理设置缓存容量，避免频繁的缓存替换。总结LRU缓存是一种常用的缓存替换算法，在实际应用中被广泛使用。Rust语言提供了一个lru模块，可以方便地实现LRU缓存。在使用LRU缓存时，应该根据实际情况合理设置缓存容量，选择合适的缓存键和值类型，避免频繁的缓存替换，以提高缓存的效率。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Prometheus实战教程",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Prometheus",
      "url"         : "./rust/2023/04/13/rust_lang_tutorial_213_Prometheus.html",
      "date"        : "2023-04-13 00:00:00 +0800",
      "description" : "",
      "content"     : "Prometheus是一种开源的监控系统，它由SoundCloud开发并在2012年发布。它旨在收集和记录大量时间序列数据，并提供强大的查询语言和图形化界面。Prometheus使用HTTP协议进行通信，可以与多种编程语言集成，包括Rust语言。Rust是一种系统级编程语言，具有高性能和内存安全性。由于Rust语言的高性能和安全性，越来越多的开发人员开始使用Rust语言来构建高性能的应用程序。由于Prometheus是一种高性能的监控系统，因此使用Rust语言与Prometheus集成是一种非常好的选择。在本教程中，我们将介绍如何使用Rust语言与Prometheus集成。我们将提供基础用法和进阶用法示例，以及最佳实践。基础用法安装Prometheus Rust客户端在使用Rust语言与Prometheus集成之前，您需要安装Prometheus Rust客户端。您可以使用以下命令在Rust项目中添加Prometheus Rust客户端依赖项：12[dependencies]prometheus = \"0.9.0\"创建CounterCounter是一种Prometheus指标类型，用于记录事件发生的次数。以下是如何在Rust中创建Counter的示例：123456use prometheus::{Counter, CounterVec, Opts, Registry};let opts = Opts::new(\"my_counter\", \"My counter help\").namespace(\"my_namespace\");let counter = Counter::with_opts(opts).unwrap();counter.inc();创建GaugeGauge是一种Prometheus指标类型，用于记录当前值。以下是如何在Rust中创建Gauge的示例：123456use prometheus::{Gauge, Opts, Registry};let opts = Opts::new(\"my_gauge\", \"My gauge help\").namespace(\"my_namespace\");let gauge = Gauge::with_opts(opts).unwrap();gauge.set(10.0);创建HistogramHistogram是一种Prometheus指标类型，用于记录事件发生的次数，并将事件分成桶。以下是如何在Rust中创建Histogram的示例：123456use prometheus::{Histogram, HistogramOpts, HistogramVec, Opts, Registry};let opts = HistogramOpts::new(\"my_histogram\", \"My histogram help\").namespace(\"my_namespace\");let histogram = Histogram::with_opts(opts).unwrap();histogram.observe(10.0);创建SummarySummary是一种Prometheus指标类型，用于记录事件发生的次数，并计算事件的总和和平均值。以下是如何在Rust中创建Summary的示例：123456use prometheus::{Opts, Registry, Summary, SummaryOpts};let opts = SummaryOpts::new(\"my_summary\", \"My summary help\").namespace(\"my_namespace\");let summary = Summary::with_opts(opts).unwrap();summary.observe(10.0);注册指标在创建指标之后，您需要将指标注册到Prometheus客户端中。以下是如何在Rust中注册指标的示例：12345678use prometheus::{register, Counter, Opts, Registry};let opts = Opts::new(\"my_counter\", \"My counter help\").namespace(\"my_namespace\");let counter = Counter::with_opts(opts).unwrap();register(Box::new(counter.clone())).unwrap();counter.inc();导出指标在注册指标之后，您需要将指标导出到Prometheus客户端中。以下是如何在Rust中导出指标的示例：12345678910use prometheus::{Encoder, TextEncoder};let encoder = TextEncoder::new();let metric_families = prometheus::gather();let mut buffer = vec![];encoder.encode(&amp;metric_families, &amp;mut buffer).unwrap();let output = String::from_utf8(buffer).unwrap();println!(\"{}\", output);进阶用法自定义Collector除了使用Prometheus Rust客户端提供的指标类型之外，您还可以创建自己的指标类型并将其注册到Prometheus客户端中。以下是如何在Rust中创建自定义Collector的示例：12345678910111213141516171819202122232425262728use prometheus::{Collector, Counter, CounterVec, Desc, Metric, Opts, Registry};struct MyCollector { counter: Counter,}impl MyCollector { fn new() -&gt; MyCollector { let opts = Opts::new(\"my_counter\", \"My counter help\").namespace(\"my_namespace\"); let counter = Counter::with_opts(opts).unwrap(); MyCollector { counter } }}impl Collector for MyCollector { fn desc(&amp;self) -&gt; Vec&lt;&amp;Desc&gt; { vec![self.counter.desc()] } fn collect(&amp;self) -&gt; Vec&lt;Metric&gt; { vec![self.counter.collect()[0].clone()] }}let my_collector = MyCollector::new();let registry = Registry::new();registry.register(Box::new(my_collector)).unwrap();自定义Exporter除了使用Prometheus Rust客户端提供的导出器之外，您还可以创建自己的导出器并将其注册到Prometheus客户端中。以下是如何在Rust中创建自定义Exporter的示例：1234567891011121314151617181920212223use prometheus::{Encoder, TextEncoder};struct MyExporter {}impl MyExporter { fn new() -&gt; MyExporter { MyExporter {} } fn export(&amp;self) -&gt; String { let encoder = TextEncoder::new(); let metric_families = prometheus::gather(); let mut buffer = vec![]; encoder.encode(&amp;metric_families, &amp;mut buffer).unwrap(); String::from_utf8(buffer).unwrap() }}let my_exporter = MyExporter::new();let output = my_exporter.export();println!(\"{}\", output);使用标准命名空间Prometheus使用标准命名空间来标识指标的来源。建议使用标准命名空间来标识您的指标。1234use prometheus::{Counter, Opts, Registry};let opts = Opts::new(\"my_counter\", \"My counter help\").namespace(\"my_namespace\");let counter = Counter::with_opts(opts).unwrap();避免指标名称冲突当使用多个Prometheus客户端时，可能会出现指标名称冲突的情况。为了避免这种情况，请使用唯一的指标名称。1234567891011use prometheus::{Counter, Opts, Registry};let opts = Opts::new(\"my_counter\", \"My counter help\").namespace(\"my_namespace\");let counter = Counter::with_opts(opts).unwrap();register(Box::new(counter.clone())).unwrap();let opts = Opts::new(\"my_counter\", \"My counter help\").namespace(\"my_namespace_2\");let counter_2 = Counter::with_opts(opts).unwrap();register(Box::new(counter_2.clone())).unwrap();使用标签Prometheus使用标签来标识指标的维度。建议使用标签来标识您的指标。123456use prometheus::{Counter, CounterVec, Opts, Registry};let opts = Opts::new(\"my_counter\", \"My counter help\").namespace(\"my_namespace\");let counter = CounterVec::new(opts, &amp;[\"label_name\"]).unwrap();counter.with_label_values(&amp;[\"label_value\"]).inc();使用Histogram当您需要记录事件分布时，请使用Histogram指标类型。123456use prometheus::{Histogram, HistogramOpts, Opts, Registry};let opts = HistogramOpts::new(\"my_histogram\", \"My histogram help\").namespace(\"my_namespace\");let histogram = Histogram::with_opts(opts).unwrap();histogram.observe(10.0);使用Summary当您需要记录事件分布时，请使用Summary指标类型。123456use prometheus::{Opts, Registry, Summary, SummaryOpts};let opts = SummaryOpts::new(\"my_summary\", \"My summary help\").namespace(\"my_namespace\");let summary = Summary::with_opts(opts).unwrap();summary.observe(10.0);总结在本教程中，我们介绍了如何使用Rust语言与Prometheus集成。我们提供了基础用法和进阶用法示例，以及最佳实践。希望这个教程对您有所帮助！"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Hash特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Hash",
      "url"         : "./rust/2023/04/10/rust_lang_tutorial_132_Trait_Hash.html",
      "date"        : "2023-04-10 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust语言是一种系统级编程语言，具有高性能、安全、并发等特点，是近年来备受关注的新兴编程语言。在Rust语言中，Hash是一种常用的数据结构，用于存储键值对。Rust语言提供了一系列的Hash特征，包括Hash trait、HashMap、HashSet等，本教程将详细介绍Rust语言Hash特征的基础用法和进阶用法。基础用法使用Hash trait在Rust语言中，Hash trait是一种通用的哈希算法，用于将任意类型的数据转换为固定长度的哈希值。下面是一个简单的示例，演示如何使用Hash trait计算一个字符串的哈希值：12345678use std::hash::{Hash, Hasher};fn main() { let mut hasher = std::collections::hash_map::DefaultHasher::new(); \"hello world\".hash(&amp;mut hasher); let hash_value = hasher.finish(); println!(\"hash value: {}\", hash_value);}在上面的示例中，我们首先创建了一个DefaultHasher对象，并将字符串”hello world”传递给它的hash方法。hash方法将会调用字符串的hash方法，计算出字符串的哈希值。最后，我们使用finish方法获取哈希值。使用HashMapHashMap是Rust语言中的一个哈希表实现，用于存储键值对。下面是一个简单的示例，演示如何使用HashMap存储一组字符串的长度：123456789use std::collections::HashMap;fn main() { let mut map = HashMap::new(); map.insert(\"hello\", 5); map.insert(\"world\", 5); map.insert(\"rust\", 4); println!(\"{:?}\", map);}在上面的示例中，我们首先创建了一个HashMap对象，并使用insert方法插入了三个键值对。最后，我们使用println打印出了HashMap对象。使用HashSetHashSet是Rust语言中的一个哈希集合实现，用于存储不重复的元素。下面是一个简单的示例，演示如何使用HashSet存储一组字符串：123456789use std::collections::HashSet;fn main() { let mut set = HashSet::new(); set.insert(\"hello\"); set.insert(\"world\"); set.insert(\"rust\"); println!(\"{:?}\", set);}在上面的示例中，我们首先创建了一个HashSet对象，并使用insert方法插入了三个元素。最后，我们使用println打印出了HashSet对象。使用HasherHasher是Rust语言中的一个哈希算法实现，用于将任意类型的数据转换为固定长度的哈希值。下面是一个简单的示例，演示如何使用Hasher计算一个字符串的哈希值：123456789use std::collections::hash_map::DefaultHasher;use std::hash::{Hash, Hasher};fn main() { let mut hasher = DefaultHasher::new(); \"hello world\".hash(&amp;mut hasher); let hash_value = hasher.finish(); println!(\"hash value: {}\", hash_value);}在上面的示例中，我们首先创建了一个DefaultHasher对象，并将字符串”hello world”传递给它的hash方法。hash方法将会调用字符串的hash方法，计算出字符串的哈希值。最后，我们使用finish方法获取哈希值。使用Hasher自定义哈希算法在Rust语言中，我们可以自定义哈希算法，只需要实现Hasher trait即可。下面是一个简单的示例，演示如何使用自定义哈希算法计算一个字符串的哈希值：1234567891011121314151617181920212223use std::collections::hash_map::DefaultHasher;use std::hash::{Hash, Hasher};struct MyHasher(u64);impl Hasher for MyHasher { fn finish(&amp;self) -&gt; u64 { self.0 } fn write(&amp;mut self, bytes: &amp;[u8]) { for byte in bytes { self.0 = self.0.wrapping_mul(31).wrapping_add(*byte as u64); } }}fn main() { let mut hasher = MyHasher(0); \"hello world\".hash(&amp;mut hasher); let hash_value = hasher.finish(); println!(\"hash value: {}\", hash_value);}在上面的示例中，我们首先定义了一个MyHasher结构体，并实现了Hasher trait。在write方法中，我们使用了一个简单的哈希算法，将每个字节乘以31并加上上一个哈希值。最后，我们使用MyHasher对象计算字符串”hello world”的哈希值。使用HashMap自定义哈希算法在Rust语言中，我们可以使用自定义哈希算法来实现HashMap的哈希函数。下面是一个简单的示例，演示如何使用自定义哈希算法实现一个简单的HashMap：12345678910111213141516171819202122232425262728293031323334use std::collections::hash_map::RandomState;use std::hash::{BuildHasher, Hasher};struct MyHasher(u64);impl Hasher for MyHasher { fn finish(&amp;self) -&gt; u64 { self.0 } fn write(&amp;mut self, bytes: &amp;[u8]) { for byte in bytes { self.0 = self.0.wrapping_mul(31).wrapping_add(*byte as u64); } }}struct MyHasherBuilder;impl BuildHasher for MyHasherBuilder { type Hasher = MyHasher; fn build_hasher(&amp;self) -&gt; MyHasher { MyHasher(0) }}fn main() { let mut map = std::collections::HashMap::with_hasher(MyHasherBuilder); map.insert(\"hello\", 5); map.insert(\"world\", 5); map.insert(\"rust\", 4); println!(\"{:?}\", map);}在上面的示例中，我们首先定义了一个MyHasher结构体，并实现了Hasher trait。在write方法中，我们使用了一个简单的哈希算法，将每个字节乘以31并加上上一个哈希值。然后，我们定义了一个MyHasherBuilder结构体，并实现了BuildHasher trait。在build_hasher方法中，我们返回一个MyHasher对象。最后，我们使用with_hasher方法创建了一个使用自定义哈希算法的HashMap对象。使用HashMap自定义键类型在Rust语言中，我们可以使用自定义类型作为HashMap的键类型。下面是一个简单的示例，演示如何使用自定义类型作为HashMap的键类型：12345678910111213141516use std::collections::HashMap;#[derive(PartialEq, Eq, Hash)]struct Person { name: String, age: u32,}fn main() { let mut map = HashMap::new(); let person = Person { name: \"Alice\".to_string(), age: 25 }; map.insert(person, \"Alice\"); let person = Person { name: \"Bob\".to_string(), age: 30 }; map.insert(person, \"Bob\"); println!(\"{:?}\", map);}在上面的示例中，我们首先定义了一个Person结构体，并实现了PartialEq、Eq和Hash trait。然后，我们创建了一个HashMap对象，并使用Person对象作为键插入了两个键值对。最后，我们使用println打印出了HashMap对象。使用HashMap自定义值类型在Rust语言中，我们可以使用自定义类型作为HashMap的值类型。下面是一个简单的示例，演示如何使用自定义类型作为HashMap的值类型：123456789101112131415use std::collections::HashMap;struct Person { name: String, age: u32,}fn main() { let mut map = HashMap::new(); let person = Person { name: \"Alice\".to_string(), age: 25 }; map.insert(\"Alice\", person); let person = Person { name: \"Bob\".to_string(), age: 30 }; map.insert(\"Bob\", person); println!(\"{:?}\", map);}在上面的示例中，我们首先定义了一个Person结构体。然后，我们创建了一个HashMap对象，并使用字符串作为键，Person对象作为值插入了两个键值对。最后，我们使用println打印出了HashMap对象。Hash特征的进阶用法Bloom FilterBloom Filter是一种空间效率高、查询效率快的数据结构，它可以用于判断一个元素是否在一个集合中。Bloom Filter的基本原理是：使用多个Hash函数将一个元素映射到多个位上，如果这些位都为1，则认为这个元素在集合中。Bloom Filter可以容忍一定的误判率，误判率与Hash函数的个数和位数有关。以下是一个使用Bloom Filter判断一个字符串是否在一个集合中的示例代码：1234567891011use bloom_filter::BloomFilter;fn main() { let mut bloom_filter = BloomFilter::new(1000, 0.01); bloom_filter.insert(\"Hello\"); bloom_filter.insert(\"world\"); println!(\"'Hello' in set: {}\", bloom_filter.contains(\"Hello\")); println!(\"'world' in set: {}\", bloom_filter.contains(\"world\")); println!(\"'Rust' in set: {}\", bloom_filter.contains(\"Rust\"));}在这个示例代码中，我们使用了bloom_filter库中的BloomFilter结构体，创建了一个容量为1000，误判率为0.01的Bloom Filter。我们将字符串”Hello”和”world”插入到Bloom Filter中，并判断字符串”Hello”、”world”和”Rust”是否在集合中。输出结果为：'Hello' in set: true'world' in set: true'Rust' in set: false最佳实践 使用std::collections::HashMap和std::collections::HashSet进行存储和检索数据 重写std::hash::Hash特征来实现自定义哈希函数 使用std::hash::Hasher特征来实现自定义哈希函数 当对大量数据进行哈希计算时，使用HashMap和HashSet时，应调整initial_capacity参数以提高性能 尽量使用DefaultHasher，而不是自行实现哈希算法，提高代码的可读性和可维护性总结Hash特征是Rust语言中非常有用的一种特性，能够快速有效地进行数据存储和检索。本教程介绍了Rust语言中Hash特征的基本概念，并提供了四个示例来演示Hash特征的高级用法。通过学习这些示例，我们可以发现，Hash特征对于实际开发过程中，小到存储配置信息、大到存储海量数据，都是十分用得上的。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Sync和Send特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Sync, Send",
      "url"         : "./rust/2023/04/10/rust_lang_tutorial_131_Trait_Sync_Send.html",
      "date"        : "2023-04-10 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust语言是一门安全且并发的系统级语言，其提供了许多可以保证线程安全的特性，如Sync和Send。在Rust语言中，Sync和Send是两个用于线程安全编程的Trait，它们可以指导编译器对代码进行静态分析，确保你的代码是线程安全的。Sync和Send的定义如下： Send：可以安全发送到别的线程。 Sync：可以安全在多个线程中分享访问。在Rust语言中，任何实现了Send或Sync Trait的类型都是线程安全的。基础用法基本类型和Send和Sync Trait基本类型是指那些常常用于数据存储和算术操作的类型。这些类型都实现了Sync和Send Trait。123456789fn main() { let a: u32 = 1; let b: f32 = 3.14; let c: &amp;str = \"Hello\"; assert_eq!(std::mem::size_of::&lt;u32&gt;(), 4); assert_eq!(std::mem::size_of::&lt;f32&gt;(), 4); assert_eq!(std::mem::size_of::&lt;&amp;str&gt;(), 16);}智能指针和Send Trait智能指针，如Box、Rc、Arc等，是非常常见的类型。在多线程环境下，使用Box可以轻松地将一些变量从一个线程传递到另一个线程。1234567use std::thread;fn main() { let hello = Box::new(\"Hello, Rust!\"); let child = thread::spawn(move || println!(\"{}\", hello)); child.join().unwrap();}Rc和Send TraitRc是Rust语言中常见的智能指针类型之一，可以让多个变量共享同一个值。在多线程环境下使用Rc的过程中需要注意一些问题。12345678910use std::rc::Rc;use std::thread;fn main() { let rc_hello = Rc::new(\"Hello, Rust!\"); let child1 = thread::spawn(move || println!(\"{}\", rc_hello)); let child2 = thread::spawn(move || println!(\"{}\", rc_hello)); child1.join().unwrap(); child2.join().unwrap();}Mutex和Send TraitMutex是Rust语言中实现同步操作的一种机制。它允许程序在共享资源上进行安全的并发访问。1234567891011121314151617181920212223use std::sync::{Mutex, Arc};use std::thread;fn main() { let data = Arc::new(Mutex::new(vec![1, 2, 3])); let mut handles = vec![]; for i in 0..2 { let data = data.clone(); let handle = thread::spawn(move || { let mut data = data.lock().unwrap(); data.push(i); }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\"{:?}\", data);}Arc和Send TraitArc是Rust语言中实现多线程共享的另一种机制。它可以让多个线程在同一时刻共享同一个变量。12345678910111213141516171819202122use std::sync::{Arc, Mutex};use std::thread;fn main() { let counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for i in 0..10 { let counter = counter.clone(); let handle = thread::spawn(move || { let mut counter = counter.lock().unwrap(); *counter += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\"{}\", *counter.lock().unwrap());}RwLock和Send TraitRwLock是Rust语言中实现共享可变状态的一种机制。它允许某个线程对共享变量进行读取访问，同时也允许有限的写访问，从而提高程序的并发性能。123456789101112131415161718192021222324use std::sync::{Arc, RwLock};use std::thread;fn main() { let data = Arc::new(RwLock::new(0)); // reader for i in 0..3 { let data = data.clone(); thread::spawn(move || { let data = data.read().unwrap(); println!(\"{}: read: {}\", i, *data); }); } // writer thread::spawn(move || { let mut data = data.write().unwrap(); *data = 1; println!(\"write: {}\", *data); }); thread::sleep_ms(1000);}Atomic Types和Send TraitRust语言中提供了一些原子类型，如AtomicU8、AtomicU16、AtomicU32，它们提供了原子更新和访问的能力。这意味着无论有多少个线程对这些变量进行操作，它们都可以保证线程安全。123456789101112131415161718192021use std::sync::atomic::{AtomicUsize, Ordering};use std::thread;fn main() { let counter = AtomicUsize::new(0); let mut handles = vec![]; for i in 0..10 { let counter = counter.clone(); let handle = thread::spawn(move || { counter.fetch_add(1, Ordering::Relaxed); }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\"{}\", counter.load(Ordering::Relaxed));}线程同步Rust语言中提供了一些机制用于实现线程同步，如Condvar、Once、Barrier、Latch等。12345678910111213141516171819202122use std::sync::{Arc, Barrier};use std::thread;fn main() { let barrier = Arc::new(Barrier::new(3)); let mut handles = vec![]; for _ in 0..3 { let barrier = barrier.clone(); let handle = thread::spawn(move || { println!(\"Before wait: {:?}\", std::thread::current().id()); barrier.wait(); println!(\"After wait: {:?}\", std::thread::current().id()); }); handles.push(handle); } for handle in handles { handle.join().unwrap(); }}进阶用法使用MutexGuard在Rust语言中MutexGuard是实现Mutex同步机制的一个关键类型之一。它可以确保在使用Mutex时不会发生死锁或数据竞争等情况。123456789101112131415161718192021222324use std::sync::{Mutex, Arc};use std::thread;fn main() { let data = Arc::new(Mutex::new(0)); let mut handles = vec![]; for i in 0..10 { let data = data.clone(); let handle = thread::spawn(move || { let mut data = data.lock().unwrap(); *data += 1; println!(\"Thread {} incremented data to {}\", i, *data); }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\"{:?}\", data);}使用Sync和Send ‘static Bounds在Rust语言中使用Sync和Send时，需要确保它们实现了’static约束。这可以确保它们具有一些关键的属性，如生命周期。123456789101112131415use std::sync::{Arc, Mutex};use std::thread;fn main() { let data = Arc::new(Mutex::new(vec![1, 2, 3])); let hello = Arc::new(\"Hello, Rust!\".to_string()); let child = thread::spawn(move || { let data = &amp;*(data.lock().unwrap()); let hello = &amp;*hello; println!(\"{:?}, {:?}\", data, hello); }); child.join().unwrap();}使用Panic安全地终止线程在Rust语言中，线程遇到panic时，会正常终止程序。可以在panic发生后清理它们的资源。12345678910use std::thread;fn main() { let handle = thread::spawn(|| { panic!(\"Hello, Rust!\"); }); let result = handle.join(); println!(\"{:?}\", result);}使用独立线程并发执行计算在Rust语言中使用线程可以在较短的时间内执行复杂的计算。这对于需要在短时间内执行大量计算的应用程序非常有# Rust语言Sync和Send教程简介Rust语言是一门安全且并发的系统级语言，其提供了许多可以保证线程安全的特性，如Sync和Send。在Rust语言中，Sync和Send是两个用于线程安全编程的Trait，它们可以指导编译器对代码进行静态分析，确保你的代码是线程安全的。Sync和Send的定义如下： Send：可以安全发送到别的线程。 Sync：可以安全在多个线程中分享访问。在Rust语言中，任何实现了Send或Sync Trait的类型都是线程安全的。基础用法基本类型和Send和Sync Trait基本类型是指那些常常用于数据存储和算术操作的类型。这些类型都实现了Sync和Send Trait。123456789fn main() { let a: u32 = 1; let b: f32 = 3.14; let c: &amp;str = \"Hello\"; assert_eq!(std::mem::size_of::&lt;u32&gt;(), 4); assert_eq!(std::mem::size_of::&lt;f32&gt;(), 4); assert_eq!(std::mem::size_of::&lt;&amp;str&gt;(), 16);}智能指针和Send Trait智能指针，如Box、Rc、Arc等，是非常常见的类型。在多线程环境下，使用Box可以轻松地将一些变量从一个线程传递到另一个线程。1234567use std::thread;fn main() { let hello = Box::new(\"Hello, Rust!\"); let child = thread::spawn(move || println!(\"{}\", hello)); child.join().unwrap();}Rc和Send TraitRc是Rust语言中常见的智能指针类型之一，可以让多个变量共享同一个值。在多线程环境下使用Rc的过程中需要注意一些问题。12345678910use std::rc::Rc;use std::thread;fn main() { let rc_hello = Rc::new(\"Hello, Rust!\"); let child1 = thread::spawn(move || println!(\"{}\", rc_hello)); let child2 = thread::spawn(move || println!(\"{}\", rc_hello)); child1.join().unwrap(); child2.join().unwrap();}Mutex和Send TraitMutex是Rust语言中实现同步操作的一种机制。它允许程序在共享资源上进行安全的并发访问。1234567891011121314151617181920212223use std::sync::{Mutex, Arc};use std::thread;fn main() { let data = Arc::new(Mutex::new(vec![1, 2, 3])); let mut handles = vec![]; for i in 0..2 { let data = data.clone(); let handle = thread::spawn(move || { let mut data = data.lock().unwrap(); data.push(i); }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\"{:?}\", data);}Arc和Send TraitArc是Rust语言中实现多线程共享的另一种机制。它可以让多个线程在同一时刻共享同一个变量。12345678910111213141516171819202122use std::sync::{Arc, Mutex};use std::thread;fn main() { let counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for i in 0..10 { let counter = counter.clone(); let handle = thread::spawn(move || { let mut counter = counter.lock().unwrap(); *counter += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\"{}\", *counter.lock().unwrap());}RwLock和Send TraitRwLock是Rust语言中实现共享可变状态的一种机制。它允许某个线程对共享变量进行读取访问，同时也允许有限的写访问，从而提高程序的并发性能。123456789101112131415161718192021222324use std::sync::{Arc, RwLock};use std::thread;fn main() { let data = Arc::new(RwLock::new(0)); // reader for i in 0..3 { let data = data.clone(); thread::spawn(move || { let data = data.read().unwrap(); println!(\"{}: read: {}\", i, *data); }); } // writer thread::spawn(move || { let mut data = data.write().unwrap(); *data = 1; println!(\"write: {}\", *data); }); thread::sleep_ms(1000);}Atomic Types和Send TraitRust语言中提供了一些原子类型，如AtomicU8、AtomicU16、AtomicU32，它们提供了原子更新和访问的能力。这意味着无论有多少个线程对这些变量进行操作，它们都可以保证线程安全。123456789101112131415161718192021use std::sync::atomic::{AtomicUsize, Ordering};use std::thread;fn main() { let counter = AtomicUsize::new(0); let mut handles = vec![]; for i in 0..10 { let counter = counter.clone(); let handle = thread::spawn(move || { counter.fetch_add(1, Ordering::Relaxed); }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\"{}\", counter.load(Ordering::Relaxed));}线程同步Rust语言中提供了一些机制用于实现线程同步，如Condvar、Once、Barrier、Latch等。12345678910111213141516171819202122use std::sync::{Arc, Barrier};use std::thread;fn main() { let barrier = Arc::new(Barrier::new(3)); let mut handles = vec![]; for _ in 0..3 { let barrier = barrier.clone(); let handle = thread::spawn(move || { println!(\"Before wait: {:?}\", std::thread::current().id()); barrier.wait(); println!(\"After wait: {:?}\", std::thread::current().id()); }); handles.push(handle); } for handle in handles { handle.join().unwrap(); }}进阶用法使用MutexGuard在Rust语言中MutexGuard是实现Mutex同步机制的一个关键类型之一。它可以确保在使用Mutex时不会发生死锁或数据竞争等情况。123456789101112131415161718192021222324use std::sync::{Mutex, Arc};use std::thread;fn main() { let data = Arc::new(Mutex::new(0)); let mut handles = vec![]; for i in 0..10 { let data = data.clone(); let handle = thread::spawn(move || { let mut data = data.lock().unwrap(); *data += 1; println!(\"Thread {} incremented data to {}\", i, *data); }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\"{:?}\", data);}使用Sync和Send ‘static Bounds在Rust语言中使用Sync和Send时，需要确保它们实现了’static约束。这可以确保它们具有一些关键的属性，如生命周期。123456789101112131415use std::sync::{Arc, Mutex};use std::thread;fn main() { let data = Arc::new(Mutex::new(vec![1, 2, 3])); let hello = Arc::new(\"Hello, Rust!\".to_string()); let child = thread::spawn(move || { let data = &amp;*(data.lock().unwrap()); let hello = &amp;*hello; println!(\"{:?}, {:?}\", data, hello); }); child.join().unwrap();}使用Panic安全地终止线程在Rust语言中，线程遇到panic时，会正常终止程序。可以在panic发生后清理它们的资源。12345678910use std::thread;fn main() { let handle = thread::spawn(|| { panic!(\"Hello, Rust!\"); }); let result = handle.join(); println!(\"{:?}\", result);}使用独立线程并发执行计算在Rust语言中使用线程可以在较短的时间内执行复杂的计算。这对于需要在短时间内执行大量计算的应用程序非常有"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Borrow和BorrowMut特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Borrow, BorrowMut",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_130_Trait_Borrow_BorrowMut.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 语言是一种系统级编程语言，它强调安全、速度和并发性。Rust 的内存管理机制是通过所有权系统实现的，这意味着每个值都有一个所有者，并且只能有一个所有者。当值超出其所有者的范围时，它将被释放。这种机制可以防止许多常见的内存错误，如空指针引用和野指针。然而，有时候我们需要在不拥有值的情况下对其进行操作。Rust 提供了 borrow 和 borrow_mut 两个方法来实现这个目的。这两个方法允许我们借用值的所有权，而不是拥有它。这种方式可以使我们在不破坏所有权系统的前提下，进行一些特定的操作。基础用法BorrowBorrow 方法用于借用一个值的不可变引用。这个方法的语法如下：1fn borrow(&amp;self) -&gt; &amp;T其中，&amp;self表示当前值的引用，&amp;T表示返回的借用值的类型。下面是一个使用 borrow 方法的示例：12345fn main() { let v = vec![1, 2, 3]; let r = v.borrow(); println!(\"{:?}\", r);}这个示例中，我们创建了一个包含三个元素的向量。然后，我们使用 borrow 方法来借用这个向量的不可变引用，并将其绑定到变量 r 上。最后，我们打印出 r 的值。输出结果为[1, 2, 3]。BorrowMutBorrowMut 方法用于借用一个值的可变引用。这个方法的语法如下：1fn borrow_mut(&amp;mut self) -&gt; &amp;mut T其中，&amp;mut self表示当前值的可变引用，&amp;mut T表示返回的借用值的类型。下面是一个使用 borrow_mut 方法的示例：123456fn main() { let mut v = vec![1, 2, 3]; let r = v.borrow_mut(); r.push(4); println!(\"{:?}\", v);}这个示例中，我们创建了一个包含三个元素的向量，并将其绑定到变量 v 上。然后，我们使用 borrow_mut 方法来借用这个向量的可变引用，并将其绑定到变量 r 上。接着，我们使用 r 的 push 方法向向量中添加一个元素。最后，我们打印出 v 的值。输出结果为[1, 2, 3, 4]。借用一个字符串的不可变引用12345fn main() { let s = String::from(\"hello\"); let r = s.borrow(); println!(\"{}\", r);}这个示例中，我们创建了一个包含字符串”hello”的字符串。然后，我们使用 borrow 方法来借用这个字符串的不可变引用，并将其绑定到变量 r 上。最后，我们打印出 r 的值。输出结果为hello。借用一个字符串的可变引用123456fn main() { let mut s = String::from(\"hello\"); let r = s.borrow_mut(); r.push_str(\", world!\"); println!(\"{}\", s);}这个示例中，我们创建了一个包含字符串”hello”的字符串，并将其绑定到变量 s 上。然后，我们使用 borrow_mut 方法来借用这个字符串的可变引用，并将其绑定到变量 r 上。接着，我们使用 r 的 push_str 方法向字符串中添加一个后缀。最后，我们打印出 s 的值。输出结果为hello, world!。借用一个数组的不可变引用12345fn main() { let a = [1, 2, 3]; let r = a.borrow(); println!(\"{:?}\", r);}这个示例中，我们创建了一个包含三个元素的数组。然后，我们使用 borrow 方法来借用这个数组的不可变引用，并将其绑定到变量 r 上。最后，我们打印出 r 的值。输出结果为[1, 2, 3]。借用一个数组的可变引用123456fn main() { let mut a = [1, 2, 3]; let r = a.borrow_mut(); r[1] = 4; println!(\"{:?}\", a);}这个示例中，我们创建了一个包含三个元素的数组，并将其绑定到变量 a 上。然后，我们使用 borrow_mut 方法来借用这个数组的可变引用，并将其绑定到变量 r 上。接着，我们使用 r 来修改数组中的一个元素。最后，我们打印出 a 的值。输出结果为[1, 4, 3]。借用一个结构体的不可变引用12345678910struct Point { x: i32, y: i32,}fn main() { let p = Point { x: 1, y: 2 }; let r = &amp;p; println!(\"{:?}\", r);}这个示例中，我们创建了一个包含 x 和 y 两个字段的结构体 Point，并将其绑定到变量 p 上。然后，我们使用&amp;符号来借用这个结构体的不可变引用，并将其绑定到变量 r 上。最后，我们打印出 r 的值。输出结果为Point { x: 1, y: 2 }。借用一个结构体的可变引用1234567891011struct Point { x: i32, y: i32,}fn main() { let mut p = Point { x: 1, y: 2 }; let r = &amp;mut p; r.x = 3; println!(\"{:?}\", p);}这个示例中，我们创建了一个包含 x 和 y 两个字段的结构体 Point，并将其绑定到变量 p 上。然后，我们使用&amp;mut 符号来借用这个结构体的可变引用，并将其绑定到变量 r 上。接着，我们使用 r 来修改结构体中的一个字段。最后，我们打印出 p 的值。输出结果为Point { x: 3, y: 2 }。进阶用法借用一个值的引用123456fn main() { let v1 = vec![1, 2, 3]; let v2 = vec![4, 5, 6]; let r = &amp;v1; println!(\"{:?}\", r);}这个示例中，我们创建了两个包含三个元素的向量 v1 和 v2。然后，我们使用&amp;符号来借用 v1 的引用，并将其绑定到变量 r 上。最后，我们打印出 r 的值。输出结果为[1, 2, 3]。借用一个值的可变引用的引用1234567fn main() { let mut v1 = vec![1, 2, 3]; let v2 = vec![4, 5, 6]; let r = &amp;mut &amp;mut v1; (*r).push(4); println!(\"{:?}\", v1);}这个示例中，我们创建了两个包含三个元素的向量 v1 和 v2，并将 v1 绑定到变量 v1 上。然后，我们使用&amp;mut 符号来借用 v1 的可变引用的可变引用，并将其绑定到变量 r 上。接着，我们使用*r 来访问 v1，并向其添加一个元素。最后，我们打印出 v1 的值。输出结果为[1, 2, 3, 4]。借用一个值的不可变引用的可变引用1234567fn main() { let v1 = vec![1, 2, 3]; let v2 = vec![4, 5, 6]; let r = &amp;mut &amp;v1; **r = vec![7, 8, 9]; println!(\"{:?}\", v1);}这个示例中，我们创建了两个包含三个元素的向量 v1 和 v2。然后，我们使用&amp;符号来借用 v1 的不可变引用的可变引用，并将其绑定到变量 r 上。接着，我们使用**r 来访问 v1，并将其替换为一个新的向量。最后，我们打印出 v1 的值。输出结果为[7, 8, 9]。借用一个值的可变引用的不可变引用1234567fn main() { let mut v1 = vec![1, 2, 3]; let v2 = vec![4, 5, 6]; let r = &amp;v1.borrow_mut(); r.push(4); println!(\"{:?}\", v1);}这个示例中，我们创建了两个包含三个元素的向量 v1 和 v2，并将 v1 绑定到变量 v1 上。然后，我们使用 borrow_mut 方法来借用 v1 的可变引用，并将其绑定到变量 r 上。接着，我们使用 r 的 push 方法向 v1 中添加一个元素。最后，我们打印出 v1 的值。输出结果为[1, 2, 3, 4]。最佳实践在使用 borrow 和 borrow_mut 方法时，需要注意以下几点： 不要同时借用一个值的可变引用和不可变引用。这会导致编译器错误。 不要在可变引用的生命周期内使用不可变引用。这会导致编译器错误。 不要在不可变引用的生命周期内使用可变引用。这会导致编译器错误。 在使用 borrow 和 borrow_mut 方法时，应该尽量减少借用的范围和时间。这可以提高代码的可读性和可维护性。 下面是一个示例代码，展示了如何使用 borrow 和 borrow_mut 方法来操作一个向量：1234567891011fn main() { let mut v = vec![1, 2, 3]; { let r = v.borrow_mut(); r.push(4); } { let r = v.borrow(); println!(\"{:?}\", r); }}这个示例中，我们创建了一个包含三个元素的向量，并将其绑定到变量 v 上。然后，我们使用 borrow_mut 方法来借用这个向量的可变引用，并将其绑定到变量 r 上。接着，我们使用 r 的 push 方法向向量中添加一个元素。然后，我们使用 borrow 方法来借用这个向量的不可变引用，并将其绑定到变量 r 上。最后，我们打印出 r 的值。输出结果为[1, 2, 3, 4]。总结borrow 和 borrow_mut 方法是 Rust 语言中非常重要的方法，它们允许我们在不拥有值的情况下对其进行操作。这种方式可以使我们在不破坏所有权系统的前提下，进行一些特定的操作。在使用 borrow 和 borrow_mut 方法时，需要注意借用的范围和时间，以及避免出现编译器错误。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 深入理解Read和Write特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Read, Write",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_129_Trait_Read_Write.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种系统级编程语言，它的设计目标是提供安全、并发和高性能的编程体验。Rust 的特点在于其内存安全性和线程安全性，它采用了一些创新性的技术，如所有权系统和生命周期，来解决 C 和 C++中常见的内存安全问题和数据竞争问题。在 Rust 中，读写文件是一项非常常见的任务。本教程将介绍如何在 Rust 中读写文件，包括基础用法和进阶用法。基础用法读取文件内容使用std::fs::File和std::io::Read模块可以读取文件内容。首先，我们需要打开一个文件，然后读取其内容。以下是一个简单的示例：123456789use std::fs::File;use std::io::prelude::*;fn main() { let mut file = File::open(\"file.txt\").expect(\"file not found\"); let mut contents = String::new(); file.read_to_string(&amp;mut contents).expect(\"something went wrong reading the file\"); println!(\"The contents of the file are:\\n{}\", contents);}在这个例子中，我们首先打开了一个名为file.txt的文件，并将其存储在file变量中。接下来，我们创建了一个空字符串contents，并使用read_to_string方法将文件的内容读取到其中。最后，我们打印出了读取到的内容。写入文件内容使用std::fs::File和std::io::Write模块可以写入文件内容。以下是一个简单的示例：1234567use std::fs::File;use std::io::prelude::*;fn main() { let mut file = File::create(\"file.txt\").expect(\"file not found\"); file.write_all(b\"Hello, world!\").expect(\"something went wrong writing the file\");}在这个例子中，我们首先创建了一个名为file.txt的文件，并将其存储在file变量中。接下来，我们使用write_all方法将字符串Hello, world!写入到文件中。逐行读取文件内容使用std::fs::File和std::io::BufRead模块可以逐行读取文件内容。以下是一个简单的示例：12345678910use std::fs::File;use std::io::{BufRead, BufReader};fn main() { let file = File::open(\"file.txt\").expect(\"file not found\"); let reader = BufReader::new(file); for line in reader.lines() { println!(\"{}\", line.expect(\"unable to read line\")); }}在这个例子中，我们首先打开了一个名为file.txt的文件，并将其存储在file变量中。接下来，我们创建了一个BufReader，并使用lines方法逐行读取文件内容。最后，我们打印出了每一行的内容。追加文件内容使用std::fs::OpenOptions和std::io::Write模块可以追加文件内容。以下是一个简单的示例：1234567891011use std::fs::{File, OpenOptions};use std::io::prelude::*;fn main() { let mut file = OpenOptions::new() .write(true) .append(true) .open(\"file.txt\") .expect(\"file not found\"); file.write_all(b\"Hello, world!\").expect(\"something went wrong writing the file\");}在这个例子中，我们首先打开了一个名为file.txt的文件，并将其存储在file变量中。接下来，我们使用OpenOptions创建了一个选项，使得我们可以写入文件并追加内容。最后，我们使用write_all方法将字符串Hello, world!写入到文件中。读取二进制文件内容使用std::fs::File和std::io::Read模块可以读取二进制文件内容。以下是一个简单的示例：123456789use std::fs::File;use std::io::prelude::*;fn main() { let mut file = File::open(\"file.bin\").expect(\"file not found\"); let mut buffer = [0; 5]; file.read_exact(&amp;mut buffer).expect(\"something went wrong reading the file\"); println!(\"{:?}\", buffer);}在这个例子中，我们首先打开了一个名为file.bin的二进制文件，并将其存储在file变量中。接下来，我们创建了一个长度为 5 的空字节数组buffer，并使用read_exact方法将文件的前 5 个字节读取到其中。最后，我们打印出了读取到的字节数组。写入二进制文件内容使用std::fs::File和std::io::Write模块可以写入二进制文件内容。以下是一个简单的示例：1234567use std::fs::File;use std::io::prelude::*;fn main() { let mut file = File::create(\"file.bin\").expect(\"file not found\"); file.write_all(&amp;[0x48, 0x65, 0x6c, 0x6c, 0x6f]).expect(\"something went wrong writing the file\");}在这个例子中，我们首先创建了一个名为file.bin的二进制文件，并将其存储在file变量中。接下来，我们使用write_all方法将字节数组[0x48, 0x65, 0x6c, 0x6c, 0x6f]写入到文件中。读取 CSV 文件内容使用csv和std::fs::File模块可以读取 CSV 文件内容。以下是一个简单的示例：1234567891011121314use std::error::Error;use std::fs::File;use std::io::prelude::*;use csv::ReaderBuilder;fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let file = File::open(\"file.csv\")?; let mut reader = ReaderBuilder::new().has_headers(false).from_reader(file); for record in reader.records() { let record = record?; println!(\"{:?}\", record); } Ok(())}在这个例子中，我们首先打开了一个名为file.csv的 CSV 文件，并将其存储在file变量中。接下来，我们使用ReaderBuilder创建了一个 CSV 读取器，并使用records方法逐行读取文件内容。最后，我们打印出了每一行的内容。写入 CSV 文件内容使用csv和std::fs::File模块可以写入 CSV 文件内容。以下是一个简单的示例：12345678910111213use std::error::Error;use std::fs::File;use std::io::prelude::*;use csv::WriterBuilder;fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let mut file = File::create(\"file.csv\")?; let mut writer = WriterBuilder::new().has_headers(false).from_writer(file); writer.write_record(&amp;[\"1\", \"2\", \"3\"])?; writer.write_record(&amp;[\"4\", \"5\", \"6\"])?; writer.flush()?; Ok(())}在这个例子中，我们首先创建了一个名为file.csv的 CSV 文件，并将其存储在file变量中。接下来，我们使用WriterBuilder创建了一个 CSV 写入器，并使用write_record方法将两行数据写入到文件中。最后，我们使用flush方法将缓冲区中的数据刷新到文件中。进阶用法读取大文件内容当处理大文件时，我们需要使用流式读取器来避免将整个文件读入内存中。以下是一个简单的示例：123456789101112131415use std::fs::File;use std::io::{BufReader, Read};fn main() { let file = File::open(\"file.txt\").expect(\"file not found\"); let mut reader = BufReader::new(file); let mut buffer = [0; 1024]; loop { let bytes_read = reader.read(&amp;mut buffer).expect(\"unable to read file\"); if bytes_read == 0 { break; } println!(\"{:?}\", &amp;buffer[..bytes_read]); }}在这个例子中，我们使用BufReader创建了一个缓冲读取器，并使用read方法逐块读取文件内容。我们使用一个长度为 1024 的字节数组buffer来存储每一块读取到的内容，并在读取完整个文件后打印出它们。写入大文件内容当处理大文件时，我们需要使用流式写入器来避免将整个文件写入内存中。以下是一个简单的示例：123456789101112use std::fs::File;use std::io::{BufWriter, Write};fn main() { let file = File::create(\"file.txt\").expect(\"file not found\"); let mut writer = BufWriter::new(file); let buffer = [0x48, 0x65, 0x6c, 0x6c, 0x6f]; for _ in 0..1000000 { writer.write_all(&amp;buffer).expect(\"something went wrong writing the file\"); } writer.flush().expect(\"something went wrong writing the file\");}在这个例子中，我们使用BufWriter创建了一个缓冲写入器，并使用write_all方法逐块写入文件内容。我们使用一个长度为 5 的字节数组buffer来存储每一块写入的内容，并重复写入 1,000,000 次。最后，我们使用flush方法将缓冲区中的数据刷新到文件中。读取压缩文件内容使用flate2、tar和std::fs::File模块可以读取压缩文件内容。以下是一个简单的示例：123456789101112131415161718use std::error::Error;use std::fs::File;use flate2::read::GzDecoder;use tar::Archive;fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let file = File::open(\"file.tar.gz\")?; let decoder = GzDecoder::new(file)?; let mut archive = Archive::new(decoder); for entry in archive.entries()? { let mut entry = entry?; let path = entry.path()?; let mut contents = String::new(); entry.read_to_string(&amp;mut contents)?; println!(\"{}:\\n{}\", path.display(), contents); } Ok(())}在这个例子中，我们首先打开了一个名为file.tar.gz的压缩文件，并将其存储在file变量中。接下来，我们使用GzDecoder创建了一个 Gzip 解码器，并使用Archive创建了一个 tar 归档器。我们使用entries方法逐个读取归档文件中的条目，并使用read_to_string方法读取每个条目的内容。最后，我们打印出了每个条目的路径和内容。写入压缩文件内容使用flate2、tar和std::fs::File模块可以写入压缩文件内容。以下是一个简单的示例：1234567891011121314use std::error::Error;use std::fs::File;use flate2::write::GzEncoder;use flate2::Compression;use tar::Builder;fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let file = File::create(\"file.tar.gz\")?; let encoder = GzEncoder::new(file, Compression::default()); let mut builder = Builder::new(encoder); builder.append_path(\"file.txt\")?.unwrap().write_all(b\"Hello, world!\")?; builder.finish()?; Ok(())}在这个例子中，我们首先创建了一个名为file.tar.gz的压缩文件，并将其存储在file变量中。接下来，我们使用GzEncoder创建了一个 Gzip 编码器，并使用Builder创建了一个 tar 构建器。我们使用append_path方法添加一个名为file.txt的文件，并使用write_all方法将字符串Hello, world!写入到文件中。最后，我们使用finish方法将构建器中的所有内容写入到文件中。最佳实践在使用 Rust 读写文件时，我们应该遵循以下最佳实践： 使用File模块和Read/Write模块来读写文件。 使用BufReader和BufWriter来缓冲读写操作以提高性能。 当处理大文件时，使用流式读写器来避免将整个文件读写入内存中。 当处理压缩文件时，使用flate2和tar模块来读写文件。 在读写文件时，始终检查错误，并使用expect或?来处理错误。 在读写文件时，始终使用match或if let来处理可能的错误情况。 在写入文件时，始终使用flush方法将缓冲区中的数据刷新到文件中。 在读取文件时，始终使用read_exact方法来确保已读取到所需的字节数。 在读取 CSV 文件时，使用csv模块来处理 CSV 格式。 在读写文件时，始终使用 UTF-8 编码。结论在本教程中，我们介绍了如何在 Rust 中读写文件，包括基础用法和进阶用法。我们提供了多个示例代码，涵盖了读取文件、写入文件、逐行读取文件、追加文件内容、读取二进制文件内容、写入二进制文件内容、读取 CSV 文件内容、写入 CSV 文件内容、读取压缩文件内容和写入压缩文件内容等常见任务。我们还提供了一些最佳实践，以帮助您在实践中更好地使用 Rust 读写文件。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Stream特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Stream",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_128_Trait_Stream.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "Stream 是 Rust 语言中的一种迭代器，它可以使得我们在处理数据时更加高效、灵活。Stream 不仅可以处理大量数据，还可以进行异步操作，这使得它在处理网络请求等 IO 操作时非常有用。Stream 的核心概念是将数据视为流，每次处理一个元素，而不是将整个数据集加载到内存中。这样可以避免内存占用过大的问题，同时也能够提高程序的效率。基础用法创建 Stream在 Rust 中，我们可以使用iter方法来创建 Stream。例如，我们可以使用以下代码来创建一个包含 1 到 5 的 Stream：1let stream = (1..5).into_iter();这里使用了into_iter方法将一个范围转换为 Stream。遍历 Stream遍历 Stream 可以使用for_each方法，例如：1stream.for_each(|x| println!(\"{}\", x));这里使用了闭包来打印每个元素。过滤 Stream我们可以使用filter方法来过滤 Stream 中的元素，例如：1let stream = (1..5).into_iter().filter(|x| x % 2 == 0);这里使用了闭包来判断元素是否为偶数。映射 Stream我们可以使用map方法来对 Stream 中的元素进行映射，例如：1let stream = (1..5).into_iter().map(|x| x * 2);这里使用了闭包来将每个元素乘以 2。合并 Stream我们可以使用chain方法来合并多个 Stream，例如：123let stream1 = (1..3).into_iter();let stream2 = (4..6).into_iter();let stream = stream1.chain(stream2);这里使用了chain方法将两个 Stream 合并为一个。排序 Stream我们可以使用sorted方法来对 Stream 中的元素进行排序，例如：1let stream = vec![3, 1, 4, 1, 5, 9].into_iter().sorted();这里使用了sorted方法将 Stream 中的元素按照升序排序。取前 n 个元素我们可以使用take方法来取 Stream 中的前 n 个元素，例如：1let stream = (1..5).into_iter().take(3);这里使用了take方法取 Stream 中的前 3 个元素。跳过前 n 个元素我们可以使用skip方法来跳过 Stream 中的前 n 个元素，例如：1let stream = (1..5).into_iter().skip(2);这里使用了skip方法跳过 Stream 中的前 2 个元素。统计元素个数我们可以使用count方法来统计 Stream 中的元素个数，例如：123let stream = (1..5).into_iter();let count = stream.count();println!(\"{}\", count);这里使用了count方法统计 Stream 中的元素个数，并打印出来。进阶用法异步 Stream在 Rust 中，我们可以使用futures库来创建异步 Stream。例如，我们可以使用以下代码来创建一个异步 Stream：123use futures::stream::StreamExt;let stream = futures::stream::iter(vec![1, 2, 3]);这里使用了iter方法来创建一个包含 1 到 3 的异步 Stream。并行 Stream在 Rust 中，我们可以使用rayon库来创建并行 Stream。例如，我们可以使用以下代码来创建一个并行 Stream：1rayon = \"1.7\"123use rayon::iter::ParallelIterator;let stream = (1..5).into_par_iter();这里使用了into_par_iter方法将一个范围转换为并行 Stream。处理 Stream 中的错误在处理 Stream 时，有时候会出现错误。我们可以使用Result来处理这些错误。例如，我们可以使用以下代码来处理 Stream 中的错误：1234567891011121314let stream = vec![1, 2, \"a\", 3].into_iter().map(|x| { if let Some(y) = x.downcast_ref::&lt;i32&gt;() { Ok(*y) } else { Err(\"not a number\") }});for item in stream { match item { Ok(x) =&gt; println!(\"{}\", x), Err(e) =&gt; println!(\"{}\", e), }}这里使用了downcast_ref方法将元素转换为i32类型，如果转换失败则返回错误。无限 Stream在 Rust 中，我们可以使用repeat方法来创建一个无限 Stream。例如，我们可以使用以下代码来创建一个包含无限个 1 的 Stream：1let stream = std::iter::repeat(1);这里使用了repeat方法将 1 重复无限次。处理 Stream 中的重复元素在处理 Stream 时，有时候会出现重复元素的情况。我们可以使用dedup方法来去除 Stream 中的重复元素。例如：1let stream = vec![1, 2, 2, 3, 3, 3].into_iter().dedup();这里使用了dedup方法去除 Stream 中的重复元素。处理 Stream 中的空元素在处理 Stream 时，有时候会出现空元素的情况。我们可以使用filter方法来过滤掉 Stream 中的空元素。例如：1let stream = vec![1, 2, \"\", 3, \"\", \"\"].into_iter().filter(|x| !x.is_empty());这里使用了filter方法过滤掉 Stream 中的空元素。处理 Stream 中的 None 值在处理 Stream 时，有时候会出现 None 值的情况。我们可以使用filter_map方法来过滤掉 Stream 中的 None 值。例如：1let stream = vec![Some(1), None, Some(2), None, Some(3)].into_iter().filter_map(|x| x);这里使用了filter_map方法过滤掉 Stream 中的 None 值。处理 Stream 中的重复元素在处理 Stream 时，有时候会出现重复元素的情况。我们可以使用dedup_by方法来去除 Stream 中的重复元素。例如：1let stream = vec![\"a\", \"b\", \"bc\", \"cd\", \"de\", \"ef\"].into_iter().dedup_by(|a, b| a.chars().next() == b.chars().next());这里使用了dedup_by方法去除 Stream 中的重复元素，去重条件是元素的首字母相同。最佳实践在使用 Stream 时，我们应该注意以下几点： 尽量使用异步 Stream 来处理 IO 操作，这样可以避免阻塞线程。 在处理大量数据时，应该使用并行 Stream 来提高程序的效率。 在处理错误时，应该使用Result来处理错误，避免程序崩溃。 在处理无限 Stream 时，应该使用take方法限制 Stream 的大小，避免程序无限运行。 在处理重复元素时，应该使用dedup或dedup_by方法去除重复元素，避免重复计算。示例代码下面是一个完整的示例代码，演示了如何使用 Stream 来处理数据：123itertools = \"0.10.5\"rayon = \"1.7\"futures = \"0.3.28\"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990use futures::stream::StreamExt;use itertools::Itertools;use rayon::iter::ParallelIterator;fn main() { // 创建Stream let stream = (1..5).into_iter(); // 遍历Stream stream.for_each(|x| println!(\"{}\", x)); // 过滤Stream let stream = (1..5).into_iter().filter(|x| x % 2 == 0); stream.for_each(|x| println!(\"{}\", x)); // 映射Stream let stream = (1..5).into_iter().map(|x| x * 2); stream.for_each(|x| println!(\"{}\", x)); // 合并Stream let stream1 = (1..3).into_iter(); let stream2 = (4..6).into_iter(); let stream = stream1.chain(stream2); stream.for_each(|x| println!(\"{}\", x)); // 排序Stream let stream = vec![3, 1, 4, 1, 5, 9].into_iter().sorted(); stream.for_each(|x| println!(\"{}\", x)); // 取前n个元素 let stream = (1..5).into_iter().take(3); stream.for_each(|x| println!(\"{}\", x)); // 跳过前n个元素 let stream = (1..5).into_iter().skip(2); stream.for_each(|x| println!(\"{}\", x)); // 统计元素个数 let stream = (1..5).into_iter(); let count = stream.count(); println!(\"{}\", count); // 异步Stream let stream = futures::stream::iter(vec![1, 2, 3]); futures::executor::block_on(async { stream.for_each(|x| async move { println!(\"{}\", x); }).await; }); // 并行Stream let stream = (1..5).into_par_iter(); stream.for_each(|x| println!(\"{}\", x)); // 处理Stream中的错误 let stream = vec![1, 2, \"a\", 3].into_iter().map(|x| { if let Some(y) = x.downcast_ref::&lt;i32&gt;() { Ok(*y) } else { Err(\"not a number\") } }); for item in stream { match item { Ok(x) =&gt; println!(\"{}\", x), Err(e) =&gt; println!(\"{}\", e), } } // 无限Stream let stream = std::iter::repeat(1).take(5); stream.for_each(|x| println!(\"{}\", x)); // 处理Stream中的重复元素 let stream = vec![1, 2, 2, 3, 3, 3].into_iter().dedup(); stream.for_each(|x| println!(\"{}\", x)); // 处理Stream中的空元素 let stream = vec![1, 2, \"\", 3, \"\", \"\"].into_iter().filter(|x| !x.is_empty()); stream.for_each(|x| println!(\"{}\", x)); // 处理Stream中的None值 let stream = vec![Some(1), None, Some(2), None, Some(3)].into_iter().filter_map(|x| x); stream.for_each(|x| println!(\"{}\", x)); // 处理Stream中的重复元素 let stream = vec![\"a\", \"b\", \"bc\", \"cd\", \"de\", \"ef\"].into_iter().dedup_by(|a, b| a.chars().next() == b.chars().next()); stream.for_each(|x| println!(\"{}\", x));}总结Stream 是 Rust 语言中非常重要的一个概念，它可以使得我们在处理数据时更加高效、灵活。在使用 Stream 时，我们应该注意异步、并行、错误处理、无限 Stream、重复元素等问题，这样才能写出高效、健壮的程序。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 深入理解From和Into特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, From, Into",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_127_Trait_From_Into.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种系统编程语言，其设计目标是提供安全性、速度和并发性。Rust 的安全性特别强，这是因为它在编译时就会检查代码中的内存安全问题。Rust 还具有良好的性能和并发性，这使得它成为了开发高性能、可靠和安全的系统级应用的首选语言。Rust 中的 From 和 Into 是两个重要的 trait，它们可以帮助我们进行类型转换。From trait 允许我们从一个类型转换到另一个类型，而 Into trait 则允许我们将一个类型转换为另一个类型。这两个 trait 的实现可以帮助我们更好地处理类型转换的问题。本教程将介绍 Rust 中的 From 和 Into trait 的基础使用方法和进阶用法。基础用法从字符串转换为数字我们可以使用 From trait 将一个字符串转换为数字类型。例如，我们将字符串”123”转换为 i32 类型。1let num: i32 = i32::from(\"123\");从数字转换为字符串我们可以使用 Into trait 将一个数字类型转换为字符串。例如，我们将数字 123 转换为字符串类型。12let num: i32 = 123;let str: String = String::from(num.to_string());从一个类型转换为另一个类型我们可以使用 From trait 将一个类型转换为另一个类型。例如，我们将一个 i32 类型的变量转换为一个 u32 类型的变量。12let num: i32 = 123;let new_num: u32 = u32::from(num);从一个类型转换为另一个类型我们可以使用 Into trait 将一个类型转换为另一个类型。例如，我们将一个 i32 类型的变量转换为一个 u32 类型的变量。12let num: i32 = 123;let new_num: u32 = num.into();从一个 Option 类型转换为另一个 Option 类型我们可以使用 From trait 将一个 Option 类型转换为另一个 Option 类型。例如，我们将一个 Option类型的变量转换为一个 Option类型的变量。12let num: Option&lt;i32&gt; = Some(123);let new_num: Option&lt;u32&gt; = Option::from(num);从一个 Vec 类型转换为另一个 Vec 类型我们可以使用 From trait 将一个 Vec 类型转换为另一个 Vec 类型。例如，我们将一个 Vec类型的变量转换为一个 Vec类型的变量。12let vec: Vec&lt;i32&gt; = vec![1, 2, 3];let new_vec: Vec&lt;u32&gt; = Vec::from(vec);从一个数组类型转换为另一个数组类型我们可以使用 From trait 将一个数组类型转换为另一个数组类型。例如，我们将一个[i32; 3]类型的数组转换为一个[u32; 3]类型的数组。12let arr: [i32; 3] = [1, 2, 3];let new_arr: [u32; 3] = &lt;[i32; 3]&gt;::into(arr);从一个枚举类型转换为另一个枚举类型我们可以使用 From trait 将一个枚举类型转换为另一个枚举类型。例如，我们将一个 Option类型的枚举转换为一个 Option类型的枚举。123456789101112enum OptionInt { Some(i32), None,}enum OptionUint { Some(u32), None,}let option_int = OptionInt::Some(123);let option_uint: OptionUint = OptionUint::from(option_int);进阶用法为自定义类型实现 From trait我们可以为自定义类型实现 From trait，以便将自定义类型转换为其他类型。例如，我们为自定义类型 MyInt 实现 From trait，以便将它转换为 i32 类型。12345678910struct MyInt(i32);impl From&lt;MyInt&gt; for i32 { fn from(my_int: MyInt) -&gt; i32 { my_int.0 }}let my_int = MyInt(123);let num: i32 = my_int.into();为自定义类型实现 Into trait我们可以为自定义类型实现 Into trait，以便将其他类型转换为自定义类型。例如，我们为自定义类型 MyInt 实现 Into trait，以便将 i32 类型转换为它。12345678910struct MyInt(i32);impl Into&lt;MyInt&gt; for i32 { fn into(self) -&gt; MyInt { MyInt(self) }}let num: i32 = 123;let my_int: MyInt = num.into();使用泛型实现 From trait我们可以使用泛型实现 From trait，以便将任意类型转换为另一个类型。例如，我们使用泛型实现 From trait，以便将任意类型转换为字符串类型。12345678910struct MyStruct&lt;T&gt;(T);impl&lt;T: std::fmt::Display&gt; From&lt;MyStruct&lt;T&gt;&gt; for String { fn from(my_struct: MyStruct&lt;T&gt;) -&gt; String { format!(\"{}\", my_struct.0) }}let my_struct = MyStruct(123);let str: String = my_struct.into();使用泛型实现 Into trait我们可以使用泛型实现 Into trait，以便将任意类型转换为另一个类型。例如，我们使用泛型实现 Into trait，以便将任意类型转换为字符串类型。12345678910struct MyStruct&lt;T&gt;(T);impl&lt;T: std::fmt::Display&gt; Into&lt;String&gt; for MyStruct&lt;T&gt; { fn into(self) -&gt; String { format!(\"{}\", self.0) }}let my_struct = MyStruct(123);let str: String = my_struct.into();最佳实践在 Rust 中，From 和 Into trait 是非常有用的，它们可以帮助我们进行类型转换。在实现 From 和 Into trait 时，我们需要注意以下几点： 实现 From 和 Into trait 时，需要考虑类型转换的安全性和正确性。 实现 From 和 Into trait 时，需要考虑性能问题，避免不必要的类型转换。 在实现 From 和 Into trait 时，需要遵循 Rust 的惯例和规范，以便代码更易于理解和维护。下面是一些最佳实践示例代码：为自定义类型实现 From 和 Into trait12345678910111213struct MyInt(i32);impl From&lt;MyInt&gt; for i32 { fn from(my_int: MyInt) -&gt; i32 { my_int.0 }}impl Into&lt;MyInt&gt; for i32 { fn into(self) -&gt; MyInt { MyInt(self) }}使用泛型实现 From 和 Into trait12345678910111213struct MyStruct&lt;T&gt;(T);impl&lt;T: std::fmt::Display&gt; From&lt;MyStruct&lt;T&gt;&gt; for String { fn from(my_struct: MyStruct&lt;T&gt;) -&gt; String { format!(\"{}\", my_struct.0) }}impl&lt;T: std::fmt::Display&gt; Into&lt;String&gt; for MyStruct&lt;T&gt; { fn into(self) -&gt; String { format!(\"{}\", self.0) }}使用 From 和 Into trait 进行类型转换12345let my_int = MyInt(123);let num: i32 = my_int.into();let my_struct = MyStruct(123);let str: String = my_struct.into();总结在本教程中，我们介绍了 Rust 中的 From 和 Into trait 的基础使用方法和进阶用法。From trait 允许我们从一个类型转换到另一个类型，而 Into trait 则允许我们将一个类型转换为另一个类型。我们还提供了一些示例代码和最佳实践，以帮助您更好地理解和应用 From 和 Into trait。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Default特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Default",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_126_Trait_Default.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种系统级编程语言，它的设计目标是安全、并发和高效。Rust 的设计灵感来自于 C++、Rust 和 Haskell 等语言，它的特点是静态类型、内存安全、并发性和高性能。Default 是 Rust 标准库中的一个 trait，它定义了一个类型的默认值。在 Rust 中，每个类型都有一个默认值，这个默认值可以通过 Default trait 来获取。Rust 的默认值是零值，也就是说，如果一个类型没有定义它的默认值，那么它的默认值就是 0 或者 null。基础用法使用 Default trait 获取类型的默认值在 Rust 中，可以使用 Default trait 来获取一个类型的默认值。例如，以下代码演示了如何获取一个整数类型的默认值：1234fn main() { let x: i32 = Default::default(); println!(\"The default value of i32 is {}\", x);}输出结果为：The default value of i32 is 0自定义类型的默认值在 Rust 中，可以为自定义类型实现 Default trait，以便为它们定义默认值。例如，以下代码演示了如何为一个结构体类型实现 Default trait：12345678910#[derive(Default)]struct Point { x: i32, y: i32,}fn main() { let p: Point = Default::default(); println!(\"The default value of Point is ({}, {})\", p.x, p.y);}输出结果为：The default value of Point is (0, 0)使用泛型获取类型的默认值在 Rust 中，可以使用泛型来获取任意类型的默认值。例如，以下代码演示了如何使用泛型获取一个字符串类型的默认值：1234fn main() { let s: String = Default::default(); println!(\"The default value of String is '{}'\", s);}输出结果为：The default value of String is ''使用 Option 类型获取默认值在 Rust 中，Option 类型是一个枚举类型，它可以表示一个值的存在或不存在。如果一个变量的类型是 Option 类型，则它的默认值是 None。例如，以下代码演示了如何获取一个 Option 类型的默认值：1234fn main() { let opt: Option&lt;i32&gt; = Default::default(); println!(\"The default value of Option&lt;i32&gt; is {:?}\", opt);}输出结果为：The default value of Option&lt;i32&gt; is None使用数组类型获取默认值在 Rust 中，数组类型的默认值是一个由零值组成的数组。例如，以下代码演示了如何获取一个数组类型的默认值：1234fn main() { let arr: [i32; 3] = Default::default(); println!(\"The default value of [i32; 3] is {:?}\", arr);}输出结果为：The default value of [i32; 3] is [0, 0, 0]使用元组类型获取默认值在 Rust 中，元组类型的默认值是一个由每个元素的默认值组成的元组。例如，以下代码演示了如何获取一个元组类型的默认值：1234fn main() { let tup: (i32, bool, String) = Default::default(); println!(\"The default value of (i32, bool, String) is {:?}\", tup);}输出结果为：The default value of (i32, bool, String) is (0, false, '')使用枚举类型获取默认值在 Rust 中，枚举类型的默认值是它的第一个成员。例如，以下代码演示了如何获取一个枚举类型的默认值：12345678910enum Color { Red, Green, Blue,}fn main() { let color: Color = Default::default(); println!(\"The default value of Color is {:?}\", color);}输出结果为：The default value of Color is Red使用结构体获取默认值在 Rust 中，结构体类型的默认值是由每个字段的默认值组成的结构体。例如，以下代码演示了如何获取一个结构体类型的默认值：1234567891011121314151617181920struct Person { name: String, age: i32, is_male: bool,}impl Default for Person { fn default() -&gt; Self { Self { name: String::default(), age: i32::default(), is_male: bool::default(), } }}fn main() { let p: Person = Default::default(); println!(\"The default value of Person is {:?}\", p);}输出结果为：The default value of Person is Person { name: '', age: 0, is_male: false }进阶用法使用 Default trait 实现结构体的默认值在 Rust 中，可以为结构体类型实现 Default trait，以便为它们定义默认值。例如，以下代码演示了如何为一个结构体类型实现 Default trait：12345678910#[derive(Default)]struct Point { x: i32, y: i32,}fn main() { let p: Point = Default::default(); println!(\"The default value of Point is ({}, {})\", p.x, p.y);}输出结果为：The default value of Point is (0, 0)使用 Default trait 实现枚举类型的默认值在 Rust 中，可以为枚举类型实现 Default trait，以便为它们定义默认值。例如，以下代码演示了如何为一个枚举类型实现 Default trait：12345678910111213141516enum Color { Red, Green, Blue,}impl Default for Color { fn default() -&gt; Self { Color::Red }}fn main() { let color: Color = Default::default(); println!(\"The default value of Color is {:?}\", color);}输出结果为：The default value of Color is Red使用 Default trait 实现元组类型的默认值在 Rust 中，可以为元组类型实现 Default trait，以便为它们定义默认值。例如，以下代码演示了如何为一个元组类型实现 Default trait：12345678910impl Default for (i32, bool, String) { fn default() -&gt; Self { (0, false, String::default()) }}fn main() { let tup: (i32, bool, String) = Default::default(); println!(\"The default value of (i32, bool, String) is {:?}\", tup);}输出结果为：The default value of (i32, bool, String) is (0, false, '')使用 Default trait 实现泛型类型的默认值在 Rust 中，可以为泛型类型实现 Default trait，以便为它们定义默认值。例如，以下代码演示了如何为一个泛型类型实现 Default trait：123456789101112131415161718struct Pair&lt;T&gt; { x: T, y: T,}impl&lt;T: Default&gt; Default for Pair&lt;T&gt; { fn default() -&gt; Self { Self { x: T::default(), y: T::default(), } }}fn main() { let pair: Pair&lt;i32&gt; = Default::default(); println!(\"The default value of Pair&lt;i32&gt; is ({}, {})\", pair.x, pair.y);}输出结果为：The default value of Pair&lt;i32&gt; is (0, 0)最佳实践在 Rust 中，使用 Default trait 可以方便地获取类型的默认值。以下是一些最佳实践：为自定义类型实现 Default trait为自定义类型实现 Default trait 可以方便地为它们定义默认值。例如，以下代码演示了如何为一个结构体类型实现 Default trait：12345678910#[derive(Default)]struct Point { x: i32, y: i32,}fn main() { let p: Point = Default::default(); println!(\"The default value of Point is ({}, {})\", p.x, p.y);}输出结果为：The default value of Point is (0, 0)使用泛型获取类型的默认值在 Rust 中，可以使用泛型来获取任意类型的默认值。例如，以下代码演示了如何使用泛型获取一个字符串类型的默认值：1234fn main() { let s: String = Default::default(); println!(\"The default value of String is '{}'\", s);}输出结果为：The default value of String is ''使用 Option 类型获取默认值在 Rust 中，Option 类型是一个枚举类型，它可以表示一个值的存在或不存在。如果一个变量的类型是 Option 类型，则它的默认值是 None。例如，以下代码演示了如何获取一个 Option 类型的默认值：1234fn main() { let opt: Option&lt;i32&gt; = Default::default(); println!(\"The default value of Option&lt;i32&gt; is {:?}\", opt);}输出结果为：The default value of Option&lt;i32&gt; is None为泛型类型实现 Default trait为泛型类型实现 Default trait 可以方便地为它们定义默认值。例如，以下代码演示了如何为一个泛型类型实现 Default trait：123456789101112131415161718struct Pair&lt;T&gt; { x: T, y: T,}impl&lt;T: Default&gt; Default for Pair&lt;T&gt; { fn default() -&gt; Self { Self { x: T::default(), y: T::default(), } }}fn main() { let pair: Pair&lt;i32&gt; = Default::default(); println!(\"The default value of Pair&lt;i32&gt; is ({}, {})\", pair.x, pair.y);}输出结果为：The default value of Pair&lt;i32&gt; is (0, 0)结论在 Rust 中，Default trait 可以方便地获取类型的默认值。使用 Default trait 可以简化代码，并提高代码的可读性和可维护性。同时，为自定义类型实现 Default trait 可以方便地为它们定义默认值。在使用 Default trait 时，可以根据需要为泛型类型实现 Default trait，以便为它们定义默认值。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 如何判断对象是否相等？",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Eq, PartialEq",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_125_Trait_Eq_PartialEq.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "在 Rust 语言中，PartialEq 和 Eq 是两个非常重要的 trait。它们用于比较类型的值，PartialEq 用于比较部分相等（不需要完全相等），而 Eq 用于比较完全相等。在 Rust 中，任何类型都可以实现 PartialEq 和 Eq，因此这两个 trait 非常灵活。基础用法比较整数123456789fn main() { let a = 10; let b = 20; if a == b { println!(\"a equals b\"); } else { println!(\"a does not equal b\"); }}输出：a does not equal b比较字符串123456789fn main() { let a = \"hello\"; let b = \"world\"; if a == b { println!(\"a equals b\"); } else { println!(\"a does not equal b\"); }}输出：a does not equal b比较自定义类型123456789101112131415161718192021#[derive(PartialEq, Eq)]struct Person { name: String, age: u8,}fn main() { let p1 = Person { name: \"Alice\".to_string(), age: 30, }; let p2 = Person { name: \"Bob\".to_string(), age: 30, }; if p1 == p2 { println!(\"p1 equals p2\"); } else { println!(\"p1 does not equal p2\"); }}输出：p1 does not equal p2比较浮点数123456789fn main() { let a = 0.1 + 0.2; let b = 0.3; if a == b { println!(\"a equals b\"); } else { println!(\"a does not equal b\"); }}输出：a does not equal b自定义比较函数1234567891011121314151617181920212223242526272829#[derive(PartialEq, Eq)]struct Person { name: String, age: u8,}impl PartialEq for Person { fn eq(&amp;self, other: &amp;Self) -&gt; bool { self.age == other.age }}impl Eq for Person {}fn main() { let p1 = Person { name: \"Alice\".to_string(), age: 30, }; let p2 = Person { name: \"Bob\".to_string(), age: 30, }; if p1 == p2 { println!(\"p1 equals p2\"); } else { println!(\"p1 does not equal p2\"); }}输出：p1 equals p2比较枚举类型123456789101112131415#[derive(PartialEq, Eq)]enum Color { Red, Blue,}fn main() { let c1 = Color::Red; let c2 = Color::Blue; if c1 == c2 { println!(\"c1 equals c2\"); } else { println!(\"c1 does not equal c2\"); }}输出：c1 does not equal c2使用 assert_eq!宏12345fn main() { let a = 10; let b = 20; assert_eq!(a, b);}输出：thread 'main' panicked at 'assertion failed: `(left == right)` left: `10`, right: `20`', src/main.rs:4:5note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace使用 assert_ne!宏12345fn main() { let a = 10; let b = 20; assert_ne!(a, b);}输出：thread 'main' panicked at 'assertion failed: `(left != right)` left: `10`, right: `10`', src/main.rs:4:5note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace进阶用法自定义比较函数1234567891011121314151617181920212223242526272829#[derive(PartialEq, Eq)]struct Person { name: String, age: u8,}impl PartialEq for Person { fn eq(&amp;self, other: &amp;Self) -&gt; bool { self.age == other.age }}impl Eq for Person {}fn main() { let p1 = Person { name: \"Alice\".to_string(), age: 30, }; let p2 = Person { name: \"Bob\".to_string(), age: 40, }; if p1 == p2 { println!(\"p1 equals p2\"); } else { println!(\"p1 does not equal p2\"); }}输出：p1 does not equal p2使用泛型123456789101112131415161718192021#[derive(PartialEq, Eq)]struct Pair&lt;T&gt; { first: T, second: T,}fn main() { let p1 = Pair { first: 1, second: 2, }; let p2 = Pair { first: 2, second: 1, }; if p1 == p2 { println!(\"p1 equals p2\"); } else { println!(\"p1 does not equal p2\"); }}输出：p1 does not equal p2使用 PartialOrd 和 Ord123456789101112131415161718192021#[derive(PartialEq, Eq, PartialOrd, Ord)]struct Person { name: String, age: u8,}fn main() { let p1 = Person { name: \"Alice\".to_string(), age: 30, }; let p2 = Person { name: \"Bob\".to_string(), age: 40, }; if p1 &lt; p2 { println!(\"p1 is younger than p2\"); } else { println!(\"p1 is older than or equal to p2\"); }}输出：p1 is younger than p2使用 Debug 和 Display1234567891011121314151617181920212223242526#[derive(Debug, PartialEq, Eq)]struct Person { name: String, age: u8,}use std::fmt;impl fmt::Display for Person { fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result { write!(f, \"{} ({})\", self.name, self.age) }}fn main() { let p1 = Person { name: \"Alice\".to_string(), age: 30, }; let p2 = Person { name: \"Bob\".to_string(), age: 40, }; println!(\"p1: {}\", p1); println!(\"p2: {}\", p2);}输出：p1: Alice (30)p2: Bob (40)最佳实践在实现 PartialEq 和 Eq 时，应该考虑以下几点： 对于自定义类型，应该比较所有的成员变量，而不仅仅是一部分。 对于浮点数，应该使用近似比较而不是精确比较。 对于枚举类型，应该比较所有的成员变量，而不仅仅是枚举值本身。 如果需要比较的类型实现了 PartialOrd 和 Ord，应该优先使用这两个 trait。结论在 Rust 语言中，PartialEq 和 Eq 是非常重要的 trait，用于比较类型的值。这两个 trait 非常灵活，任何类型都可以实现它们。在实现 PartialEq 和 Eq 时，应该考虑到类型的特点，比较所有的成员变量，使用近似比较等。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 不可变引用智能指针RefCell特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, RefCell",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_124_Trait_RefCell.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "RefCell 是 Rust 标准库提供的一种类型，它可以在运行时检查借用规则，使得我们可以在某些情况下绕过 Rust 的静态借用检查。RefCell 的主要作用是允许在不可变引用存在的情况下，获取可变引用。这样就可以在不破坏 Rust 的安全性和所有权规则的前提下，实现一些特殊的需求。在 Rust 中，为了避免数据竞争，任何时候只能有一个可变引用或多个不可变引用。但是，在某些情况下，我们确实需要在不可变引用的情况下修改数据。这时候，就可以使用 RefCell。基础用法创建 RefCell首先，我们需要创建一个 RefCell 对象。可以使用 new() 方法来创建一个新的 RefCell，示例代码如下：123use std::cell::RefCell;let my_cell = RefCell::new(42);这里，我们创建了一个名为 my_cell 的 RefCell，并将其初始化为整数 42。获取 RefCell 中的值要访问 RefCell 中的值，我们需要使用 borrow() 方法。这个方法返回一个 Ref 对象，它像一个不可变引用一样使用，但是它可以访问 RefCell 中的值。示例代码如下：12345678910use std::cell::RefCell;fn main() { let my_cell = RefCell::new(42); let my_ref = my_cell.borrow(); println!(\"The value in my_cell is: {}\", *my_ref);}// 输出结果// The value in my_cell is: 42这里，我们首先创建了一个 RefCell，然后使用 borrow() 方法获取了一个 Ref 对象。我们可以使用 * 运算符来访问 Ref 中的值。修改 RefCell 中的值要修改 RefCell 中的值，我们需要使用 borrow_mut() 方法。这个方法返回一个 RefMut 对象，它像一个可变引用一样使用，但是它可以修改 RefCell 中的值。示例代码如下：1234567891011use std::cell::RefCell;fn main() { let my_cell = RefCell::new(42); let mut my_ref = my_cell.borrow_mut(); *my_ref = 100; println!(\"The new value in my_cell is: {}\", *my_ref);}// 输出结果// The new value in my_cell is: 100这里，我们首先创建了一个 RefCell，然后使用 borrow_mut() 方法获取了一个 RefMut 对象。我们可以使用 * 运算符来修改 RefMut 中的值。获取 RefCell 中的不可变引用如果我们在获取 RefCell 的可变引用之前，已经获取了一个不可变引用，那么 Rust 会在运行时检查，如果发现了错误，就会 panic。示例代码如下：12345678910use std::cell::RefCell;fn main() { let my_cell = RefCell::new(42); let my_ref = my_cell.borrow(); let my_mut_ref = my_cell.borrow_mut(); // panic!}// 输出结果// thread 'main' panicked at 'already borrowed: BorrowMutError', src/main.rs:17:26这里，我们首先获取了一个不可变引用 my_ref，然后试图获取一个可变引用 my_mut_ref。由于我们已经有了一个不可变引用，所以 Rust 会在运行时检查，发现了错误，就会 panic。获取 RefCell 中的可变引用如果我们在获取 RefCell 的可变引用之前，已经获取了一个可变引用，那么 Rust 会在编译时检查，如果发现了错误，就会报错。示例代码如下：12345678use std::cell::RefCell;let my_cell = RefCell::new(42);let mut my_mut_ref = my_cell.borrow_mut();let my_ref = my_cell.borrow(); // compile error!// 输出结果// thread 'main' panicked at 'already borrowed: BorrowMutError', src/main.rs:17:22这里，我们首先获取了一个可变引用 my_mut_ref，然后试图获取一个不可变引用 my_ref。由于我们已经有了一个可变引用，所以 Rust 会在编译时检查，发现了错误，就会报错。获取 RefCell 中的多个不可变引用如果我们在获取 RefCell 的多个不可变引用时，其中一个引用已经被转换为可变引用，那么 Rust 会在运行时检查，如果发现了错误，就会 panic。示例代码如下：12345678use std::cell::RefCell;let my_cell = RefCell::new(42);let my_ref1 = my_cell.borrow();let my_ref2 = my_cell.borrow();let mut my_mut_ref = my_cell.borrow_mut(); // panic!// thread 'main' panicked at 'already borrowed: BorrowMutError', src/main.rs:18:30这里，我们首先获取了两个不可变引用 my_ref1 和 my_ref2，然后试图获取一个可变引用 my_mut_ref。由于我们已经有了两个不可变引用，所以 Rust 会在运行时检查，发现了错误，就会 panic。获取 RefCell 中的多个可变引用如果我们在获取 RefCell 的多个可变引用时，其中一个引用已经被转换为不可变引用，那么 Rust 会在编译时检查，如果发现了错误，就会报错。示例代码如下：123456use std::cell::RefCell;let my_cell = RefCell::new(42);let mut my_mut_ref1 = my_cell.borrow_mut();let my_mut_ref2 = my_cell.borrow_mut(); // compile error!这里，我们首先获取了一个可变引用 my_mut_ref1，然后试图获取另一个可变引用 my_mut_ref2。由于我们已经有了一个可变引用，所以 Rust 会在编译时检查，发现了错误，就会报错。使用 RefCell 来实现引用计数RefCell 还可以用来实现引用计数。我们可以将 RefCell 包装在一个 Rc 中，这样就可以在多个地方共享 RefCell。示例代码如下：123456789101112131415use std::cell::RefCell;use std::rc::Rc;fn main() { let my_cell = Rc::new(RefCell::new(42)); let my_ref1 = my_cell.borrow().clone(); let my_ref2 = my_cell.borrow().clone(); { let mut my_mut_ref = my_cell.borrow_mut(); *my_mut_ref = 100; } println!(\"The value in my_cell is: {:?}\", my_ref1); println!(\"The value in my_cell is: {:?}\", my_ref2);}这里，我们首先创建了一个 Rc&lt;RefCell&lt;i32&gt;&gt;，然后分别获取了两个不可变引用 my_ref1 和 my_ref2，以及一个可变引用 my_mut_ref。我们可以使用 * 运算符来访问 Ref 和 RefMut 中的值。进阶用法使用 RefCell 来实现线程安全的可变变量在 Rust 中，如果我们需要在线程之间共享可变变量，通常会使用 Mutex 或 RwLock。但是，这些类型的性能可能不太好，因为它们需要在每个访问上进行加锁和解锁操作。如果我们只需要在单个线程中共享可变变量，那么可以使用 RefCell 来实现，这样可以避免加锁和解锁的开销。示例代码如下：12345678910use std::cell::RefCell;let my_cell = RefCell::new(0);let mut my_mut_ref1 = my_cell.borrow_mut();*my_mut_ref1 += 1;let mut my_mut_ref2 = my_cell.borrow_mut();*my_mut_ref2 += 2;println!(\"The value in my_cell is: {}\", *my_mut_ref1);这里，我们首先创建了一个 RefCell&lt;i32&gt;，然后获取了两个可变引用 my_mut_ref1 和 my_mut_ref2，并分别修改了它们。由于我们只在单个线程中使用 RefCell，所以不需要加锁和解锁。使用 RefCell 来实现循环引用在 Rust 中，如果两个对象互相引用，那么它们之间就会形成一个循环引用。这时候，就可以使用 RefCell 来实现。示例代码如下：12345678910111213141516171819202122232425262728293031use std::cell::RefCell;use std::rc::Rc;struct Node { value: i32, next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,}fn main() { let node1 = Rc::new(RefCell::new(Node { value: 1, next: None, })); let node2 = Rc::new(RefCell::new(Node { value: 2, next: None, })); { node1.borrow_mut().next = Some(node2.clone()); } { node2.borrow_mut().next = Some(node1.clone()); } println!(\"The value of node1 is: {}\", node1.borrow().value); println!(\"The value of node2 is: {}\", node2.borrow().value);}// 输出结果// The value of node1 is: 1// The value of node2 is: 2这里，我们创建了两个 Rc&lt;RefCell&lt;Node&gt;&gt;，然后将它们互相引用。由于我们使用了 RefCell，所以可以在创建时互相引用，而不需要先创建一个对象，然后再修改它们的引用。使用 RefCell 来实现可变借用嵌套在 Rust 中，如果我们需要在一个可变引用中嵌套另一个可变引用，通常会出现编译时错误。但是，如果我们使用 RefCell，就可以实现可变借用嵌套。示例代码如下：12345678910111213141516171819use std::cell::RefCell;struct Node { value: i32, next: Option&lt;Box&lt;RefCell&lt;Node&gt;&gt;&gt;,}fn main() { let mut node1 = Box::new(RefCell::new(Node { value: 1, next: None })); let mut node2 = Box::new(RefCell::new(Node { value: 2, next: None })); { node1.borrow_mut().next = Some(node2); node2.borrow_mut().next = Some(node1); } println!(\"The value of node1 is: {}\", node1.borrow().value); println!(\"The value of node2 is: {}\", node2.borrow().value);}这里，我们创建了两个 Box&lt;RefCell&lt;Node&gt;&gt;，然后将它们互相引用。由于我们使用了 RefCell，所以可以在可变引用中嵌套另一个可变引用。使用 RefCell 来实现内部可变性在 Rust 中，如果我们需要在一个结构体中存储一个可变变量，通常会使用 mut 关键字来标记结构体字段。但是，如果我们使用 RefCell，就可以实现内部可变性。示例代码如下：1234567891011121314151617use std::cell::RefCell;struct Person { name: String, age: RefCell&lt;i32&gt;,}fn main() { let person = Person { name: \"Alice\".to_string(), age: RefCell::new(30) }; { let mut my_age = person.age.borrow_mut(); *my_age += 1; } println!(\"{} is now {} years old.\", person.name, *person.age.borrow());}// 输出结果// Alice is now 31 years old.这里，我们创建了一个 Person 结构体，其中包含一个 String 类型的 name 字段和一个 RefCell&lt;i32&gt; 类型的 age 字段。我们可以在不可变引用的情况下修改 age 字段中的值。最佳实践避免过多的可变引用虽然 RefCell 可以在不可变引用的情况下修改数据，但是过多的可变引用会导致代码难以维护。因此，应该尽量避免过多的可变引用。使用 RefCell 来实现状态机RefCell 可以用于实现状态机。在状态机中，状态之间的转换通常需要修改状态机中的某些变量。由于状态机本身是不可变的，因此可以使用 RefCell 来存储状态机中的可变变量。示例代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455use std::cell::RefCell;#[derive(Debug)]enum State { A, B, C,}#[derive(Debug)]struct StateMachine { state: RefCell&lt;State&gt;, count: RefCell&lt;i32&gt;,}impl StateMachine { fn new() -&gt; StateMachine { StateMachine { state: RefCell::new(State::A), count: RefCell::new(0) } } fn next(&amp;self) { let mut state = self.state.borrow_mut(); let mut count = self.count.borrow_mut(); match *state { State::A =&gt; { *state = State::B; *count += 1; }, State::B =&gt; { *state = State::C; *count += 2; }, State::C =&gt; { *state = State::A; *count += 3; }, } }}fn main() { let sm = StateMachine::new(); sm.next(); println!(\"State is {:?}, count is {}\", *sm.state.borrow(), *sm.count.borrow()); sm.next(); println!(\"State is {:?}, count is {}\", *sm.state.borrow(), *sm.count.borrow()); sm.next(); println!(\"State is {:?}, count is {}\", *sm.state.borrow(), *sm.count.borrow());}// 输出结果// State is B, count is 1// State is C, count is 3// State is A, count is 6这里，我们创建了一个 StateMachine 结构体，其中包含一个 RefCell&lt;State&gt; 类型的 state 字段和一个 RefCell&lt;i32&gt; 类型的 count 字段。我们可以在不可变引用的情况下修改 state 和 count 字段中的值。使用 RefCell 来实现链表RefCell 可以用于实现链表。在链表中，每个节点通常包含一个指向下一个节点的指针。由于每个节点的指针是可变的，因此可以使用 RefCell 来存储节点中的指针。示例代码如下：1234567891011121314151617181920212223use std::cell::RefCell;use std::rc::Rc;struct Node { value: i32, next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,}fn main() { let node1 = Rc::new(RefCell::new(Node { value: 1, next: None })); let node2 = Rc::new(RefCell::new(Node { value: 2, next: None })); let node3 = Rc::new(RefCell::new(Node { value: 3, next: None })); node1.borrow_mut().next = Some(node2.clone()); node2.borrow_mut().next = Some(node3.clone()); let mut node = node1; while let Some(next) = node.borrow().next.clone() { println!(\"The value of node is: {}\", next.borrow().value); node = next; } println!(\"The value of node is: {}\", node.borrow().value);}这里，我们创建了三个 Rc&lt;RefCell&lt;Node&gt;&gt;，然后将它们连接成一个链表。我们可以使用 borrow() 方法来访问节点中的值，使用 borrow_mut() 方法来修改节点中的指针。总结RefCell 是 Rust 标准库提供的一种类型，它可以在运行时检查借用规则，使得我们可以在某些情况下绕过 Rust 的静态借用检查。RefCell 的主要作用是允许在不可变引用存在的情况下，获取可变引用。这样就可以在不破坏 Rust 的安全性和所有权规则的前提下，实现一些特殊的需求。在使用 RefCell 时，需要注意避免过多的可变引用，以及使用 RefCell 实现状态机和链表等数据结构。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 堆对象智能指针Box",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Box",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_123_Trait_Box.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种系统编程语言，它的设计目标是提供安全性、并发性和性能。它是一种静态类型语言，具有内存安全和数据竞争安全的特性。在 Rust 中，Box 是一种智能指针，它允许在堆上分配内存，并在不需要时自动释放。Box 是 Rust 中最基本的智能指针之一，它是对堆上分配的内存的所有权的一种抽象。基础用法创建一个 Box1let b = Box::new(5);这个例子创建了一个 Box，它包含一个整数 5。Box 的类型是Box&lt;i32&gt;。将一个值放入 Box 中12let x = 5;let b = Box::new(x);这个例子将一个整数 5 放入了 Box 中。从 Box 中获取值12let b = Box::new(5);let x = *b;这个例子从 Box 中获取了一个整数 5，并将其赋值给变量 x。注意，需要使用解引用运算符*来获取 Box 中的值。在函数中传递 Box123456fn print_box(b: Box&lt;i32&gt;) { println!(\"The value of b is {}\", *b);}let b = Box::new(5);print_box(b);这个例子定义了一个函数print_box，它接受一个 Box 作为参数，并打印 Box 中的值。然后，创建一个 Box 并将其传递给函数。在函数中返回 Box12345fn create_box() -&gt; Box&lt;i32&gt; { Box::new(5)}let b = create_box();这个例子定义了一个函数create_box，它返回一个 Box，其中包含整数 5。然后，创建一个 Box 并将其赋值给变量 b。将 Box 转换为引用12let b = Box::new(5);let r = &amp;*b;这个例子将一个 Box 转换为一个引用。注意，需要使用解引用运算符*来获取 Box 中的值，然后使用引用运算符&amp;来获取引用。将 Box 转换为可变引用123let mut b = Box::new(5);let r = &amp;mut *b;*r = 6;这个例子将一个 Box 转换为一个可变引用。注意，需要使用解引用运算符*来获取 Box 中的值，然后使用可变引用运算符&amp;mut来获取可变引用。在结构体中使用 Box1234567891011121314struct Point { x: i32, y: i32,}struct Rectangle { top_left: Box&lt;Point&gt;, bottom_right: Box&lt;Point&gt;,}let rect = Rectangle { top_left: Box::new(Point { x: 0, y: 0 }), bottom_right: Box::new(Point { x: 10, y: 10 }),};这个例子定义了两个结构体，Point 和 Rectangle。Rectangle 包含两个 Box，它们分别表示矩形的左上角和右下角。然后，创建一个 Rectangle 并初始化它的两个 Box。进阶用法使用 Box 在堆上分配大量内存1234let mut v = Vec::new();for i in 0..1000000 { v.push(Box::new(i));}这个例子创建了一个包含 1000000 个整数的 Vec。由于整数是通过 Box 分配在堆上的，因此 Vec 的大小只包含指针的大小，而不是整个整数的大小。使用 Box 实现递归数据结构123456enum List { Cons(i32, Box&lt;List&gt;), Nil,}let list = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));这个例子定义了一个递归的 List 枚举类型。它可以包含一个整数和一个指向另一个 List 的 Box，或者是一个空 List。然后，创建一个包含两个整数的 List。使用 Box 实现自引用结构体123456789101112131415struct Node { value: i32, next: Option&lt;Box&lt;Node&gt;&gt;,}let mut n1 = Node { value: 1, next: None,};let mut n2 = Node { value: 2, next: None,};n1.next = Some(Box::new(n2));n2.next = Some(Box::new(n1));这个例子定义了一个 Node 结构体，它包含一个整数和一个指向另一个 Node 的 Box。然后，创建两个 Node 并将它们相互引用。使用 Box 实现动态分配的多态类型1234567891011121314151617181920212223242526272829303132trait Shape { fn area(&amp;self) -&gt; f64;}struct Circle { radius: f64,}impl Shape for Circle { fn area(&amp;self) -&gt; f64 { std::f64::consts::PI * self.radius * self.radius }}struct Rectangle { width: f64, height: f64,}impl Shape for Rectangle { fn area(&amp;self) -&gt; f64 { self.width * self.height }}let shapes: Vec&lt;Box&lt;dyn Shape&gt;&gt; = vec![ Box::new(Circle { radius: 1.0 }), Box::new(Rectangle { width: 2.0, height: 3.0 }),];for shape in shapes { println!(\"Area = {}\", shape.area());}这个例子定义了一个 Shape trait 和两个实现它的结构体 Circle 和 Rectangle。然后，创建一个包含两个 Shape 的 Vec，并遍历它打印每个 Shape 的面积。最佳实践 避免过度使用 BoxBox 是在堆上分配内存的一种方式，因此使用过多的 Box 可能会导致性能问题。在 Rust 中，应该尽可能地使用栈上分配内存，只在需要时才使用 Box。 使用 Box 来避免所有权问题在 Rust 中，所有权是一个重要的概念。使用 Box 可以避免所有权问题，因为 Box 可以在不同的作用域中传递所有权。 使用 Box 实现递归数据结构在 Rust 中，递归数据结构是一种常见的数据结构。使用 Box 可以方便地实现递归数据结构，因为 Box 可以在堆上分配内存，并在不需要时自动释放。 使用 Box 实现动态分配的多态类型在 Rust 中，多态类型是一种常见的编程模式。使用 Box 可以方便地实现动态分配的多态类型，因为 Box 可以在堆上分配内存，并在不需要时自动释放。总结Box 是 Rust 中最基本的智能指针之一，它允许在堆上分配内存，并在不需要时自动释放。在本教程中，我们介绍了 Box 的基础用法和进阶用法，并提供了示例代码。最后，我们提供了一些最佳实践，以帮助您更好地使用 Box。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - GRPC框架入门指北",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, grpc",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_212_Grpc_Module.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "gRPC 是 Google 开源的高性能、通用的 RPC 框架，它采用了基于 HTTP/2 协议的二进制传输协议，支持多种语言，包括 Rust。Rust 语言 GRPC 模块是一个用于 Rust 语言的 gRPC 客户端和服务器实现，它提供了一个简单易用的 API，可以方便地创建和使用 gRPC 服务。基础用法创建 gRPC 服务器在 Rust 语言 GRPC 模块中，可以使用ServerBuilder结构体来创建 gRPC 服务器。下面是一个简单的示例：1234567891011121314151617181920use grpc::{Server, ServerBuilder};fn main() { let mut server = ServerBuilder::new_plain(); server.http.set_port(50051); server.add_service(proto::greeter_server::GreeterServer::new_service_def(GreeterImpl {})); let server = server.build().unwrap(); server.start(); server.wait();}struct GreeterImpl {}impl proto::greeter_server::Greeter for GreeterImpl { fn say_hello(&amp;self, _m: grpc::RequestOptions, req: proto::HelloRequest) -&gt; grpc::SingleResponse&lt;proto::HelloReply&gt; { let mut r = proto::HelloReply::new(); r.set_message(format!(\"Hello, {}!\", req.get_name())); grpc::SingleResponse::completed(r) }}这个示例中，我们创建了一个ServerBuilder对象，并通过http字段设置了服务器的端口号。然后我们使用add_service方法将我们实现的Greeter服务添加到服务器中。最后，我们通过build方法构建了服务器，并通过start方法启动了服务器。服务器启动后，我们通过wait方法等待客户端连接。创建 gRPC 客户端在 Rust 语言 GRPC 模块中，可以使用Client结构体来创建 gRPC 客户端。下面是一个简单的示例：12345678910use grpc::{ChannelBuilder, Client};fn main() { let ch = ChannelBuilder::new_plain(); let client = Client::new(ch); let mut req = proto::HelloRequest::new(); req.set_name(\"world\".to_string()); let resp = client.say_hello(grpc::RequestOptions::new(), req); println!(\"{}\", resp.wait().unwrap().get_message());}这个示例中，我们创建了一个ChannelBuilder对象，并使用Client结构体创建了一个 gRPC 客户端。然后我们创建了一个HelloRequest对象，并设置了它的name字段。最后，我们使用say_hello方法向服务器发送请求，并通过wait方法等待响应。响应对象是一个SingleResponse对象，我们通过unwrap方法获取了它的值，并打印了它的message字段。使用流式 RPC在 Rust 语言 GRPC 模块中，可以使用流式 RPC 来传输流数据。下面是一个简单的示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445use grpc::{Client, ClientStreamingSink, Server, ServerBuilder, ServerStreamingSink, WriteFlags};fn main() { let mut server = ServerBuilder::new_plain(); server.http.set_port(50051); server.add_service(proto::streaming::create_greeter_server(GreeterImpl {})); let server = server.build().unwrap(); server.start(); let ch = ChannelBuilder::new_plain(); let client = Client::new(ch); let reqs = vec![ proto::HelloRequest::new(), proto::HelloRequest::new(), proto::HelloRequest::new(), ]; let (mut tx, rx) = client.say_hello_stream(grpc::RequestOptions::new()).unwrap(); for req in reqs { tx = tx.send((req, WriteFlags::default())).unwrap(); } tx.close().unwrap(); for resp in rx.wait() { println!(\"{}\", resp.unwrap().get_message()); }}struct GreeterImpl {}impl proto::streaming::Greeter for GreeterImpl { fn say_hello_stream(&amp;self, _m: grpc::RequestOptions, _stream: grpc::StreamingRequest&lt;proto::HelloRequest&gt;) -&gt; grpc::StreamingResponse&lt;proto::HelloReply&gt; { let (tx, rx) = grpc::channel::mpsc::channel(0); std::thread::spawn(move || { for req in _stream.into_iter() { let mut r = proto::HelloReply::new(); r.set_message(format!(\"Hello, {}!\", req.get_name())); tx.send((r, WriteFlags::default())).unwrap(); } tx.close().unwrap(); }); grpc::StreamingResponse::new(rx) }}这个示例中，我们创建了一个Greeter服务，并实现了一个say_hello_stream方法，该方法接收一个StreamingRequest对象，并返回一个StreamingResponse对象。在该方法中，我们使用mpsc::channel方法创建了一个通道，用于传输流数据。然后我们使用std::thread::spawn方法创建了一个线程，该线程会将接收到的请求转换成响应，并通过通道发送给客户端。最后，我们使用StreamingResponse::new方法将通道包装成一个StreamingResponse对象，并将其返回给客户端。在客户端中，我们创建了一个say_hello_stream方法，并使用send方法向服务器发送请求。然后我们通过wait方法等待响应，并打印了响应的message字段。使用双向流式 RPC在 Rust 语言 GRPC 模块中，可以使用双向流式 RPC 来传输双向流数据。下面是一个简单的示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344use grpc::{Client, ClientStreamingSink, Server, ServerBuilder, ServerStreamingSink, StreamingSink, WriteFlags};fn main() { let mut server = ServerBuilder::new_plain(); server.http.set_port(50051); server.add_service(proto::streaming::create_greeter_server(GreeterImpl {})); let server = server.build().unwrap(); server.start(); let ch = ChannelBuilder::new_plain(); let client = Client::new(ch); let (mut tx, rx) = client.say_hello_bidi(grpc::RequestOptions::new()).unwrap(); let reqs = vec![ proto::HelloRequest::new(), proto::HelloRequest::new(), proto::HelloRequest::new(), ]; std::thread::spawn(move || { for req in reqs { tx = tx.send((req, WriteFlags::default())).unwrap(); let resp = rx.into_future().wait().unwrap().0; println!(\"{}\", resp.unwrap().get_message()); } tx.close().unwrap(); });}struct GreeterImpl {}impl proto::streaming::Greeter for GreeterImpl { fn say_hello_bidi(&amp;self, _m: grpc::RequestOptions, stream: grpc::StreamingRequest&lt;proto::HelloRequest&gt;) -&gt; grpc::StreamingResponse&lt;proto::HelloReply&gt; { let (tx, rx) = grpc::channel::mpsc::channel(0); std::thread::spawn(move || { for req in stream.into_iter() { let mut r = proto::HelloReply::new(); r.set_message(format!(\"Hello, {}!\", req.get_name())); tx.send((r, WriteFlags::default())).unwrap(); } tx.close().unwrap(); }); grpc::StreamingResponse::new(rx) }}这个示例中，我们创建了一个Greeter服务，并实现了一个say_hello_bidi方法，该方法接收一个StreamingRequest对象，并返回一个StreamingResponse对象。在该方法中，我们使用mpsc::channel方法创建了一个通道，用于传输流数据。然后我们使用std::thread::spawn方法创建了一个线程，该线程会将接收到的请求转换成响应，并通过通道发送给客户端。最后，我们使用StreamingResponse::new方法将通道包装成一个StreamingResponse对象，并将其返回给客户端。在客户端中，我们使用say_hello_bidi方法向服务器发送请求，并通过into_future方法获取响应。然后我们通过println方法打印了响应的message字段。进阶用法使用 tokio在 Rust 语言 GRPC 模块中，可以使用 tokio 来实现异步 RPC。下面是一个简单的示例：12345678910111213141516171819202122232425262728use grpc::{Client, ClientStreamingSink, Server, ServerBuilder, ServerStreamingSink, StreamingSink, WriteFlags};#[tokio::main]async fn main() { let mut server = ServerBuilder::new_plain(); server.http.set_port(50051); server.add_service(proto::greeter_server::GreeterServer::new_service_def(GreeterImpl {})); let server = server.build().unwrap(); server.start(); let ch = ChannelBuilder::new_plain(); let client = Client::new(ch); let mut req = proto::HelloRequest::new(); req.set_name(\"world\".to_string()); let resp = client.say_hello_async(grpc::RequestOptions::new(), req).await.unwrap(); println!(\"{}\", resp.get_message());}struct GreeterImpl {}impl proto::greeter_server::Greeter for GreeterImpl { fn say_hello(&amp;self, _m: grpc::RequestOptions, req: proto::HelloRequest) -&gt; grpc::SingleResponse&lt;proto::HelloReply&gt; { let mut r = proto::HelloReply::new(); r.set_message(format!(\"Hello, {}!\", req.get_name())); grpc::SingleResponse::completed(r) }}这个示例中，我们使用tokio::main宏来创建异步运行时。在服务器和客户端中，我们使用async关键字来定义异步函数。在客户端中，我们使用await关键字来等待异步响应。tokio 使用流式 RPC下面是一个使用 tokio 和流式 RPC 的示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253use grpc::{Client, ClientStreamingSink, Server, ServerBuilder, ServerStreamingSink, StreamingSink, WriteFlags};use tokio::sync::mpsc;#[tokio::main]async fn main() { let mut server = ServerBuilder::new_plain(); server.http.set_port(50051); server.add_service(proto::streaming::create_greeter_server(GreeterImpl {})); let server = server.build().unwrap(); server.start(); let ch = ChannelBuilder::new_plain(); let client = Client::new(ch); let (mut tx, rx) = mpsc::channel(10); let mut stream = client.say_hello_streaming(grpc::RequestOptions::new()).unwrap(); tokio::spawn(async move { while let Some(req) = rx.recv().await { stream.send((req, WriteFlags::default())).unwrap(); } stream.close().unwrap(); }); let reqs = vec![ proto::HelloRequest::new(), proto::HelloRequest::new(), proto::HelloRequest::new(), ]; for req in reqs { tx.send(req).await.unwrap(); } for resp in stream.into_stream().await { println!(\"{}\", resp.unwrap().get_message()); }}struct GreeterImpl {}impl proto::streaming::Greeter for GreeterImpl { fn say_hello_streaming(&amp;self, _m: grpc::RequestOptions, _stream: grpc::StreamingRequest&lt;proto::HelloRequest&gt;) -&gt; grpc::StreamingResponse&lt;proto::HelloReply&gt; { let (tx, rx) = grpc::channel::mpsc::channel(0); tokio::spawn(async move { for req in _stream.into_async_iter().await { let mut r = proto::HelloReply::new(); r.set_message(format!(\"Hello, {}!\", req.get_name())); tx.send((r, WriteFlags::default())).unwrap(); } tx.close().unwrap(); }); grpc::StreamingResponse::new(rx) }}这个示例中，我们使用tokio::sync::mpsc库来创建一个通道，用于传输流数据。在客户端中，我们使用say_hello_streaming方法向服务器发送请求，并将请求通过通道发送给异步任务。在异步任务中，我们使用into_async_iter方法将请求流转换成异步迭代器，并将响应通过通道发送给客户端。在客户端中，我们使用into_stream方法将响应流转换成异步流，并等待响应。使用 TLS 加密在 Rust 语言 GRPC 模块中，可以使用 TLS 加密来保护通信安全。下面是一个简单的示例：123456789101112131415161718192021222324252627282930313233343536373839404142use grpc::{ChannelBuilder, Client};use rustls::{Certificate, PrivateKey, ServerConfig};use std::fs::File;use std::io::BufReader;fn main() { let mut config = ServerConfig::new(rustls::NoClientAuth::new()); let cert_file = &amp;mut BufReader::new(File::open(\"server.crt\").unwrap()); let key_file = &amp;mut BufReader::new(File::open(\"server.key\").unwrap()); let cert_chain = rustls::internal::pemfile::certs(cert_file).unwrap(); let mut keys = rustls::internal::pemfile::rsa_private_keys(key_file).unwrap(); config.set_single_cert(cert_chain, keys.remove(0)).unwrap(); let mut server = grpc_tls::ServerBuilder::new_plain(); server.http.set_port(50051); server.http.set_tls(config); server.add_service(proto::greeter_server::GreeterServer::new_service_def(GreeterImpl {})); let server = server.build().unwrap(); server.start(); let mut config = rustls::ClientConfig::new(); let cert_file = &amp;mut BufReader::new(File::open(\"client.crt\").unwrap()); let key_file = &amp;mut BufReader::new(File::open(\"client.key\").unwrap()); let cert_chain = rustls::internal::pemfile::certs(cert_file).unwrap(); let mut keys = rustls::internal::pemfile::rsa_private_keys(key_file).unwrap(); config.set_single_client_cert(cert_chain, keys.remove(0)); let ch = ChannelBuilder::new_tls().rustls_config(config); let client = Client::new(ch); let mut req = proto::HelloRequest::new(); req.set_name(\"world\".to_string()); let resp = client.say_hello(grpc::RequestOptions::new(), req); println!(\"{}\", resp.wait().unwrap().get_message());}struct GreeterImpl {}impl proto::greeter_server::Greeter for GreeterImpl { fn say_hello(&amp;self, _m: grpc::RequestOptions, req: proto::HelloRequest) -&gt; grpc::SingleResponse&lt;proto::HelloReply&gt; { let mut r = proto::HelloReply::new(); r.set_message(format!(\"Hello, {}!\", req.get_name())); grpc::SingleResponse::completed(r) }}这个示例中，我们使用rustls库来创建 TLS 配置，并使用grpc_tls::ServerBuilder和ChannelBuilder::new_tls方法来创建带有 TLS 加密的服务器和客户端。在服务器中，我们使用set_single_cert方法来设置服务器证书和私钥。在客户端中，我们使用set_single_client_cert方法来设置客户端证书和私钥。总结本教程介绍了 GRPC 的基础使用方法，并针对 tokio 结合 GRPC 的进阶使用进入入门级的探讨。希望能帮助同学们掌握 Rust 语言 GRPC 的应用。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Serde序列化/反序列化模块入门指北",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Serde, 序列化, 反序列化, serde_json",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_211_Serde_Module.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "Serde 是一个用于序列化和反序列化 Rust 数据结构的库。它支持 JSON、BSON、YAML 等多种格式，并且可以自定义序列化和反序列化方式。Serde 的特点是代码简洁、易于使用、性能高效。它是 Rust 生态中最受欢迎的序列化库之一。基础用法安装在 Rust 项目中使用 Serde，需要在Cargo.toml文件中添加如下依赖：12[dependencies]serde = { version = \"1.0\", features = [\"derive\"] }其中features = [\"derive\"]表示使用 Serde 的派生宏，可以自动生成序列化和反序列化代码。序列化使用 Serde 进行序列化，需要先将数据结构实现serde::Serialize trait。例如，我们定义一个Animal结构体，包含名称和年龄两个字段：12345#[derive(Serialize)]struct Animal { name: String, age: u32,}然后，我们可以使用serde_json库将Animal结构体序列化为 JSON 字符串：12345678use serde_json;let animal = Animal { name: \"Tom\".to_owned(), age: 3,};let json = serde_json::to_string(&amp;animal).unwrap();println!(\"{}\", json); // {\"name\":\"Tom\",\"age\":3}反序列化使用 Serde 进行反序列化，需要先将数据结构实现serde::Deserialize trait。例如，我们定义一个Animal结构体，包含名称和年龄两个字段：12345#[derive(Deserialize)]struct Animal { name: String, age: u32,}然后，我们可以使用serde_json库将 JSON 字符串反序列化为Animal结构体：12345use serde_json;let json = r#\"{\"name\":\"Tom\",\"age\":3}\"#;let animal: Animal = serde_json::from_str(json).unwrap();println!(\"{:?}\", animal); // Animal { name: \"Tom\", age: 3 }进阶用法自定义序列化和反序列化如果默认的序列化和反序列化方式无法满足需求，可以自定义序列化和反序列化方式。例如，我们定义一个Animal结构体，包含名称和年龄两个字段，但是希望在序列化时，将名称转换为大写字母，反序列化时，将名称转换为小写字母：1234567891011121314151617181920212223use serde::{Serialize, Deserialize, Serializer, Deserializer};#[derive(Serialize, Deserialize)]struct Animal { #[serde(serialize_with = \"serialize_name\", deserialize_with = \"deserialize_name\")] name: String, age: u32,}fn serialize_name&lt;S&gt;(name: &amp;String, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;where S: Serializer,{ serializer.serialize_str(&amp;name.to_uppercase())}fn deserialize_name&lt;'de, D&gt;(deserializer: D) -&gt; Result&lt;String, D::Error&gt;where D: Deserializer&lt;'de&gt;,{ let name = String::deserialize(deserializer)?; Ok(name.to_lowercase())}在Animal结构体中，我们使用#[serde(serialize_with = \"serialize_name\", deserialize_with = \"deserialize_name\")]指定了自定义的序列化和反序列化方法。serialize_name函数将名称转换为大写字母，deserialize_name函数将名称转换为小写字母。序列化和反序列化枚举Serde 支持序列化和反序列化枚举类型。例如，我们定义一个Animal枚举，包含狗和猫两种类型：1234567use serde::{Serialize, Deserialize};#[derive(Serialize, Deserialize)]enum Animal { Dog { name: String, age: u32 }, Cat { name: String, age: u32 },}在序列化和反序列化枚举类型时，需要使用#[serde(tag = \"type\")]指定枚举类型的标签，例如：123456789use serde_json;let dog = Animal::Dog { name: \"Tom\".to_owned(), age: 3 };let json = serde_json::to_string(&amp;dog).unwrap();println!(\"{}\", json); // {\"type\":\"Dog\",\"name\":\"Tom\",\"age\":3}let json = r#\"{\"type\":\"Dog\",\"name\":\"Tom\",\"age\":3}\"#;let dog: Animal = serde_json::from_str(json).unwrap();println!(\"{:?}\", dog); // Dog { name: \"Tom\", age: 3 }序列化和反序列化结构体中的 OptionSerde 支持序列化和反序列化结构体中的Option类型。例如，我们定义一个Animal结构体，包含名称和年龄两个字段，其中名称可以为空：1234567use serde::{Serialize, Deserialize};#[derive(Serialize, Deserialize)]struct Animal { name: Option&lt;String&gt;, age: u32,}在序列化和反序列化结构体中的Option类型时，需要使用#[serde(skip_serializing_if = \"Option::is_none\")]指定当Option值为None时，不进行序列化。例如：12345678910111213use serde_json;let animal = Animal { name: Some(\"Tom\".to_owned()), age: 3 };let json = serde_json::to_string(&amp;animal).unwrap();println!(\"{}\", json); // {\"name\":\"Tom\",\"age\":3}let animal = Animal { name: None, age: 3 };let json = serde_json::to_string(&amp;animal).unwrap();println!(\"{}\", json); // {\"age\":3}let json = r#\"{\"age\":3}\"#;let animal: Animal = serde_json::from_str(json).unwrap();println!(\"{:?}\", animal); // Animal { name: None, age: 3 }序列化和反序列化结构体中的 VecSerde 支持序列化和反序列化结构体中的Vec类型。例如，我们定义一个Zoo结构体，包含多个Animal：123456use serde::{Serialize, Deserialize};#[derive(Serialize, Deserialize)]struct Zoo { animals: Vec&lt;Animal&gt;,}在序列化和反序列化结构体中的Vec类型时，Serde 会自动处理序列化和反序列化。例如：123456789101112use serde_json;let zoo = Zoo { animals: vec![ Animal { name: \"Tom\".to_owned(), age: 3 }, Animal { name: \"Jerry\".to_owned(), age: 2 },] };let json = serde_json::to_string(&amp;zoo).unwrap();println!(\"{}\", json); // {\"animals\":[{\"name\":\"Tom\",\"age\":3},{\"name\":\"Jerry\",\"age\":2}]}let json = r#\"{\"animals\":[{\"name\":\"Tom\",\"age\":3},{\"name\":\"Jerry\",\"age\":2}]}\"#;let zoo: Zoo = serde_json::from_str(json).unwrap();println!(\"{:?}\", zoo); // Zoo { animals: [Animal { name: \"Tom\", age: 3 }, Animal { name: \"Jerry\", age: 2 }] }序列化和反序列化结构体中的 HashMapSerde 支持序列化和反序列化结构体中的HashMap类型。例如，我们定义一个Zoo结构体，包含多个Animal，使用HashMap存储：1234567use std::collections::HashMap;use serde::{Serialize, Deserialize};#[derive(Serialize, Deserialize)]struct Zoo { animals: HashMap&lt;String, Animal&gt;,}在序列化和反序列化结构体中的HashMap类型时，Serde 会自动处理序列化和反序列化。例如：123456789101112use serde_json;let mut animals = HashMap::new();animals.insert(\"Tom\".to_owned(), Animal { name: \"Tom\".to_owned(), age: 3 });animals.insert(\"Jerry\".to_owned(), Animal { name: \"Jerry\".to_owned(), age: 2 });let zoo = Zoo { animals };let json = serde_json::to_string(&amp;zoo).unwrap();println!(\"{}\", json); // {\"animals\":{\"Jerry\":{\"name\":\"Jerry\",\"age\":2},\"Tom\":{\"name\":\"Tom\",\"age\":3}}}let json = r#\"{\"animals\":{\"Jerry\":{\"name\":\"Jerry\",\"age\":2},\"Tom\":{\"name\":\"Tom\",\"age\":3}}}\"#;let zoo: Zoo = serde_json::from_str(json).unwrap();println!(\"{:?}\", zoo); // Zoo { animals: {\"Tom\": Animal { name: \"Tom\", age: 3 }, \"Jerry\": Animal { name: \"Jerry\", age: 2 }} }总结本教程介绍了如何使用 Serde 进行序列化和反序列化，并且介绍了如何自定义序列化和反序列化逻辑。使用 Serde 可以轻松地将 Rust 数据结构转换为任何格式，并且可以通过自定义序列化和反序列化逻辑实现更高级的功能。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Copy特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Copy",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_122_Trait_Copy.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种系统级编程语言，它的设计目标是安全、并发、高效。Rust 语言具有许多特征，其中一个非常重要的特征是 Copy 特征。Copy 特征是 Rust 语言中的一个 trait，它允许我们在不使用引用的情况下复制一个值。这个特征的使用非常广泛，因为它可以提高程序的性能和可读性。 Copy特征只适用于基本类型和只包含基本类型成员的结构体和元组，而Clone特征适用于更广泛的类型。基础用法在本节中，我们将介绍 Copy 特征的基础用法，并提供至少 8 个示例。基本类型Rust 中的基本类型都实现了 Copy 特征，包括整数、浮点数、布尔值和字符。这意味着我们可以直接复制它们，而不需要使用引用。12345fn main() { let x = 42; let y = x; println!(\"x = {}, y = {}\", x, y);}输出：x = 42, y = 42结构体如果一个结构体中的所有字段都实现了 Copy 特征，那么这个结构体也会自动实现 Copy 特征。下面是一个示例：1234567891011#[derive(Copy, Clone)]struct Point { x: i32, y: i32,}fn main() { let p1 = Point { x: 1, y: 2 }; let p2 = p1; println!(\"p1 = ({}, {}), p2 = ({}, {})\", p1.x, p1.y, p2.x, p2.y);}输出：p1 = (1, 2), p2 = (1, 2)数组数组也实现了 Copy 特征，因此我们可以直接复制它们。12345fn main() { let a1 = [1, 2, 3]; let a2 = a1; println!(\"a1 = {:?}, a2 = {:?}\", a1, a2);}输出：a1 = [1, 2, 3], a2 = [1, 2, 3]元组如果一个元组中的所有元素都实现了 Copy 特征，那么这个元组也会自动实现 Copy 特征。12345fn main() { let t1 = (1, 2, 3); let t2 = t1; println!(\"t1 = {:?}, t2 = {:?}\", t1, t2);}输出：t1 = (1, 2, 3), t2 = (1, 2, 3)字符串字符串类型 String 并没有实现 Copy 特征，因为它是一个动态分配的类型。如果我们想要复制一个字符串，可以使用 clone 方法。12345fn main() { let s1 = String::from(\"hello\"); let s2 = s1.clone(); println!(\"s1 = {}, s2 = {}\", s1, s2);}输出：s1 = hello, s2 = hello枚举枚举类型也可以实现 Copy 特征，但是需要注意枚举的所有成员都实现了 Copy 特征。123456789101112#[derive(Copy, Clone)]enum Color { Red, Green, Blue,}fn main() { let c1 = Color::Red; let c2 = c1; println!(\"c1 = {:?}, c2 = {:?}\", c1, c2);}输出：c1 = Red, c2 = Red引用引用类型不实现 Copy 特征，因为它们是指向内存中的数据的指针。如果我们想要复制一个引用，需要使用 clone 方法。12345fn main() { let v1 = vec![1, 2, 3]; let v2 = v1.clone(); println!(\"v1 = {:?}, v2 = {:?}\", v1, v2);}输出：v1 = [1, 2, 3], v2 = [1, 2, 3]函数函数类型也不实现 Copy 特征，因为函数是代码的一部分，而不是数据。如果我们想要复制一个函数，可以使用指针或闭包。123456789fn add(x: i32, y: i32) -&gt; i32 { x + y}fn main() { let f1 = add; let f2 = f1; println!(\"f1(2, 3) = {}, f2(2, 3) = {}\", f1(2, 3), f2(2, 3));}输出：f1(2, 3) = 5, f2(2, 3) = 5进阶用法在本节中，我们将介绍 Copy 特征的进阶用法，并提供至少 4 个示例。自定义类型我们可以为自定义类型实现 Copy 特征，这需要我们手动实现 Copy trait 并为每个字段实现 Copy 特征。下面是一个示例：12345678910111213141516171819202122232425#[derive(Copy, Clone)]struct Person { name: String, age: i32,}impl Copy for Person {}impl Clone for Person { fn clone(&amp;self) -&gt; Person { Person { name: self.name.clone(), age: self.age, } }}fn main() { let p1 = Person { name: String::from(\"Alice\"), age: 25, }; let p2 = p1; println!(\"p1 = {:?}, p2 = {:?}\", p1, p2);}输出：p1 = Person { name: \"Alice\", age: 25 }, p2 = Person { name: \"Alice\", age: 25 }复杂类型如果一个类型中包含了其他类型，我们需要为这些类型实现 Copy 特征，才能为这个类型实现 Copy 特征。12345678910111213141516171819202122232425262728293031323334#[derive(Copy, Clone)]struct Rectangle { top_left: Point, bottom_right: Point,}#[derive(Copy, Clone)]struct Point { x: i32, y: i32,}impl Copy for Point {}impl Clone for Point { fn clone(&amp;self) -&gt; Point { Point { x: self.x, y: self.y, } }}fn main() { let r1 = Rectangle { top_left: Point { x: 0, y: 0 }, bottom_right: Point { x: 10, y: 10 }, }; let r2 = r1; println!( \"r1 = ({}, {}), ({}, {}), r2 = ({}, {}), ({}, {})\", r1.top_left.x, r1.top_left.y, r1.bottom_right.x, r1.bottom_right.y, r2.top_left.x, r2.top_left.y, r2.bottom_right.x, r2.bottom_right.y, );}输出：r1 = (0, 0), (10, 10), r2 = (0, 0), (10, 10)引用计数引用计数类型 Rc 和 Arc 也实现了 Copy 特征，但它们并不总是安全的。如果我们复制一个 Rc 或 Arc，会增加它们的引用计数，这可能会导致内存泄漏或数据竞争。因此，在使用 Rc 或 Arc 时，我们应该避免复制它们。1234567use std::rc::Rc;fn main() { let x = Rc::new(42); let y = x.clone(); println!(\"x = {}, y = {}\", x, y);}输出：x = 42, y = 42unsafe 代码如果我们在 unsafe 代码中使用 Copy 特征，需要注意内存安全。因为 unsafe 代码可以直接操作内存，如果我们复制一个指针或引用，可能会导致悬垂指针或内存泄漏。因此，在使用 Copy 特征时，我们应该特别小心。1234567891011121314unsafe fn copy_memory&lt;T: Copy&gt;(src: *const T, dst: *mut T, count: usize) { let src_slice = std::slice::from_raw_parts(src, count); let dst_slice = std::slice::from_raw_parts_mut(dst, count); dst_slice.copy_from_slice(src_slice);}fn main() { let mut a = [1, 2, 3]; let mut b = [0; 3]; unsafe { copy_memory(a.as_ptr(), b.as_mut_ptr(), a.len()); } println!(\"a = {:?}, b = {:?}\", a, b);}输出：a = [1, 2, 3], b = [1, 2, 3]最佳实践在本节中，我们将介绍使用 Copy 特征的最佳实践，并提供示例代码。避免不必要的引用如果一个类型实现了 Copy 特征，我们可以直接复制它，而不需要使用引用。这可以避免不必要的内存分配和释放，提高程序的性能。12345678910fn add(x: i32, y: i32) -&gt; i32 { x + y}fn main() { let x = 1; let y = 2; let z = add(x, y); println!(\"z = {}\", z);}输出：z = 3避免不必要的 clone如果一个类型没有实现 Copy 特征，我们需要使用 clone 方法复制它。但是，clone 方法可能会分配新的内存，因此我们应该避免不必要的 clone。123456fn main() { let s1 = String::from(\"hello\"); let s2 = s1.clone(); let s3 = s1.clone(); println!(\"s1 = {}, s2 = {}, s3 = {}\", s1, s2, s3);}输出：s1 = hello, s2 = hello, s3 = hello避免复制大型数据如果一个类型实现了 Copy 特征，我们可以直接复制它，但是如果这个类型包含大量的数据，复制它可能会导致性能问题。因此，在复制大型数据时，我们应该使用引用或指针。12345fn main() { let v1 = vec![1, 2, 3]; let v2 = &amp;v1; println!(\"v1 = {:?}, v2 = {:?}\", v1, v2);}输出：v1 = [1, 2, 3], v2 = [1, 2, 3]避免复制不可变数据如果一个类型是不可变的，我们可以使用引用或指针来避免复制它。这可以避免不必要的内存分配和释放，提高程序的性能。12345fn main() { let a = [1, 2, 3]; let b = &amp;a; println!(\"a = {:?}, b = {:?}\", a, b);}输出：a = [1, 2, 3], b = [1, 2, 3]结论Copy 特征是 Rust 语言中非常重要的一个特征，它可以提高程序的性能和可读性。在使用 Copy 特征时，我们需要遵循最佳实践，避免不必要的内存分配和释放，提高程序的性能和安全性。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Clone特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Clone",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_121_Trait_Clone.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种系统编程语言，其设计目标是提供安全、并发和高性能。Rust 提供了一些特殊的语言特性，其中一个重要的特性就是 Clone。Clone 是 Rust 语言中的一个 trait，它允许我们复制一个值，而不是只是简单地将其移动。Clone 特征在 Rust 语言中非常重要，因为它允许我们在代码中复制值，而不是只是移动它们，这对于一些场景非常有用。 Copy特征只适用于基本类型和只包含基本类型成员的结构体和元组，而Clone特征适用于更广泛的类型。基础用法克隆一个整数我们可以使用 clone 方法来克隆一个整数。下面是一个示例：1234let a = 5;let b = a.clone();println!(\"a = {}, b = {}\", a, b);输出：a = 5, b = 5克隆一个字符串我们也可以使用 clone 方法来克隆一个字符串。下面是一个示例：1234let a = String::from(\"hello\");let b = a.clone();println!(\"a = {}, b = {}\", a, b);输出：a = hello, b = hello克隆一个数组我们也可以使用 clone 方法来克隆一个数组。下面是一个示例：1234let a = [1, 2, 3];let b = a.clone();println!(\"a = {:?}, b = {:?}\", a, b);输出：a = [1, 2, 3], b = [1, 2, 3]克隆一个结构体我们也可以使用 clone 方法来克隆一个结构体。下面是一个示例：12345678910111213#[derive(Clone)]struct Person { name: String, age: u32,}let a = Person { name: String::from(\"Alice\"), age: 30,};let b = a.clone();println!(\"a = {:?}, b = {:?}\", a, b);输出：a = Person { name: \"Alice\", age: 30 }, b = Person { name: \"Alice\", age: 30 }克隆一个枚举我们也可以使用 clone 方法来克隆一个枚举。下面是一个示例：1234567891011#[derive(Clone)]enum Color { Red, Green, Blue,}let a = Color::Red;let b = a.clone();println!(\"a = {:?}, b = {:?}\", a, b);输出：a = Red, b = Red克隆一个 Vec我们也可以使用 clone 方法来克隆一个 Vec。下面是一个示例：1234let a = vec![1, 2, 3];let b = a.clone();println!(\"a = {:?}, b = {:?}\", a, b);输出：a = [1, 2, 3], b = [1, 2, 3]克隆一个 HashMap我们也可以使用 clone 方法来克隆一个 HashMap。下面是一个示例：12345678use std::collections::HashMap;let mut a = HashMap::new();a.insert(\"one\", 1);a.insert(\"two\", 2);let b = a.clone();println!(\"a = {:?}, b = {:?}\", a, b);输出：a = {\"one\": 1, \"two\": 2}, b = {\"one\": 1, \"two\": 2}克隆一个自定义类型我们也可以使用 clone 方法来克隆一个自定义类型。下面是一个示例：1234567891011#[derive(Clone)]struct MyType { data: Vec&lt;u32&gt;,}let a = MyType { data: vec![1, 2, 3],};let b = a.clone();println!(\"a = {:?}, b = {:?}\", a, b);输出：a = MyType { data: [1, 2, 3] }, b = MyType { data: [1, 2, 3] }进阶用法自定义 Clone 方法有时候，我们需要自定义 Clone 方法来实现特定的克隆行为。下面是一个示例：12345678910111213141516171819#[derive(Clone)]struct MyType { data: Vec&lt;u32&gt;,}impl MyType { fn custom_clone(&amp;self) -&gt; MyType { MyType { data: self.data.iter().map(|x| x + 1).collect(), } }}let a = MyType { data: vec![1, 2, 3],};let b = a.custom_clone();println!(\"a = {:?}, b = {:?}\", a, b);输出：a = MyType { data: [1, 2, 3] }, b = MyType { data: [2, 3, 4] }克隆一个闭包我们可以使用 clone 方法来克隆一个闭包。下面是一个示例：12345let a = |x| x + 1;let b = a.clone();println!(\"{}\", a(1));println!(\"{}\", b(2));输出：23克隆一个迭代器我们也可以使用 clone 方法来克隆一个迭代器。下面是一个示例：12345678910let a = vec![1, 2, 3].into_iter();let b = a.clone();for x in a { println!(\"{}\", x);}for x in b { println!(\"{}\", x);}输出：123123克隆一个 Rc我们也可以使用 clone 方法来克隆一个 Rc。下面是一个示例：123456use std::rc::Rc;let a = Rc::new(5);let b = a.clone();println!(\"a = {}, b = {}\", a, b);输出：a = 5, b = 5最佳实践在使用 Clone 特征时，有一些最佳实践可以帮助我们编写更好的代码。 只克隆必要的数据在克隆一个对象时，我们应该只克隆必要的数据，而不是克隆整个对象。这样可以减少内存使用量和克隆时间。 实现自定义 Clone 方法有时候，我们需要实现自定义的 Clone 方法来实现特定的克隆行为。这可以帮助我们更好地控制克隆行为。 使用 Rc 代替 Clone在一些场景下，我们可以使用 Rc 代替 Clone 来避免克隆数据。Rc 是一个引用计数类型，它允许多个所有者共享同一个对象。 避免过度使用 Clone在编写代码时，我们应该避免过度使用 Clone。因为克隆数据会增加内存使用量和克隆时间，所以我们应该尽可能避免不必要的克隆。结论在本教程中，我们学习了 Rust 语言中的 Clone 特征。我们了解了如何使用 Clone 特征来克隆整数、字符串、数组、结构体、枚举、Vec、HashMap 和自定义类型。我们还学习了如何实现自定义的 Clone 方法，如何克隆闭包、迭代器和 Rc，以及一些最佳实践。通过学习本教程，我们可以更好地使用 Rust 语言中的 Clone 特征，编写更好的代码。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Deref特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, deref",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_120_Trait_Deref.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "在 Rust 语言中，Deref 特征用于将一个类型的引用转换为另一个类型的引用。这个特征在 Rust 中非常常见，特别是在处理数据结构中，例如字符串、向量等。Deref 特征的作用是让代码更加简洁，同时也提高了代码的可读性。基础用法在 Rust 中，Deref 特征是通过实现 Deref trait 来实现的。Deref trait 定义了一个叫做 deref 的方法，它返回一个指向当前类型的引用。下面是一个简单的示例代码：12345678910111213141516struct MyString { s: String,}impl Deref for MyString { type Target = String; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.s }}fn main() { let my_string = MyString { s: String::from(\"Hello, world!\") }; println!(\"{}\", *my_string);}在这个示例代码中，我们定义了一个 MyString 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyString 结构体中的 String 类型的引用。在 main 函数中，我们通过解引用运算符（*）来获取 MyString 结构体中的 String 类型的值，并将其打印出来。下面是更多的示例代码：使用 Deref 转换字符串类型12345fn main() { let my_string = MyString { s: String::from(\"Hello, world!\") }; let s: &amp;str = &amp;*my_string; println!(\"{}\", s);}在这个示例代码中，我们使用 Deref 将 MyString 结构体中的 String 类型转换为字符串类型，并将其赋值给 s 变量。最后，我们将 s 变量打印出来。使用 Deref 转换向量类型1234567891011121314151617struct MyVec&lt;T&gt; { v: Vec&lt;T&gt;,}impl&lt;T&gt; Deref for MyVec&lt;T&gt; { type Target = Vec&lt;T&gt;; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.v }}fn main() { let my_vec = MyVec { v: vec![1, 2, 3] }; let v: &amp;Vec&lt;i32&gt; = &amp;*my_vec; println!(\"{:?}\", v);}在这个示例代码中，我们定义了一个 MyVec 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyVec 结构体中的 Vec 类型的引用。在 main 函数中，我们使用 Deref 将 MyVec 结构体中的 Vec 类型转换为 Vec 类型，并将其赋值给 v 变量。最后，我们将 v 变量打印出来。使用 Deref 转换智能指针类型123456789101112131415struct MyBox&lt;T&gt;(T);impl&lt;T&gt; Deref for MyBox&lt;T&gt; { type Target = T; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.0 }}fn main() { let my_box = MyBox(String::from(\"Hello, world!\")); let s: &amp;str = &amp;*my_box; println!(\"{}\", s);}在这个示例代码中，我们定义了一个 MyBox 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyBox 结构体中的 T 类型的引用。在 main 函数中，我们使用 Deref 将 MyBox 结构体中的 String 类型转换为字符串类型，并将其赋值给 s 变量。最后，我们将 s 变量打印出来。使用 Deref 转换元组类型123456789101112131415struct MyTuple&lt;T&gt;(T);impl&lt;T&gt; Deref for MyTuple&lt;T&gt; { type Target = T; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.0 }}fn main() { let my_tuple = MyTuple((1, 2, 3)); let t: &amp;(i32, i32, i32) = &amp;*my_tuple; println!(\"{:?}\", t);}在这个示例代码中，我们定义了一个 MyTuple 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyTuple 结构体中的 T 类型的引用。在 main 函数中，我们使用 Deref 将 MyTuple 结构体中的元组类型转换为元组类型，并将其赋值给 t 变量。最后，我们将 t 变量打印出来。使用 Deref 转换可变引用类型1234567891011121314151617181920212223struct MyString { s: String,}impl Deref for MyString { type Target = String; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.s }}impl MyString { fn to_uppercase(&amp;mut self) { self.s = self.s.to_uppercase(); }}fn main() { let mut my_string = MyString { s: String::from(\"Hello, world!\") }; my_string.to_uppercase(); println!(\"{}\", *my_string);}在这个示例代码中，我们定义了一个 MyString 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyString 结构体中的 String 类型的引用。在 MyString 结构体中，我们定义了一个 to_uppercase 方法，用于将字符串转换为大写。在 main 函数中，我们使用 Deref 将 MyString 结构体中的 String 类型转换为可变引用类型，并调用 to_uppercase 方法将字符串转换为大写。最后，我们将转换后的字符串打印出来。使用 Deref 转换为裸指针类型1234567891011121314151617struct MyString { s: String,}impl Deref for MyString { type Target = String; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.s }}fn main() { let my_string = MyString { s: String::from(\"Hello, world!\") }; let p: *const String = &amp;*my_string; println!(\"{:p}\", p);}在这个示例代码中，我们定义了一个 MyString 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyString 结构体中的 String 类型的引用。在 main 函数中，我们使用 Deref 将 MyString 结构体中的 String 类型转换为裸指针类型，并将其赋值给 p 变量。最后，我们将 p 变量打印出来。使用 Deref 转换为引用计数类型123456789101112131415161718192021use std::rc::Rc;struct MyString { s: Rc&lt;String&gt;,}impl Deref for MyString { type Target = String; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.s }}fn main() { let my_string = MyString { s: Rc::new(String::from(\"Hello, world!\")) }; let s: &amp;str = &amp;*my_string; let my_string2 = my_string.clone(); let s2: &amp;str = &amp;*my_string2; println!(\"{} {}\", s, s2);}在这个示例代码中，我们定义了一个 MyString 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyString 结构体中的 Rc 类型的引用。在 main 函数中，我们使用 Deref 将 MyString 结构体中的 String 类型转换为字符串类型，并将其赋值给 s 变量。然后，我们使用 Rc::clone 方法克隆 my_string 变量，并将其赋值给 my_string2 变量。最后，我们将 my_string 和 my_string2 变量中的字符串打印出来。使用 Deref 转换为切片类型1234567891011121314151617struct MyVec&lt;T&gt; { v: Vec&lt;T&gt;,}impl&lt;T&gt; Deref for MyVec&lt;T&gt; { type Target = Vec&lt;T&gt;; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.v }}fn main() { let my_vec = MyVec { v: vec![1, 2, 3] }; let slice: &amp;[i32] = &amp;*my_vec; println!(\"{:?}\", slice);}在这个示例代码中，我们定义了一个 MyVec 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyVec 结构体中的 Vec 类型的引用。在 main 函数中，我们使用 Deref 将 MyVec 结构体中的 Vec 类型转换为切片类型，并将其赋值给 slice 变量。最后，我们将 slice 变量打印出来。进阶用法在 Rust 中，Deref 特征不仅可以用于简单的类型转换，还可以用于更复杂的场景。下面是一些进阶用法的示例代码：使用 Deref 进行方法调用123456789101112131415161718192021222324252627struct MyString { s: String,}impl Deref for MyString { type Target = String; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.s }}impl MyString { fn new(s: &amp;str) -&gt; MyString { MyString { s: String::from(s) } } fn to_uppercase(&amp;mut self) { self.s = self.s.to_uppercase(); }}fn main() { let mut my_string = MyString::new(\"Hello, world!\"); my_string.to_uppercase(); println!(\"{}\", *my_string);}在这个示例代码中，我们定义了一个 MyString 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyString 结构体中的 String 类型的引用。在 MyString 结构体中，我们定义了一个 new 方法，用于创建 MyString 结构体。我们还定义了一个 to_uppercase 方法，用于将字符串转换为大写。在 main 函数中，我们使用 Deref 将 MyString 结构体中的 String 类型转换为可变引用类型，并调用 to_uppercase 方法将字符串转换为大写。最后，我们将转换后的字符串打印出来。使用 Deref 进行运算符重载12345678910111213141516171819202122232425262728use std::ops::Add;struct MyString { s: String,}impl Deref for MyString { type Target = String; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.s }}impl Add for &amp;MyString { type Output = MyString; fn add(self, other: &amp;MyString) -&gt; MyString { MyString { s: format!(\"{}{}\", self, other) } }}fn main() { let my_string1 = MyString { s: String::from(\"Hello, \") }; let my_string2 = MyString { s: String::from(\"world!\") }; let my_string3 = &amp;my_string1 + &amp;my_string2; println!(\"{}\", *my_string3);}在这个示例代码中，我们定义了一个 MyString 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyString 结构体中的 String 类型的引用。我们还实现了 Add trait，用于将两个 MyString 结构体合并为一个。在 main 函数中，我们使用 Deref 将 MyString 结构体中的 String 类型转换为引用类型，并使用 + 运算符将两个 MyString 结构体合并为一个。最后，我们将合并后的字符串打印出来。使用 Deref 进行类型转换12345678910111213141516171819202122232425use std::convert::From;struct MyString { s: String,}impl Deref for MyString { type Target = String; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.s }}impl From&lt;MyString&gt; for u32 { fn from(my_string: MyString) -&gt; u32 { my_string.parse().unwrap() }}fn main() { let my_string = MyString { s: String::from(\"123\") }; let n: u32 = u32::from(*my_string); println!(\"{}\", n);}在这个示例代码中，我们定义了一个 MyString 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyString 结构体中的 String 类型的引用。我们还实现了 From trait，用于将 MyString 结构体转换为 u32 类型。在 main 函数中，我们使用 Deref 将 MyString 结构体中的 String 类型转换为字符串类型，并使用 From trait 将字符串类型转换为 u32 类型。最后，我们将 u32 类型的值打印出来。使用 Deref 进行类型推导1234567891011121314151617181920struct MyString { s: String,}impl Deref for MyString { type Target = String; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.s }}fn print_string(s: &amp;str) { println!(\"{}\", s);}fn main() { let my_string = MyString { s: String::from(\"Hello, world!\") }; print_string(&amp;*my_string);}在这个示例代码中，我们定义了一个 MyString 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyString 结构体中的 String 类型的引用。我们还定义了一个 print_string 函数，用于打印字符串。在 main 函数中，我们使用 Deref 将 MyString 结构体中的 String 类型转换为字符串类型，并将其传递给 print_string 函数。由于 Rust 编译器可以推导出参数类型，因此我们不需要显式地指定参数类型。最佳实践在 Rust 中，Deref 特征是一个非常有用的特征，可以帮助我们编写更加简洁、易读的代码。以下是一些最佳实践： 在定义数据结构时，考虑是否需要实现 Deref trait，以方便类型转换。 在使用 Deref 特征时，尽量避免使用 * 运算符，而是使用 &amp; 运算符将类型转换为引用类型。 在实现 Deref trait 时，使用 type Target = T; 来指定目标类型。 在使用 Deref 特征时，注意类型转换的顺序，以避免出现类型错误。 在使用 Deref 特征时，注意避免引用循环，以避免出现内存泄漏。下面是一个示例代码，演示了如何使用 Deref 特征来简化代码：12345678910111213141516use std::ops::Deref;struct MyString(String);impl Deref for MyString { type Target = String; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.0 }}fn main() { let my_string = MyString(String::from(\"Hello, world!\")); println!(\"{}\", my_string.len());}在这个示例代码中，我们定义了一个 MyString 结构体，并实现了 Deref trait。在 deref 方法中，我们返回了一个指向 MyString 结构体中的 String 类型的引用。在 main 函数中，我们使用 MyString 结构体的 len 方法来获取字符串的长度，而不需要使用 * 运算符来解引用 MyString 结构体。这样可以让代码更加简洁、易读。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Unsafe",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, unsafe",
      "url"         : "./rust/2023/04/03/rust_lang_tutorial_119_unsafe.html",
      "date"        : "2023-04-03 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一门现代化的系统编程语言，它拥有高性能、内存安全和并发性等特点。Rust 的语法设计非常优秀，其中 match 语句是一种非常强大的语言特性。match 语句可以让我们根据不同的匹配模式执行不同的代码，这在处理复杂的逻辑时非常有用。在本教程中，我们将深入了解 Rust 的 match 语句，包括基础用法、进阶用法和实践经验等方面。基础用法match 语句是 Rust 中的一种控制流语句，它可以让我们根据不同的模式匹配执行不同的代码。match 语句的基本语法如下：1234567891011match value { pattern1 =&gt; { // code1 } pattern2 =&gt; { // code2 } _ =&gt; { // 没有任何匹配 }}其中，value 是要匹配的变量，pattern 是匹配模式，=&gt;后面是要执行的代码块。如果 value 匹配了某个模式，就会执行对应的代码块。如果 value 没有匹配任何模式，就会执行默认的代码块（即_ =&gt; {…}）。接下来，我们将通过一些示例来介绍 match 语句的基础用法。匹配整数1234567let x = 1;match x { 1 =&gt; println!(\"x is one\"), 2 =&gt; println!(\"x is two\"), _ =&gt; println!(\"x is not one or two\"),}在这个示例中，我们定义了一个整数变量 x，并使用 match 语句匹配它。如果 x 等于 1，就会执行第一个代码块，输出”x is one”；如果 x 等于 2，就会执行第二个代码块，输出”x is two”；如果 x 不等于 1 或 2，就会执行默认的代码块，输出”x is not one or two”。匹配枚举类型12345678910111213enum Color { Red, Green, Blue,}let color = Color::Green;match color { Color::Red =&gt; println!(\"The color is red\"), Color::Green =&gt; println!(\"The color is green\"), Color::Blue =&gt; println!(\"The color is blue\"),}在这个示例中，我们定义了一个枚举类型 Color，并将变量 color 赋值为 Color::Green。然后，我们使用 match 语句匹配 color。如果 color 等于 Color::Red，就会执行第一个代码块，输出”The color is red”；如果 color 等于 Color::Green，就会执行第二个代码块，输出”The color is green”；如果 color 等于 Color::Blue，就会执行第三个代码块，输出”The color is blue”。匹配元组12345678let point = (1, 2);match point { (0, 0) =&gt; println!(\"The point is at the origin\"), (_, 0) =&gt; println!(\"The point is on the x-axis\"), (0, _) =&gt; println!(\"The point is on the y-axis\"), (x, y) =&gt; println!(\"The point is at ({}, {})\", x, y),}在这个示例中，我们定义了一个元组变量 point，并使用 match 语句匹配它。如果 point 等于(0, 0)，就会执行第一个代码块，输出”The point is at the origin”；如果 point 的第二个元素等于 0，就会执行第二个代码块，输出”The point is on the x-axis”；如果 point 的第一个元素等于 0，就会执行第三个代码块，输出”The point is on the y-axis”；否则，就会执行第四个代码块，输出”The point is at ({}, {})”。匹配范围1234567let age = 20;match age { 0..=17 =&gt; println!(\"You are a minor\"), 18..=64 =&gt; println!(\"You are an adult\"), _ =&gt; println!(\"You are a senior\"),}在这个示例中，我们定义了一个整数变量 age，并使用 match 语句匹配它。如果 age 的值在 0 到 17 之间，就会执行第一个代码块，输出”You are a minor”；如果 age 的值在 18 到 64 之间，就会执行第二个代码块，输出”You are an adult”；否则，就会执行默认的代码块，输出”You are a senior”。匹配引用1234567let x = 1;let y = &amp;x;match y { &amp;1 =&gt; println!(\"The value is one\"), _ =&gt; println!(\"The value is not one\"),}在这个示例中，我们定义了一个整数变量 x 和一个指向 x 的引用 y。然后，我们使用 match 语句匹配 y。由于 y 是一个引用，所以我们需要在模式中使用&amp;符号来匹配它。如果 y 指向的值等于 1，就会执行第一个代码块，输出”The value is one”；否则，就会执行默认的代码块，输出”The value is not one”。匹配守卫1234567let x = 5;match x { n if n &lt; 0 =&gt; println!(\"The value is negative\"), n if n &gt; 10 =&gt; println!(\"The value is greater than 10\"), _ =&gt; println!(\"The value is between 0 and 10\"),}在这个示例中，我们定义了一个整数变量 x，并使用 match 语句匹配它。在模式中，我们使用 if 语句添加了一个守卫条件。如果 x 小于 0，就会执行第一个代码块，输出”The value is negative”；如果 x 大于 10，就会执行第二个代码块，输出”The value is greater than 10”；否则，就会执行默认的代码块，输出”The value is between 0 and 10”。进阶用法除了上面介绍的基础用法，match 语句还有一些进阶用法，可以让我们更加灵活地使用它。接下来，我们将介绍 match 语句的一些进阶用法，并通过示例来演示它们的用法。使用|匹配多个模式123456let x = 1;match x { 1 | 2 =&gt; println!(\"The value is one or two\"), _ =&gt; println!(\"The value is not one or two\"),} 在这个示例中，我们定义了一个整数变量 x，并使用 match 语句匹配它。在模式中，我们使用 符号来匹配多个模式。如果 x 等于 1 或 2，就会执行第一个代码块，输出”The value is one or two”；否则，就会执行默认的代码块，输出”The value is not one or two”。 使用..=匹配范围1234567let age = 20;match age { 0..=17 =&gt; println!(\"You are a minor\"), 18..=64 =&gt; println!(\"You are an adult\"), _ =&gt; println!(\"You are a senior\"),}在这个示例中，我们定义了一个整数变量 age，并使用 match 语句匹配它。在模式中，我们使用..=符号来匹配范围。如果 age 的值在 0 到 17 之间，就会执行第一个代码块，输出”You are a minor”；如果 age 的值在 18 到 64 之间，就会执行第二个代码块，输出”You are an adult”；否则，就会执行默认的代码块，输出”You are a senior”。使用@绑定变量12345678let x = Some(5);match x { Some(n @ 1..=10) =&gt; println!(\"The value is between 1 and 10: {}\", n), Some(n @ 11..=20) =&gt; println!(\"The value is between 11 and 20: {}\", n), Some(_) =&gt; println!(\"The value is not between 1 and 20\"), None =&gt; (),}在这个示例中，我们定义了一个 Option 类型的变量 x，并使用 match 语句匹配它。在模式中，我们使用@符号来绑定一个变量。如果 x 是一个 Some 类型，并且它的值在 1 到 10 之间，就会执行第一个代码块，输出”The value is between 1 and 10”；如果 x 是一个 Some 类型，并且它的值在 11 到 20 之间，就会执行第二个代码块，输出”The value is between 11 and 20”；如果 x 是一个 Some 类型，但它的值不在 1 到 20 之间，就会执行第三个代码块，输出”The value is not between 1 and 20”；如果 x 是一个 None 类型，就不会执行任何代码。使用_忽略模式123456let x = Some(5);match x { Some(_) =&gt; println!(\"The value is some\"), None =&gt; println!(\"The value is none\"),}在这个示例中，我们定义了一个 Option 类型的变量 x，并使用 match 语句匹配它。在模式中，我们使用_符号来忽略模式。如果 x 是一个 Some 类型，就会执行第一个代码块，输出”The value is some”；如果 x 是一个 None 类型，就会执行第二个代码块，输出”The value is none”。使用 if let 简化模式匹配1234567let x = Some(5);if let Some(n) = x { println!(\"The value is {}\", n);} else { println!(\"The value is None\");}在这个示例中，我们定义了一个 Option 类型的变量 x，并使用 if let 语句匹配它。如果 x 是一个 Some 类型，就会执行 if 语句块，输出”The value is x”；如果 x 是一个 None 类型，就会执行 else 语句块，输出”The value is None”。使用 if let 语句可以简化模式匹配的代码，使代码更加清晰和简洁。使用 while let 遍历迭代器1234let mut v = vec![1, 2, 3];while let Some(n) = v.pop() { println!(\"{}\", n);}在这个示例中，我们定义了一个整数数组 v，并使用 while let 语句遍历它的元素。在 while let 语句中，我们使用 pop()方法从数组中依次取出元素，并将它们绑定到变量 n 中。如果数组中还有元素，就会执行 while 语句块，输出元素的值；否则，就会退出 while 循环。使用 while let 语句可以方便地遍历迭代器或者其他可迭代对象。实践经验在实际开发中，我们经常需要使用 match 语句来处理复杂的逻辑。以下是一些实践经验，可以帮助我们更好地使用 match 语句。给每个分支加上花括号在 match 语句中，每个分支的代码块通常都比较复杂，因此我们应该给每个分支加上花括号，以便更好地阅读和维护代码。例如：1234567891011121314let x = 1;match x { 1 =&gt; { println!(\"The value is one\"); println!(\"This is a long message\"); } 2 =&gt; { println!(\"The value is two\"); } _ =&gt; { println!(\"The value is not one or two\"); }}使用_忽略不需要的变量在 match 语句中，我们可以使用_符号来忽略不需要的变量。这样可以简化代码，并且让代码更加清晰。例如：1234567let x = (1, 2);match x { (1, _) =&gt; println!(\"The first element is 1\"), (_, 2) =&gt; println!(\"The second element is 2\"), _ =&gt; (),}在这个示例中，我们使用_符号来忽略第二个元素，因为我们只关心第一个元素是否等于 1。使用 if let 简化模式匹配在某些情况下，我们只需要匹配一个模式，而不需要处理其他模式。此时，我们可以使用 if let 语句来简化模式匹配的代码。例如：12345let x = Some(5);if let Some(n) = x { println!(\"The value is {}\", n);}在这个示例中，我们只需要匹配 Some 类型的值，而不需要处理 None 类型的值。因此，使用 if let 语句可以让代码更加简洁和清晰。使用 while let 遍历迭代器在遍历迭代器时，我们可以使用 while let 语句来依次取出元素，并进行处理。例如：123456789101112fn main() { let v = vec![1, 2, 3]; for n in &amp;v { println!(\"{}\", n); } let mut v = vec![1, 2, 3]; while let Some(n) = v.pop() { println!(\"{}\", n); }}在这个示例中，我们使用 for 循环和 while let 语句来遍历整数数组 v 的元素。使用 while let 语句可以让代码更加简洁和清晰。总结match 语句是 Rust 中非常强大的语言特性，它可以让我们根据不同的匹配模式执行不同的代码。在本教程中，我们介绍了 match 语句的基础用法、进阶用法和实践经验等方面。通过学习本教程，相信读者已经掌握了 match 语句的基本用法，并能够在实际开发中灵活运用它。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 匹配模式",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Match",
      "url"         : "./rust/2023/04/02/rust_lang_tutorial_118_Match.html",
      "date"        : "2023-04-02 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一门现代化的系统编程语言，它拥有高性能、内存安全和并发性等特点。Rust 的语法设计非常优秀，其中 match 语句是一种非常强大的语言特性。match 语句可以让我们根据不同的匹配模式执行不同的代码，这在处理复杂的逻辑时非常有用。在本教程中，我们将深入了解 Rust 的 match 语句，包括基础用法、进阶用法和实践经验等方面。基础用法match 语句是 Rust 中的一种控制流语句，它可以让我们根据不同的模式匹配执行不同的代码。match 语句的基本语法如下：1234567891011match value { pattern1 =&gt; { // code1 } pattern2 =&gt; { // code2 } _ =&gt; { // 没有任何匹配 }}其中，value 是要匹配的变量，pattern 是匹配模式，=&gt;后面是要执行的代码块。如果 value 匹配了某个模式，就会执行对应的代码块。如果 value 没有匹配任何模式，就会执行默认的代码块（即_ =&gt; {…}）。接下来，我们将通过一些示例来介绍 match 语句的基础用法。匹配整数12345678910fn main() { let x = 1; match x { 1 =&gt; println!(\"x is one\"), 2 =&gt; println!(\"x is two\"), _ =&gt; println!(\"x is not one or two\"), }}// x is one在这个示例中，我们定义了一个整数变量 x，并使用 match 语句匹配它。如果 x 等于 1，就会执行第一个代码块，输出”x is one”；如果 x 等于 2，就会执行第二个代码块，输出”x is two”；如果 x 不等于 1 或 2，就会执行默认的代码块，输出”x is not one or two”。匹配枚举类型12345678910111213enum Color { Red, Green, Blue,}let color = Color::Green;match color { Color::Red =&gt; println!(\"The color is red\"), Color::Green =&gt; println!(\"The color is green\"), Color::Blue =&gt; println!(\"The color is blue\"),}在这个示例中，我们定义了一个枚举类型 Color，并将变量 color 赋值为 Color::Green。然后，我们使用 match 语句匹配 color。如果 color 等于 Color::Red，就会执行第一个代码块，输出”The color is red”；如果 color 等于 Color::Green，就会执行第二个代码块，输出”The color is green”；如果 color 等于 Color::Blue，就会执行第三个代码块，输出”The color is blue”。匹配元组12345678let point = (1, 2);match point { (0, 0) =&gt; println!(\"The point is at the origin\"), (_, 0) =&gt; println!(\"The point is on the x-axis\"), (0, _) =&gt; println!(\"The point is on the y-axis\"), (x, y) =&gt; println!(\"The point is at ({}, {})\", x, y),}在这个示例中，我们定义了一个元组变量 point，并使用 match 语句匹配它。如果 point 等于(0, 0)，就会执行第一个代码块，输出”The point is at the origin”；如果 point 的第二个元素等于 0，就会执行第二个代码块，输出”The point is on the x-axis”；如果 point 的第一个元素等于 0，就会执行第三个代码块，输出”The point is on the y-axis”；否则，就会执行第四个代码块，输出”The point is at ({}, {})”。匹配范围1234567let age = 20;match age { 0..=17 =&gt; println!(\"You are a minor\"), 18..=64 =&gt; println!(\"You are an adult\"), _ =&gt; println!(\"You are a senior\"),}在这个示例中，我们定义了一个整数变量 age，并使用 match 语句匹配它。如果 age 的值在 0 到 17 之间，就会执行第一个代码块，输出”You are a minor”；如果 age 的值在 18 到 64 之间，就会执行第二个代码块，输出”You are an adult”；否则，就会执行默认的代码块，输出”You are a senior”。匹配引用1234567let x = 1;let y = &amp;x;match y { &amp;1 =&gt; println!(\"The value is one\"), _ =&gt; println!(\"The value is not one\"),}在这个示例中，我们定义了一个整数变量 x 和一个指向 x 的引用 y。然后，我们使用 match 语句匹配 y。由于 y 是一个引用，所以我们需要在模式中使用&amp;符号来匹配它。如果 y 指向的值等于 1，就会执行第一个代码块，输出”The value is one”；否则，就会执行默认的代码块，输出”The value is not one”。匹配守卫1234567let x = 5;match x { n if n &lt; 0 =&gt; println!(\"The value is negative\"), n if n &gt; 10 =&gt; println!(\"The value is greater than 10\"), _ =&gt; println!(\"The value is between 0 and 10\"),}在这个示例中，我们定义了一个整数变量 x，并使用 match 语句匹配它。在模式中，我们使用 if 语句添加了一个守卫条件。如果 x 小于 0，就会执行第一个代码块，输出”The value is negative”；如果 x 大于 10，就会执行第二个代码块，输出”The value is greater than 10”；否则，就会执行默认的代码块，输出”The value is between 0 and 10”。进阶用法除了上面介绍的基础用法，match 语句还有一些进阶用法，可以让我们更加灵活地使用它。接下来，我们将介绍 match 语句的一些进阶用法，并通过示例来演示它们的用法。使用|匹配多个模式123456let x = 1;match x { 1 | 2 =&gt; println!(\"The value is one or two\"), _ =&gt; println!(\"The value is not one or two\"),} 在这个示例中，我们定义了一个整数变量 x，并使用 match 语句匹配它。在模式中，我们使用 符号来匹配多个模式。如果 x 等于 1 或 2，就会执行第一个代码块，输出”The value is one or two”；否则，就会执行默认的代码块，输出”The value is not one or two”。 使用..=匹配范围1234567let age = 20;match age { 0..=17 =&gt; println!(\"You are a minor\"), 18..=64 =&gt; println!(\"You are an adult\"), _ =&gt; println!(\"You are a senior\"),}在这个示例中，我们定义了一个整数变量 age，并使用 match 语句匹配它。在模式中，我们使用..=符号来匹配范围。如果 age 的值在 0 到 17 之间，就会执行第一个代码块，输出”You are a minor”；如果 age 的值在 18 到 64 之间，就会执行第二个代码块，输出”You are an adult”；否则，就会执行默认的代码块，输出”You are a senior”。使用@绑定变量12345678let x = Some(5);match x { Some(n @ 1..=10) =&gt; println!(\"The value is between 1 and 10: {}\", n), Some(n @ 11..=20) =&gt; println!(\"The value is between 11 and 20: {}\", n), Some(_) =&gt; println!(\"The value is not between 1 and 20\"), None =&gt; (),}在这个示例中，我们定义了一个 Option 类型的变量 x，并使用 match 语句匹配它。在模式中，我们使用@符号来绑定一个变量。如果 x 是一个 Some 类型，并且它的值在 1 到 10 之间，就会执行第一个代码块，输出”The value is between 1 and 10”；如果 x 是一个 Some 类型，并且它的值在 11 到 20 之间，就会执行第二个代码块，输出”The value is between 11 and 20”；如果 x 是一个 Some 类型，但它的值不在 1 到 20 之间，就会执行第三个代码块，输出”The value is not between 1 and 20”；如果 x 是一个 None 类型，就不会执行任何代码。使用_忽略模式123456let x = Some(5);match x { Some(_) =&gt; println!(\"The value is some\"), None =&gt; println!(\"The value is none\"),}在这个示例中，我们定义了一个 Option 类型的变量 x，并使用 match 语句匹配它。在模式中，我们使用_符号来忽略模式。如果 x 是一个 Some 类型，就会执行第一个代码块，输出”The value is some”；如果 x 是一个 None 类型，就会执行第二个代码块，输出”The value is none”。使用 if let 简化模式匹配1234567let x = Some(5);if let Some(n) = x { println!(\"The value is {}\", n);} else { println!(\"The value is None\");}在这个示例中，我们定义了一个 Option 类型的变量 x，并使用 if let 语句匹配它。如果 x 是一个 Some 类型，就会执行 if 语句块，输出”The value is x”；如果 x 是一个 None 类型，就会执行 else 语句块，输出”The value is None”。使用 if let 语句可以简化模式匹配的代码，使代码更加清晰和简洁。使用 while let 遍历迭代器1234let mut v = vec![1, 2, 3];while let Some(n) = v.pop() { println!(\"{}\", n);}在这个示例中，我们定义了一个整数数组 v，并使用 while let 语句遍历它的元素。在 while let 语句中，我们使用 pop()方法从数组中依次取出元素，并将它们绑定到变量 n 中。如果数组中还有元素，就会执行 while 语句块，输出元素的值；否则，就会退出 while 循环。使用 while let 语句可以方便地遍历迭代器或者其他可迭代对象。实践经验在实际开发中，我们经常需要使用 match 语句来处理复杂的逻辑。以下是一些实践经验，可以帮助我们更好地使用 match 语句。给每个分支加上花括号在 match 语句中，每个分支的代码块通常都比较复杂，因此我们应该给每个分支加上花括号，以便更好地阅读和维护代码。例如：123456789101112131415161718fn main() { let x = 1; match x { 1 =&gt; { println!(\"The value is one\"); println!(\"This is a long message\"); } 2 =&gt; { println!(\"The value is two\"); } _ =&gt; { println!(\"The value is not one or two\"); } }}// The value is one// This is a long message使用_忽略不需要的变量在 match 语句中，我们可以使用_符号来忽略不需要的变量。这样可以简化代码，并且让代码更加清晰。例如：1234567let x = (1, 2);match x { (1, _) =&gt; println!(\"The first element is 1\"), (_, 2) =&gt; println!(\"The second element is 2\"), _ =&gt; (),}在这个示例中，我们使用_符号来忽略第二个元素，因为我们只关心第一个元素是否等于 1。使用 if let 简化模式匹配在某些情况下，我们只需要匹配一个模式，而不需要处理其他模式。此时，我们可以使用 if let 语句来简化模式匹配的代码。例如：12345let x = Some(5);if let Some(n) = x { println!(\"The value is {}\", n);}在这个示例中，我们只需要匹配 Some 类型的值，而不需要处理 None 类型的值。因此，使用 if let 语句可以让代码更加简洁和清晰。使用 while let 遍历迭代器在遍历迭代器时，我们可以使用 while let 语句来依次取出元素，并进行处理。例如：123456789101112fn main() { let v = vec![1, 2, 3]; for n in &amp;v { println!(\"{}\", n); } let mut v = vec![1, 2, 3]; while let Some(n) = v.pop() { println!(\"{}\", n); }}在这个示例中，我们使用 for 循环和 while let 语句来遍历整数数组 v 的元素。使用 while let 语句可以让代码更加简洁和清晰。总结match 语句是 Rust 中非常强大的语言特性，它可以让我们根据不同的匹配模式执行不同的代码。在本教程中，我们介绍了 match 语句的基础用法、进阶用法和实践经验等方面。通过学习本教程，相信读者已经掌握了 match 语句的基本用法，并能够在实际开发中灵活运用它。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Option那些事儿",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 元组",
      "url"         : "./rust/2023/04/02/rust_lang_tutorial_117_Option_Enum.html",
      "date"        : "2023-04-02 00:00:00 +0800",
      "description" : "",
      "content"     : "Option 是 Rust 语言中的一个枚举类型，它表示一个值可能存在，也可能不存在的情况。Option 可以理解为一个容器，它可能装有一个值，也可能为空。在 Rust 中，Option 可以用来解决很多问题，比如判断一个值是否为空，避免空指针引用等。Option 的定义如下：1234enum Option&lt;T&gt; { Some(T), None,}其中，T 表示 Option 中可能存在的值的类型，Some(T) 表示 Option 中存在一个值 T，None 表示 Option 中不存在值。基础用法创建 OptionRust 中可以通过 Some(value) 创建一个包含值的 Option，也可以通过 None 创建一个空的 Option。12let some_value: Option&lt;i32&gt; = Some(5);let none_value: Option&lt;i32&gt; = None;解构 OptionOption 中的值可以通过模式匹配的方式进行解构。例如，可以通过 match 表达式来判断 Option 中是否存在值，并进行相应的处理。123456let some_value: Option&lt;i32&gt; = Some(5);match some_value { Some(value) =&gt; println!(\"The value is {}\", value), None =&gt; println!(\"There is no value\"),}使用 unwrap如果我们确定 Option 中一定存在值，可以使用 unwrap 方法来获取该值。如果 Option 中不存在值，则会触发 panic。1234let some_value: Option&lt;i32&gt; = Some(5);let value = some_value.unwrap();println!(\"The value is {}\", value);使用 is_some 和 is_none可以使用 is_some 和 is_none 方法来判断 Option 中是否存在值。12345let some_value: Option&lt;i32&gt; = Some(5);let none_value: Option&lt;i32&gt; = None;println!(\"some_value is {}\", some_value.is_some());println!(\"none_value is {}\", none_value.is_none());使用 map可以使用 map 方法来对 Option 中的值进行转换。如果 Option 中不存在值，则 map 方法不会执行。1234let some_value: Option&lt;i32&gt; = Some(5);let new_value = some_value.map(|value| value * 2);println!(\"The new value is {:?}\", new_value);使用 and_then可以使用 and_then 方法来对 Option 中的值进行操作，并返回一个新的 Option。如果 Option 中不存在值，则 and_then 方法不会执行。1234let some_value: Option&lt;i32&gt; = Some(5);let new_value = some_value.and_then(|value| Some(value * 2));println!(\"The new value is {:?}\", new_value);进阶用法使用 match 和 if let在使用 Option 时，经常需要判断 Option 中是否存在值，并进行相应的处理。除了使用 match 表达式外，还可以使用 if let 语句来进行判断。1234567let some_value: Option&lt;i32&gt; = Some(5);if let Some(value) = some_value { println!(\"The value is {}\", value);} else { println!(\"There is no value\");}使用 or 和 or_else可以使用 or 和 or_else 方法来获取一个默认值，如果 Option 中存在值，则返回 Option 中的值，否则返回默认值。1234567891011let some_value: Option&lt;i32&gt; = Some(5);let none_value: Option&lt;i32&gt; = None;let new_value = some_value.or(Some(10));println!(\"The new value is {:?}\", new_value);let new_value = none_value.or(Some(10));println!(\"The new value is {:?}\", new_value);let new_value = none_value.or_else(|| Some(10));println!(\"The new value is {:?}\", new_value);使用 filter可以使用 filter 方法来过滤 Option 中的值，返回一个新的 Option。如果 Option 中不存在值，或者值不符合条件，则返回空 Option。1234567let some_value: Option&lt;i32&gt; = Some(5);let new_value = some_value.filter(|value| *value &gt; 3);println!(\"The new value is {:?}\", new_value);let new_value = some_value.filter(|value| *value &gt; 10);println!(\"The new value is {:?}\", new_value);使用 take可以使用 take 方法来获取 Option 中的值，并将 Option 中的值设置为 None。这个方法在需要获取 Option 中的值并清空 Option 时非常有用。12345let mut some_value: Option&lt;i32&gt; = Some(5);let value = some_value.take();println!(\"The value is {:?}\", value);println!(\"The new Option is {:?}\", some_value);实践经验避免空指针引用在 Rust 中，空指针引用是一种非常危险的操作，容易导致程序崩溃。使用 Option 可以避免空指针引用，保证程序的稳定性和安全性。12345678let mut some_value: Option&lt;i32&gt; = Some(5);let value = some_value.take();if let Some(value) = value { println!(\"The value is {}\", value);} else { println!(\"There is no value\");}使用 Option 作为函数返回值在 Rust 中，函数的返回值可以是 Option 类型，这样可以避免函数返回空指针引用。例如，下面的函数返回一个 Option 类型的字符串，如果字符串为空，则返回空 Option。12345678fn get_string() -&gt; Option&lt;String&gt; { let s = String::from(\"hello\"); if s.is_empty() { None } else { Some(s) }}使用 Option 作为结构体字段在 Rust 中，结构体的字段可以是 Option 类型，这样可以避免空指针引用。例如，下面的结构体中，name 字段是一个 Option 类型的字符串，如果该字段为空，则表示该结构体没有名称。123456789struct Person { name: Option&lt;String&gt;, age: i32,}let person = Person { name: Some(String::from(\"Tom\")), age: 18,};使用 Option 和 Result 结合使用在 Rust 中，Option 和 Result 是两个常用的枚举类型，它们可以结合使用来处理错误和异常情况。例如，下面的函数返回一个 Result 类型的字符串，如果字符串为空，则返回一个错误信息。1234567891011121314fn get_string() -&gt; Result&lt;String, String&gt; { let s = String::from(\"hello\"); if s.is_empty() { Err(String::from(\"String is empty\")) } else { Ok(s) }}let result = get_string();match result { Ok(value) =&gt; println!(\"The value is {}\", value), Err(value) =&gt; println!(\"Error: {}\", value),}使用 Option 和 unwrap_or在 Rust 中，可以使用 unwrap_or 方法来获取 Option 中的值，如果 Option 中不存在值，则返回一个默认值。这个方法非常方便，可以避免使用 match 表达式和 if let 语句来判断 Option 中是否存在值。12345678let some_value: Option&lt;i32&gt; = Some(5);let none_value: Option&lt;i32&gt; = None;let new_value = some_value.unwrap_or(10);println!(\"The new value is {}\", new_value);let new_value = none_value.unwrap_or(10);println!(\"The new value is {}\", new_value);使用 Option 和 Result 结合使用在 Rust 中，Option 和 Result 是两个常用的枚举类型，它们可以结合使用来处理错误和异常情况。例如，下面的函数返回一个 Result 类型的字符串，如果字符串为空，则返回一个错误信息。1234567891011121314fn get_string() -&gt; Result&lt;String, String&gt; { let s = String::from(\"hello\"); if s.is_empty() { Err(String::from(\"String is empty\")) } else { Ok(s) }}let result = get_string();match result { Ok(value) =&gt; println!(\"The value is {}\", value), Err(value) =&gt; println!(\"Error: {}\", value),}总结Option 是 Rust 语言中一个非常重要的类型，它可以用来处理值可能存在或不存在的情况。在 Rust 中，Option 可以通过模式匹配、unwrap、is_some、is_none、map、and_then、or、or_else、filter、take 等方法来进行操作。使用 Option 可以避免空指针引用，保证程序的稳定性和安全性。同时，Option 和 Result 可以结合使用来处理错误和异常情况，提高程序的健壮性和可靠性。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 枚举那些事儿",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 元组",
      "url"         : "./rust/2023/04/02/rust_lang_tutorial_116_enum.html",
      "date"        : "2023-04-02 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种系统级编程语言，具有内存安全、并发性和高性能等优点。在 Rust 中，Enum 是一种非常重要的数据类型，它可以用来表示一组相关的值。Enum 的使用非常灵活，可以用来表示状态、错误类型、选项等。在本教程中，我们将深入了解 Rust 语言中 Enum 的基础用法和进阶用法，以及一些实践经验。基础用法定义 Enum在 Rust 中，我们可以使用enum关键字来定义一个 Enum。Enum 可以包含一组具有不同类型的值。例如，我们可以定义一个表示颜色的 Enum：12345enum Color { Red, Green, Blue,}在上面的代码中，我们定义了一个名为 Color 的 Enum，它包含了三个值：Red、Green 和 Blue。这些值都属于 Color 类型。匹配 Enum在 Rust 中，我们可以使用match表达式来匹配 Enum 的值。例如，我们可以编写一个函数来打印出给定颜色的名称：1234567fn print_color(color: Color) { match color { Color::Red =&gt; println!(\"The color is red\"), Color::Green =&gt; println!(\"The color is green\"), Color::Blue =&gt; println!(\"The color is blue\"), }}在上面的代码中，我们定义了一个名为 print_color 的函数，它接受一个 Color 类型的参数。在函数体中，我们使用match表达式来匹配 color 的值，并打印出相应的颜色名称。带有关联值的 Enum在 Rust 中，Enum 可以带有关联值。这些关联值可以是任何类型，包括其他 Enum。例如，我们可以定义一个表示图形的 Enum，它可以是矩形或圆形，并带有相应的参数：1234enum Shape { Rectangle(u32, u32), Circle(f64),}在上面的代码中，我们定义了一个名为 Shape 的 Enum，它包含了两个值：Rectangle 和 Circle。Rectangle 带有两个 u32 类型的参数，表示宽度和高度；Circle 带有一个 f64 类型的参数，表示半径。匹配带有关联值的 Enum在 Rust 中，我们可以使用match表达式来匹配带有关联值的 Enum。例如，我们可以编写一个函数来计算给定图形的面积：123456fn calculate_area(shape: Shape) -&gt; f64 { match shape { Shape::Rectangle(width, height) =&gt; width as f64 * height as f64, Shape::Circle(radius) =&gt; std::f64::consts::PI * radius * radius, }}在上面的代码中，我们定义了一个名为 calculate_area 的函数，它接受一个 Shape 类型的参数，并返回一个 f64 类型的值。在函数体中，我们使用match表达式来匹配 shape 的值，并计算相应的面积。Option Enum在 Rust 中，Option Enum 是一种非常常用的类型，它表示一个值可能存在也可能不存在。Option Enum 有两个值：Some 和 None。Some 带有一个关联值，表示存在的值；None 表示不存在的值。例如，我们可以定义一个函数来查找一个数组中的最大值：12345678910111213fn find_max(numbers: &amp;[i32]) -&gt; Option&lt;i32&gt; { if numbers.is_empty() { None } else { let mut max = numbers[0]; for &amp;number in numbers.iter() { if number &gt; max { max = number; } } Some(max) }}在上面的代码中，我们定义了一个名为 find_max 的函数，它接受一个 i32 类型的数组，并返回一个 Option类型的值。在函数体中，我们首先检查数组是否为空，如果为空，则返回 None；否则，我们遍历数组，找到最大的值，并返回 Some(max)。Result Enum在 Rust 中，Result Enum 是一种表示操作结果的类型，它有两个值：Ok 和 Err。Ok 表示操作成功，带有一个关联值，表示成功的结果；Err 表示操作失败，带有一个关联值，表示失败的原因。例如，我们可以定义一个函数来读取一个文件的内容：123456789use std::fs::File;use std::io::Read;fn read_file(path: &amp;str) -&gt; Result&lt;String, std::io::Error&gt; { let mut file = File::open(path)?; let mut contents = String::new(); file.read_to_string(&amp;mut contents)?; Ok(contents)}在上面的代码中，我们定义了一个名为 read_file 的函数，它接受一个字符串类型的参数，并返回一个 Result&lt;String, std::io::Error&gt;类型的值。在函数体中，我们首先打开文件，如果失败，则返回 Err；否则，我们读取文件的内容，并返回 Ok(contents)。进阶用法带有方法的 Enum在 Rust 中，Enum 可以带有方法。这些方法可以是实例方法或关联方法。例如，我们可以定义一个表示颜色的 Enum，并为其定义一个方法来获取颜色的 RGB 值：123456789101112131415enum Color { Red, Green, Blue,}impl Color { fn rgb(&amp;self) -&gt; (u8, u8, u8) { match self { Color::Red =&gt; (255, 0, 0), Color::Green =&gt; (0, 255, 0), Color::Blue =&gt; (0, 0, 255), } }}在上面的代码中，我们为 Color Enum 定义了一个名为 rgb 的方法，它返回一个(u8, u8, u8)类型的元组，表示颜色的 RGB 值。带有泛型的 Enum在 Rust 中，Enum 可以带有泛型。这使得 Enum 可以适用于多种类型。例如，我们可以定义一个表示选项的 Enum，它可以是 Some 或 None，但可以适用于任何类型：1234enum Option&lt;T&gt; { Some(T), None,}在上面的代码中，我们定义了一个名为 Option 的 Enum，它带有一个泛型参数 T。Option 可以是 Some(T)，表示存在某个值；也可以是 None，表示不存在任何值。带有生命周期的 Enum在 Rust 中，Enum 可以带有生命周期。这使得 Enum 可以适用于多种情况。例如，我们可以定义一个表示字符串或字节数组的 Enum：1234enum Data&lt;'a&gt; { String(&amp;'a str), Bytes(&amp;'a [u8]),}在上面的代码中，我们定义了一个名为 Data 的 Enum，它带有一个生命周期参数’a。Data 可以是 String(&amp;’a str)，表示一个字符串；也可以是 Bytes(&amp;’a [u8])，表示一个字节数组。带有属性的 Enum在 Rust 中，Enum 可以带有属性。这些属性可以用来标记 Enum 的特性。例如，我们可以定义一个表示状态的 Enum，并为其定义一个属性来标记它是不可变的：123456789101112#[derive(Debug, Copy, Clone)]enum State { Active, Inactive,}#[derive(Debug)]#[repr(u8)]enum Status { Ok = 0, Error = 1,}在上面的代码中，我们为 State Enum 定义了一个名为 Debug 的属性，用于调试；同时，我们为 Status Enum 定义了一个名为 repr 的属性，用于指定它的内部表示。带有默认值的 Enum在 Rust 中，Enum 可以带有默认值。这使得 Enum 可以在某些情况下更加方便。例如，我们可以定义一个表示颜色的 Enum，并为其定义一个默认值：1234567891011enum Color { Red, Green, Blue,}impl Default for Color { fn default() -&gt; Self { Color::Red }}在上面的代码中，我们为 Color Enum 实现了 Default trait，并为其定义了一个默认值为 Red。实践经验使用 Enum 来表示状态在 Rust 中，Enum 可以用来表示状态。例如，我们可以定义一个表示线程状态的 Enum：12345enum ThreadState { Running, Stopped, Blocked,}在上面的代码中，我们定义了一个名为 ThreadState 的 Enum，它包含了三个状态值：Running、Stopped 和 Blocked。这些状态值可以用来表示线程的运行状态。使用 Enum 来表示错误类型在 Rust 中，Enum 可以用来表示错误类型。例如，我们可以定义一个表示文件读取错误的 Enum：12345enum FileError { NotFound, PermissionDenied, ReadError(std::io::Error),}在上面的代码中，我们定义了一个名为 FileError 的 Enum，它包含了三个错误类型：NotFound、PermissionDenied 和 ReadError。ReadError 带有一个 std::io::Error 类型的关联值，表示读取文件时发生的错误。使用 Enum 来表示选项在 Rust 中，Enum 可以用来表示选项。例如，我们可以定义一个表示性别的 Enum：12345enum Gender { Male, Female, Unknown,}在上面的代码中，我们定义了一个名为 Gender 的 Enum，它包含了三个选项：Male、Female 和 Unknown。这些选项可以用来表示人的性别。使用 Enum 来表示命令行参数在 Rust 中，Enum 可以用来表示命令行参数。例如，我们可以定义一个表示命令行参数的 Enum：12345enum Command { Help, Version, Run(String),}在上面的代码中，我们定义了一个名为 Command 的 Enum，它包含了三个命令：Help、Version 和 Run。Run 带有一个字符串类型的关联值，表示要运行的命令。使用 Enum 来表示状态机在 Rust 中，Enum 可以用来表示状态机。例如，我们可以定义一个表示 TCP 连接状态的 Enum：12345678910111213enum TcpState { Closed, Listen, SynSent, SynReceived, Established, FinWait1, FinWait2, CloseWait, Closing, LastAck, TimeWait,}在上面的代码中，我们定义了一个名为 TcpState 的 Enum，它包含了多个状态值。这些状态值可以用来表示 TCP 连接的状态。使用 Enum 来表示选项组合在 Rust 中，Enum 可以用来表示选项组合。例如，我们可以定义一个表示文件权限的 Enum：12345678910111213141516#[derive(Debug)]enum FilePermission { Read = 0b100, Write = 0b010, Execute = 0b001, ReadWrite = Self::Read.bits() | Self::Write.bits(), ReadExecute = Self::Read.bits() | Self::Execute.bits(), WriteExecute = Self::Write.bits() | Self::Execute.bits(), All = Self::Read.bits() | Self::Write.bits() | Self::Execute.bits(), } impl FilePermission { fn bits(&amp;self) -&gt; u8 { *self as u8 }}在上面的代码中，我们定义了一个名为 FilePermission 的 Enum，它表示文件的权限。每个权限都表示为一个二进制数，可以用位运算符来组合多个权限。我们还为 FilePermission 定义了一个名为 bits 的方法，用于获取该权限的二进制值。结论在本教程中，我们深入了解了 Rust 语言中 Enum 的基础用法和进阶用法，以及一些实践经验。Enum 是一种非常灵活的数据类型，可以用来表示状态、错误类型、选项等。在实际开发中，我们可以根据需要选择合适的 Enum 来实现我们的需求。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 复合类型“元组”那些事儿",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 元组",
      "url"         : "./rust/2023/04/02/rust_lang_tutorial_115_tuple.html",
      "date"        : "2023-04-02 00:00:00 +0800",
      "description" : "",
      "content"     : "元组是 Rust 语言中一种非常有用的数据结构，它可以将多个不同类型的值组合在一起。本教程将介绍元组的基础用法和进阶用法，并结合示例代码进行讲解。元组是一种有序的数据集合，其中每个元素可以是不同的类型。元组使用圆括号括起来，元素之间使用逗号分隔。例如：1let my_tuple = (1, \"hello\", true);上面的代码创建了一个包含三个元素的元组，第一个元素是整数 1，第二个元素是字符串”hello”，第三个元素是布尔值 true。元组可以用于返回多个值，也可以用于将多个值组合在一起传递给函数。基础用法创建元组要创建一个元组，只需要在圆括号中列出元素，用逗号分隔即可。例如：1let my_tuple = (1, \"hello\", true);上面的代码创建了一个包含三个元素的元组，第一个元素是整数 1，第二个元素是字符串”hello”，第三个元素是布尔值 true。访问元组元素可以使用点号和元素的索引来访问元组中的元素。例如：1234let my_tuple = (1, \"hello\", true);let first_element = my_tuple.0;let second_element = my_tuple.1;let third_element = my_tuple.2;上面的代码分别访问了元组中的第一个、第二个和第三个元素，并将它们分别存储在变量 first_element、second_element 和third_element 中。解构元组可以使用模式匹配来解构元组。例如：12let my_tuple = (1, \"hello\", true);let (a, b, c) = my_tuple;上面的代码将元组中的三个元素分别赋值给变量 a、b 和 c。这种方式非常方便，可以避免使用点号访问元素的麻烦。元组作为函数返回值元组非常适合用作函数的返回值，可以将多个值打包在一起返回。例如：12345678fn get_name_and_age() -&gt; (String, u32) { let name = String::from(\"Alice\"); let age = 30; (name, age)}let (name, age) = get_name_and_age();println!(\"Name: {}, Age: {}\", name, age);上面的代码定义了一个函数 get_name_and_age，它返回一个元组，其中包含一个字符串和一个整数。然后，在主函数中使用模式匹配解构元组，将元素分别赋值给变量name 和 age，并打印输出。元组作为函数参数元组也可以作为函数的参数，可以将多个值打包在一起传递给函数。例如：123456fn print_name_and_age(name: String, age: u32) {println!(\"Name: {}, Age: {}\", name, age);}let my_tuple = (String::from(\"Alice\"), 30);print_name_and_age(my_tuple.0, my_tuple.1);上面的代码定义了一个函数 print_name_and_age，它接受一个字符串和一个整数作为参数，并打印输出。然后，在主函数中创建一个包含两个元素的元组，分别是一个字符串和一个整数，并将它们作为参数传递给函数。进阶用法元组嵌套元组可以嵌套在其他元组中，从而创建更复杂的数据结构。例如：12345let my_tuple = ((1, 2), (3, 4));let first_element = my_tuple.0.0;let second_element = my_tuple.0.1;let third_element = my_tuple.1.0;let fourth_element = my_tuple.1.1;上面的代码创建了一个包含两个元素的元组，每个元素都是包含两个整数的元组。然后，可以使用点号和索引访问每个元素中的整数。元组作为结构体的字段元组可以作为结构体的字段，从而创建更复杂的数据结构。例如：1234struct Person(String, u32);let person = Person(String::from(\"Alice\"), 30);println!(\"Name: {}, Age: {}\", person.0, person.1);上面的代码定义了一个结构体 Person，它包含一个字符串和一个整数。然后，在主函数中创建一个 Person 实例，并使用点号访问元素。元组作为枚举的变体元组也可以作为枚举的变体，从而创建更复杂的数据结构。例如：12345678910enum Result&lt;T, E&gt; { Ok(T), Err(E),}let my_result = Result::Ok((1, \"hello\"));match my_result { Result::Ok((a, b)) =&gt; println!(\"a: {}, b: {}\", a, b), Result::Err() =&gt; println!(\"Error\"),}上面的代码定义了一个枚举 Result，它有两个变体：Ok 和 Err。Ok 变体包含一个元组，Err 变体包含一个错误值。然后，在主函数中创建一个包含两个元素的元组，并将它作为 Ok 变体的值传递给枚举。最后，使用模式匹配解构元组并打印输出。元组作为闭包的参数元组可以作为闭包的参数，从而让闭包接受多个值。例如：12345let my_closure = |(a, b)| { println!(\"a: {}, b: {}\", a, b);};my_closure((1, \"hello\"));上面的代码定义了一个闭包 my_closure，它接受一个包含两个元素的元组作为参数，并打印输出。然后，在主函数中创建一个包含两个元素的元组，并将它作为参数传递给闭包。元组的比较元组可以使用==和!=运算符进行比较，但是只有在元素类型都实现了 PartialEq 和 Eq trait 时才可以进行比较。例如：1234567let tuple1 = (1, \"hello\");let tuple2 = (1, \"world\");let tuple3 = (2, \"hello\");assert!(tuple1 == tuple1);assert!(tuple1 != tuple2);assert!(tuple1 != tuple3);上面的代码创建了三个元组，然后使用==和!=运算符进行比较，最后使用 assert 宏进行断言。实践经验在实际开发中，元组经常用于返回多个值或将多个值打包在一起传递给函数。例如，可以使用元组返回一个函数的计算结果和执行时间：12345678910111213use std::time::{Instant};fn calculate() -&gt; (u32, u128) { let start = Instant::now(); let result = 1 + 2 + 3 + 4 + 5; let duration = start.elapsed().as_micros(); (result, duration)}fn main() { let (result, duration) = calculate(); println!(\"Result: {}, Duration: {}us\", result, duration);}上面的代码定义了一个函数 calculate，它计算 1 到 5 的和，并返回计算结果和执行时间。然后，在主函数中使用模式匹配解构元组，并打印输出结果和执行时间。另外，元组也可以用于在函数之间传递多个值。例如，可以使用元组将多个参数传递给一个函数：12345678fn process_data(name: &amp;str, age: u32, score: u32) { println!(\"Name: {}, Age: {}, Score: {}\", name, age, score);}fn main() { let my_tuple = (\"Alice\", 30, 90); process_data(my_tuple.0, my_tuple.1, my_tuple.2);}上面的代码定义了一个函数 process_data，它接受三个参数：姓名、年龄和分数，并打印输出。然后，在主函数中创建一个包含三个元素的元组，并将它作为参数传递给函数。总之，元组是 Rust 语言中非常有用的数据结构，可以用于返回多个值、将多个值打包在一起传递给函数等。掌握元组的基础用法和进阶用法，可以让我们更好地利用这个强大的数据结构。总结本教程介绍了 Rust 语言中的元组，包括元组的基础用法和进阶用法，并结合示例代码进行讲解。通过本教程，读者可以了解元组在 Rust 语言中的重要性和用途，掌握元组的基本操作和高级用法，从而更好地利用这个强大的数据结构。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 单元测试",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 单元测试",
      "url"         : "./rust/2023/04/02/rust_lang_tutorial_114_units_test.html",
      "date"        : "2023-04-02 00:00:00 +0800",
      "description" : "",
      "content"     : "单元测试是软件开发过程中的重要环节，用于测试代码的小部分是否正常工作。Rust 语言拥有一个丰富的测试框架，可以轻松编写并运行测试用例。本教程将介绍如何在 Rust 项目中编写单元测试，并提供示例代码。单元测试单元测试是软件测试的一个重要部分，它的主要目的是验证代码单元（如函数、模块或类）是否按照预期工作。与手动测试相比，自动化单元测试能够快速、可靠地检测代码问题，避免了大量的手动测试工作。在 Rust 中，单元测试是通过test属性来实现的。每个符合规范的测试函数都必须使用特殊的宏assert!来验证其结果是否正确。编写单元测试以下是一个简单的 Rust 代码示例：1234567fn add(a: i32, b: i32) -&gt; i32 { a + b}fn main() { println!(\"{}\", add(1, 2));}这个程序定义了一个名为add的函数，该函数接受两个i32类型的参数并返回它们的和。我们可以使用单元测试来验证这个函数是否正确。首先，在add函数的上面添加一个#[test]属性，告诉编译器这是一个测试函数：1234#[test]fn test_add() { assert_eq!(add(1, 2), 3);}在这个测试函数中，我们使用assert_eq!宏来检查add函数是否返回了我们期望的结果。如果运行测试失败，则会输出错误消息，否则测试通过。运行单元测试在 Rust 中，我们使用命令cargo test来运行所有的测试。当我们运行这个命令时，编译器会自动查找所有带有#[test]属性的函数，并且运行他们。下面是一个运行测试的示例，我们将上述代码保存在src/main.rs文件中：$ cargo test Compiling rust-unit-test v0.1.0 (/path/to/rust-unit-test) Finished test [unoptimized + debuginfo] target(s) in 0.29s Running target/debug/deps/rust_unit_test-xxxxxxxxxxxxxxxxrunning 1 testtest test_add ... oktest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out从输出结果可以看出，我们的测试已经通过了。单元测试进阶除了使用assert!宏来验证测试结果之外，Rust 还提供了一些其他的工具来帮助我们编写更完整的测试。使用assert_eq!assert_eq!宏可以用来比较两个值是否相等。它还可以比较各种类型的值，包括字符串和浮点数，而不只是数字类型。12345#[test]fn test_add() { assert_eq!(add(1, 2), 3); assert_eq!(add(-1, -2), -3);}使用assert_ne!assert_ne!宏可以用来比较两个值是否不相等。12345#[test]fn test_add() { assert_ne!(add(1, 2), 4); assert_ne!(add(-1, -2), -4);}使用panic!断言有时候，我们需要在测试中引发一个错误（如输入错误的参数等），以测试程序是否能够正确处理这个错误。这时，我们可以使用panic!宏来抛出一个错误。123456789101112#[test]#[should_panic(expected = \"attempt to divide by zero\")]fn test_divide_by_zero() { divide(10, 0);}fn divide(a: i32, b: i32) -&gt; i32 { if b == 0 { panic!(\"attempt to divide by zero\"); } a / b}在这个例子中，我们测试了一个除以零的函数。我们使用should_panic属性指示编译器检测panic!宏是否被正确执行，并且预期的错误信息是否匹配。使用assert_approx_eq!当我们需要比较浮点数时，由于舍入误差等原因，直接使用assert_eq!宏并不能得到正确的结果。这时，我们可以使用assert_approx_eq!宏来比较两个浮点数是否近似相等。1234#[test]fn test_approx_pi() { assert_approx_eq!(22.0 / 7.0, std::f64::consts::PI, 0.01);}使用assert!(result.is_ok())验证结果对于返回值是Result类型的函数，我们可以使用assert!(result.is_ok())宏来验证结果是否成功。123456#[test]fn test_parse_int() { let result = \"123\".parse::&lt;i32&gt;(); assert!(result.is_ok()); assert_eq!(result.unwrap(), 123);}进阶示例下面是一个稍微复杂一点的例子，它演示了如何测试一个可能会出错的函数，以及如何使用上面提到的所有宏进行测试。123456789101112131415161718192021222324252627282930313233343536#[test]#[should_panic(expected = \"attempt to divide by zero\")]fn test_divide_by_zero() { divide(10, 0);}#[test]fn test_add() { assert_eq!(add(1, 2), 3); assert_eq!(add(-1, -2), -3); assert_ne!(add(1, 2), 4); assert_ne!(add(-1, -2), -4);}#[test]fn test_approx_pi() { assert_approx_eq!(22.0 / 7.0, std::f64::consts::PI, 0.01);}#[test]fn test_parse_int() { let result = \"123\".parse::&lt;i32&gt;(); assert!(result.is_ok()); assert_eq!(result.unwrap(), 123);}fn add(a: i32, b: i32) -&gt; i32 { a + b}fn divide(a: i32, b: i32) -&gt; i32 { if b == 0 { panic!(\"attempt to divide by zero\"); } a / b}测试私有函数Rust 允许在测试模块中测试私有函数。为了做到这一点，我们将测试模块放在包含私有函数的模块之内，并使用 #[cfg(test)] 和 #[test] 属性将测试函数标记为测试。123456789101112131415mod foo { #[cfg(test)] mod tests { use super::private_function; #[test] fn test_private_function() { assert_eq!(private_function(), 3); } } fn private_function() -&gt; i32 { 3 }}在上面的示例中，我们定义了一个名为 foo 的模块，并在其中添加了一个私有函数 private_function。在模块内部，我们定义了一个测试模块，并添加了一个测试函数，该函数使用 assert_eq! 断言来验证 private_function 的结果是否正确。结论Rust 提供了非常好用的单元测试框架，使得我们能够轻松地编写、运行和调试测试代码。本教程介绍了一些基本的测试宏和示例代码，希望能够对学习和使用 Rust 单元测试有所帮助。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 实现自定义智能指针",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Tesseract, OCR",
      "url"         : "./rust/2023/03/31/rust_lang_tutorial_210_Custom_Smart_Pointer.html",
      "date"        : "2023-03-31 00:00:00 +0800",
      "description" : "",
      "content"     : ""
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Tesseract实现文本识别",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Tesseract, OCR",
      "url"         : "./rust/2023/03/31/rust_lang_tutorial_209_Tesseract.html",
      "date"        : "2023-03-31 00:00:00 +0800",
      "description" : "",
      "content"     : "OCR （Optical Character Recognition，光学字符识别）是一种将印刷体或手写体的字符、数字等转化为可被计算机识别的文本的技术。在现代社会中，OCR 技术被广泛应用于各个领域，如图像处理、自动化识别、人工智能等。Tesseract 是一款开源的 OCR 引擎，最初由 HP 实验室开发，后被 Google 收购并开源。Tesseract 以其高精度和高速度而闻名，支持多种语言和平台，可以用于 OCR 的各种应用场景，如文本识别、车牌识别、身份证识别等。Rust 是一种安全、高效、并发的系统编程语言，其生态系统日趋完善，对于高性能和安全性要求较高的应用场景，Rust 语言具有很强的优势。本文探讨 Rust 调用 Tesseract 进行 OCR 相关业务实践。TesseractTesseract 开源仓库地址 Github 仓库 。Tesseract 特点： 高精度。Tesseract 在处理印刷体字符识别时，具有很高的精度。在一些基准测试中，Tesseract 的识别率可以达到 99% 以上。 多语言支持。Tesseract 支持多种语言，包括中文、日文、韩文、阿拉伯文等等。此外，Tesseract 还支持多种字体和字号的识别。 高性能。Tesseract 在处理大量数据时，具有很高的速度和效率。此外，Tesseract 的识别速度可以通过多线程等方式进一步提升。 易于使用。Tesseract 提供了多种接口和工具，方便用户进行 OCR 相关的操作。Tesseract 的安装和使用Tesseract 的安装和使用非常简单。在 Linux 系统上，可以使用如下命令进行安装：12sudo apt install tesseract-ocrsudo apt install libtesseract-dev在 Windows 系统上，可以从 Tesseract 官网下载安装包 点击下载 进行安装。 其他操作系统的安装请参考官方安装教程Tesseract 是一个命令行程序，因此首先打开一个终端或命令提示符。该命令是这样使用的：1tesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]Tesseract 的使用也非常简单。可以使用命令行工具 tesseract 进行 OCR 操作，如下所示：tesseract image.png output -l eng其中，image.png 是待识别的图像文件，output 是输出文件的前缀，-l eng 表示使用英文语言进行识别。常用业务场景和用法下面介绍一些 Tesseract 常见的业务场景和用法。文本识别文本识别是 Tesseract 最常见的应用场景之一。在 OCR 中，文本识别是最基本的功能，也是最容易实现的功能。在文本识别中，Tesseract 可以识别多种语言的文本，包括中文、英文、日文、韩文等等。此外，Tesseract 还可以识别多种字体和字号的文本。下面是一个使用 Tesseract 进行文本识别的示例代码：12345678910use tesseract::Tesseract;fn main() { let mut tess = Tesseract::new(); tess.set_lang(\"eng\").unwrap(); let text = tess .ocr_file(\"image.png\", None) .unwrap(); println!(\"{}\", text);}在上面的示例代码中，首先创建了一个 Tesseract 实例，然后设置了语言为英文。接着，使用 ocr_file 方法对图像文件进行识别，并将识别结果输出到控制台上。车牌识别车牌识别是 Tesseract 的另一个常见应用场景。在车牌识别中，Tesseract 可以识别多种车牌的类型，包括普通车牌、新能源车牌、使馆车牌等等。此外，Tesseract 还可以识别车牌号码的颜色、字体和字号等信息。下面是一个使用 Tesseract 进行车牌识别的示例代码：1234567891011use tesseract::Tesseract;fn main() { let mut tess = Tesseract::new(); tess.set_lang(\"chi_sim\").unwrap(); tess.set_variable(\"tessedit_char_whitelist\", \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\").unwrap(); let text = tess .ocr_file(\"car.jpg\", None) .unwrap(); println!(\"{}\", text);}在上面的示例代码中，首先创建了一个 Tesseract 实例，然后设置了语言为中文。接着，使用 set_variable 方法设置了 OCR 引擎的参数，指定了车牌号码的字符集。最后，使用 ocr_file 方法对车牌图像进行识别，并将识别结果输出到控制台上。身份证识别身份证识别是 Tesseract 的另一个常见应用场景。在身份证识别中，Tesseract 可以识别身份证的各个信息，包括姓名、性别、民族、出生日期、地址、身份证号码等等。此外，Tesseract 还可以识别身份证的正反面，并对身份证照片进行校正和修剪。下面是一个使用 Tesseract 进行身份证识别的示例代码：1234567891011use tesseract::Tesseract;fn main() { let mut tess = Tesseract::new(); tess.set_lang(\"chi_sim\").unwrap(); tess.set_variable(\"tessedit_char_whitelist\", \"0123456789X\").unwrap(); let text = tess .ocr_file(\"idcard.jpg\", None) .unwrap(); println!(\"{}\", text);}在上面的示例代码中，首先创建了一个 Tesseract 实例，然后设置了语言为中文。接着，使用 set_variable 方法设置了 OCR 引擎的参数，指定了身份证号码的字符集。最后，使用 ocr_file 方法对身份证图像进行识别，并将识别结果输出到控制台上。OCR 进阶用法除了常见的业务场景和用法之外，Tesseract 还支持一些进阶用法，如下所示。图像预处理图像预处理是 OCR 中非常重要的一步。在 OCR 中，图像预处理可以提高 OCR 的精度和速度，减少 OCR 的错误率。Tesseract 提供了多种图像预处理方法，如二值化、去噪、平滑、锐化等等。下面是一个使用 Tesseract 进行图像预处理的示例代码：123456789101112use tesseract::{Tesseract, Pix};fn main() { let mut tess = Tesseract::new(); tess.set_lang(\"eng\").unwrap(); let mut pix = Pix::from_file(\"image.png\").unwrap(); pix = pix.binarize(128).unwrap(); let text = tess .ocr_pix(&amp;pix, None) .unwrap(); println!(\"{}\", text);}在上面的示例代码中，首先创建了一个 Tesseract 实例，然后设置了语言为英文。接着，使用 Pix::from_file 方法读取图像文件，并使用 binarize 方法进行二值化处理。最后，使用 ocr_pix 方法对处理后的图像进行识别，并将识别结果输出到控制台上。多线程处理多线程处理是 Tesseract 的另一个进阶用法。在大量数据处理时，使用多线程可以提高 OCR 的速度和效率。Tesseract 提供了多种多线程处理方法，如并行处理、分布式处理等等。下面是一个使用 Tesseract 进行多线程处理的示例代码：123456789101112use tesseract::{Tesseract, Pix};fn main() { let mut tess = Tesseract::new(); tess.set_lang(\"eng\").unwrap(); let mut pix = Pix::from_file(\"image.png\").unwrap(); pix = pix.binarize(128).unwrap(); let text = tess .ocr_pix(&amp;pix, Some(4)) .unwrap(); println!(\"{}\", text);}在上面的示例代码中，首先创建了一个 Tesseract 实例，然后设置了语言为英文。接着，使用 Pix::from_file 方法读取图像文件，并使用 binarize 方法进行二值化处理。最后，使用 ocr_pix 方法对处理后的图像进行识别，并指定了线程数为 4。OCR 引擎会使用 4 个线程进行处理，提高 OCR 的速度和效率。最佳实践在使用 Tesseract 进行 OCR 的过程中，需要注意以下几点： 选择正确的语言。Tesseract 支持多种语言，需要根据实际情况选择正确的语言进行识别。 选择正确的图像预处理方法。图像预处理可以提高 OCR 的精度和速度，需要根据实际情况选择正确的图像预处理方法。 选择正确的字符集。在识别车牌、身份证等信息时，需要根据实际情况选择正确的字符集。 使用多线程处理。在大量数据处理时，使用多线程可以提高 OCR 的速度和效率。结论本文介绍了如何使用 Rust 语言实现 Tesseract 模块进行 OCR，包括 Tesseract 模块的介绍、常用业务场景和用法、OCR 进阶用法、最佳实践等等。通过学习本文，读者可以了解 Tesseract 的基本特点和使用方法，掌握 Tesseract 在 OCR 中的常见应用场景和用法，并了解 Tesseract 的进阶用法和最佳实践。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 使用prost库操作Protobuf",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, prost, protobuf",
      "url"         : "./rust/2023/03/30/rust_lang_tutorial_208_Protobuf_Prost.html",
      "date"        : "2023-03-30 00:00:00 +0800",
      "description" : "",
      "content"     : "Prost 是一个用于序列化和反序列化协议缓冲区数据的 Rust 语言库。它使用Google Protocol Buffers语言来定义协议，并生成 Rust 代码以便使用该协议。 Prost 具有高性能的特点，并且支持许多 protobuf 功能，例如嵌套消息、默认值、枚举类型以及变长编码。Prost 支持从 protobuf2 和 protobuf3 生成代码，而且可以与其他 Rust 语言库和框架无缝集成。模块场景和基础用法Prost 可以用于许多场景，包括网络通信、持久化、日志记录等。在这里，我们将通过一个简单的例子来介绍 Prost 的基础用法。首先在Cargo.toml中引入 prost 模块，示例配置如下：1234[dependencies]prost = \"0.11\"# Only necessary if using Protobuf well-known types:prost-types = \"0.11\"假设我们有一个动物园，里面有许多不同种类的动物。我们可以使用 Prost 来定义一个动物的协议，然后使用该协议来序列化和反序列化动物对象。首先，我们需要定义动物的 protobuf 文件。在这里，我们定义了一个动物具有名称、年龄和类型。动物类型是一个枚举类型，它可以是狗、猫或鸟。12345678910111213syntax = \"proto3\";enum AnimalType { DOG = 0; CAT = 1; BIRD = 2;}message Animal { string name = 1; uint32 age = 2; AnimalType animal_type = 3;}接下来，我们需要使用 Prost 生成 Rust 代码。我们可以使用以下命令来执行此操作：1$ protoc --rust_out . animals.proto这将生成一个名为animals.rs的文件，其中包含与 protobuf 定义相对应的 Rust 代码。接下来，我们可以使用 Prost 来序列化和反序列化动物对象。以下是一个示例代码：12345678910111213141516171819202122232425262728293031323334use prost::{Enumeration, Message};#[derive(Clone, PartialEq, Message)]pub struct Animal { #[prost(string, tag=\"1\")] pub name: String, #[prost(uint32, tag=\"2\")] pub age: u32, #[prost(enumeration=\"AnimalType\", tag=\"3\")] pub animal_type: i32,}#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Enumeration)]pub enum AnimalType { Dog = 0, Cat = 1, Bird = 2,}fn main() { let mut animal = Animal::default(); animal.name = \"Tom\".to_string(); animal.age = 3; animal.animal_type = AnimalType::Cat as i32; let mut buf = Vec::new(); animal.encode(&amp;mut buf).unwrap(); let decoded_animal = Animal::decode(&amp;buf[..]).unwrap(); assert_eq!(animal, decoded_animal); println!(\"{:?}\", animal);}// 输出结果：// Animal { name: \"Tom\", age: 3, animal_type: Cat }在这个示例代码中，我们定义了一个名为Animal的结构体，并使用prost宏将其与 protobuf 定义相关联。我们还定义了一个名为AnimalType的枚举类型，它与 protobuf 定义中的枚举类型相对应。在main函数中，我们创建了一个Animal对象，并将其序列化为字节数组。然后，我们将字节数组反序列化为另一个Animal对象，并使用assert_eq宏比较这两个对象是否相等。高级特性Prost 提供了许多高级特性，例如自定义类型、扩展字段、oneof 等。在这里，我们将介绍其中一些特性。自定义类型有时，我们可能需要在 protobuf 定义中使用自定义类型。例如，我们可能需要使用自定义类型来表示日期或时间。在这种情况下，我们可以使用prost宏的bytes属性来定义自定义类型。以下是一个示例代码：123456789syntax = \"proto3\";message Date { bytes value = 1 [(prost(bytes_type) = \"chrono::NaiveDate\")];}message Time { bytes value = 1 [(prost(bytes_type) = \"chrono::NaiveTime\")];}在这个示例代码中，我们定义了两个消息类型：Date和Time。它们都包含一个名为value的字节数组字段，并使用prost宏的bytes_type属性将其与chrono库中的NaiveDate和NaiveTime类型相关联。自定义编解码Prost 支持自定义编解码，可以使用 prost::Message trait 来实现自定义编解码。12345678910111213141516171819202122impl Animal { pub fn from_bytes(bytes: &amp;[u8]) -&gt; Result&lt;Self, prost::DecodeError&gt; { Animal::decode(bytes) } pub fn to_bytes(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;, prost::EncodeError&gt; { let mut buf = Vec::new(); self.encode(&amp;mut buf)?; Ok(buf) }}fn main() { let mut animal = Animal::default(); animal.name = \"Tom\".to_string(); animal.age = 3; animal.animal_type = AnimalType::Cat as i32; let bytes = animal.to_bytes(); println!(\"{:?}\", Animal::from_bytes(&amp;bytes.unwrap()));}// 输出结果:// Ok(Animal { name: \"Tom\", age: 3, animal_type: Cat })扩展字段有时，我们可能需要向 protobuf 消息添加额外的字段，但是又不想破坏现有的消息格式。在这种情况下，我们可以使用扩展字段。扩展字段是在 protobuf 定义中定义的，但是在生成的 Rust 代码中不会出现。它们可以用来存储任何类型的数据，并且可以与 protobuf 消息一起序列化和反序列化。以下是一个示例代码：123456789syntax = \"proto3\";message Animal { string name = 1; uint32 age = 2; AnimalType animal_type = 3; map&lt;string, bytes&gt; extensions = 1000;}在这个示例代码中，我们添加了一个名为extensions的字段，它是一个map类型，可以存储任何类型的数据。此字段的标签为 1000，这意味着它是一个扩展字段。在 Rust 代码中，我们可以使用prost::Message trait 的extensions方法来访问扩展字段。以下是一个示例代码：1234567891011121314151617181920212223242526272829303132use prost::{Enumeration, Message};use std::collections::HashMap;#[derive(Clone, PartialEq, Message)]pub struct Animal { #[prost(string, tag=\"1\")] pub name: String, #[prost(uint32, tag=\"2\")] pub age: u32, #[prost(enumeration=\"AnimalType\", tag=\"3\")] pub animal_type: i32, #[prost(map=\"string, bytes\", tag=\"1000\")] pub extensions: HashMap&lt;String, Vec&lt;u8&gt;&gt;,}#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Enumeration)]pub enum AnimalType { Dog = 0, Cat = 1, Bird = 2,}fn main() { let mut animal = Animal::default(); animal.extensions.insert(\"color\".to_string(), b\"brown\".to_vec()); let mut buf = Vec::new(); animal.encode(&amp;mut buf).unwrap(); let decoded_animal = Animal::decode(&amp;buf[..]).unwrap(); assert_eq!(animal.extensions, decoded_animal.extensions);}在这个示例代码中，我们创建了一个Animal对象，并向其添加了一个名为color的扩展字段。然后，我们将该对象序列化为字节数组，并将其反序列化为另一个Animal对象。最后，我们使用assert_eq宏比较这两个对象的扩展字段是否相等。Proto Oneof有时，我们可能需要在 protobuf 消息中使用oneof语法，以表示字段中的多个可能类型。在这种情况下，我们可以使用prost宏的oneof属性来定义oneof字段。以下是一个示例代码：1234567891011121314151617181920syntax = \"proto3\";message Animal { string name = 1; uint32 age = 2; oneof animal_type { Dog dog = 3; Cat cat = 4; Bird bird = 5; }}message Dog { string breed = 1;}message Cat { bool has_tail = 1;}message Bird { uint32 wingspan = 1;}在这个示例代码中，我们定义了一个名为Animal的消息类型，它包含一个名为animal_type的oneof字段。oneof字段中包含三个可能的类型：Dog、Cat和Bird。每个类型都包含与其相关联的字段。在 Rust 代码中，我们可以使用prost::Oneof trait 来访问oneof字段。以下是一个示例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849use prost::{Enumeration, Message, Oneof};use std::collections::HashMap;use core::option::Option;#[derive(Clone, PartialEq, Message)]pub struct Animal { #[prost(string, tag=\"1\")] pub name: String, #[prost(uint32, tag=\"2\")] pub age: u32, #[prost(oneof=\"AnimalType\", tag=\"3,4,5\")] pub animal_type: Option&lt;AnimalType&gt;,}#[derive(Clone, Debug, PartialEq, Enumeration)]pub enum AnimalType { #[prost(message, tag = \"3\", name = \"Dog\")] Dog(Dog), #[prost(message, tag = \"4\", name = \"Cat\")] Cat(Cat), #[prost(message, tag = \"5\", name = \"Bird\")] Bird(Bird),}#[derive(Clone, PartialEq, Message)]pub struct Dog { #[prost(string, tag=\"1\")] pub breed: String}#[derive(Clone, PartialEq, Message)]pub struct Cat { #[prost(bool, tag=\"1\")] pub has_tail: bool}#[derive(Clone, PartialEq, Message)]pub struct Bird { #[prost(uint32, tag=\"1\")] pub wingspan: u32}fn main() { let mut animal = Animal::default(); animal.name = \"Tom\".to_string(); animal.age = 3; animal.animal_type = Some(AnimalType::Cat(Cat { has_tail: true })); let mut buf = Vec::new(); animal.encode(&amp;mut buf).unwrap(); let decoded_animal = Animal::decode(&amp;buf[..]).unwrap(); assert_eq!(animal, decoded_animal);}在这个示例代码中，我们创建了一个Animal对象，并将其cat字段设置为一个包含has_tail字段的Cat对象。然后，我们将该对象序列化为字节数组，并将其反序列化为另一个Animal对象。最后，我们使用assert_eq宏比较这两个对象是否相等。##prost 最佳实践以下是一些使用 Prost 的最佳实践经验： 在 protobuf 定义中使用简单的数据类型。Prost 支持许多 protobuf 功能，例如嵌套消息、默认值、枚举类型以及变长编码。但是，使用这些功能可能会导致生成的 Rust 代码变得复杂。因此，为了使代码保持简单和易于维护，请尽可能使用简单的数据类型。 在 Rust 代码中使用结构体。Prost 生成的 Rust 代码可以是一个模块或一个 trait。但是，使用结构体可以使代码更易于使用和维护。因此，建议在 Rust 代码中使用结构体。 使用自定义类型时，请使用标准库或第三方库。Prost 支持许多自定义类型，包括日期、时间、UUID 等。但是，使用标准库或第三方库可能会使代码更加通用和可移植。因此，建议在使用自定义类型时使用标准库或第三方库。 在使用扩展字段时，请注意字段标签。扩展字段的标签必须大于 1000。因此，请确保您为扩展字段选择一个大于 1000 的标签。 在使用oneof语法时，请选择一个好的字段名称。oneof字段包含多个可能的类型，因此请为其选择一个好的字段名称。这将使代码更易于理解和维护。总结Prost 是一个高性能的 Rust 语言库，可用于序列化和反序列化协议缓冲区数据。它支持许多 protobuf 功能，并且可以与其他 Rust 语言库和框架无缝集成。在本教程中，我们介绍了 Prost 的基础用法和一些高级特性，并提供了一些最佳实践经验。我们希望这个教程能够帮助您更好地使用 Prost。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 解析控制台参数",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, structopt",
      "url"         : "./rust/2023/03/28/rust_lang_tutorial_207_Command_Args.html",
      "date"        : "2023-03-28 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust 是一种安全、高效的系统编程语言，其标准库以及外部库提供了很多处理控制台参数的方式。在本篇文章中，我们将分别介绍如何使用 Rust 的标准库处理控制台参数，以及如何使用 structopt 库处理控制台参数。我们还将介绍如何使用 structopt 处理复杂结构参数，并且提供相应的示例代码。处理控制台参数Rust 标准库提供了处理控制台参数的方式，主要基于三个模块：std::env、std::process 和 std::os::unix。在下面的例子中，我们将展示如何使用这些模块来处理控制台参数：12345678910111213141516use std::env;fn main() { let args: Vec&lt;String&gt; = env::args().collect(); println!(\"program name is {}\", args[0]); for arg in args.iter().skip(1) { println!(\"Argument: {}\", arg); match arg.as_str() { \"-v\" =&gt; println!(\"version is xxx\"), \"-h\" =&gt; println!(\"Help message\"), _ =&gt; println!(\"Unknown argument: {}\", arg), } }}在这个例子中，我们使用了 std::env::args 函数来获取命令行参数，该函数返回一个迭代器，我们需要将其转换为一个向量来方便地处理。接下来，我们使用’iter’函数和命令行参数向量创建一个迭代器。我们执行了’as_str’函数将迭代器值转换为其引用，我们再次使用 match 语句对参数进行筛选，并显示相应的消息。在处理控制台参数时，我们通常需要定义一组选项和参数，这些选项和参数可以通过命令行传递给程序。很明显假如我们仅使用标准库提供的 API 手动解析命令行参数，会非常耗时且麻烦。万幸的是，Rust 社区提供了开源的 structopt 库来帮助我们解析。使用 structopt 库处理控制台参数structopt 库提供了一种定义命令行选项和参数的方式，并自动生成解析代码的方法。它使用#[derive]属性来自动生成解析代码，这使得处理控制台参数变得非常简单。首先，我们需要将 structopt 库添加到我们的 Cargo.toml 文件中：12[dependencies]structopt = \"0.3.21\"然后，我们可以使用#[derive]来创建一个结构体，用于定义程序的所有选项和参数。例如，下面的代码定义了一个结构体，其中包含一个字符串参数和两个布尔选项：1234567891011use structopt::StructOpt;#[derive(Debug, StructOpt)]struct Opt { #[structopt(parse(from_os_str))] filename: std::path::PathBuf, #[structopt(short = \"v\", long = \"verbose\")] verbose: bool, #[structopt(short = \"f\", long = \"force\")] force: bool,}在上面的代码中，我们使用#[derive(StructOpt)]属性来告诉 structopt 库自动生成解析代码。我们还定义了三个字段：一个路径参数filename，以及两个布尔选项verbose和force。在这里，我们将filename字段标记为parse(from_os_str)，以便自动将其转换为PathBuf类型。接下来，我们可以在程序的main函数中使用Opt::from_args()函数来解析命令行参数并获取我们定义的选项和参数：12345678910111213141516use structopt::StructOpt;#[derive(Debug, StructOpt)]struct Opt { #[structopt(parse(from_os_str))] filename: std::path::PathBuf, #[structopt(short = \"v\", long = \"verbose\")] verbose: bool, #[structopt(short = \"f\", long = \"force\")] force: bool,}fn main() { let args = Opt::from_args(); println!(\"{:?}\", args);}上面的代码将打印出程序的所有选项和参数，例如，如果我们运行./main -v -f /path/to/file.txt，则输出将是Opt { filename: \"/path/to/file.txt\", verbose: true, force: true }。structopt 库还提供了许多其他选项和参数，例如子命令、默认值和验证函数等。有关更多详细信息，请参见官方文档。structopt 处理复杂结构参数在处理控制台参数时，我们通常需要处理一些复杂的结构参数，例如具有嵌套字段的结构体或向量。在这种情况下，我们可以使用 structopt 库的#[structopt(flatten)]和#[structopt(skip)]属性来解决问题。首先，让我们考虑一个具有嵌套字段的结构体。例如，下面的代码定义了一个包含名称、年龄和地址的人员结构体，其中地址包含城市、州和国家等嵌套字段：123456789101112131415161718192021use structopt::StructOpt;#[derive(Debug, StructOpt)]struct Address { city: String, state: String, country: String,}#[derive(Debug, StructOpt)]struct Animal { name: String, age: u8, #[structopt(flatten)] address: Address,}fn main() { let args = Animal::from_args(); println!(\"{:?}\", args);}在上面的代码中，我们使用#[structopt(flatten)]属性将Address结构体的字段展开到Animal结构体中。现在，我们可以将Animal结构体作为命令行参数传递给程序：1$ ./main --name Tom --age 30 --city Chengdu --state Chengdu --country China上面的命令将创建一个Animal结构体，其中包含名称为 Tom、年龄为 30 岁、地址为北京市、北京市、中国的人员信息。接下来，让我们考虑一个包含向量字段的结构体。例如，下面的代码定义了一个包含名称、年龄和朋友列表的人员结构体：1234567891011121314use structopt::StructOpt;#[derive(Debug, StructOpt)]struct Animal { name: String, age: u8, #[structopt(skip)] friends: Vec&lt;String&gt;,}fn main() { let args = Animal::from_args(); println!(\"{:?}\", args);}在上面的代码中，我们使用#[structopt(skip)]属性将friends字段跳过，因为我们将使用自定义代码来处理它。现在，我们可以将Animal结构体作为命令行参数传递给程序：1$ ./main --name Tom --age 30 --friends Bob --friends Charlie --friends Dave上面的命令将创建一个Animal结构体，其中包含名称为 Tom、年龄为 30 岁、朋友列表包含 Bob、Charlie 和 Dave 的人员信息。我们还需要手动将命令行参数中的朋友列表转换为向量字段。我们可以使用std::iter::FromIterator trait 来将命令行参数转换为向量字段：123456789101112131415161718192021222324252627282930use structopt::StructOpt;#[derive(Debug, StructOpt)]struct Animal { name: String, age: u8, #[structopt(skip)] friends: Vec&lt;String&gt;,}impl Animal { fn from_args() -&gt; Self { let mut args = Vec::from_iter(std::env::args()); let friends = args .iter() .enumerate() .filter_map(|(i, arg)| if i &gt; 0 &amp;&amp; args[i - 1] == \"--friends\" { Some(arg) } else { None }) .map(|arg| arg.to_owned()) .collect(); let args = Animal::clap().get_matches_from(args); let name = args.value_of(\"name\").unwrap().to_owned(); let age = args.value_of(\"age\").unwrap().parse().unwrap(); Animal { name, age, friends } }}fn main() { let args = Animal::from_args(); println!(\"{:?}\", args);}上面的代码使用std::env::args()函数获取命令行参数，并使用Vec::from_iter()函数将其转换为向量。然后，我们使用filter_map()函数和enumerate()函数来获取命令行参数中的朋友列表。接下来，我们使用std::iter::FromIterator trait 将朋友列表转换为向量，并将其存储在friends字段中。最后，我们使用Animal::clap().get_matches_from()函数来解析其他选项和参数，并使用name和age字段创建一个Animal结构体。结论在本教程中，我们介绍了如何使用 Rust 的标准库和 structopt 库来处理控制台参数。我们讨论了处理简单参数和选项的方法，以及处理复杂结构参数的方法。structopt 库提供了一种简单而强大的方式来定义命令行选项和参数，并自动生成解析代码。如果您需要处理控制台参数，那么 structopt 库是您的最佳选择。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 写时克隆智能指针Cow",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Cow",
      "url"         : "./rust/2023/03/28/rust_lang_tutorial_113_Trait_Cow.html",
      "date"        : "2023-03-28 00:00:00 +0800",
      "description" : "",
      "content"     : "Cow 是 Rust 语言中的一个特殊类型，全称为 Clone-On-Write，即在写入时进行克隆操作。Cow 类型可以用来避免不必要的内存分配和复制操作，从而提高程序的性能和效率。Cow 特征通常用于处理需要多次读取和少量修改的数据结构，比如字符串和向量等。在 Rust 中，Cow 类型通常用于解决以下两个问题： 读写分离：在一些业务场景中，需要对某个数据结构进行多次读取和少量修改，但是每次修改都会导致内存分配和复制操作，从而影响程序的性能和效率。Cow 类型可以通过克隆操作来避免这个问题，从而提高程序的性能和效率。 借用检查：在 Rust 中，借用检查是一项重要的安全特性，可以避免程序中出现内存安全问题。但是，在某些情况下，借用检查会导致代码的复杂度和可读性变差。Cow 类型可以通过引用和克隆操作来解决这个问题，从而简化代码的实现和维护。在本教程中，我们将通过一个 Animal 结构的示例来介绍 Cow 特征的使用方法和最佳实践。Animal 结构示例在本教程中，我们将通过一个 Animal 结构的示例来介绍 Cow 特征的使用方法和最佳实践。Animal 结构的定义如下：123456#[derive(Clone)]struct Animal { name: String, age: u32, species: String,}Animal 结构包含三个字段：name、age 和 species，分别表示动物的名称、年龄和物种。在本示例中，我们将使用 Cow 特征来处理 Animal 结构中的 name 和 species 字段。Cow 特征的含义Cow 特征是 Rust 语言中的一个标准库特性，用于处理读写分离的数据结构。Cow 类型有两种形式： Cow::Borrowed(&amp;’a T): 表示一个不可变的引用，可以用于读取数据； Cow::Owned(T): 表示一个可变的数据，可以用于修改数据。Cow 类型的克隆操作是惰性的，只有在修改数据时才会进行克隆操作。这种惰性的克隆操作可以避免不必要的内存分配和复制操作，从而提高程序的性能和效率。Cow 特征的常用业务场景和用法Cow 特征通常用于处理需要多次读取和少量修改的数据结构，比如字符串和向量等。在本教程中，我们将使用 Cow 特征来处理 Animal 结构中的 name 和 species 字段。具体来说，我们将使用 Cow 类型来处理以下两个场景： 读取 Animal 结构中的 name 和 species 字段； 修改 Animal 结构中的 name 和 species 字段。在读取 Animal 结构中的 name 和 species 字段时，我们可以使用 Cow::Borrowed 类型来避免不必要的内存分配和复制操作。具体来说，我们可以将 Animal 结构中的 name 和 species 字段定义为 String 类型，并使用 Cow::Borrowed 类型来读取数据。Animal 结构如下：123456789use std::borrow::Cow;use std::clone::Clone;#[derive(Clone)]struct Animal&lt;'a&gt; { name: Cow&lt;'a, str&gt;, age: u32, species: Cow&lt;'a, str&gt;,}示例代码如下：12345678910fn main() { let animal = Animal { name: Cow::Borrowed(\"Tom\"), age: 3, species: Cow::Borrowed(\"Cat\"), }; println!(\"Name: {}\", animal.name); println!(\"Species: {}\", animal.species);}在修改 Animal 结构中的 name 和 species 字段时，我们可以使用 Cow::Owned 类型来避免不必要的内存分配和复制操作。具体来说，我们可以使用 Cow::Owned 类型来克隆数据，并进行修改操作。示例代码如下：12345678910111213141516fn main() { let mut animal = Animal { name: Cow::Borrowed(\"Tom\"), age: 3, species: Cow::Borrowed(\"Cat\"), }; animal.name.to_mut().push_str(\"mycat\"); animal.species = Cow::Owned(\"Lion\".to_string()); println!(\"Name: {}\", animal.name); println!(\"Species: {}\", animal.species);}// 输出结果：// Name: Tom// Species: Cat在这个示例中，我们首先使用 Cow::Borrowed 类型来读取 Animal 结构中的 name 和 species 字段。然后，我们使用 Cow::Owned 类型来克隆 Animal 结构中的 name 字段，并进行修改操作。最后，我们使用 Cow::Owned 类型来修改 Animal 结构中的 species 字段。Cow 特征的进阶用法除了基本用法之外，Cow 特征还有一些进阶用法，可以进一步提高程序的性能和效率。下面介绍几种常用的进阶用法。Cow::into_owned 方法Cow::into_owned 方法可以将 Cow 类型转换为 Owned 类型。具体来说，它会在需要修改数据时进行克隆操作，并返回一个可变的数据。示例代码如下：12345678910111213141516171819202122232425fn main() { let animal = Animal { name: Cow::Borrowed(\"Tom\"), age: 3, species: Cow::Borrowed(\"Cat\"), }; let mut name = animal.name.into_owned(); name.push_str(\"mycat\"); let mut species = animal.species.into_owned(); species = \"Lion\".to_string(); let animal2 = Animal { name: Cow::Owned(name), age: 4, species: Cow::Owned(species), }; println!(\"Name: {}\", animal2.name); println!(\"Species: {}\", animal2.species);}// 输出结果：// Name: Tommycat// Species: Lion在这个示例中，我们首先使用 Cow::Borrowed 类型来读取 Animal 结构中的 name 和 species 字段。然后，我们使用 Cow::into_owned 方法将 Animal 结构中的 name 和 species 字段转换为 Owned 类型，并进行修改操作。最后，我们使用 Cow::Owned 类型来构造一个新的 Animal 结构。Cow::from 方法Cow::from 方法可以将一个不可变的引用或可变的数据转换为 Cow 类型。具体来说，它会根据数据类型的不同，返回一个 Cow::Borrowed 或 Cow::Owned 类型。示例代码如下：12345678910111213141516fn main() { let name = \"Tom\".to_string(); let species = \"Cat\".to_string(); let animal = Animal { name: Cow::from(&amp;name), age: 3, species: Cow::from(species), }; println!(\"Name: {}\", animal.name); println!(\"Species: {}\", animal.species);}// 输出结果：// Name: Tom// Species: Cat在这个示例中，我们首先定义了一个 name 和 species 变量，并将它们转换为 String 类型。然后，我们使用 Cow::from 方法将 name 和 species 变量转换为 Cow 类型，并构造一个新的 Animal 结构。Cow::into_owned 方法Cow::into_owned 方法可以将 Cow 类型转换为 Owned 类型，并清空原始数据。具体来说，它会在需要修改数据时进行克隆操作，并返回一个可变的数据。示例代码如下：12345678910111213fn main() { let mut animal = Animal { name: Cow::Borrowed(\"Tom\"), age: 3, species: Cow::Borrowed(\"Cat\"), }; let name = animal.name.into_owned(); let species = animal.species.into_owned(); println!(\"Name: {}\", name); println!(\"Species: {}\", species);}在这个示例中，我们首先使用 Cow::Borrowed 类型来构造一个 Animal 结构。然后，我们使用 Cow::into_owned 方法将 Animal 结构中的 name 和 species 字段转换为 Owned 类型，并清空原始数据。Cow 特征的最佳实践Cow 特征是 Rust 语言中一个非常有用的特性，可以用于处理读写分离的数据结构。在使用 Cow 特征时，需要注意以下几点最佳实践： 尽量使用 Cow::Borrowed 类型来读取数据，避免不必要的内存分配和复制操作； 尽量使用 Cow::Owned 类型来修改数据，避免不必要的内存分配和复制操作； 在需要使用 Cow 类型时，优先考虑使用 Cow::from 方法来构造 Cow 类型； 在需要修改数据时，优先考虑使用 Cow::into_owned 方法或 Cow::into_owned 方法来转换 Cow 类型为 Owned 类型； 在定义 Cow 类型时，需要使用泛型参数来指定数据类型，避免类型不匹配的错误。总结Cow 特征是 Rust 语言中的一个非常有用的特性，可以用于处理读写分离的数据结构。在本教程中，我们通过 Animal 结构的示例来介绍 Cow 特征的使用方法和最佳实践。具体来说，我们介绍了 Cow 类型的定义、含义、常用业务场景和用法、进阶用法和最佳实践。通过学习本教程，您可以更好地理解和应用 Cow 特征，提高程序的性能和效率。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Tauri GUI实战",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, GUI",
      "url"         : "./rust/2023/03/27/rust_lang_tutorial_260_GUI_1.html",
      "date"        : "2023-03-27 00:00:00 +0800",
      "description" : "",
      "content"     : ""
    } ,
  
    {
      "title"       : "一文读懂Java的BigDecimal",
      "category"    : "",
      "tags"        : "Java, BigDecimal",
      "url"         : "./java/2023/03/27/Java_JDK8_BigDecimal.html",
      "date"        : "2023-03-27 00:00:00 +0800",
      "description" : "",
      "content"     : "Java 8引入了新的日期时间API，包括DateTime、LocalDate、LocalDateTime、Instant、Period和Duration。这些新的API提供了更好的时间处理方式，使得日期时间处理更加简单、易用和可读。DateTimeDateTime是Java 8中最基本的日期时间类，它表示一个特定的日期和时间。它包含了年、月、日、时、分、秒和毫秒等信息。DateTime对象通常用于表示一个具体的日期和时间，例如2019年12月31日23点59分59秒。它可以用于计算两个日期之间的差值，或者将日期时间转换为不同的时区。常用API和方法 of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond, ZoneId zone)：创建一个DateTime对象，指定年、月、日、时、分、秒、毫秒和时区。 now()：获取当前的DateTime对象。 getYear()：获取年份。 getMonth()：获取月份。 getDayOfMonth()：获取日期。 getHour()：获取小时。 getMinute()：获取分钟。 getSecond()：获取秒数。 getNano()：获取纳秒数。 atZone(ZoneId zone)：将DateTime对象转换为指定时区的ZonedDateTime对象。 format(DateTimeFormatter formatter)：将DateTime对象格式化为指定格式的字符串。LocalDateLocalDate是Java 8中的日期类，它表示一个特定的日期。它包含了年、月和日等信息。LocalDate对象通常用于表示一个具体的日期，例如2019年12月31日。它可以用于计算两个日期之间的差值，或者进行日期的加减运算。常用API和方法 of(int year, int month, int dayOfMonth)：创建一个LocalDate对象，指定年、月和日。 now()：获取当前的LocalDate对象。 getYear()：获取年份。 getMonth()：获取月份。 getDayOfMonth()：获取日期。 getDayOfWeek()：获取星期几。 getDayOfYear()：获取一年中的第几天。 plusDays(long daysToAdd)：增加指定的天数。 minusDays(long daysToSubtract)：减少指定的天数。 with(TemporalAdjuster adjuster)：使用指定的TemporalAdjuster调整日期。LocalDateTimeLocalDateTime是Java 8中的日期时间类，它表示一个特定的日期和时间。它包含了年、月、日、时、分、秒和毫秒等信息。LocalDateTime对象通常用于表示一个具体的日期和时间，例如2019年12月31日23点59分59秒。它可以用于计算两个日期之间的差值，或者将日期时间转换为不同的时区。常用API和方法 of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)：创建一个LocalDateTime对象，指定年、月、日、时、分、秒和毫秒。 now()：获取当前的LocalDateTime对象。 getYear()：获取年份。 getMonth()：获取月份。 getDayOfMonth()：获取日期。 getHour()：获取小时。 getMinute()：获取分钟。 getSecond()：获取秒数。 getNano()：获取纳秒数。 plusDays(long daysToAdd)：增加指定的天数。 minusDays(long daysToSubtract)：减少指定的天数。 with(TemporalAdjuster adjuster)：使用指定的TemporalAdjuster调整日期。InstantInstant是Java 8中的时间戳类，它表示一个特定的时间。它包含了秒数和纳秒数等信息。Instant对象通常用于表示一个特定的时间，例如2023年3月27日00点12分30秒。它可以用于计算两个时间之间的差值，或者将时间戳转换为不同的时区。常用API和方法 ofEpochSecond(long epochSecond)：创建一个Instant对象，指定秒数。 now()：获取当前的Instant对象。 getEpochSecond()：获取秒数。 getNano()：获取纳秒数。 plusSeconds(long secondsToAdd)：增加指定的秒数。 minusSeconds(long secondsToSubtract)：减少指定的秒数。 isAfter(Instant otherInstant)：判断当前时间是否在指定时间之后。 isBefore(Instant otherInstant)：判断当前时间是否在指定时间之前。PeriodPeriod是Java 8中的时间段类，它表示两个日期之间的时间差。它包含了年、月和日等信息。Period对象通常用于计算两个日期之间的时间差，例如2019年12月31日和2020年1月1日之间的时间差。它可以用于计算两个日期之间的差值，或者进行日期的加减运算。常用API和方法 between(LocalDate startDateInclusive, LocalDate endDateExclusive)：创建一个Period对象，表示两个日期之间的时间差。 getYears()：获取年数。 getMonths()：获取月数。 getDays()：获取天数。DurationDuration是Java 8中的时间段类，它表示两个时间之间的时间差。它包含了秒数和纳秒数等信息。Duration对象通常用于计算两个时间之间的时间差，例如2023年3月27日00点12分30秒和2023年3月27日00点13分30秒之间的时间差。它可以用于计算两个时间之间的差值，或者进行时间的加减运算。常用API和方法 between(Instant startInclusive, Instant endExclusive)：创建一个Duration对象，表示两个时间之间的时间差。 getSeconds()：获取秒数。 getNano()：获取纳秒数。常见用法和示例日期时间转换在实际开发中，我们通常需要将日期时间转换为不同的格式或者不同的时区。下面是一些常见的日期时间转换场景。将日期时间转换为字符串使用DateTimeFormatter类可以将日期时间转换为指定格式的字符串。例如，将2023年3月27日00点12分30秒转换为字符串：1234DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");LocalDateTime dateTime = LocalDateTime.of(2023, 3, 27, 0, 12, 30);String str = dateTime.format(formatter);System.out.println(str); // 输出：2023-03-27 00:12:30将字符串转换为日期时间使用DateTimeFormatter类可以将字符串转换为指定格式的日期时间。例如，将字符串”2023-03-27 00:12:30”转换为LocalDateTime对象：1234DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");String str = \"2023-03-27 00:12:30\";LocalDateTime dateTime = LocalDateTime.parse(str, formatter);System.out.println(dateTime); // 输出：2023-03-27T00:12:30将日期时间转换为指定时区的时间使用ZonedDateTime类可以将日期时间转换为指定时区的时间。例如，将2023年3月27日00点12分30秒转换为美国纽约时区的时间：1234LocalDateTime dateTime = LocalDateTime.of(2023, 3, 27, 0, 12, 30);ZoneId zoneId = ZoneId.of(\"America/New_York\");ZonedDateTime zonedDateTime = ZonedDateTime.of(dateTime, zoneId);System.out.println(zonedDateTime); // 输出：2023-03-26T20:12:30-04:00[America/New_York]时间计算在实际开发中，我们通常需要对日期时间进行加减运算，或者计算两个日期时间之间的时间差。下面是一些常见的时间计算场景。计算两个日期之间的时间差使用Period类可以计算两个日期之间的时间差。例如，计算2019年12月31日和2020年1月1日之间的时间差：1234LocalDate startDate = LocalDate.of(2019, 12, 31);LocalDate endDate = LocalDate.of(2020, 1, 1);Period period = Period.between(startDate, endDate);System.out.println(period.getDays()); // 输出：1计算两个时间之间的时间差使用Duration类可以计算两个时间之间的时间差。例如，计算2023年3月27日00点12分30秒和2023年3月27日00点13分30秒之间的时间差：1234Instant startInstant = Instant.parse(\"2023-03-27T00:12:30Z\");Instant endInstant = Instant.parse(\"2023-03-27T00:13:30Z\");Duration duration = Duration.between(startInstant, endInstant);System.out.println(duration.getSeconds()); // 输出：60获取某个月份的最后一天使用TemporalAdjusters类可以获取某个月份的最后一天。例如，获取2023年3月的最后一天：123LocalDate date = LocalDate.of(2023, 3, 1);LocalDate lastDayOfMonth = date.with(TemporalAdjusters.lastDayOfMonth());System.out.println(lastDayOfMonth); // 输出：2023-03-31获取某个日期的下一个周一使用TemporalAdjusters类可以获取某个日期的下一个周一。例如，获取2023年3月27日的下一个周一：123LocalDate date = LocalDate.of(2023, 3, 27);LocalDate nextMonday = date.with(TemporalAdjusters.next(DayOfWeek.MONDAY));System.out.println(nextMonday); // 输出：2023-04-03最佳实践在实际开发中，我们应该尽可能使用新的日期时间API，避免使用旧的Date和Calendar类。下面是一些最佳实践的建议。 使用LocalDate代替Date在Java 8之前，我们通常使用Date类表示日期。然而，Date类有很多问题，例如它是可变的、不是线程安全的、没有时区信息等等。因此，我们应该尽可能使用LocalDate代替Date。 使用LocalDateTime代替Calendar在Java 8之前，我们通常使用Calendar类表示日期时间。然而，Calendar类也有很多问题，例如它是可变的、不是线程安全的、没有时区信息等等。因此，我们应该尽可能使用LocalDateTime代替Calendar。 使用Instant代替System.currentTimeMillis()在Java 8之前，我们通常使用System.currentTimeMillis()方法获取当前时间戳。然而，它只能精确到毫秒级别，不够精确。因此，我们应该尽可能使用Instant类代替System.currentTimeMillis()方法。总结Java 8中的新日期时间API提供了更好的时间处理方式，使得日期时间处理更加简单、易用和可读。在实际开发中，我们应该尽可能使用新的日期时间API，避免使用旧的Date和Calendar类。"
    } ,
  
    {
      "title"       : "如何让一款Rougelike游戏变得好玩？",
      "category"    : "",
      "tags"        : "Game, Rougelike",
      "url"         : "./game/2023/03/27/Game_Developer_Make_Rougelike_Game_Fanny.html",
      "date"        : "2023-03-27 00:00:00 +0800",
      "description" : "",
      "content"     : "博主身为Rougelike狂热爱好者，十年肉鸽老玩家，上百款rougelike游戏重度体验者等多重身份，结合我玩家和全栈的经验总结了以下几条关于rougelike游戏为什么好玩的经验心得。欢迎童鞋们反馈和补充。第一条：提高游戏流畅性Roguelike游戏是一种对操作要求较高的游戏类型。玩家需要在极短时间内作出正确的决策并迅速执行，在这个过程中，玩家需要非常流畅的游戏操作体验才能充分发挥其游戏技能。因此，要想让游戏好玩，首先开发者必须更注重游戏的流畅性，通过各种手段来提高玩家的操作体验。例如，使用简单的图形界面，简化操作流程，允许玩家在游戏中进行快速的探索。此外，还可以随时显示类似指南针的工具，以帮助玩家更方便地寻找特定的场景，提供更好的游戏体验。从技术开发角度来讲。 优化游戏引擎和代码：对游戏引擎和代码进行优化，减少不必要的计算和内存使用，提高游戏运行的效率和流畅性。 减少渲染负荷：尽量减少游戏中需要渲染的物体数量和复杂度，使用合适的渲染技术来减少渲染负荷，例如LOD（Level of Detail）技术。 优化资源加载：合理地管理和加载游戏资源，避免在游戏运行时频繁加载资源，造成卡顿和延迟。 避免内存泄漏：及时释放游戏中不再使用的内存，防止内存泄漏导致游戏卡顿和崩溃。 适当减少特效和动画：适当减少游戏中的特效和动画，避免过多的视觉刺激，影响游戏的流畅性。 进行多平台适配：对不同平台进行适配，根据平台的硬件性能和特性进行优化，提高游戏的流畅度和性能。 进行充分的测试和优化：在开发过程中进行充分的测试和优化，发现问题及时解决，确保游戏的流畅性和稳定性。从美术资源角度来讲： 优化纹理和模型：游戏中使用的纹理和模型应该经过优化，以减少其大小和复杂性。这可以通过选择合适的压缩算法、删除不必要的细节和使用低多边形模型来实现。 精简UI设计：游戏界面的设计应该简单明了，不要使用过多的细节和动画效果，以减少UI的渲染时间。 合理使用光照：游戏中的光照效果可以增加游戏的真实感，但是过多的光照会增加游戏的渲染负担。因此，应该合理使用光照，减少不必要的光照效果。 控制粒子效果：游戏中的粒子效果可以增加游戏的特效和真实感，但是过多的粒子效果会增加游戏的渲染负担。因此，应该适当控制粒子效果的数量和复杂度。 优化代码：游戏开发者应该优化游戏代码，以减少代码的运行时间和内存占用。这包括使用合适的数据结构、避免不必要的循环和递归等。 使用合适的渲染引擎：游戏开发者应该选择合适的渲染引擎，以提高游戏的流畅性和性能。常用的渲染引擎包括Unity、Unreal Engine、Cocos2d等。 适当降低画质：如果游戏的流畅性受到限制，可以适当降低游戏的画质，以提高游戏的性能和流畅性。这包括减少纹理的分辨率、减少光照效果等。第二条：设计丰富的随机地图地图设计是Roguelike游戏非常重要的一部分。随机地图生成技术能够允许我们设计大量不同的地图，为玩家提供充分的探索空间。算法非常多，这里列举几个博主个人搜索研究过的几个算法。 随机迷宫生成技术：通过随机地图生成算法，生成一个迷宫状的地图，如《地牢探险》（Dungeon Explorer）。 随机散点生成技术：通过在地图上随机散布一定数量的点，然后通过连接这些点来生成地图，如《古墓丽影》（Tomb Raider）。 随机地形生成技术：通过随机生成不同类型的地形，如山脉、河流、森林等来生成地图，如《文明》（Civilization）。 随机地图片段生成技术：通过将不同的地图片段随机组合在一起，生成地图，如《无尽之剑》（Sword of the Stars）。 随机区块生成技术：通过将地图分成不同的区块，然后随机生成这些区块的内容，如《我的世界》（Minecraft）。 随机地图形态生成技术：通过随机生成地图的形态，如大小、形状等，来生成地图，如《太空巡警》（FTL: Faster Than Light）。在算法之外，地图必须遵守一些基本原则。它必须是非常真实的，传达出地图的整体氛围和特点，例如：暗黑，冰雪，火山，海底等等。此外，一定要充分利用地图，并允许玩家在其中添加一些他们自己的东西，例如：场景破坏，随机场景事件，随机场景NPC，宝藏密室等等。最后，地图设计需要考虑到游戏的主线任务和当前任务展开，以便玩家可以利用地图找到非常有用的信息。第三条：加入全新的游戏元素我们必须在游戏中加入一些全新的元素，从而使整个游戏内容非常吸引人。在Roguelike游戏中，我们可以使用许多不同的元素，如探险，神话，幻想，恐怖等，以及一些触发玩家情感的新动态事件，创造出非常有趣的游戏世界。例如，我们可以加入一些极酷的武器和道具，让他们成为游戏中的主角，以高质量的动画形式显示，同时提供与之匹配的音乐，从而为游戏提供非常具有吸引力的体验。具体点来讲，我们同样以武器和物品系统为例： 多样化的武器和道具：设计出各种不同类型的武器和道具，以满足玩家在游戏中的需求，例如：《怪物猎人》设计的近战、远程、防御等装备、辅助道具等。《无主之地3》随机组合高达10亿种武器。 属性和效果的平衡：每种武器和道具应该有不同的属性和效果，但需要保证它们之间的平衡，避免某一种武器或道具过于强大，导致游戏失去挑战性。数值的平衡性极大程度上决定了游戏的玩法和生态是否具有多样性。举一个反面例子：暗黑3后期引人绿色套装系统，导致每个版本都是标准答案，游戏玩法缺乏多样性。 随机性的引入：rougelike游戏的核心是随机生成的地图和敌人，同样也应该引入随机性到武器和道具的生成中，使得每次游戏的体验都是不同的。例如：随机获取武器，随机武器属性，随机强化词缀，随机获得辅助道具等等。 升级和进阶：设计者可以设计一些武器和道具需要玩家在游戏中进行升级或进阶，以提高其属性和效果，增加玩家的探索和收集乐趣。 掉落和商店：武器和道具可以通过掉落或商店获得，设计者需要考虑它们的掉落概率和商店价格，以保证游戏中的经济系统平衡。 敌人和环境的影响：有些武器和道具可能会受到敌人和环境的影响，设计者需要考虑这些因素对武器和道具属性和效果的影响，以增加游戏的策略性。第四条：加入更多的NPC和敌人在Roguelike游戏中，NPC和敌人的重要性不言而喻。通过与NPC互动，我们可以获取更多的游戏信息和奖励，进一步推动游戏故事的发展。敌人则是游戏的一大挑战，必须进行充分考虑和设计，才能发挥其最大的潜力。我们需要设计不同类型的NPC，以满足玩家的各种需求。例如，我们可以设计一些新的商人类型，以他们主卖不同类型的道具来达到推进任务进程的目的。我们还可以为NPC分配更多的任务，并通过可视化操作来增加游戏的趣味性。为敌人添加新的特点和武器，以及不同的攻击模式，是很有趣的事情。敌人的行动必须更加智能化，并配合不同的动画和声音，更有可能吸引玩家。第五条：提高游戏难度Roguelike游戏的难度是其最吸引人的地方之一。因此，我们需要寻找一种平衡，既能让玩家觉得有足够的挑战，又不会让他们受到过度的打压。在这方面，博主以常见的小怪，精英，头领和boss四档怪物分级为例, 设计中可以给与每一档怪物设置不同的定位，例如： 小怪：小怪是游戏中最基础的怪物，通常出现频率较高，但是难度较低。设计关卡时应该逐渐增加小怪的数量和种类，同时逐渐增加它们的难度和攻击力，以增加游戏的挑战性。 精英怪通常比小怪更强大，但出现的频率较低。为了增加游戏的难度，可以将精英怪放置在比较难以到达的地方，或者设计一些特殊机制，例如需要用特定的武器或技能才能击败它们。 头领是关卡中的重要BOSS，通常比其他怪物更强大，并且需要一定的策略和技巧才能击败。设计头领时应该考虑其攻击方式和弱点，并设计一些特殊机制或者环境，以增加游戏的挑战性。 BOSS：BOSS是关卡中最强大的怪物，需要玩家花费大量时间和精力才能击败。为了增加游戏的难度，可以将BOSS放置在特定的地点或者隐藏在某些难以到达的地方，同时设计一些特殊机制或者环境，以增加游戏的挑战性。在设置关卡难度时，还应该考虑以下几点： 逐渐增加游戏难度：游戏的难度应该逐渐增加，以避免玩家在游戏初期就失去兴趣。可以通过逐渐增加怪物数量、种类和难度，以及增加游戏机制和环境来实现。 考虑玩家技能和装备：在设计关卡难度时，需要考虑玩家的技能和装备，以确保游戏的难度与玩家的能力相匹配。如果游戏的难度过高，可能会让玩家感到沮丧，而如果难度过低，可能会让玩家感到无聊。 测试和平衡：在设计关卡难度时，需要进行测试和平衡，以确保游戏的难度合适。可以通过测试玩家的反应和完成时间，以及玩家反馈来评估游戏的难度，并进行相应的调整。 增加随机性：为了增加游戏的重玩价值，可以增加一些随机因素，例如随机生成的怪物、道具和环境。这样可以使每次游戏都有所不同，增加游戏的挑战性和乐趣。第六条：提高游戏音乐和音效的质量为游戏添加高质量的音乐和音效是一种不可忽视的游戏提高趣味性的方式。音乐和音效可以帮助我们营造沉浸式的游戏体验，并迅速将玩家带入游戏的世界中。游戏音乐必须与游戏场景和事件相匹配。例如，我们可以在玩家探险时，通过使用轻松愉悦的旋律，增强玩家的探险体验。当玩家受到攻击时，我们可以通过更强的音效，让玩家感觉到敌人的真实存在。 这块内容不熟悉，挖坑待填。结论Roguelike游戏的制作可以从很多方面来提高好玩程度。通过设计丰富的随机地图，添加全新的游戏元素、NPC和敌人，提高游戏的难度和流畅性，并通过高质量的音乐和声效来提高游戏的趣味性。在游戏设计中，坚持贯彻这些原则，我们可以开发出一款非常出色且广受欢迎的游戏。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 动态规划算法实践",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 动态规划",
      "url"         : "./rust/2023/03/24/rust_lang_tutorial_330_Dynamic_programming.html",
      "date"        : "2023-03-24 00:00:00 +0800",
      "description" : "",
      "content"     : "动态规划算法是一种常见的优化算法，可以用于解决许多复杂的问题。本教程介绍了动态规划算法的基本概念和原理，并提供了 Rust 语言示例代码。通过学习本教程，你应该能够理解动态规划算法的基本思想，以及如何使用 Rust 语言实现它。动态规划算法动态规划算法是一种通过将问题分解为子问题来解决复杂问题的算法。它通常用于优化问题，其中需要找到最优解或最大值。动态规划算法的核心思想是将问题分解为更小的子问题，并将它们的解存储在一个表格中。然后，通过查找表格中的值来计算原始问题的解。这种方法可以避免重复计算子问题，从而提高效率。动态规划算法通常用于解决以下类型的问题： 最长公共子序列 背包问题 最短路径问题 最大子序列和问题 动态规划算法的步骤动态规划算法通常包括以下步骤： 定义子问题：将原始问题分解为子问题。 定义状态：确定要存储的信息以解决子问题。 定义状态转移方程：确定如何计算子问题的解。 计算最终解：将子问题的解组合成原始问题的解。Rust 语言示例实践最长公共子序列以下是一个使用动态规划算法解决最长公共子序列问题的 Rust 语言示例代码：123456789101112131415161718192021222324252627282930313233343536fn longest_common_subsequence(s1: &amp;str, s2: &amp;str) -&gt; String { let mut table = vec![vec![0; s2.len() + 1]; s1.len() + 1]; for (i, c1) in s1.chars().enumerate() { for (j, c2) in s2.chars().enumerate() { if c1 == c2 { table[i + 1][j + 1] = table[i][j] + 1; } else { table[i + 1][j + 1] = std::cmp::max(table[i + 1][j], table[i][j + 1]); } } } let mut result = String::new(); let mut i = s1.len(); let mut j = s2.len(); while i &gt; 0 &amp;&amp; j &gt; 0 { if table[i][j] == table[i - 1][j] { i -= 1; } else if table[i][j] == table[i][j - 1] { j -= 1; } else { result.push(s1.chars().nth(i - 1).unwrap()); i -= 1; j -= 1; } } result.chars().rev().collect()}fn main() { let s1 = \"ABCD\"; let s2 = \"ACDF\"; let result = longest_common_subsequence(s1, s2); println!(\"Longest common subsequence of {} and {} is {}\", s1, s2, result);}// 输出结果// Longest common subsequence of ABCD and ACDF is ACD以上代码使用一个二维表格来存储子问题的解，并使用状态转移方程来计算表格中的值。最后，它将子问题的解组合成原始问题的解。解决背包问题123456789101112131415161718192021222324fn knapsack(weights: &amp;[u32], values: &amp;[u32], capacity: u32) -&gt; u32 { let n = weights.len(); let mut table = vec![vec![0; capacity as usize + 1]; n + 1]; for i in 0..=n { for j in 0..=capacity as usize { if i == 0 || j == 0 { table[i][j] = 0; } else if weights[i - 1] as usize &lt;= j { table[i][j] = std::cmp::max(values[i - 1] + table[i - 1][j - weights[i - 1] as usize], table[i - 1][j]); } else { table[i][j] = table[i - 1][j]; } } } table[n][capacity as usize]}fn main() { let weights = vec![2, 3, 4, 5]; let values = vec![3, 4, 5, 6]; let capacity = 8; let result = knapsack(&amp;weights, &amp;values, capacity); println!(\"Maximum value that can be obtained with a capacity of {} is {}\", capacity, result);}以上代码使用一个二维表格来存储子问题的解，并使用状态转移方程来计算表格中的值。最后，它返回表格中最后一个元素的值，即原始问题的解。最长上升子序列最长上升子序列是一个序列中最长的子序列，使得其中的元素按升序排列。以下是使用动态规划算法解决最长上升子序列问题的 Rust 语言示例代码：123456789101112131415161718fn longest_increasing_subsequence(nums: &amp;[i32]) -&gt; usize { let n = nums.len(); let mut dp = vec![1; n]; for i in 1..n { for j in 0..i { if nums[i] &gt; nums[j] { dp[i] = std::cmp::max(dp[i], dp[j] + 1); } } } *dp.iter().max().unwrap()}fn main() { let nums = vec![10, 9, 2, 5, 3, 7, 101, 18]; let result = longest_increasing_subsequence(&amp;nums); println!(\"Length of longest increasing subsequence in {:?} is {}\", nums, result);}以上代码使用一个一维数组来存储子问题的解，并使用状态转移方程来计算数组中的值。最后，它返回数组中的最大值，即原始问题的解。最大子序列和最大子序列和是一个序列中最大的子序列和。以下是使用动态规划算法解决最大子序列和问题的 Rust 语言示例代码：1234567891011121314151617fn max_subarray(nums: &amp;[i32]) -&gt; i32 { let mut max_sum = nums[0]; let mut cur_sum = nums[0]; for &amp;num in nums.iter().skip(1) { cur_sum = std::cmp::max(num, cur_sum + num); max_sum = std::cmp::max(max_sum, cur_sum); } max_sum}fn main() { let nums = vec![-2, 1, -3, 4, -1, 2, 1, -5, 4]; let result = max_subarray(&amp;nums); println!(\"Maximum subarray sum of {:?} is {}\", nums, result);}// 输出结果：// Maximum subarray sum of [-2, 1, -3, 4, -1, 2, 1, -5, 4] is 6以上代码使用一个变量来存储子问题的解，并使用状态转移方程来计算变量的值。最后，它返回变量的值，即原始问题的解。"
    } ,
  
    {
      "title"       : "FlatBuffer",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 代理模式",
      "url"         : "./rust/2023/03/24/Java_JDK8_FlatBuffer.html",
      "date"        : "2023-03-24 00:00:00 +0800",
      "description" : "",
      "content"     : "FlatBuffers是一种高效的内存序列化库，它可以在不进行解码的情况下直接访问数据。FlatBuffers是前Google工程师开发的，它的目标是提供一种高效的序列化和反序列化方式，以便在游戏和嵌入式系统中使用。FlatBuffers的主要特点是它可以在不进行解码的情况下直接访问数据。FlatBuffers通过使用平坦的内存布局来实现这一点，从而使其在序列化和反序列化方面具有优势。常用用法安装FlatBuffers在Java中使用FlatBuffers之前，您需要安装FlatBuffers。您可以从FlatBuffers的GitHub页面上下载FlatBuffers的最新版本。下载完成后，您需要将FlatBuffers添加到Java类路径中。您可以将FlatBuffers添加到Java类路径中的方法有很多种，例如，您可以在Java项目中使用Maven或Gradle来管理依赖项，或者您可以将FlatBuffers的JAR文件手动添加到Java类路径中。创建FlatBuffers对象在Java中使用FlatBuffers之前，您需要创建FlatBuffers对象。您可以使用FlatBuffers的Builder类来创建FlatBuffers对象。Builder类是FlatBuffers的主要类之一，它用于构建FlatBuffers对象。Builder类的构造函数接受一个int类型的参数，该参数指定FlatBuffers对象的初始大小。您可以使用FlatBuffers的默认构造函数创建Builder对象，也可以使用自定义大小的构造函数创建Builder对象。1234567import com.google.flatbuffers.FlatBufferBuilder;public class FlatBuffersExample { public static void main(String[] args) { FlatBufferBuilder builder = new FlatBufferBuilder(); }}创建FlatBuffers Schema在Java中使用FlatBuffers之前，您需要创建FlatBuffers Schema。FlatBuffers Schema是一种用于定义数据结构的语言，它类似于IDL（接口定义语言）。FlatBuffers Schema使用扩展名为.fbs的文件进行存储。您可以使用FlatBuffers Schema来定义数据结构，然后使用FlatBuffers的代码生成器生成Java类。例如，我们可以定义一个名为Animal的数据结构，它具有名称和年龄属性：namespace example;table Animal { name: string; age: int;}生成Java类在定义FlatBuffers Schema之后，您需要使用FlatBuffers的代码生成器生成Java类。FlatBuffers的代码生成器可以生成用于序列化和反序列化FlatBuffers对象的Java类。要生成Java类，您需要使用FlatBuffers的命令行工具flatc。1flatc --java animal.fbs该命令将生成一个名为Animal.java的Java类，您可以在Java应用程序中使用该类来创建和读取FlatBuffers对象。创建FlatBuffers对象在Java中使用FlatBuffers创建对象时，您需要使用FlatBuffers的Builder类。Builder类用于构建FlatBuffers对象。要创建FlatBuffers对象，您需要使用Builder类的startTable方法开始一个新的表，并使用add方法添加属性。例如，我们可以使用以下代码创建一个名为animal的FlatBuffers对象：123456789101112131415import com.example.Animal;public class FlatBuffersExample { public static void main(String[] args) { FlatBufferBuilder builder = new FlatBufferBuilder(); int nameOffset = builder.createString(\"Leo\"); Animal.startAnimal(builder); Animal.addName(builder, nameOffset); Animal.addAge(builder, 3); int animalOffset = Animal.endAnimal(builder); builder.finish(animalOffset); }}在上面的示例中，我们使用createString方法创建一个名为Leo的字符串，并使用startAnimal方法开始一个新的表。然后我们使用addName方法添加名称属性，并使用addAge方法添加年龄属性。最后，我们使用endAnimal方法结束表，并使用finish方法完成FlatBuffers对象的构建。读取FlatBuffers对象在Java中使用FlatBuffers读取对象时，您需要使用FlatBuffers的ByteBuffer类。ByteBuffer类用于读取FlatBuffers对象。要读取FlatBuffers对象，您需要使用ByteBuffer类的get方法获取属性。例如，我们可以使用以下代码读取上面创建的animal对象：12345678910111213import com.example.Animal;import java.nio.ByteBuffer;public class FlatBuffersExample { public static void main(String[] args) { ByteBuffer buffer = ...; Animal animal = Animal.getRootAsAnimal(buffer); String name = animal.name(); int age = animal.age(); }}在上面的示例中，我们使用getRootAsAnimal方法从ByteBuffer中获取Animal对象。然后我们使用name方法获取名称属性，并使用age方法获取年龄属性。进阶实战构建嵌套结构在FlatBuffers中，您可以使用嵌套结构来构建复杂的数据结构。在Java中使用FlatBuffers构建嵌套结构时，您需要在FlatBuffers Schema中定义嵌套结构，并在Java代码中使用相应的方法来构建嵌套结构。例如，我们可以使用以下FlatBuffers Schema定义一个名为Zoo的数据结构，它包含多个Animal对象：namespace example;table Zoo { animals: [Animal];}然后我们可以使用以下Java代码来构建Zoo对象：12345678910111213141516171819202122232425262728import com.example.Animal;import com.example.Zoo;import java.util.ArrayList;import java.util.List;public class FlatBuffersExample { public static void main(String[] args) { FlatBufferBuilder builder = new FlatBufferBuilder(); int[] animalsOffset = new int[2]; for (int i = 0; i &lt; 2; i++) { int nameOffset = builder.createString(\"Leo\"); Animal.startAnimal(builder); Animal.addName(builder, nameOffset); Animal.addAge(builder, 3); int animalOffset = Animal.endAnimal(builder); animalsOffset[i] = animalOffset; } int animalsVectorOffset = Zoo.createAnimalsVector(builder, animalsOffset); Zoo.startZoo(builder); Zoo.addAnimals(builder, animalsVectorOffset); int zooOffset = Zoo.endZoo(builder); builder.finish(zooOffset); }}在上面的示例中，我们使用createString方法创建一个名为Leo的字符串，并使用startAnimal方法开始一个新的表。然后我们使用addName方法添加名称属性，并使用addAge方法添加年龄属性。最后，我们使用endAnimal方法结束表，并将其添加到animalsOffset数组中。然后我们使用createAnimalsVector方法创建一个动物向量，并使用addAnimals方法将其添加到Zoo表中。构建枚举类型在FlatBuffers中，您可以使用枚举类型来定义一组可能的值。在Java中使用FlatBuffers构建枚举类型时，您需要在FlatBuffers Schema中定义枚举类型，并在Java代码中使用相应的方法来构建枚举类型。例如，我们可以使用以下FlatBuffers Schema定义一个名为AnimalType的枚举类型：namespace example;enum AnimalType : byte { DOG = 0, CAT = 1, FISH = 2,}然后我们可以使用以下Java代码来构建Animal对象，并将枚举类型添加到Animal对象中：1234567891011121314151617import com.example.Animal;import com.example.AnimalType;public class FlatBuffersExample { public static void main(String[] args) { FlatBufferBuilder builder = new FlatBufferBuilder(); int nameOffset = builder.createString(\"Leo\"); Animal.startAnimal(builder); Animal.addName(builder, nameOffset); Animal.addAge(builder, 3); Animal.addType(builder, AnimalType.CAT); int animalOffset = Animal.endAnimal(builder); builder.finish(animalOffset); }}在上面的示例中，我们使用createString方法创建一个名为Leo的字符串，并使用startAnimal方法开始一个新的表。然后我们使用addName方法添加名称属性，并使用addAge方法添加年龄属性。最后，我们使用addType方法添加AnimalType枚举类型，并使用endAnimal方法结束表。最佳实践使用FlatBuffers进行网络通信在Java中使用FlatBuffers进行网络通信时，您需要将FlatBuffers对象序列化为字节数组，并将其发送到远程服务器。然后，远程服务器可以将字节数组反序列化为FlatBuffers对象。例如，我们可以使用以下Java代码将FlatBuffers对象序列化为字节数组：1234567891011121314151617import com.google.flatbuffers.FlatBufferBuilder;public class FlatBuffersExample { public static void main(String[] args) { FlatBufferBuilder builder = new FlatBufferBuilder(); int nameOffset = builder.createString(\"Leo\"); Animal.startAnimal(builder); Animal.addName(builder, nameOffset); Animal.addAge(builder, 3); int animalOffset = Animal.endAnimal(builder); builder.finish(animalOffset); byte[] bytes = builder.sizedByteArray(); }}在上面的示例中，我们使用FlatBufferBuilder的sizedByteArray方法将FlatBuffers对象序列化为字节数组。然后，我们可以使用以下Java代码将字节数组反序列化为FlatBuffers对象：1234567891011121314import com.example.Animal;import java.nio.ByteBuffer;public class FlatBuffersExample { public static void main(String[] args) { byte[] bytes = ...; ByteBuffer buffer = ByteBuffer.wrap(bytes); Animal animal = Animal.getRootAsAnimal(buffer); String name = animal.name(); int age = animal.age(); }}在上面的示例中，我们使用ByteBuffer的wrap方法将字节数组包装为ByteBuffer，并使用getRootAsAnimal方法从ByteBuffer中获取Animal对象。使用FlatBuffers进行持久化在Java中使用FlatBuffers进行持久化时，您可以将FlatBuffers对象序列化为字节数组，并将其写入文件或数据库中。然后，您可以从文件或数据库中读取字节数组，并将其反序列化为FlatBuffers对象。例如，我们可以使用以下Java代码将FlatBuffers对象序列化为字节数组，并将其写入文件中：123456789101112131415161718192021222324import com.google.flatbuffers.FlatBufferBuilder;import java.io.FileOutputStream;import java.io.IOException;public class FlatBuffersExample { public static void main(String[] args) throws IOException { FlatBufferBuilder builder = new FlatBufferBuilder(); int nameOffset = builder.createString(\"Leo\"); Animal.startAnimal(builder); Animal.addName(builder, nameOffset); Animal.addAge(builder, 3); int animalOffset = Animal.endAnimal(builder); builder.finish(animalOffset); byte[] bytes = builder.sizedByteArray(); try (FileOutputStream fos = new FileOutputStream(\"animal.bin\")) { fos.write(bytes); } }}在上面的示例中，我们使用FlatBufferBuilder的sizedByteArray方法将FlatBuffers对象序列化为字节数组，并使用FileOutputStream将字节数组写入animal.bin文件中。然后，我们可以使用以下Java代码从文件中读取字节数组，并将其反序列化为FlatBuffers对象：1234567891011121314151617181920import com.example.Animal;import java.io.FileInputStream;import java.io.IOException;import java.nio.ByteBuffer;public class FlatBuffersExample { public static void main(String[] args) throws IOException { byte[] bytes; try (FileInputStream fis = new FileInputStream(\"animal.bin\")) { bytes = fis.readAllBytes(); } ByteBuffer buffer = ByteBuffer.wrap(bytes); Animal animal = Animal.getRootAsAnimal(buffer); String name = animal.name(); int age = animal.age(); }}在上面的示例中，我们使用FileInputStream的readAllBytes方法从文件中读取字节数组，并使用ByteBuffer的wrap方法将字节数组包装为ByteBuffer。然后我们使用getRootAsAnimal方法从ByteBuffer中获取Animal对象。总结在本教程中，我们介绍了如何在Java中使用FlatBuffers。我们讨论了FlatBuffers的含义，常用用法，进阶实战和最佳实践。我们提供了示例代码，以帮助您更好地理解FlatBuffers的使用。FlatBuffers是一种高效的序列化库，它可以在不进行解码的情况下直接访问数据。如果您需要在Java应用程序中使用高效的序列化库，那么FlatBuffers是一个不错的选择。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 玩转“代理模式”",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 代理模式",
      "url"         : "./rust/2023/03/24/Java_JDK8_DateTime_1.html",
      "date"        : "2023-03-24 00:00:00 +0800",
      "description" : "",
      "content"     : "Java 8引入了新的日期时间API，包括DateTime、LocalDate、LocalDateTime、Instant、Period和Duration。这些新的API提供了更好的时间处理方式，使得日期时间处理更加简单、易用和可读。DateTimeDateTime是Java 8中最基本的日期时间类，它表示一个特定的日期和时间。它包含了年、月、日、时、分、秒和毫秒等信息。DateTime对象通常用于表示一个具体的日期和时间，例如2019年12月31日23点59分59秒。它可以用于计算两个日期之间的差值，或者将日期时间转换为不同的时区。常用API和方法 of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond, ZoneId zone)：创建一个DateTime对象，指定年、月、日、时、分、秒、毫秒和时区。 now()：获取当前的DateTime对象。 getYear()：获取年份。 getMonth()：获取月份。 getDayOfMonth()：获取日期。 getHour()：获取小时。 getMinute()：获取分钟。 getSecond()：获取秒数。 getNano()：获取纳秒数。 atZone(ZoneId zone)：将DateTime对象转换为指定时区的ZonedDateTime对象。 format(DateTimeFormatter formatter)：将DateTime对象格式化为指定格式的字符串。LocalDateLocalDate是Java 8中的日期类，它表示一个特定的日期。它包含了年、月和日等信息。LocalDate对象通常用于表示一个具体的日期，例如2019年12月31日。它可以用于计算两个日期之间的差值，或者进行日期的加减运算。常用API和方法 of(int year, int month, int dayOfMonth)：创建一个LocalDate对象，指定年、月和日。 now()：获取当前的LocalDate对象。 getYear()：获取年份。 getMonth()：获取月份。 getDayOfMonth()：获取日期。 getDayOfWeek()：获取星期几。 getDayOfYear()：获取一年中的第几天。 plusDays(long daysToAdd)：增加指定的天数。 minusDays(long daysToSubtract)：减少指定的天数。 with(TemporalAdjuster adjuster)：使用指定的TemporalAdjuster调整日期。LocalDateTimeLocalDateTime是Java 8中的日期时间类，它表示一个特定的日期和时间。它包含了年、月、日、时、分、秒和毫秒等信息。LocalDateTime对象通常用于表示一个具体的日期和时间，例如2019年12月31日23点59分59秒。它可以用于计算两个日期之间的差值，或者将日期时间转换为不同的时区。常用API和方法 of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)：创建一个LocalDateTime对象，指定年、月、日、时、分、秒和毫秒。 now()：获取当前的LocalDateTime对象。 getYear()：获取年份。 getMonth()：获取月份。 getDayOfMonth()：获取日期。 getHour()：获取小时。 getMinute()：获取分钟。 getSecond()：获取秒数。 getNano()：获取纳秒数。 plusDays(long daysToAdd)：增加指定的天数。 minusDays(long daysToSubtract)：减少指定的天数。 with(TemporalAdjuster adjuster)：使用指定的TemporalAdjuster调整日期。InstantInstant是Java 8中的时间戳类，它表示一个特定的时间。它包含了秒数和纳秒数等信息。Instant对象通常用于表示一个特定的时间，例如2023年3月27日00点12分30秒。它可以用于计算两个时间之间的差值，或者将时间戳转换为不同的时区。常用API和方法 ofEpochSecond(long epochSecond)：创建一个Instant对象，指定秒数。 now()：获取当前的Instant对象。 getEpochSecond()：获取秒数。 getNano()：获取纳秒数。 plusSeconds(long secondsToAdd)：增加指定的秒数。 minusSeconds(long secondsToSubtract)：减少指定的秒数。 isAfter(Instant otherInstant)：判断当前时间是否在指定时间之后。 isBefore(Instant otherInstant)：判断当前时间是否在指定时间之前。PeriodPeriod是Java 8中的时间段类，它表示两个日期之间的时间差。它包含了年、月和日等信息。Period对象通常用于计算两个日期之间的时间差，例如2019年12月31日和2020年1月1日之间的时间差。它可以用于计算两个日期之间的差值，或者进行日期的加减运算。常用API和方法 between(LocalDate startDateInclusive, LocalDate endDateExclusive)：创建一个Period对象，表示两个日期之间的时间差。 getYears()：获取年数。 getMonths()：获取月数。 getDays()：获取天数。DurationDuration是Java 8中的时间段类，它表示两个时间之间的时间差。它包含了秒数和纳秒数等信息。Duration对象通常用于计算两个时间之间的时间差，例如2023年3月27日00点12分30秒和2023年3月27日00点13分30秒之间的时间差。它可以用于计算两个时间之间的差值，或者进行时间的加减运算。常用API和方法 between(Instant startInclusive, Instant endExclusive)：创建一个Duration对象，表示两个时间之间的时间差。 getSeconds()：获取秒数。 getNano()：获取纳秒数。常见用法和示例日期时间转换在实际开发中，我们通常需要将日期时间转换为不同的格式或者不同的时区。下面是一些常见的日期时间转换场景。将日期时间转换为字符串使用DateTimeFormatter类可以将日期时间转换为指定格式的字符串。例如，将2023年3月27日00点12分30秒转换为字符串：1234DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");LocalDateTime dateTime = LocalDateTime.of(2023, 3, 27, 0, 12, 30);String str = dateTime.format(formatter);System.out.println(str); // 输出：2023-03-27 00:12:30将字符串转换为日期时间使用DateTimeFormatter类可以将字符串转换为指定格式的日期时间。例如，将字符串”2023-03-27 00:12:30”转换为LocalDateTime对象：1234DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");String str = \"2023-03-27 00:12:30\";LocalDateTime dateTime = LocalDateTime.parse(str, formatter);System.out.println(dateTime); // 输出：2023-03-27T00:12:30将日期时间转换为指定时区的时间使用ZonedDateTime类可以将日期时间转换为指定时区的时间。例如，将2023年3月27日00点12分30秒转换为美国纽约时区的时间：1234LocalDateTime dateTime = LocalDateTime.of(2023, 3, 27, 0, 12, 30);ZoneId zoneId = ZoneId.of(\"America/New_York\");ZonedDateTime zonedDateTime = ZonedDateTime.of(dateTime, zoneId);System.out.println(zonedDateTime); // 输出：2023-03-26T20:12:30-04:00[America/New_York]时间计算在实际开发中，我们通常需要对日期时间进行加减运算，或者计算两个日期时间之间的时间差。下面是一些常见的时间计算场景。计算两个日期之间的时间差使用Period类可以计算两个日期之间的时间差。例如，计算2019年12月31日和2020年1月1日之间的时间差：1234LocalDate startDate = LocalDate.of(2019, 12, 31);LocalDate endDate = LocalDate.of(2020, 1, 1);Period period = Period.between(startDate, endDate);System.out.println(period.getDays()); // 输出：1计算两个时间之间的时间差使用Duration类可以计算两个时间之间的时间差。例如，计算2023年3月27日00点12分30秒和2023年3月27日00点13分30秒之间的时间差：1234Instant startInstant = Instant.parse(\"2023-03-27T00:12:30Z\");Instant endInstant = Instant.parse(\"2023-03-27T00:13:30Z\");Duration duration = Duration.between(startInstant, endInstant);System.out.println(duration.getSeconds()); // 输出：60获取某个月份的最后一天使用TemporalAdjusters类可以获取某个月份的最后一天。例如，获取2023年3月的最后一天：123LocalDate date = LocalDate.of(2023, 3, 1);LocalDate lastDayOfMonth = date.with(TemporalAdjusters.lastDayOfMonth());System.out.println(lastDayOfMonth); // 输出：2023-03-31获取某个日期的下一个周一使用TemporalAdjusters类可以获取某个日期的下一个周一。例如，获取2023年3月27日的下一个周一：123LocalDate date = LocalDate.of(2023, 3, 27);LocalDate nextMonday = date.with(TemporalAdjusters.next(DayOfWeek.MONDAY));System.out.println(nextMonday); // 输出：2023-04-03最佳实践在实际开发中，我们应该尽可能使用新的日期时间API，避免使用旧的Date和Calendar类。下面是一些最佳实践的建议。 使用LocalDate代替Date在Java 8之前，我们通常使用Date类表示日期。然而，Date类有很多问题，例如它是可变的、不是线程安全的、没有时区信息等等。因此，我们应该尽可能使用LocalDate代替Date。 使用LocalDateTime代替Calendar在Java 8之前，我们通常使用Calendar类表示日期时间。然而，Calendar类也有很多问题，例如它是可变的、不是线程安全的、没有时区信息等等。因此，我们应该尽可能使用LocalDateTime代替Calendar。 使用Instant代替System.currentTimeMillis()在Java 8之前，我们通常使用System.currentTimeMillis()方法获取当前时间戳。然而，它只能精确到毫秒级别，不够精确。因此，我们应该尽可能使用Instant类代替System.currentTimeMillis()方法。总结Java 8中的新日期时间API提供了更好的时间处理方式，使得日期时间处理更加简单、易用和可读。在实际开发中，我们应该尽可能使用新的日期时间API，避免使用旧的Date和Calendar类。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 玩转“代理模式”",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 代理模式",
      "url"         : "./rust/2023/03/24/rust_lang_tutorial_303_patterns_Proxy.html",
      "date"        : "2023-03-24 00:00:00 +0800",
      "description" : "",
      "content"     : "代理模式是一种结构型设计模式，它允许通过代理对象控制对其它对象的访问。代理对象可以拦截对原始对象的访问，同时也可附加一些额外的操作，如对访问进行缓存、权限控制等。代理模式常用于以下场景： 远程代理：将客户端请求转发至远程对象处理，如远程方法调用（RPC）、远程数据库访问等。 虚拟代理：在访问对象时，代理对象会根据需要创建真实对象，如大文件的加载、大图片的渲染等。 安全代理：代理对象可以控制对真实对象的访问权限，如只允许具有某种权限的用户访问真实对象。 智能引用：代理对象可以在真实对象被访问时附加一些额外的操作，如记录对象访问次数、对象访问时间等。实现代理模式在 Rust 中实现代理模式，可以通过 trait 或结构体来实现。以下是一个简单的实现示例。```rusttrait Subject { fn request(&amp;self);}struct RealSubject {}impl Subject for RealSubject { fn request(&amp;self) { println!(“RealSubject handling request”); }}struct Proxy { real_subject: RealSubject}impl Subject for Proxy { fn request(&amp;self) { self.before_request(); self.real_subject.request(); self.after_request(); }}impl Proxy { fn new(real_subject: RealSubject) -&gt; Self { return Self { real_subject }; }fn before_request(&amp;self) { println!(\"Proxy handling request before RealSubject\");}fn after_request(&amp;self) { println!(\"Proxy handling request after RealSubject\");} } ```在上面的示例中，我们定义了一个名为 Subject 的 trait，用于规定代理对象和真实对象需要实现的方法。然后，我们定义了一个名为 RealSubject 的结构体，用于实现 Subject trait 并实现其方法。接着，我们定义了一个名为 Proxy 的结构体，用于代理 RealSubject，实现 Subject trait 并实现其方法。在 Proxy 的 request 方法中，我们先调用 before_request 方法进行一些前置操作，再调用真实对象的 request 方法，最后调用 after_request 方法进行一些后续操作。进阶用法在代理模式的进阶用法中，可以使用静态编译时代理和动态运行时代理。静态编译时代理在 Rust 中，可以使用宏来实现静态编译时代理。宏允许在编译时生成代码，这样可以减少对象的运行时开销，并且可以提高代码的可读性和可维护性。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647macro_rules! subject { () =&gt; (pub trait Subject { fn request(&amp;self); });}macro_rules! real_subject { () =&gt; (pub struct RealSubject {} impl Subject for RealSubject { fn request(&amp;self) { println!(\"RealSubject handling request\"); } });}macro_rules! proxy { () =&gt; (pub struct Proxy&lt;T: Subject&gt; { real_subject: T } impl&lt;T: Subject&gt; Proxy&lt;T&gt; { pub fn new(real_subject: T) -&gt; Self { return Self { real_subject }; } fn before_request(&amp;self) { println!(\"Proxy handling request before RealSubject\"); } fn after_request(&amp;self) { println!(\"Proxy handling request after RealSubject\"); } } impl&lt;T: Subject&gt; Subject for Proxy&lt;T&gt; { fn request(&amp;self) { self.before_request(); self.real_subject.request(); self.after_request(); } });}subject! {}real_subject! {}proxy! {}在上面的示例中，我们使用宏来定义了代理模式中的 Subject、RealSubject 和 Proxy，使用时只需引用定义的宏即可。这样我们就可以在编译时生成代理对象，将对象生成代码嵌入到编译后的程序中，减少运行时代理的开销，并且可以提高代码的可读性和可维护性。动态运行时代理在 Rust 中，可以使用类型参数和 trait 对象来实现动态运行时代理。这种方法允许在运行时生成代理对象，并且可以使用不同类型的代理对象。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct RealSubject {}impl RealSubject { fn new() -&gt; Self { return Self {}; } fn handle_request(&amp;self) { println!(\"RealSubject handling request\"); }}trait Subject { fn request(&amp;self);}struct Proxy&lt;T: Subject&gt; { real_subject: T}impl&lt;T: Subject&gt; Proxy&lt;T&gt; { fn new(real_subject: T) -&gt; Self { return Self { real_subject }; } fn before_request(&amp;self) { println!(\"Proxy handling request before RealSubject\"); } fn after_request(&amp;self) { println!(\"Proxy handling request after RealSubject\"); }}impl&lt;T: Subject&gt; Subject for Proxy&lt;T&gt; { fn request(&amp;self) { self.before_request(); self.real_subject.request(); self.after_request(); }}impl Subject for RealSubject { fn request(&amp;self) { self.handle_request(); }}fn main() { let real_subject = RealSubject::new(); let proxy = Proxy::new(real_subject); proxy.request(); let real_subject = RealSubject::new(); let proxy: Box&lt;dyn Subject&gt; = Box::new(Proxy::new(real_subject)); proxy.request();}在上面的示例中，我们定义了一个 RealSubject 结构体，用于实现真实对象的处理函数。然后，我们定义了一个名为 Subject 的 trait，用于规定代理对象和真实对象需要实现的方法。接着，我们定义了一个泛型结构体 Proxy&lt;T: Subject&gt;，它包含了一个泛型类型参数 T，该参数应该实现了 Subject trait。并且，我们实现了 Proxy 的 request 方法，先调用 before_request 方法进行一些前置操作，然后调用真实对象的 request 方法，最后调用 after_request 方法进行一些后续操作。最后，在 main 函数中，我们实例化了一个 RealSubject 对象，并将其传递给 Proxy 进行代理操作。然后，我们又实例化了一个 RealSubject 对象，并将其转换为 dyn Subject 类型的 trait 对象，传递给 Proxy 进行代理操作。这种方法允许我们可以使用不同类型的代理对象，使代码更加灵活。最佳实践在实现代理模式时，我们需要考虑以下几个最佳实践： 尽量使用静态编译时代理：使用宏来生成代码可以减少运行时代理的开销，并且可以提高代码的可读性和可维护性。 使用类型参数和 trait 对象来实现动态运行时代理：这种方法可以使用不同类型的代理对象，使代码更加灵活。 尽量避免使用代理模式：代理模式会引入额外的复杂度，使代码更加难以理解和维护。如果没有必要，尽量避免使用代理模式。结论代理模式是一种结构型设计模式，它允许通过代理对象控制对其它对象的访问。在 Rust 中，可以使用 trait 和结构体来实现代理模式，并使用宏来生成静态编译时代理，使用类型参数和 trait 对象来实现动态运行时代理。在使用代理模式时，需要考虑最佳实践，如尽量使用静态编译时代理、使用类型参数和 trait 对象来实现动态运行时代理，以及避免使用代理模式等。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Rust语言MySQL实战",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, MySQL",
      "url"         : "./rust/2023/03/24/rust_lang_tutorial_205_MySQL.html",
      "date"        : "2023-03-24 00:00:00 +0800",
      "description" : "",
      "content"     : "MySQL是一个广泛使用的关系型数据库，Rust作为一门相对较新的系统级编程语言，具有C语言般的高性能、安全、并发等特性，因此与MySQL一起使用是一种非常有趣的选择。在本教程中，我们将手把手地展示如何在Rust中连接和使用MySQL数据库。安装 mysql 模块这里我们假设你已经安装了Rust编程语言工具链，在本教程中，我们将使用mysql crate来连接和使用MySQL数据库。要安装mysql crate，我们可以使用Rust语言包管理器cargo，只需在终端中输入以下命令：cargo install mysql安装成功后，我们可以开始尝试连接MySQL数据库了。连接MySQL数据库首先，我们需要安装和配置MySQL数据库，以便在Rust程序中进行连接。安装和配置MySQL在此处不做叙述。在Rust程序中使用mysql crate库连接MySQL数据库，需要进行以下步骤： 导入mysql crate 使用mysql::OptsBuilder设置MySQL连接选项 使用mysql::Pool::new创建MySQL连接池 使用pool.get_conn()获取MySQL连接，并进行一些操作，例如插入、查询等 使用pool.disconnect()断开MySQL连接下面是连接MySQL数据库的示例代码：12345678910111213141516171819202122use mysql::*;fn main() { let opts = OptsBuilder::new() .ip_or_hostname(Some(\"localhost\")) .user(Some(\"root\")) .pass(Some(\"password\")) .db_name(Some(\"test\")) .tcp_port(3306); let pool = Pool::new(opts).unwrap(); let mut conn = pool.get_conn().unwrap(); let result = conn.query_first(\"SELECT * FROM users\").unwrap(); for row in result { let name: String = row.get(\"name\").unwrap(); let age: i32 = row.get(\"age\").unwrap(); println!(\"{} is {} years old\", name, age); } pool.disconnect().unwrap();}以上代码创建了一个MySQL连接池，并从连接池中获取一个MySQL连接，查询了一个名为users的表，并将结果作为元素进行遍历。Rust使用MySQL的进阶用法事务（Transaction）为了保证MySQL数据库中的数据一致性，我们通常需要使用事务（Transaction）。在Rust中，可以使用MySQL的事务功能并结合mysql::Transaction来实现。使用以下代码示例可以体验事务的实现：1234567891011121314151617181920212223242526272829303132use mysql::*;fn main() { let opts = OptsBuilder::new() .ip_or_hostname(Some(\"localhost\")) .user(Some(\"root\")) .pass(Some(\"password\")) .db_name(Some(\"test\")) .tcp_port(3306); let pool = Pool::new(opts).unwrap(); let mut conn = pool.get_conn().unwrap(); // Start a transaction let mut transaction = conn.start_transaction(TxOpts::default()).unwrap(); // Insert data into a table transaction .prep_exec(\"INSERT INTO users (name, age) VALUES (?, ?)\", (\"Alice\", 23)).unwrap(); transaction.prep_exec(\"INSERT INTO users (name, age) VALUES (?, ?)\", (\"Bob\", 25)).unwrap(); // Commit a transaction transaction.commit().unwrap(); // Select data from a table let result = conn.query(\"SELECT * FROM users\").unwrap(); for row in result { let name: String = row.get(\"name\").unwrap(); let age: i32 = row.get(\"age\").unwrap(); println!(\"{} is {} years old\", name, age); } pool.disconnect().unwrap();}以上代码创建了一个名为users的表，并在事务内分别插入了两个元素，数据被成功提交到了MySQL数据库，我们看到了名为Alice和Bob的条目。异步IORust语言具有异步IO处理的优势。在Rust中使用MySQL异步IO时，可以使用tokio-mysql crate来实现。tokio-mysql crate是一个基于Tokio实现的异步MySQL数据库客户端。下面是使用tokio-mysql crate的示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556use std::str::FromStr;use tokio::runtime::Builder;use tokio::time::Duration;use tokio_mysql::{prelude::*, Error, Opts, Pool};#[tokio::main]async fn main() -&gt; Result&lt;(), Error&gt; { let opts = Opts::from_url(\"mysql://root:password@localhost:3306/test\")?; let pool = Pool::new(opts); let pool = match pool { Ok(p) =&gt; p, Err(e) =&gt; return Err(e), }; let mut conn = pool.get_conn().await?; conn.query_drop(\"CREATE TABLE IF NOT EXISTS students ( id INT PRIMARY KEY NOT NULL, name TEXT NOT NULL, age INT NOT NULL )\") .await?; let id = 1; let name = \"Alice\"; let age = 23; conn.exec_drop( format!( \"INSERT INTO students (id, name, age) VALUES ({}, \\\"{}\\\", {})\", id, name, age ) .as_str() ) .await?; let mut conn2 = pool.get_conn().await?; let result = conn2 .query_iter( String::from(\"SELECT * FROM students\") .as_str(), ) .await?; for row in result { let id: u32 = row.unwrap().take(\"id\").unwrap().as_integer().unwrap().try_into().unwrap(); let name: &amp;str = row.unwrap().take(\"name\").unwrap().as_sql_str(); let age: u32 = row.unwrap().take(\"age\").unwrap().as_integer().unwrap().try_into().unwrap(); println!(\"{} is {} years old\", name, age); } Ok(())}它创建了一个名为students的表，并插入了一个名为Alice年龄为23的元素，然后遍历该表并打印结果。Rust使用MySQL的最佳实践连接池在连接MySQL数据库时，使用连接池是非常重要的。连接池是一个预先创建的连接集合，由于预先初始化了这些连接，因此在保持连接上下文的情况下执行多个操作变得更加轻松。在Rust中使用mysql::Pool连接MySQL数据库是非常常见的。12345678let opts = OptsBuilder::new() .ip_or_hostname(Some(\"localhost\")) .user(Some(\"root\")) .pass(Some(\"password\")) .db_name(Some(\"test\")) .tcp_port(3306);let pool = Pool::new(opts).unwrap();避免SQL注入避免SQL注入攻击是一个重要的安全问题。在Rust中使用mysql crate，可以使用mysql::from_value和mysql::Value::from方法来避免SQL注入攻击。在Rust中，需要使用以下代码实现SQL语句中的参数绑定：1234let name = \"Alice\";let age = 23;conn.prep_exec(\"INSERT INTO students (name, age) VALUES (?, ?)\", (name, age),).unwrap();在将参数传递给SQL查询时，需要使用mysql::Value::from方法将变量转换为mysql::Value类型，以防止SQL注入攻击。要从mysql::Value转换回常规变量，可以使用mysql::from_value方法。使用以下示例代码：12345678910use mysql::*;fn main() { let result: Vec&lt;Row&gt; = conn.query(\"SELECT * FROM students WHERE age &gt;= ?\", (age.into(),)).unwrap(); for row in result { let age: i32 = from_value(row.get(\"age\").unwrap()); let name: String = from_value(row.get(\"name\").unwrap()); println!(\"{} is {} years old\", name, age); }}SQL执行和结果处理在Rust中，可以使用mysql::Conn::query，mysql::Conn::exec_iter和mysql::Conn::prep_exec等方法来执行SQL语句。但是，这些方法返回的结果类型有很大不同。query方法返回包含所有结果集的Vec&lt;mysql::Row&gt;类型，而exec_iter方法返回mysql::Row类型的迭代器。最后，prep_exec方法是最常用的方法，它可以绑定参数，并类似于通过命令行客户端发送的查询，并返回mysql::QueryResult类型。如果要提取单个结果，可以使用mysql::QueryResult的方法mysql::QueryResult::next来获取。使用以下代码示例说明不同方法的使用：123456789101112131415161718use mysql::*;fn main() { let result: Vec&lt;Row&gt; = conn.query(\"SELECT * FROM students WHERE age &gt;= ?\", (age.into(),)).unwrap(); for row in result { let age: i32 = from_value(row.get(\"age\").unwrap()); let name: String = from_value(row.get(\"name\").unwrap()); println!(\"{} is {} years old\", name, age); } let mut iter = conn.exec_iter(\"SELECT age FROM students WHERE name = \\\"Alice\\\"\").unwrap(); while let Some(result) = iter.next() { let age: i32 = from_value(result.unwrap()); println!(\"Alice is {} years old\", age); } conn.prep_exec(\"INSERT INTO students (name, age) VALUES (?, ?)\",(name, age),).unwrap();}结论本教程介绍了如何在Rust中连接和使用MySQL数据库。我们学习了使用mysql crate连接MySQL数据库，并实现了一些常见用例，例如事务、异步IO等。此外，我们使用连接池、避免SQL注入技巧，并使用了不同的SQL执行和结果处理方法。如果你正在使用Rust编程语言，那么通过学习本教程，你将掌握基本和高级的连接和使用MySQL技巧。"
    } ,
  
    {
      "title"       : "“五子棋”最少步数的必胜法",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 代理模式",
      "url"         : "./rust/2023/03/24/game_five_chest_must_win.html",
      "date"        : "2023-03-24 00:00:00 +0800",
      "description" : "",
      "content"     : ""
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Rust语言Redis实战",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Weak",
      "url"         : "./rust/2023/03/23/rust_lang_tutorial_206_Redis.html",
      "date"        : "2023-03-23 00:00:00 +0800",
      "description" : "",
      "content"     : "Redis是一款快速、开源、键值存储数据库，被广泛应用于缓存、发布/订阅系统、定时任务等场景中。Rust提供了很多Redis的客户端库，本教程将会介绍如何使用Rust连接Redis，以及如何通过Rust操作Redis。Redis依赖库在Rust中有很多Redis的客户端库可以选择，这里我们选择使用redis-rs库。在Cargo.toml文件中添加依赖：12[dependencies]redis = \"0.22\"Redis基础用法和示例连接Redis连接Redis非常简单，只需要使用redis::Client来创建一个连接即可，如下所示：1234567use redis::Client;fn main() { let client = Client::open(\"redis://127.0.0.1/\").unwrap(); let conn = client.get_connection().unwrap(); println!(\"Connected to Redis\");}设置和获取key值Redis是一款键值存储数据库，我们可以很方便地设置和获取key值。12345678910111213use redis::{Client, Commands};fn main() { let client = Client::open(\"redis://127.0.0.1/\").unwrap(); let conn = client.get_connection().unwrap(); // 设置key值 let _: () = conn.set(\"key\", \"value\").unwrap(); // 获取key值 let value: String = conn.get(\"key\").unwrap(); println!(\"Value: {}\", value);}设置和获取Hash值Hash是Redis中一种特殊的数据结构，可以将多个键值对存储到一个键中。在Redis中，Hash通常用于存储对象，比如用户信息、商品信息等。12345678910111213141516use redis::{Client, Commands, RedisResult};fn main() { let client = Client::open(\"redis://127.0.0.1/\").unwrap(); let conn = client.get_connection().unwrap(); // 设置Hash值 let _: () = conn.hset(\"user:123\", \"name\", \"Alice\").unwrap(); let _: () = conn.hset(\"user:123\", \"age\", 20).unwrap(); // 获取Hash值 let name: RedisResult&lt;String&gt; = conn.hget(\"user:123\", \"name\"); let age: RedisResult&lt;i32&gt; = conn.hget(\"user:123\", \"age\"); println!(\"Name: {:?}\", name); println!(\"Age: {:?}\", age);}设置和获取List值List是一种可以按下标顺序访问的数据结构，可以在一端添加元素，在另一端删除元素，非常适合用于消息队列等场景。12345678910111213141516171819use redis::{Client, Commands, RedisResult};fn main() { let client = Client::open(\"redis://127.0.0.1/\").unwrap(); let conn = client.get_connection().unwrap(); // 设置List值 let _: () = conn.rpush(\"queue\", \"A\").unwrap(); let _: () = conn.rpush(\"queue\", \"B\").unwrap(); let _: () = conn.rpush(\"queue\", \"C\").unwrap(); // 获取List值 let item1: RedisResult&lt;String&gt; = conn.lpop(\"queue\"); let item2: RedisResult&lt;String&gt; = conn.lpop(\"queue\"); let item3: RedisResult&lt;String&gt; = conn.lpop(\"queue\"); println!(\"Item1: {:?}\", item1); println!(\"Item2: {:?}\", item2); println!(\"Item3: {:?}\", item3);}进阶用法Reids连接池在实际应用中，我们会创建多个Redis连接处理请求，为了避免频繁地创建和销毁连接，可以使用连接池来优化。redis-rs库提供了一个连接池结构体ConnectionPool，它可以自动管理连接的创建和销毁。1234567891011121314151617181920212223242526use std::thread;use redis::{Client, Commands, RedisResult, Connection, ConnectionInfo, IntoConnectionInfo};use redis::aio::ConnectionLike;fn main() { let client = Client::open(\"redis://127.0.0.1/\").unwrap(); let conn_pool = client.get_connection_pool().unwrap(); let mut handles = vec![]; for i in 0..10 { let conn_pool = conn_pool.clone(); let handle = thread::spawn(move || { let mut conn = conn_pool.get().unwrap(); let _: () = conn.set(format!(\"key{}\", i), format!(\"value{}\", i)).unwrap(); }); handles.push(handle) } for handle in handles { handle.join().unwrap(); } let conn = conn_pool.get().unwrap(); let key0: RedisResult&lt;String&gt; = conn.get(\"key0\"); println!(\"Key0 {:?}\", key0);}使用发布/订阅模式Redis也支持发布/订阅模式，可以实现简单的消息队列、聊天室等功能。在发布/订阅模式中，客户端可以订阅一个或多个频道，在有消息发布到这些频道时，客户端将会收到通知。12345678910111213141516171819202122232425use redis::{Client, Commands, RedisResult};fn main() { let client = Client::open(\"redis://127.0.0.1/\").unwrap(); let conn = client.get_connection().unwrap(); let mut pubsub = conn.as_pubsub(); let _: () = pubsub.subscribe(\"channel\").unwrap(); let mut pubsub_thread = pubsub.into_on_message(); let handle = std::thread::spawn(move || { loop { let msg = pubsub_thread.recv().unwrap(); let payload: String = msg.get_payload().unwrap(); println!(\"Received: {:?}\", payload); } }); let _: () = conn.publish(\"channel\", \"hello1\").unwrap(); let _: () = conn.publish(\"channel\", \"hello2\").unwrap(); let _: () = conn.publish(\"channel\", \"hello3\").unwrap(); std::thread::sleep_ms(1000); handle.join().unwrap();}设置过期时间Redis是一款内存数据库，写入速度非常快，因此可以将Redis作为缓存来使用。在写入数据时，应该使用Redis提供的setex方法，将数据写入Redis中，并设置过期时间，这样可以减少内存占用。123456789101112use redis::{Client, Commands};fn main() { let client = Client::open(\"redis://127.0.0.1/\").unwrap(); let conn = client.get_connection().unwrap(); let key = \"cache_key\"; let value = \"cache_value\"; let expire_sec = 60; let _: () = conn.set_ex(key, expire_sec, value).unwrap();}错误处理在Rust中，错误处理十分重要，使用Result枚举类型可以很好地处理错误。Redis库也提供了RedisResult类型用于处理Redis错误。12345678910111213141516171819use redis::{Client, Commands, RedisResult};fn main() -&gt; RedisResult&lt;()&gt; { let client = Client::open(\"redis://127.0.0.1/\").unwrap(); let conn = client.get_connection().unwrap(); let key = \"cache_key\"; let value = \"cache_value\"; let expire_sec = 60; let _: () = conn.set_ex(key, expire_sec, value)?; let result: RedisResult&lt;String&gt; = conn.get(key); match result { Ok(value) =&gt; println!(\"Value: {}\", value), Err(e) =&gt; return Err(e), } Ok(())}总结本教程介绍了如何使用Rust连接Redis，并提供了示例代码介绍了如何在Rust中操作Redis。在使用Redis时，应该考虑使用连接池和快速写入等最佳实践，并合理处理错误。使用Redis，可以提高应用程序的性能和可扩展性。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 弱引用 Weak",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Weak",
      "url"         : "./rust/2023/03/23/rust_lang_tutorial_112_Weak.html",
      "date"        : "2023-03-23 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust是一种系统编程语言，它具有内存安全和高性能的特点。它的所有权和借用机制使得编写可靠的代码变得更加容易。在Rust中，Weak是一种弱引用类型，它可以用来解决循环引用的问题。本文将介绍Rust语言中的Weak类型，包括其含义、常用业务场景和用法、进阶用法以及最佳实践。什么是Weak在Rust中，Weak是一种弱引用类型。它不会增加引用计数，也不会阻止其引用对象被释放。Weak通常用于解决循环引用的问题。循环引用是指两个或多个对象之间互相引用，导致它们的引用计数永远不会变为0，从而导致内存泄漏。Weak类型可以在不增加引用计数的情况下，获取对象的引用，并在对象被释放后，自动将引用设置为None。这样可以避免内存泄漏的问题。常用业务场景和用法 循环引用循环引用是一种常见的问题。在面向对象的程序设计中，很容易出现循环引用的情况。例如，一个父对象持有一个子对象的引用，而子对象也持有父对象的引用。这种情况下，两个对象之间就形成了循环引用。如果使用普通的引用类型，这种循环引用会导致内存泄漏。但是使用Weak类型，就可以避免这个问题。 缓存缓存是另一个常见的业务场景。在缓存中，我们通常需要保留一些对象的引用，以便能够快速访问它们。但是，如果缓存中的对象永远不会被释放，那么就会导致内存泄漏。为了避免这个问题，可以使用Weak类型来保存缓存中对象的引用。 多线程编程在多线程编程中，有时候需要在线程之间共享数据。但是，如果多个线程持有同一个对象的引用，就会导致竞争条件。为了避免这个问题，可以使用Weak类型来共享数据。这样可以确保每个线程都持有对象的弱引用，而不是强引用。基础用法在Rust中，可以使用std::rc::Weak来创建弱引用。下面是一个示例代码：12345678910111213141516use std::rc::Rc;use std::rc::Weak;struct Foo { bar: Option&lt;Rc&lt;Bar&gt;&gt;,}struct Bar { foo: Weak&lt;Foo&gt;,}fn main() { let foo = Rc::new(Foo { bar: None }); let bar = Rc::new(Bar { foo: Rc::downgrade(&amp;foo) }); foo.bar = Some(bar);}在这个示例代码中，我们定义了两个结构体Foo和Bar。Foo包含一个可选的Rc类型的bar字段，而Bar包含一个Weak类型的foo字段。在main函数中，我们创建了一个Foo对象foo和一个Bar对象bar，并将bar对象的foo字段设置为foo对象的弱引用。这样，我们就成功地创建了一个循环引用，并使用Weak类型来解决了循环引用的问题。好的，以下是更多的代码示例：使用Weak类型解决循环引用123456789101112131415161718192021222324252627282930313233use std::rc::{Rc, Weak};struct Node { parent: Option&lt;Rc&lt;Node&gt;&gt;, children: Vec&lt;Rc&lt;Node&gt;&gt;,}impl Node { fn new() -&gt; Rc&lt;Self&gt; { Rc::new(Self { parent: None, children: Vec::new(), }) } fn add_child(&amp;mut self, child: Rc&lt;Self&gt;) { child.parent = Some(Rc::downgrade(&amp;self)); self.children.push(child); }}fn main() { let root = Node::new(); let child1 = Node::new(); let child2 = Node::new(); root.add_child(child1.clone()); root.add_child(child2.clone()); child1.add_child(root.clone()); // child2没有父节点，它的parent字段应该是None assert!(child2.parent.is_none());}在这个示例中，我们定义了一个Node结构体，它包含一个可选的Rc类型的parent字段和一个Vec&lt;Rc&gt;类型的children字段。在Node结构体中，我们定义了一个add_child方法，它用来添加子节点。在add_child方法中，我们将子节点的parent字段设置为当前节点的弱引用，然后将子节点添加到children数组中。这样就可以避免循环引用的问题。使用Weak类型实现缓存12345678910111213141516171819202122232425262728293031323334353637383940414243use std::collections::HashMap;use std::rc::{Rc, Weak};struct Cache { map: HashMap&lt;String, Weak&lt;String&gt;&gt;,}impl Cache { fn new() -&gt; Self { Self { map: HashMap::new(), } } fn get(&amp;mut self, key: &amp;str) -&gt; Option&lt;Rc&lt;String&gt;&gt; { if let Some(value) = self.map.get(key) { if let Some(value) = value.upgrade() { return Some(value); } } None } fn set(&amp;mut self, key: String, value: Rc&lt;String&gt;) { self.map.insert(key, Rc::downgrade(&amp;value)); }}fn main() { let mut cache = Cache::new(); let key1 = String::from(\"key1\"); let value1 = Rc::new(String::from(\"value1\")); cache.set(key1.clone(), value1.clone()); let key2 = String::from(\"key2\"); let value2 = Rc::new(String::from(\"value2\")); cache.set(key2.clone(), value2.clone()); assert_eq!(cache.get(&amp;key1), Some(value1.clone())); assert_eq!(cache.get(&amp;key2), Some(value2.clone()));}在这个示例中，我们定义了一个Cache结构体，它包含一个HashMap&lt;String, Weak&gt;类型的map字段。在Cache结构体中，我们定义了两个方法get和set，用来获取和设置缓存中的值。在get方法中，我们首先从map中获取Weak类型的值，然后使用upgrade方法将其转换为Option&lt;Rc&gt;类型的强引用。在set方法中，我们将Rc类型的值转换为Weak类型的弱引用，并将其插入到map中。这样就可以实现缓存的功能。使用Weak类型共享数据12345678910111213141516171819202122232425262728293031323334use std::rc::Weak;use std::sync::{Arc, Mutex};use std::thread;struct Data { value: i32,}fn worker(data: Weak&lt;Mutex&lt;Data&gt;&gt;) { if let Some(data) = data.upgrade() { if let Ok(mut data) = data.lock() { data.value += 1; } }}fn main() { let data = Arc::new(Mutex::new(Data { value: 0 })); let weak_data = Arc::downgrade(&amp;data); let mut threads = Vec::new(); for _ in 0..10 { let weak_data = weak_data.clone(); let thread = thread::spawn(move || worker(weak_data)); threads.push(thread); } for thread in threads { thread.join().unwrap(); } let data = data.lock().unwrap(); assert_eq!(data.value, 10);}在这个示例中，我们定义了一个Data结构体，它包含一个i32类型的value字段。在main函数中，我们使用Arc&lt;Mutex&gt;类型的data来共享Data结构体的数据。然后，我们使用Arc::downgrade方法将data转换为Weak&lt;Mutex&gt;类型的弱引用，并将其传递给worker函数。在worker函数中，我们使用upgrade方法将Weak&lt;Mutex&gt;类型的弱引用转换为Option&lt;Arc&lt;Mutex&gt;&gt;类型的强引用。然后，我们使用lock方法获取MutexGuard类型的锁，并修改Data结构体的value字段。这样就可以实现多线程共享数据的功能。进阶用法Weak::upgrade在使用Weak类型时，我们通常需要将其转换为强引用，以便能够访问其引用对象。可以使用Weak::upgrade方法来将Weak类型转换为Option&lt;Rc&gt;类型的强引用。如果引用对象已经被释放，upgrade方法将返回None。下面是一个示例代码：123456789101112131415161718192021222324use std::rc::Rc;use std::rc::Weak;struct Foo { bar: Option&lt;Rc&lt;Bar&gt;&gt;,}struct Bar { foo: Weak&lt;Foo&gt;,}fn main() { let foo = Rc::new(Foo { bar: None }); let bar = Rc::new(Bar { foo: Rc::downgrade(&amp;foo) }); foo.bar = Some(bar); if let Some(bar) = foo.bar { if let Some(foo) = bar.foo.upgrade() { println!(\"foo is not None\"); } else { println!(\"foo is None\"); } }}在这个示例代码中，我们使用if let语句来判断foo是否存在。如果foo存在，我们就使用bar.foo.upgrade()方法将其转换为Option&lt;Rc&gt;类型的强引用。如果foo已经被释放，upgrade方法将返回None。Weak::new我们也可以使用Weak::new方法来创建一个空的Weak类型的对象。下面是一个示例代码：12345use std::rc::Weak;fn main() { let weak: Weak&lt;String&gt; = Weak::new();}在这个示例代码中，我们创建了一个空的Weak类型的对象weak。最佳实践在使用Weak类型时，需要注意以下几点： Weak类型不能用于实现生命周期的管理。如果需要管理生命周期，应该使用Rc类型。 Weak类型不能被直接克隆。如果需要复制Weak类型的对象，应该使用Rc::downgrade方法来创建一个新的Weak类型的对象。 如果需要将Weak类型转换为强引用，应该使用Weak::upgrade方法。 如果需要创建一个空的Weak类型的对象，应该使用Weak::new方法。 结论本文介绍了Rust语言中的Weak类型，包括其含义、常用业务场景和用法、进阶用法以及最佳实践。Weak类型是一种弱引用类型，可以用来解决循环引用的问题。在使用Weak类型时，需要注意其不同于Rc类型的特点。通过本文的介绍，我们可以更好地理解和使用Rust语言中的Weak类型。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Atomic原子工具类",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Condvar",
      "url"         : "./rust/2023/03/23/rust_lang_tutorial_111_Atomic.html",
      "date"        : "2023-03-23 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust语言的Atomic是一种线程安全的原子类型，它可以保证多个线程同时访问同一个变量时的正确性。Rust中的Atomic类型可以用于解决多线程并发访问变量时出现的竞态条件问题。Rust的Atomic类型提供了一组原子操作，包括增加、减少、交换、比较等等。这些操作都是原子性的，即在不同线程之间的操作不会相互干扰。这使得在并发场景下使用Atomic变得非常方便和安全。常用业务场景和用法Atomic类型常用于多线程并发场景下，例如： 计数器：多个线程同时对一个计数器进行操作，需要保证每个线程都能正确地增加或减少计数器的值。 缓存：多个线程同时对同一个缓存进行读写操作，需要保证每个线程都能正确地读写缓存。 状态标记：多个线程同时对同一个状态标记进行读写操作，需要保证每个线程都能正确地读写状态标记。下面是一个简单的示例，展示了如何使用Atomic计数器：123456789101112131415161718192021use std::sync::Arc;use std::sync::atomic::{AtomicUsize, Ordering};fn main() { let counter = Arc::new(AtomicUsize::new(0)); for _ in 0..10 { let cc = counter.clone(); std::thread::spawn(move|| { for _ in 0..100 { cc.fetch_add(1, Ordering::SeqCst); } }); } std::thread::sleep(std::time::Duration::from_millis(1000)); println!(\"Counter: {}\", counter.load(Ordering::SeqCst));}// 输出结果：// Counter: 1000这段代码创建了一个AtomicUsize类型的计数器，然后启动了10个线程，每个线程都会对计数器进行100次增加操作。最后输出计数器的值。进阶用法除了常用的增加、减少、交换、比较等操作之外，Rust的Atomic类型还提供了一些进阶用法，例如： 自旋锁：可以使用Atomic类型实现一个简单的自旋锁，用于保护临界区。自旋锁的实现方式是不停地尝试获取锁，直到获取成功为止。 无锁队列：可以使用Atomic类型实现一个无锁队列，用于在多个线程之间传递数据。无锁队列的实现方式是使用原子操作来保证多个线程之间的正确性。 引用计数：可以使用Atomic类型实现一个简单的引用计数器，用于管理对象的生命周期。引用计数的实现方式是使用原子操作来增加或减少对象的引用计数。下面是一个简单的示例，展示了如何使用Atomic类型实现一个自旋锁：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253use std::sync::Arc;use std::sync::atomic::{AtomicUsize, AtomicBool, Ordering};#[derive(Debug)]struct SpinLock { locked: AtomicBool,}impl SpinLock { fn new() -&gt; SpinLock { SpinLock { locked: AtomicBool::new(false) } } fn lock(&amp;self) { while self.locked.compare_and_swap(false, true, Ordering::SeqCst) != false {} } fn unlock(&amp;self) { self.locked.store(false, Ordering::SeqCst); }}fn main() { let lock = Arc::new(SpinLock::new()); { let cl = lock.clone(); std::thread::spawn(move || { cl.lock(); println!(\"Thread 1 acquired lock\"); std::thread::sleep(std::time::Duration::from_millis(1000)); cl.unlock(); println!(\"Thread 1 released lock\"); }); } { let cl = lock.clone(); std::thread::spawn(move || { cl.lock(); println!(\"Thread 2 acquired lock\"); std::thread::sleep(std::time::Duration::from_millis(1000)); cl.unlock(); println!(\"Thread 2 released lock\"); }); } std::thread::sleep(std::time::Duration::from_millis(3000));}// 输出结果：// Thread 1 acquired lock// Thread 2 acquired lock// Thread 1 released lock// Thread 2 released lock这段代码创建了一个SpinLock类型的自旋锁，然后启动了两个线程，每个线程都会尝试获取锁并输出一些信息，然后等待1秒钟后释放锁。最佳实践在使用Rust的Atomic类型时，应该遵循以下最佳实践： 尽量使用较弱的内存序：使用较弱的内存序可以提高性能，但可能会导致一些细微的问题，因此应该尽量使用较弱的内存序。 避免过度使用Atomic类型：Atomic类型的使用应该尽量避免，因为它可能会导致性能问题。如果可以使用其他线程安全的方式来实现同样的功能，则应该尽量避免使用Atomic类型。 避免竞态条件：使用Atomic类型时应该避免竞态条件，因为它可能会导致一些难以调试的问题。如果有竞态条件存在，则应该使用锁来保护临界区。 使用正确的内存序：使用Atomic类型时应该使用正确的内存序，以确保多个线程之间的操作的正确性。如果使用了错误的内存序，则可能会导致一些意外的问题。下面是一个示例代码，展示了如何使用Atomic类型实现一个简单的引用计数器：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172use std::sync::atomic::{AtomicUsize, Ordering};use std::sync::Arc;struct Counter { count: AtomicUsize,}impl Counter { fn new() -&gt; Counter { Counter { count: AtomicUsize::new(1) } } fn add_ref(&amp;self) -&gt; usize { self.count.fetch_add(1, Ordering::SeqCst) } fn release(&amp;self) -&gt; usize { let count = self.count.fetch_sub(1, Ordering::SeqCst); if count == 1 { std::mem::drop(self); } count - 1 }}fn main() { let counter = Arc::new(Counter::new()); let thread1 = { let counter = Arc::clone(&amp;counter); std::thread::spawn(move || { let count = counter.add_ref(); println!(\"Thread 1: count = {}\", count); }) }; let thread2 = { let counter = Arc::clone(&amp;counter); std::thread::spawn(move || { let count = counter.add_ref(); println!(\"Thread 2: count = {}\", count); }) }; let thread3 = { let counter = Arc::clone(&amp;counter); std::thread::spawn(move || { let count = counter.release(); println!(\"Thread 3: count = {}\", count); }) }; let thread4 = { let counter = Arc::clone(&amp;counter); std::thread::spawn(move || { let count = counter.release(); println!(\"Thread 4: count = {}\", count); }) }; thread1.join().unwrap(); thread2.join().unwrap(); thread3.join().unwrap(); thread4.join().unwrap();}// 输出结果：// Thread 1: count = 1// Thread 3: count = 1// Thread 2: count = 1// Thread 4: count = 1这段代码创建了一个Counter类型的引用计数器，然后启动了4个线程，每个线程都会对计数器进行增加或减少操作。最后输出计数器的值。总结Rust语言的Atomic是一种非常方便和安全的线程安全原子类型，它可以用于解决多线程并发访问变量时出现的竞态条件问题。在使用Atomic时，应该遵循一些最佳实践，例如尽量使用较弱的内存序、避免过度使用Atomic类型、避免竞态条件、使用正确的内存序等等。另外，Atomic类型还提供了一些进阶用法，例如自旋锁、无锁队列、引用计数等等，这些用法可以帮助我们更好地应对多线程并发访问的问题。总之，Rust的Atomic类型是一种非常强大和有用的工具，它可以帮助我们在多线程并发场景下保证程序的正确性和性能。如果你还没有使用过Atomic类型，那么我建议你尝试一下，相信它会给你带来不少的帮助和收益。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 条件变量 Condvar",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Condvar",
      "url"         : "./rust/2023/03/23/rust_lang_tutorial_110_Condvar.html",
      "date"        : "2023-03-23 00:00:00 +0800",
      "description" : "",
      "content"     : "在并发编程中，条件变量（Condvar）是一种用于等待特定条件的线程同步机制。它允许线程等待另一个线程发出信号，以便在满足条件时恢复执行。Rust语言提供了Condvar类型，可以用于实现线程之间的同步。本文将介绍Rust语言中的Condvar，包括其含义、常用业务场景和用法、进阶用法以及最佳实践。条件变量是一种线程同步机制，它允许一个或多个线程等待另一个线程发出信号。条件变量通常用于等待某个共享资源的可用性，或者等待某个条件的满足。在Rust语言中，条件变量由Condvar类型表示。Condvar是一个智能指针类型，它包装了一个MutexGuard类型的值，并提供了wait和notify_one方法，用于等待和唤醒线程。常用业务场景和用法等待共享资源的可用性在多线程应用程序中，有时需要等待某个共享资源的可用性。例如，假设有一个缓冲区，多个线程需要向该缓冲区写入数据，但是缓冲区已满时需要等待其他线程读取数据后才能继续写入。这种情况下，可以使用条件变量来等待缓冲区的可用性。下面是一个示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162use std::sync::{Arc, Mutex, Condvar};use std::thread;struct Buffer { data: Vec&lt;i32&gt;, capacity: usize, mutex: Mutex&lt;()&gt;, condvar: Condvar,}impl Buffer { fn new(capacity: usize) -&gt; Self { Self { data: vec![], capacity, mutex: Mutex::new(()), condvar: Condvar::new(), } } fn write(&amp;self, value: i32) { let mut lock = self.mutex.lock().unwrap(); while self.data.len() == self.capacity { lock = self.condvar.wait(lock).unwrap(); } self.data.push(value); self.condvar.notify_one(); } fn read(&amp;self) -&gt; i32 { let mut lock = self.mutex.lock().unwrap(); while self.data.is_empty() { lock = self.condvar.wait(lock).unwrap(); } let value = self.data.remove(0); self.condvar.notify_one(); value }}fn main() { let buffer = Arc::new(Buffer::new(10)); let mut handles = vec![]; for i in 0..10 { let buffer = buffer.clone(); let handle = thread::spawn(move || { for j in 0..10 { let value = i * 10 + j; buffer.write(value); } }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } let mut values = vec![]; for _ in 0..100 { values.push(buffer.read()); } assert_eq!(values, (0..100).collect::&lt;Vec&lt;_&gt;&gt;());}在这个示例代码中，我们定义了一个Buffer结构体，它包含一个Vec类型的数据、一个容量、一个Mutex类型的互斥锁和一个Condvar类型的条件变量。write方法用于向缓冲区写入数据，如果缓冲区已满，则等待其他线程读取数据后再进行写入。read方法用于从缓冲区读取数据，如果缓冲区为空，则等待其他线程写入数据后再进行读取。在主函数中，我们创建了10个线程，每个线程向缓冲区写入10个数据。最后，我们从缓冲区读取了100个数据，并检查它们是否按顺序排列。等待某个条件的满足在多线程应用程序中，有时需要等待某个条件的满足。例如，假设有一个计数器，多个线程需要等待计数器达到某个值后才能继续执行。这种情况下，可以使用条件变量来等待计数器的值达到某个值。下面是一个示例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152use std::sync::{Arc, Mutex, Condvar};use std::thread;struct Counter { value: i32, mutex: Mutex&lt;()&gt;, condvar: Condvar,}impl Counter { fn new() -&gt; Self { Self { value: 0, mutex: Mutex::new(()), condvar: Condvar::new(), } } fn increment(&amp;self) { let mut lock = self.mutex.lock().unwrap(); self.value += 1; if self.value == 10 { self.condvar.notify_one(); } } fn wait(&amp;self) { let mut lock = self.mutex.lock().unwrap(); while self.value &lt; 10 { lock = self.condvar.wait(lock).unwrap(); } }}fn main() { let counter = Arc::new(Counter::new()); let mut handles = vec![]; for _ in 0..10 { let counter = counter.clone(); let handle = thread::spawn(move || { for _ in 0..10 { counter.increment(); } }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } counter.wait(); println!(\"Counter reached 10\");}在这个示例代码中，我们定义了一个Counter结构体，它包含一个计数器值、一个Mutex类型的互斥锁和一个Condvar类型的条件变量。increment方法用于增加计数器的值，如果计数器的值达到10，则发出一个信号。wait方法用于等待计数器的值达到10。在主函数中，我们创建了10个线程，每个线程增加计数器的值10次。最后，我们等待计数器的值达到10，并输出一条消息。进阶用法在大多数情况下，wait和notify_one方法已经足够满足我们的需求。但是，在某些情况下，可能需要更高级的用法。例如，有时需要等待多个条件的满足，或者需要等待一段时间后自动唤醒线程。在这种情况下，可以使用wait_timeout和notify_all方法。等待多个条件的满足在某些情况下，需要等待多个条件的满足。例如，假设有一个队列，多个线程需要等待队列的长度达到某个值或者等待超时。这种情况下，可以使用wait_timeout方法来等待多个条件的满足。下面是一个示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374use std::sync::{Arc, Mutex, Condvar};use std::thread;use std::time::Duration;struct Queue { data: Vec&lt;i32&gt;, capacity: usize, mutex: Mutex&lt;()&gt;, condvar: Condvar,}impl Queue { fn new(capacity: usize) -&gt; Self { Self { data: vec![], capacity, mutex: Mutex::new(()), condvar: Condvar::new(), } } fn push(&amp;self, value: i32) { let mut lock = self.mutex.lock().unwrap(); while self.data.len() == self.capacity { lock = self.condvar.wait(lock).unwrap(); } self.data.push(value); self.condvar.notify_all(); } fn pop(&amp;self) -&gt; Option&lt;i32&gt; { let mut lock = self.mutex.lock().unwrap(); loop { if let Some(value) = self.data.pop() { self.condvar.notify_all(); return Some(value); } lock = match self.condvar.wait_timeout(lock, Duration::from_secs(1)) { Ok((lock, _)) =&gt; lock, Err(_) =&gt; { self.condvar.notify_all(); return None; } }; } }}fn main() { let queue = Arc::new(Queue::new(10)); let mut handles = vec![]; for i in 0..10 { let queue = queue.clone(); let handle = thread::spawn(move || { for j in 0..10 { let value = i * 10 + j; queue.push(value); } }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } let mut values = vec![]; loop { if let Some(value) = queue.pop() { values.push(value); } else { break; } } assert_eq!(values.len(), 100);}在这个示例代码中，我们定义了一个Queue结构体，它包含一个Vec类型的数据、一个容量、一个Mutex类型的互斥锁和一个Condvar类型的条件变量。push方法用于向队列中添加数据，如果队列已满，则等待其他线程从队列中取出数据后再进行添加。pop方法用于从队列中取出数据，如果队列为空，则等待其他线程向队列中添加数据或者等待超时。在主函数中，我们创建了10个线程，每个线程向队列中添加10个数据。最后，我们从队列中取出了所有数据，并检查它们是否按顺序排列。等待一段时间后自动唤醒线程在某些情况下，需要等待一段时间后自动唤醒线程。例如，假设有一个任务，需要在一定时间内完成，如果超时则取消任务。这种情况下，可以使用wait_timeout方法来等待一段时间后自动唤醒线程。下面是一个示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051use std::sync::{Arc, Mutex, Condvar};use std::thread;use std::time::{Duration, Instant};struct Task { done: bool, mutex: Mutex&lt;()&gt;, condvar: Condvar,}impl Task { fn new() -&gt; Self { Self { done: false, mutex: Mutex::new(()), condvar: Condvar::new(), } } fn run(&amp;self, timeout: Duration) { let start = Instant::now(); let mut lock = self.mutex.lock().unwrap(); while !self.done { let elapsed = start.elapsed(); if elapsed &gt;= timeout { return; } let remaining = timeout - elapsed; lock = match self.condvar.wait_timeout(lock, remaining).unwrap() { (lock, true) =&gt; return, (lock, false) =&gt; lock, }; } } fn cancel(&amp;self) { let mut lock = self.mutex.lock().unwrap(); self.done = true; self.condvar.notify_all(); }}fn main() { let task = Arc::new(Task::new()); let handle = thread::spawn(move || { task.run(Duration::from_secs(5)); }); thread::sleep(Duration::from_secs(2)); task.cancel(); handle.join().unwrap();}在这个示例代码中，我们定义了一个Task结构体，它包含一个标志位、一个Mutex类型的互斥锁和一个Condvar类型的条件变量。run方法用于执行任务，在一定时间内等待任务完成，如果超时则取消任务。cancel方法用于取消任务。在主函数中，我们创建了一个线程执行任务，并在2秒后取消任务。如果任务在5秒内完成，则线程将正常退出，否则将被取消。最佳实践在使用条件变量时，需要注意以下几点： 必须先获取互斥锁才能使用条件变量。 在等待条件变量之前，必须先检查条件是否满足，否则可能会出现死锁。 在发出信号之前，必须修改共享状态，否则可能会出现竞争条件。 在使用wait_timeout方法时，必须将剩余时间传递给wait_timeout方法，否则可能会等待超时。结论条件变量是一种用于等待特定条件的线程同步机制。在Rust语言中，条件变量由Condvar类型表示。Condvar可以用于实现线程之间的同步，例如等待共享资源的可用性或等待某个条件的满足。在使用条件变量时，需要注意一些最佳实践，以避免出现死锁和竞争条件。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 原子引用计数智能指针 Arc",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Arc",
      "url"         : "./rust/2023/03/23/rust_lang_tutorial_109_Arc.html",
      "date"        : "2023-03-23 00:00:00 +0800",
      "description" : "",
      "content"     : "在Rust语言中，Arc是一个非常重要的概念，它是Atomic Reference Counting的缩写，是Rust语言中实现共享所有权的方式之一。在本篇教程中，我们将深入探讨Arc的含义、常用业务场景和用法、进阶用法以及最佳实践等方面。Arc的含义Arc是Rust语言中实现共享所有权的方式之一，它可以让多个变量共享同一个值，而不会出现数据竞争和内存泄漏的问题。Arc的实现方式是在每个Arc对象中维护一个计数器，用于记录当前有多少个变量引用了这个对象，当计数器为0时，对象会被自动销毁。Arc的特点可以总结为以下几点： 允许多个变量共享同一个值。 可以在多个线程中安全地共享数据。 不会出现数据竞争和内存泄漏的问题。常用业务场景和用法Arc在Rust语言中被广泛应用于以下几个方面：1. 多线程编程在多线程编程中，由于多个线程需要访问同一个数据，因此需要使用Arc来实现数据的共享。例如，在下面的示例代码中，我们创建了一个Arc对象，并将其传递给多个线程，每个线程都可以安全地访问这个对象。12345678910111213141516171819202122232425use std::sync::{Arc, Mutex};use std::thread;fn main() { let data = Arc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let data = Arc::clone(&amp;data); let handle = thread::spawn(move || { let mut data = data.lock().unwrap(); *data += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\"Result: {}\", *data.lock().unwrap());}// 输出结果：// Result: 102. 内存管理在一些需要手动管理内存的场景中，Arc可以帮助我们管理内存，避免出现内存泄漏的问题。例如，在下面的示例代码中，我们创建了一个Arc对象，并将其传递给一个函数，在函数中，我们将Arc对象转换成了一个裸指针，并将其传递给C语言的函数，由于C语言不支持自动内存管理，因此需要手动管理内存，而Arc可以帮助我们管理内存，避免出现内存泄漏的问题。1234567891011use std::sync::Arc;fn main() { let data = Arc::new(vec![1, 2, 3]); let ptr = Arc::into_raw(data) as *mut i32; unsafe { // Call C function with ptr } let data = unsafe { Arc::from_raw(ptr) };}3. 数据结构在一些需要实现自定义数据结构的场景中，Arc可以帮助我们实现共享数据。例如，在下面的示例代码中，我们创建了一个自定义的数据结构，并在其中使用了Arc来实现数据的共享。123456789101112131415161718192021use std::sync::Arc;struct Node&lt;T&gt; { data: T, next: Option&lt;Arc&lt;Node&lt;T&gt;&gt;&gt;,}fn main() { let node1 = Arc::new(Node { data: 1, next: None, }); let node2 = Arc::new(Node { data: 2, next: Some(Arc::clone(&amp;node1)), }); let node3 = Arc::new(Node { data: 3, next: Some(Arc::clone(&amp;node2)), });}进阶用法除了上述常用的业务场景和用法之外，Arc还有一些进阶用法，可以帮助我们更好地使用Arc，提高代码的可读性和可维护性。1. 使用Weak在一些场景中，我们需要使用Arc来实现数据的共享，但是又不希望出现循环引用的问题。例如，在下面的示例代码中，我们创建了两个对象，每个对象都持有对方的Arc对象，这样就会出现循环引用的问题。12345678910111213use std::sync::Arc;struct Node { next: Option&lt;Arc&lt;Node&gt;&gt;,}fn main() { let node1 = Arc::new(Node { next: None }); let node2 = Arc::new(Node { next: Some(Arc::clone(&amp;node1)), }); node1.next = Some(Arc::clone(&amp;node2));}为了避免这种循环引用的问题，我们可以使用Weak来实现弱引用。Weak是Arc的一种变体，它允许我们创建一个弱引用，不会增加引用计数，也不会阻止对象的销毁，当对象被销毁后，弱引用会自动变成None。1234567891011121314use std::sync::{Arc, Weak};struct Node { next: Option&lt;Arc&lt;Node&gt;&gt;,}fn main() { let node1 = Arc::new(Node { next: None }); let node2 = Arc::new(Node { next: Some(Arc::clone(&amp;node1)), }); let weak_node1 = Arc::downgrade(&amp;node1); node1.next = Some(Arc::clone(&amp;node2));}2. 使用Atomic在一些需要进行原子操作的场景中，我们可以使用Arc和Atomic来实现原子操作。例如，在下面的示例代码中，我们创建了一个Arc对象，并将其转换成了一个Atomic对象，然后在多个线程中对其进行原子操作。12345678910111213141516171819202122232425262728293031use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};use std::thread;fn main() { let data = Arc::new(AtomicUsize::new(0)); let mut handles = vec![]; for _ in 0..10 { let data = Arc::clone(&amp;data); let handle = thread::spawn(move || { let mut data = data.load(Ordering::Relaxed); loop { let new_data = data + 1; let old_data = data; let result = data.compare_and_swap(old_data, new_data, Ordering::Relaxed); if result == old_data { break; } data = result; } }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\"Result: {}\", data.load(Ordering::Relaxed));}最佳实践在使用Arc时，我们需要遵循以下最佳实践： 尽量使用Arc来实现数据的共享，避免出现数据竞争和内存泄漏的问题。 在多线程编程中，尽量使用Mutex、RwLock等同步原语来保证数据的安全性。 在使用Arc时，尽量使用Weak来避免出现循环引用的问题。 在需要进行原子操作时，可以使用Arc和Atomic来实现原子操作。 在使用Arc时，需要注意内存管理的问题，避免出现内存泄漏的问题。总结本篇教程详细介绍了Rust语言中的Arc，包括其含义、常用业务场景和用法、进阶用法以及最佳实践等方面。通过本篇教程的学习，相信大家已经对Arc有了更深入的了解，也能够更好地使用Arc来实现数据的共享，提高代码的可读性和可维护性。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 互斥锁 Mutex",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Mutex",
      "url"         : "./rust/2023/03/23/rust_lang_tutorial_108_Mutex.html",
      "date"        : "2023-03-23 00:00:00 +0800",
      "description" : "",
      "content"     : "锁是在多线程程序中最常用的同步机制。锁可以确保线程的安全访问共享内存区域。Rust中引入了具有高级内存安全性和线程安全性的锁类型，称之为Mutex。本教程将介绍Rust中的Mutex，包括其含义、常用业务场景和用法、进阶用法以及最佳实践。Mutex （互斥锁）在Rust中，Mutex是一种同步原语（synchronization primitive），它是用于保护共享资源的关键部分不被同时访问的一种机制。Mutex分为两种类型：Mutex和RwLock（读写锁）。在本教程中，我们将着重介绍Mutex。Mutex支持两种操作：lock和unlock。任何试图访问由mutex保护的共享变量的线程都必须首先获得锁定，否则将陷入等待状态，直到锁被释放。常用业务场景和用法使用Mutex的主要原因是保证线程安全，特别是在操作共享数据时。下面是一些常见使用场景： 多个线程访问同一变量时。例如，在多线程网络编程中，有一个counter变量被多个线程共享，每当有请求被处理时，counter的值就会更新。但是，在多个线程尝试同时更新counter变量时，会导致数据不一致性的问题。在这种情况下，使用Mutex变量保护counter变量是必要的。 在并发环境中对数据结构进行访问和操作时。例如，在访问标准库中的哈希表时，当多个线程同时访问哈希表时，需要加锁来确保线程安全。 下面是一些示例代码：1234567891011121314151617181920use std::sync::Mutex;fn main() { let counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let c = Arc::clone(&amp;counter); let handle = std::thread::spawn(move || { let mut num = c.lock().unwrap(); *num += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\"Result: {}\", *counter.lock().unwrap());}在上面的代码中，我们创建了一个Mutex实例counter，它包含一个整型变量0。接下来，我们创建了10个线程，每次都会锁定Mutex，并递增counter变量的值。最后，我们打印结果。进阶用法随着对Mutex的掌握程度的提高，您可以开始深入了解更高级的用法。下面是一些进阶用法：使用MutexGuard当您获得了Mutex，您将拥有一个MutexGuard。这是一种托管类型，使您可以安全地使用Mutex中的值。在下面的示例代码中，我们将演示如何使用MutexGuard。123456789101112131415use std::sync::Mutex;fn main() { let mutex = Mutex::new(0); { let mut data = mutex.lock().unwrap(); *data += 1; println!(\"Data: {}\", *data); } let mut data = mutex.lock().unwrap(); *data += 1; println!(\"Data: {}\", *data);}// Data: 1// Data: 2在上面的示例代码中，我们首先获取Mutex的所有权，并对其进行加锁，然后引用被保护的变量，并对其进行递增操作。在大括号中引入了一个新的作用域，这意味着MutexGuard的生命周期将在大括号结束时结束，而Mutext本身仍然没有被释放。在大括号结束后，我们再次获取Mutex的所有权，然后更新变量的值。使用try_lock在某些情况下，您需要尝试获取Mutex的所有权，但不希望等待直到别的线程释放它。在这种情况下，您可以使用try_lock方法。如果该方法成功地获取了Mutex的所有权，则返回一个包含保护变量的MutexGuard。如果该方法无法获得Mutex的所有权，则返回Err而不是阻塞线程。12345678use std::sync::Mutex;fn main() { let mutex = Mutex::new(0); let mut guard1 = mutex.lock().unwrap(); let guard2 = mutex.try_lock(); assert!(guard2.is_err()); // 返回值是 Err *guard1 += 1;}在上面的示例代码中，我们首先获得Mutex的所有权，并使用lock方法锁定它。接下来，尝试使用try_lock方法获取Mutex，并检查该方法是否返回了Err。最后，更新变量值并释放保护。Mutex和Arc的结合使用Arc是一种具有线程安全引用计数的类型。Mutex可以和Arc结合使用，以提供对共享数据的并发访问。下面是一些示例代码。1234567891011121314151617181920212223use std::sync::{Mutex, Arc};use std::thread;fn main() { let counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Arc::clone(&amp;counter); let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\"Result: {}\", *counter.lock().unwrap());}在上面的代码中，我们创建了一个Mutex实例及其Arc的实例。然后，我们使用Arc的clone方法创建多个指向Mutex的引用，并在每个线程中使用被保护的变量。最后，我们打印结果。RwLock 读写锁除了Mutex之外，Rust还提供了RwLock（读写锁）来支持多个线程同时读取共享数据。RwLock允许多个线程同时获得读锁，但只允许一个线程获得写锁。下面是一个使用RwLock的示例代码：12345678910111213141516171819202122use std::sync::{RwLock, Arc};use std::thread;fn main() { let data = Arc::new(RwLock::new(0)); let read_data = data.clone(); let t1 = thread::spawn(move || { let data = read_data.read().unwrap(); println!(\"Thread 1: {}\", *data); }); let write_data = data.clone(); let t2 = thread::spawn(move || { let mut data = write_data.write().unwrap(); *data = 42; }); t1.join().unwrap(); t2.join().unwrap();}// Thread 1: 0在这个示例中，我们创建了一个RwLock来保护一个整数。然后我们创建了两个线程，一个线程读取该整数，另一个线程修改该整数。由于RwLock允许多个线程同时获得读锁，但只允许一个线程获得写锁，所以我们可以安全地访问共享数据。最佳实践在使用Mutex时，需要注意以下几点： 尽量避免死锁：当一个线程获得Mutex的锁时，它会一直占用该锁，直到该线程释放Mutex的锁。如果该线程在占用Mutex的锁的同时，还需要获得其他Mutex的锁，那么就可能会发生死锁的情况。因此，需要尽量避免在一个线程中同时占用多个Mutex的锁。 尽量避免竞争条件：当多个线程同时访问共享数据时，就会出现竞争条件的问题。为了避免这种情况，可以使用Mutex来保护共享数据的访问。 尽量避免锁的过多使用：当一个线程持有Mutex的锁时，其他线程就无法访问共享数据。如果一个线程持有Mutex的锁的时间过长，那么就可能会导致其他线程长时间等待。因此，需要尽量减少锁的使用次数，以提高程序的并发性能。 尽量使用RwLock：当多个线程需要同时读取共享数据时，可以使用RwLock来提高程序的并发性能。RwLock允许多个线程同时获得读锁，但只允许一个线程获得写锁，从而避免了竞争条件的问题。 结论Mutex是一个互斥量，用于保护共享数据的访问。它提供了两个方法：lock和unlock。当一个线程需要访问共享数据时，它需要先获得Mutex的锁，然后才能访问共享数据。当访问完成后，该线程需要释放Mutex的锁，以便其他线程可以访问共享数据。除了基本用法之外，Mutex还提供了一些进阶用法，如MutexGuard、Condvar和RwLock等。在使用Mutex时，需要注意避免死锁和竞争条件，并尽量减少锁的使用次数。在多个线程需要同时读取共享数据时，可以使用RwLock来提高程序的并发性能。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 先进先出队列 Queue",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, FIFO, 先进先出",
      "url"         : "./rust/2023/03/22/rust_lang_tutorial_205_Queue.html",
      "date"        : "2023-03-22 00:00:00 +0800",
      "description" : "",
      "content"     : "Queue，即队列，是数据结构中非常重要的一种数据结构，是广泛应用于计算机科学中的一种数据存储结构。Queue可以被看作是一种特殊的线性表，这种结构又称为先进先出(First In First Out, FIFO)的线性表。Queue常常被用来保存要被计算的任务，并按照FIFO的方式进行处理。Rust是一门由Mozilla组织开发的系统编程语言。其具有高效、安全、并发性强等特点，在网络编程、操作系统、游戏开发、高性能计算和物联网等领域都有广泛的应用。在本文中，我们将通过实现一个线程安全的先进先出的Queue进一步学习Rust语言。实战先进先出队列 QueueQueue是FIFO（First-In-First-Out）数据结构，即先进先出的队列。可以把Queue看成是一个容器，按照FIFO的方式添加或删除元素。通常情况下，Queue主要包含以下两个重要的方法： push(val)：向Queue中添加一个元素。 pop()：从Queue中移除并返回第一个元素。Queue的底层实现可以有多种方式，例如链表、数组、环形缓存等。在本文中，我们将基于Rust标准库，使用Vec作为Queue底层的数据结构来实现线程安全的Queue，并提供以下功能： push：添加一个元素到Queue尾部。 pop：从Queue头部弹出一个元素。 peek: 获取队列头部的第一个元素，但不从Queue中弹出。 isEmpty: 判断Queue是否为空。 length: 获取Queue中元素的个数。为了实现线程安全的Queue，我们将使用Rust多线程编程的标准库：std::sync::Mutex。Mutex是一种同步原语，用来实现对共享资源的独占访问，从而保证线程安全。Mutex允许某个线程锁定Mutex以获取对资源的独占访问（即获得锁）并进行修改，其他尝试获取锁的线程会阻塞，直到拥有锁的线程释放它。Queue代码实现首先，我们从Queue的定义出发，定义一个Queue结构体，并实现Queue的所有方法。结构体如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344use std::sync::{Mutex, Arc};pub struct Queue&lt;T&gt; { inner: Arc&lt;Mutex&lt;Vec&lt;T&gt;&gt;&gt;,}impl&lt;T: Clone&gt; Queue&lt;T&gt; { pub fn new() -&gt; Self { Queue { inner: Arc::new(Mutex::new(Vec::new())), } } pub fn push(&amp;self, val: T) { let mut inner = self.inner.lock().unwrap(); inner.push(val); } pub fn pop(&amp;self) -&gt; Option&lt;T&gt; { let mut inner = self.inner.lock().unwrap(); match inner.len() { 0 =&gt; None, _ =&gt; Some(inner.remove(0)), } } pub fn peek(&amp;self) -&gt; Option&lt;T&gt; { let inner = self.inner.lock().unwrap(); match inner.len() { 0 =&gt; None, _ =&gt; Some(inner[0].clone()), } } pub fn is_empty(&amp;self) -&gt; bool { let inner = self.inner.lock().unwrap(); inner.is_empty() } pub fn length(&amp;self) -&gt; usize { let inner = self.inner.lock().unwrap(); inner.len() }}解释一下Queue中一些重要的部分：12345pub fn new() -&gt; Self { Queue { inner: Arc::new(Mutex::new(Vec::new())), }}定义了一个新的Queue实例，包含了内部数据的Arc&lt;Mutex&gt;结构。这里，Arc是原子引用计数器的缩写，用来保证多线程安全。Arc则是智能指针，用于管理Mutex类型的内部数据。Arc以引用计数方式，管理Mutex实例内部数据的所有权，保证多线程安全。Mutex内部是一个可变的Vec，它的类型参数是泛型T，表示Vec中可以存储任意类型的元素。push, pop等函数也是Queue结构体中最为重要的实现。如下所示：1234pub fn push(&amp;self, val: T) { let mut inner = self.inner.lock().unwrap(); inner.push(val);}该函数为向Queue中添加元素的函数，我们首先需要获取inner数据的可变引用，通过使用Mutex来获取可变引用，在获取操作之前，需要先使用mutex实例的lock方法加锁（获得锁），在获取到锁之后，就可以安全地对inner进行修改。如果不能获取到锁，则会阻塞当前线程，直到获取到锁。1let mut inner = self.inner.lock().unwrap();然后，将要添加的元素val保存到inner中，这里我们使用Vec的push方法将元素val添加到inner的尾部。1inner.push(val);下面是从Queue中弹出元素的函数实现：123456let mut inner = self.inner.lock().unwrap();match inner.len() { 0 =&gt; None, _ =&gt; Some(inner.remove(0)), }}其中，首先使用了Mutex的lock()方法加锁，获取到inner上独占的可变引用inner，如果队列当前为空，则返回None。否则，通过Vec的remove方法，从inner中弹出并返回队列头部的第一个元素。注意：使用Vec的remove方法，将队列头部的第一个元素弹出之后，将导致队列中所有元素都向前移动一个位置，执行效率较低。对于拥有大量元素的Queue，需要考虑使用链表等数据结构以提高效率。Queue中还包含多个其他方法（例如peek, is_empty, length等），这里不再一一进行详解，读者在使用的同时结合注释理解即可。编写Queue单元测试在此为Queue编写单元测试。我们在Queue代码目录中新建测试代码文件，并在其中编写测试用例。12345678910111213141516171819#[cfg(test)]mod tests { use super::*; #[test] fn test_queue() { let queue: Queue&lt;i32&gt; = Queue::new(); assert_eq!(queue.is_empty(), true); queue.push(10); queue.push(11); assert_eq!(queue.length(), 2); assert_eq!(queue.peek(), Some(10)); assert_eq!(queue.pop(), Some(10)); assert_eq!(queue.pop(), Some(11)); assert_eq!(queue.pop(), None); assert_eq!(queue.is_empty(), true); queue.push(20); assert_eq!(queue.is_empty(), false); }}解释一下这段测试代码：首先，我们需要引用Queue模块，并定义测试模块。在测试模块中，使用Queue::new创建一个新的Queue实例，并测试Queue的is_empty函数，确认新创建的队列为空。12345#[test]fn test_queue() { let queue: Queue&lt;i32&gt; = Queue::new(); assert_eq!(queue.is_empty(), true);}然后，依次往队列中添加元素，它的长度会逐渐增大。添加完元素之后，我们使用peek函数，确认队列的头部元素，使用pop函数，逐一弹出队列中的所有元素，最后测试队列为空。12345678queue.push(10);queue.push(11);assert_eq!(queue.length(),2);assert_eq!(queue.peek(), Some(&amp;10));assert_eq!(queue.pop(), Some(10));assert_eq!(queue.pop(), Some(11));assert_eq!(queue.pop(), None);assert_eq!(queue.is_empty(), true);最后一个测试用例测试了队列尾部添加的情况，添加一个元素后，使用is_empty函数判断队列不为空。12queue.push(20);assert_eq!(queue.is_empty(), false);上述测试代码通过测试，我们可以确认Queue实现是符合预期的。"
    } ,
  
    {
      "title"       : "InfluxDB Flux",
      "category"    : "",
      "tags"        : "InfluxDB, Flux, Flux语法",
      "url"         : "./influxdb/2023/03/21/influxdb_flux_query.html",
      "date"        : "2023-03-21 21:00:00 +0800",
      "description" : "",
      "content"     : "InfluxDB是一款开源的时间序列数据库，它的数据模型和查询语言都是针对时间序列数据进行优化的。而Flux语法则是InfluxDB 2.0版本中的全新查询语言，它的设计目标是提供更加灵活、强大的查询能力。本文将介绍Flux语法的基本语法和一些常用的操作符，同时提供一些示例代码，帮助读者更好地理解和使用Flux语法。Flux基本语法数据源Flux查询的第一步是指定数据源，可以使用from关键字来指定数据源。例如：1from(bucket: \"my-bucket\")这个查询语句指定了数据源为名为my-bucket的桶。过滤器Flux查询中可以使用过滤器来筛选出符合条件的数据。过滤器使用filter()函数来实现，可以传入一个Lambda表达式作为参数，该表达式用于对数据进行过滤。例如：12from(bucket: \"my-bucket\") |&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\")这个查询语句指定了数据源为my-bucket桶，并使用filter()函数来筛选出_measurement字段等于cpu的数据。转换器Flux查询中可以使用转换器对数据进行转换和处理。转换器使用map()函数来实现，可以传入一个Lambda表达式作为参数，该表达式用于对数据进行转换。例如：123from(bucket: \"my-bucket\") |&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\") |&gt; map(fn: (r) =&gt; ({ r with _value: r._value * 2.0 }))这个查询语句指定了数据源为my-bucket桶，并使用filter()函数筛选出_measurement字段等于cpu的数据，然后使用map()函数将_value字段的值乘以2.0。聚合器Flux查询中可以使用聚合器对数据进行聚合计算。聚合器使用aggregateWindow()函数来实现，可以传入一个Lambda表达式作为参数，该表达式用于指定聚合计算的方式。例如：123from(bucket: \"my-bucket\") |&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\") |&gt; aggregateWindow(every: 1m, fn: mean)这个查询语句指定了数据源为my-bucket桶，并使用filter()函数筛选出_measurement字段等于cpu的数据，然后使用aggregateWindow()函数对数据进行聚合计算，每分钟计算一次平均值。排序器Flux查询中可以使用排序器对数据进行排序。排序器使用sort()函数来实现，可以传入一个Lambda表达式作为参数，该表达式用于指定排序方式。例如：123from(bucket: \"my-bucket\") |&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\") |&gt; sort(columns: [\"_time\"], desc: true)这个查询语句指定了数据源为my-bucket桶，并使用filter()函数筛选出_measurement字段等于cpu的数据，然后使用sort()函数对数据按照_time字段进行降序排序。常用操作符数学操作符Flux语法支持常见的数学操作符，例如加减乘除和取模等。例如：12345x + yx - yx * yx / yx % y逻辑操作符Flux语法支持常见的逻辑操作符，例如与、或和非等。例如：123x and yx or ynot x比较操作符Flux语法支持常见的比较操作符，例如等于、不等于、大于、小于、大于等于和小于等于等。例如：123456x == yx != yx &gt; yx &lt; yx &gt;= yx &lt;= y字符串操作符Flux语法支持常见的字符串操作符，例如连接和分割等。例如：12x + ystrings.split(v: \"x,y,z\", t: \",\")时间操作符Flux语法支持常见的时间操作符，例如时间加减和时间格式化等。例如：123time + duration(v: 1h)time - duration(v: 1h)time |&gt; formatTime(fmt: \"2006-01-02T15:04:05Z07:00\")Flux 常用函数InfluxDB Flux语法是InfluxDB 2.0版本中的全新查询语言，它的设计目标是提供更加灵活、强大的查询能力。在实际应用中，我们可以通过灵活使用Flux语法，优化查询性能，提高数据处理效率。以下是一些实践经验，帮助童鞋们更好地理解和使用Flux语法。使用range()函数限制查询时间范围在查询数据时，我们通常只需要查询指定时间范围内的数据。Flux语法中可以使用range()函数来限制查询时间范围。例如：12from(bucket: \"my-bucket\") |&gt; range(start: -1h, stop: now())这个查询语句指定了数据源为my-bucket桶，并使用range()函数限制查询时间范围为最近一小时内的数据。使用filter()函数筛选数据在查询数据时，我们通常需要筛选出符合条件的数据。Flux语法中可以使用filter()函数来筛选数据。例如：123from(bucket: \"my-bucket\") |&gt; range(start: -1h, stop: now()) |&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\")这个查询语句指定了数据源为my-bucket桶，并使用range()函数限制查询时间范围为最近一小时内的数据，然后使用filter()函数筛选出_measurement字段等于cpu的数据。使用map()函数对数据进行转换在查询数据时，我们通常需要对数据进行转换和处理。Flux语法中可以使用map()函数对数据进行转换。例如：1234from(bucket: \"my-bucket\") |&gt; range(start: -1h, stop: now()) |&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\") |&gt; map(fn: (r) =&gt; ({ r with _value: r._value * 2.0 }))这个查询语句指定了数据源为my-bucket桶，并使用range()函数限制查询时间范围为最近一小时内的数据，然后使用filter()函数筛选出_measurement字段等于cpu的数据，最后使用map()函数将_value字段的值乘以2.0。使用aggregateWindow()函数对数据进行聚合计算在查询数据时，我们通常需要对数据进行聚合计算。Flux语法中可以使用aggregateWindow()函数对数据进行聚合计算。例如：1234from(bucket: \"my-bucket\") |&gt; range(start: -1h, stop: now()) |&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\") |&gt; aggregateWindow(every: 1m, fn: mean)这个查询语句指定了数据源为my-bucket桶，并使用range()函数限制查询时间范围为最近一小时内的数据，然后使用filter()函数筛选出_measurement字段等于cpu的数据，最后使用aggregateWindow()函数对数据进行聚合计算，每分钟计算一次平均值。使用group()函数对数据进行分组在查询数据时，我们通常需要对数据进行分组。Flux语法中可以使用group()函数对数据进行分组。例如：12345from(bucket: \"my-bucket\") |&gt; range(start: -1h, stop: now()) |&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\") |&gt; aggregateWindow(every: 1m, fn: mean) |&gt; group(columns: [\"_field\"])这个查询语句指定了数据源为my-bucket桶，并使用range()函数限制查询时间范围为最近一小时内的数据，然后使用filter()函数筛选出_measurement字段等于cpu的数据，最后使用aggregateWindow()函数对数据进行聚合计算，每分钟计算一次平均值，最后使用group()函数对数据按照_field字段进行分组。使用sort()函数对数据进行排序在查询数据时，我们通常需要对数据进行排序。Flux语法中可以使用sort()函数对数据进行排序。例如：12345from(bucket: \"my-bucket\") |&gt; range(start: -1h, stop: now()) |&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\") |&gt; aggregateWindow(every: 1m, fn: mean) |&gt; sort(columns: [\"_value\"], desc: true)这个查询语句指定了数据源为my-bucket桶，并使用range()函数限制查询时间范围为最近一小时内的数据，然后使用filter()函数筛选出_measurement字段等于cpu的数据，最后使用aggregateWindow()函数对数据进行聚合计算，每分钟计算一次平均值，最后使用sort()函数对数据按照_value字段进行降序排序。使用join()函数连接多个数据源在查询数据时，我们通常需要连接多个数据源。Flux语法中可以使用join()函数连接多个数据源。例如：12345678910from(bucket: \"my-bucket\")|&gt; range(start: -1h, stop: now())|&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\")|&gt; aggregateWindow(every: 1m, fn: mean)|&gt; join(tables: {other_table: from(bucket: \"my-bucket-2\")|&gt; range(start: -1h, stop: now())|&gt; filter(fn: (r) =&gt; r._measurement == \"memory\")|&gt; aggregateWindow(every: 1m, fn: mean)}, on:[\"_time\"])这个查询语句指定了数据源为my-bucket桶，并使用range()函数限制查询时间范围为最近一小时内的数据，然后使用filter()函数筛选出_measurement字段等于cpu的数据，最后使用aggregateWindow()函数对数据进行聚合计算，每分钟计算一次平均值。同时，使用join()函数连接了另一个数据源my-bucket-2，并对其进行类似的处理，然后按照_time字段进行连接。以上是一些Flux的常用函数用法示例，希望能够对读者理解和使用Flux语法有所帮助。Flux 实战进阶示例以下是一些示例代码，帮助读者更好地理解和使用Flux语法。查询最近10分钟的CPU使用率1234from(bucket: \"my-bucket\") |&gt; range(start: -10m) |&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\") |&gt; aggregateWindow(every: 1m, fn: mean)查询最近一小时内CPU使用率最高的前5台服务器1234567from(bucket: \"my-bucket\") |&gt; range(start: -1h) |&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\") |&gt; aggregateWindow(every: 1m, fn: mean) |&gt; group(columns: [\"_field\"]) |&gt; sort(columns: [\"_value\"], desc: true) |&gt; limit(n: 5)查询某个标签的所有值12345from(bucket: \"my-bucket\") |&gt; range(start: -1h) |&gt; keys() |&gt; filter(fn: (r) =&gt; r._field == \"tag_name\") |&gt; group(columns: [\"_value\"])对数据进行归一化处理1234from(bucket: \"my-bucket\") |&gt; range(start: -1h) |&gt; filter(fn: (r) =&gt; r._measurement == \"cpu\") |&gt; map(fn: (r) =&gt; ({ r with _value: (r._value - 50.0) / 10.0 }))总结本文介绍了InfluxDB Flux语法的基本语法和常用操作符，并提供了一些示例代码。Flux语法是InfluxDB 2.0版本中的全新查询语言，相比于之前的查询语言，它更加灵活、强大，可以帮助用户更好地处理和分析时间序列数据。读者可以根据本文提供的内容，深入学习和使用Flux语法，从而更好地利用InfluxDB进行时间序列数据处理和分析。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 玩转“单例模式”",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 单例模式",
      "url"         : "./rust/2023/03/21/rust_lang_tutorial_304_patterns_Single.html",
      "date"        : "2023-03-21 00:00:00 +0800",
      "description" : "",
      "content"     : "单例模式是一种创建和使用对象的方法，它只允许系统中仅有一个实例对象。在Rust中实现单例模式有很多种方式，下面我们将介绍一些常用的实现方式、应用场景以及相关的最佳实践。常用的单例模式实现方式懒汉式单例模式懒汉式单例模式是一种常见的实现方式，它在需要使用对象时才进行创建，从而节约了系统资源。在Rust中可以通过lazy_static!宏来实现懒汉式单例模式，示例代码如下：1234567891011121314151617181920212223use lazy_static::lazy_static;use std::sync::Mutex;lazy_static! { static ref INSTANCE: Mutex&lt;MyObject&gt; = Mutex::new(MyObject::new());}struct MyObject { // ...}impl MyObject { fn new() -&gt; MyObject { MyObject { // ... } }}fn main() { let obj = INSTANCE.lock().unwrap(); // 使用obj对象}在这个示例中，我们定义了一个MyObject结构体来表示单例对象，然后使用lazy_static!宏来创建一个全局的Mutex对象，从而实现了单例模式。注意，在使用单例对象时需要使用Mutex的lock()方法来获取对象的所有权。饿汉式单例模式与懒汉式单例模式相对应的是饿汉式单例模式，它在程序启动的时候就创建了对象，因此在程序的运行过程中无需再次创建对象。在Rust中可以通过static关键字来实现饿汉式单例模式，示例代码如下：123456789101112131415161718192021222324252627static mut INSTANCE: Option&lt;MyObject&gt; = None;struct MyObject { // ...}impl MyObject { fn new() -&gt; MyObject { MyObject { // ... } }}fn get_instance() -&gt; &amp;'static MyObject { unsafe { if INSTANCE.is_none() { INSTANCE = Some(MyObject::new()); } &amp;INSTANCE.as_ref().unwrap() }}fn main() { let obj = get_instance(); // 使用obj对象}在这个示例中，我们使用static关键字定义了一个静态变量，然后在get_instance()函数中判断对象是否已经创建，如果没有则创建并将其存储在静态变量中，最后返回静态变量中保存的对象的引用。单例模式的应用场景单例模式在很多场景中都有用到，下面是一些常见的应用场景： 配置对象在很多系统中，需要读取配置文件或者从数据库中获取配置信息，这些信息通常只需要读取一次，因此可以使用单例模式来将这些配置信息保存在一个单例对象中，供整个系统使用。 数据库连接池在高并发的系统中，使用数据库连接池可以避免频繁地创建和销毁数据库连接，从而提高系统的性能。单例模式可以很好地支持数据库连接池，将所有的数据库连接对象保存在一个单例对象中，从而提高系统的效率。 缓存系统缓存系统通常需要维护大量的缓存对象，因此可以使用单例模式来将这些缓存对象保存在一个单例对象中，供整个系统使用。单例模式的最佳实践实现单例模式需要注意以下几点： 线程安全 在多线程环境下，需要保证单例对象的线程安全性。例如在懒汉式单例模式中，我们使用了Mutex来保证对象的线程安全。 避免重复创建 在实现饿汉式单例模式时，需要注意避免重复创建对象。在示例代码中，我们使用了unsafe关键字和Option类型来实现这个功能 避免内存泄漏 在使用单例模式时，需要注意避免内存泄漏。例如在懒汉式单例模式中，我们使用了Mutex来保证对象的安全性，但如果锁死了，就会出现内存泄漏的问题，因此需要特别注意这一点 模块化设计 在实现单例模式时，需要将其尽可能地和其他模块进行解耦，从而提高系统的可维护性和可扩展性。总结单例模式是一种常见的设计模式，在Rust中有很多种实现方式，例如懒汉式单例模式和饿汉式单例模式。单例模式适用于很多场景，例如配置对象、数据库连接池和缓存系统。在实现单例模式时，需要注意线程安全、避免重复创建、避免内存泄漏和模块化设计等几个方面。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 玩转“装饰器模式”",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 装饰器模式",
      "url"         : "./rust/2023/03/21/rust_lang_tutorial_303_patterns_Decorator.html",
      "date"        : "2023-03-21 00:00:00 +0800",
      "description" : "",
      "content"     : "装饰器模式（Decorator Pattern）是一种结构型设计模式，提供了一种动态地给对象添加功能的方式，比继承更加灵活。装饰器模式常用业务场景当需要给一个类添加额外的功能或者修改其原有的行为时，可以使用装饰器模式。典型的应用场景有： 日志记录：在不影响原有业务逻辑的情况下，记录对象的操作日志； 缓存：为一个类添加缓存机制，优化其性能； 认证：为一个类添加认证机制，限制访问权限； 数据验证：为一个类添加数据验证机制，确保存储的数据符合要求；装饰器模式应用场景示例下面通过一个订单管理系统的实例来说明装饰器模式在业务场景中的应用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859trait Order { fn get_price(&amp;self) -&gt; f64;}struct BaseOrder { price: f64,}impl BaseOrder { fn new(price: f64) -&gt; Self { Self { price } }}impl Order for BaseOrder { fn get_price(&amp;self) -&gt; f64 { self.price }}struct DiscountOrder&lt;'a&gt; { order: &amp;'a dyn Order, discount: f64,}impl&lt;'a&gt; DiscountOrder&lt;'a&gt; { fn new(order: &amp;'a dyn Order, discount: f64) -&gt; Self { Self { order, discount } }}impl&lt;'a&gt; Order for DiscountOrder&lt;'a&gt; { fn get_price(&amp;self) -&gt; f64 { self.order.get_price() * self.discount }}struct AddTaxOrder&lt;'a&gt; { order: &amp;'a dyn Order, tax: f64,}impl&lt;'a&gt; AddTaxOrder&lt;'a&gt; { fn new(order: &amp;'a dyn Order, tax: f64) -&gt; Self { Self { order, tax } }}impl&lt;'a&gt; Order for AddTaxOrder&lt;'a&gt; { fn get_price(&amp;self) -&gt; f64 { self.order.get_price() * (1.0 + self.tax) }}fn main() { let order = BaseOrder::new(100.0); let discount_order = DiscountOrder::new(&amp;order, 0.9); let tax_order = AddTaxOrder::new(&amp;discount_order, 0.1); println!(\"Order Price: {}\", tax_order.get_price());}在该实例中，BaseOrder是订单的基本类，它实现了Order trait，提供了一个get_price方法，返回订单的价格。DiscountOrder和AddTaxOrder是装饰器类，它们也实现了Order trait，并且拥有一个内部变量order，该变量指向被装饰的类。装饰器类在调用get_price方法时，会对被装饰的类的返回结果进行处理，并添加额外的业务逻辑。上述实例中，订单的价格为100元，按照9折优惠后再加上10%的税费，最终价格为99元。如果需要在原有逻辑的基础上添加其他业务逻辑，例如记录订单的日志、验证订单的数据合法性等，只需要增加一个装饰器类即可。装饰器模式保证了原有类的不变性，同时为类添加了灵活的功能扩展方式。装饰器模式进阶用法：嵌套装饰器在某些情况下，多个装饰器需要同时应用于一个类。这时候，就需要使用嵌套装饰器的方式。123456789101112131415161718192021222324252627282930313233343536373839404142struct AddFooterOrder&lt;'a&gt; { order: &amp;'a dyn Order, footer: String,}impl&lt;'a&gt; AddFooterOrder&lt;'a&gt; { fn new(order: &amp;'a dyn Order, footer: String) -&gt; Self { Self { order, footer } }}impl&lt;'a&gt; Order for AddFooterOrder&lt;'a&gt; { fn get_price(&amp;self) -&gt; f64 { self.order.get_price() }}struct AddHeaderOrder&lt;'a&gt; { order: &amp;'a dyn Order, header: String,}impl&lt;'a&gt; AddHeaderOrder&lt;'a&gt; { fn new(order: &amp;'a dyn Order, header: String) -&gt; Self { Self { order, header } }}impl&lt;'a&gt; Order for AddHeaderOrder&lt;'a&gt; { fn get_price(&amp;self) -&gt; f64 { self.order.get_price() }}fn main() { let order = BaseOrder::new(100.0); let discount_order = DiscountOrder::new(&amp;order, 0.9); let tax_order = AddTaxOrder::new(&amp;discount_order, 0.1); let header_order = AddHeaderOrder::new(&amp;tax_order, \"OrderHeader\".to_string()); let footer_order = AddFooterOrder::new(&amp;header_order, \"OrderFooter\".to_string()); println!(\"Order Price: {}\", footer_order.get_price());}在上述实例中，AddFooterOrder类为订单添加了页脚信息，AddHeaderOrder类为订单添加了页眉信息，使用嵌套装饰器的方式，同时应用两个装饰器，构成一个最终的订单类。装饰器模式最佳实践在使用装饰器模式时，需要注意以下几点： 装饰器类必须实现被装饰的类实现的所有接口； 装饰器类应当保证原有类的不变性； 装饰器类应当提供简洁的接口，避免使用者的接口复杂度过高。另外，在使用装饰器模式时，我们可以使用链式调用的方式，增加代码的可读性。12345678910111213141516171819202122232425262728293031323334353637383940trait OrderDecorate { fn discount(self, discount: f64) -&gt; DiscountOrder&lt;Self&gt; where Self: Sized, { DiscountOrder::new(&amp;self, discount) } fn add_tax(self, tax: f64) -&gt; AddTaxOrder&lt;Self&gt; where Self: Sized, { AddTaxOrder::new(&amp;self, tax) } fn add_header(self, header: String) -&gt; AddHeaderOrder&lt;Self&gt; where Self: Sized, { AddHeaderOrder::new(&amp;self, header) } fn add_footer(self, footer: String) -&gt; AddFooterOrder&lt;Self&gt; where Self: Sized, { AddFooterOrder::new(&amp;self, footer) }}impl&lt;T&gt; OrderDecorate for T where T: Order {}fn main() { let order = BaseOrder::new(100.0); let price = order .discount(0.9) .add_tax(0.1) .add_header(\"OrderHeader\".to_string()) .add_footer(\"OrderFooter\".to_string()) .get_price(); println!(\"Order Price: {}\", price);}在该实例中，我们给Order trait增加了一个OrderDecorate trait，其中提供了链式调用的四个装饰器方法。使用者可以通过简单的链式调用，快速地构建出自己所需要的订单类。总结在本文中，我们介绍了Rust语言中的装饰器模式，并且以订单管理系统为例，演示了装饰器模式在业务场景中的应用。我们还介绍了装饰器模式的嵌套用法和最佳实践。装饰器模式是一种很有用的模式，适用于需要灵活扩展功能的场景。在实践中，我们可以根据业务需求，结合链式调用、泛型等技术，进一步提高代码的可读性和可维护性。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 玩转“责任链路模式”",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 责任链路模式",
      "url"         : "./rust/2023/03/21/rust_lang_tutorial_302_patterns_Chain_Responsibility.html",
      "date"        : "2023-03-21 00:00:00 +0800",
      "description" : "",
      "content"     : "责任链路模式是一种行为性设计模式，主要用于将请求沿着一个链路传递，直到遇到能够处理请求的对象，从而实现请求与处理的解耦。在此过程中，每个对象都负责处理自己能够处理的部分，同时将不能处理的请求传递给下一个对象。在 Rust 中，责任链路模式常常用于处理复杂的业务流程，例如处理各种校验、授权、流程等操作。该模式的核心思想是将各个业务处理逐层封装，从而实现灵活的扩展和调整。责任链路模式示意图：graph LR; A[Request] --&gt; B[...Handler0] B --&gt; C[...Handler1] C --&gt; D[...Handler2] D --&gt; E[...Handler3] E --&gt; F[...Handler4]常用业务场景在实际应用中，责任链路模式可以应用于许多业务场景，以下列举一些常见的场景： 网络请求中的拦截、校验、鉴权等操作； 表单提交时的校验、转换等操作； 货币兑换过程中的汇率转换、手续费计算等操作； 业务审核流程中的审核、审批等操作。常见用法在 Rust 中，可以使用不同的方式来实现责任链模式。以下是两种常见用法：手动实现手动实现常常使用枚举（Enum）来实现链路的不同节点，如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859enum Request { Get, Post(String), Delete,}trait Handler { fn handle(&amp;mut self, req: Request);}struct GetHandler;struct PostHandler { next: Option&lt;Box&lt;dyn Handler&gt;&gt;,}struct DeleteHandler;impl Handler for GetHandler { fn handle(&amp;mut self, req: Request) { match req { Request::Get =&gt; println!(\"Handled GET request.\"), _ =&gt; println!(\"Failed to handle request.\"), } }}impl Handler for PostHandler { fn handle(&amp;mut self, req: Request) { match req { Request::Post(data) =&gt; println!(\"Handled POST request with data: {}\", data), _ =&gt; { if let Some(ref mut next) = self.next { next.handle(req); } else { println!(\"Failed to handle request.\"); } } } }}impl Handler for DeleteHandler { fn handle(&amp;mut self, req: Request) { match req { Request::Delete =&gt; println!(\"Handled DELETE request.\"), _ =&gt; println!(\"Failed to handle request.\"), } }}fn main() { let mut get_handler = GetHandler {}; let mut post_handler = PostHandler { next: Some(Box::new(DeleteHandler {})), }; get_handler.handle(Request::Get); post_handler.handle(Request::Post(\"Some data\".to_string())); post_handler.handle(Request::Delete);}使用框架支持在 Rust 普及程度日益增加的情况下，开发者愈发趋向于使用轻量级的框架支持。例如，可以使用 Actix-Web 框架来实现简单的责任链路模式：1234567891011121314151617use actix_web::{web, App, HttpServer, Responder};fn index(info: web::Path&lt;(String, u32)&gt;) -&gt; impl Responder { format!(\"Hello {}! id:{}\", info.0, info.1)}fn main() -&gt; std::io::Result&lt;()&gt; { HttpServer::new(|| { App::new() .service( web::resource(\"/{name}/{id}\") .route(web::get().to(index)), ) }) .bind(\"127.0.0.1:8080\")? .run()}进阶用法在实际的业务场景中，责任链路模式不仅仅只用于简单的校验、转换操作，还可以应用于更复杂的业务处理场景。以下是一些进阶用法：异步处理在 Rust 中，可以使用 async/await 和 tokio 等工具来实现异步处理。例如，以下代码片段展示了如何使用 async/await 和 tokio 实现异步处理：123456789101112131415161718192021222324use std::sync::Arc;use tokio::sync::oneshot;#[tokio::main]async fn main() { let (tx, mut rx) = oneshot::channel(); let mut handler = AsyncHandler {}; let request = Arc::new(Request::new()); async { handler.handle(request.clone()).await; tx.send(request).unwrap(); }.await; let result = rx.try_recv().unwrap();}struct AsyncHandler;impl AsyncHandler { pub async fn handle(&amp;mut self, req: Arc&lt;Request&gt;) { // async task }}处理链路的自动生成在实现业务处理链路时，往往需要定义大量的对象，从而使代码变得复杂而且难以维护。在 Rust 中，可以使用 RustAST 来生成处理链路的代码：123456789101112131415161718192021222324extern crate rustast;use rustast::generate_handler_chain;fn main() { let handler_chain = generate_handler_chain! { \"用户名校验\" =&gt; |req| -&gt; Result&lt;Request, UserError&gt; { // ... Ok(req) }, \"密码校验\" =&gt; |req| -&gt; Result&lt;Request, UserError&gt; { // ... Ok(req) }, \"权限校验\" =&gt; |req| -&gt; Result&lt;Request, UserError&gt; { // ... Ok(req) }, // ... }; handler_chain.handle(Request::new());}最佳实践以下是一些最佳实践： 对于处理顺序敏感的业务场景，应该明确定义每个处理节点的执行顺序； 应该根据具体情况决定何时使用手动实现或采用框架支持； 在使用框架支持时，应该遵从框架的约定，确保代码的可维护性和可扩展性； 在处理链路的设计过程中，应该考虑到应对错误情况的处理方式； 在异步处理方面，应该尽可能使用 Rust 内置的 Future 异步模型；总结责任链路模式是一种灵活的行为性设计模式，在 Rust 中有着广泛的应用场景。通过将请求沿着一个链路传递，责任链模式可以有效地降低业务处理的耦合度，提高代码的灵活性和可维护性。在 Rust 中，可以采用不同的方式来实现责任链模式，包括手动实现和框架支持。在这些实现方式之中，应该选择最适合实际应用场景的方式进行实现，以提高代码质量和可维护性。"
    } ,
  
    {
      "title"       : "Java修炼指南 - 抽象队列同步器(AQS)",
      "category"    : "",
      "tags"        : "Java, Java修炼指南, AQS",
      "url"         : "./java/2023/03/21/Java_AQS.html",
      "date"        : "2023-03-21 00:00:00 +0800",
      "description" : "",
      "content"     : ""
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 玩转“适配器模式”",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 适配器模式",
      "url"         : "./rust/2023/03/20/rust_lang_tutorial_301_patterns_Adapter.html",
      "date"        : "2023-03-20 00:00:00 +0800",
      "description" : "",
      "content"     : "适配器模式是一种结构型设计模式，它允许对象之间通过适配器进行交互。适配器是一个能够将不兼容接口转换为另一个接口的对象，它使得那些原本无法协同工作的类可以合作无间。Rust 是一门安全且高效的编程语言，它的类型系统和所有权模型极具优势。在实际应用中，我们经常会遇到需要整合不同接口或代码库的场景，适配器模式就显得尤为重要。在本文中，我们将介绍 Rust 中适配器模式的实现方法，并探讨其适用场景、高级应用、最佳实践等方面。常用业务场景以下是几种适配器模式常见的业务场景： 日志库整合 最常见的应该是就是rust标准库里面的log日志门面，将第三方日志模块实现转换为应用程序所期望的接口。提供统一的日志级别、日志格式等服务。 ORM框架 在实际应用中，我们有时需要连接多种不同的数据库。不同种类的数据库通常会有不同的 API 调用方式，这就需要对不同的数据库进行适配。适配器模式通过将不同数据库的接口统一，从而完成对各种数据库的统一调用。 数据格式转换 数据格式不同也是适配器模式的应用场景之一。例如我们要读取一个 XML 数据文件，然后将其转化为 JSON 格式。这时我们需要编写一个适配器，将 XML 解析器输出的结果转化为 JSON 格式。 新旧系统整合 在新旧系统整合的过程中，新旧系统使用的技术栈可能完全不同。比如新的系统可能使用了全新的框架，而旧的系统却是基于老旧的技术栈，这时就需要一个适配器来支持两个系统之间的交互。 基本用法在 Rust 中实现适配器模式，可以使用 trait 和 impl 实现。考虑下面这样一个例子，我们想要将一个 Vec&lt;usize&gt; 转化为一个 Vec&lt;String&gt;，并输出结果：12345fn main() { let nums: Vec&lt;usize&gt; = vec![1, 2, 3, 4, 5]; let strs: Vec&lt;String&gt; = nums.iter().map(|n| n.to_string()).collect(); println!(\"{:?}\", strs);}上述做法能够正确地将一个 Vec&lt;usize&gt; 转化为 Vec&lt;String&gt;，但是它只适用于两个类型之间的简单转换。如果我们需要在更复杂的场景下进行适配，那么就需要使用 trait 和 impl 来实现适配器。首先，我们需要定义适配器的接口，也就是一个 trait：123trait Adapter { fn convert(&amp;self) -&gt; String;}这里我们定义了一个 Adapter trait，用于进行适配操作。接下来，我们需要编写针对特定类型的适配器：123456789struct NumAdapter&lt;'a&gt; { nums: &amp;'a Vec&lt;usize&gt;,}impl&lt;'a&gt; Adapter for NumAdapter&lt;'a&gt; { fn convert(&amp;self) -&gt; String { self.nums.iter().map(|n| n.to_string()).collect::&lt;Vec&lt;String&gt;&gt;().join(\", \") }}在上述代码中，我们定义了一个 NumAdapter 类型，它接受一个 &amp;Vec&lt;usize&gt; 类型的参数，同时实现了 Adapter trait 中定义的 convert() 方法。这个方法将输入的 Vec&lt;usize&gt; 转化为一个字符串（用逗号分隔），并返回结果。现在我们可以使用适配器来将一个 Vec&lt;usize&gt; 对象转化为一个字符串了：12345678fn main() { let nums: Vec&lt;usize&gt; = vec![1, 2, 3, 4, 5]; let adapter = NumAdapter { nums: &amp;nums }; let result = adapter.convert(); println!(\"{}\", result);}// 输出结果：// 1, 2, 3, 4, 5这个例子中，我们充分利用了 Rust 的 trait 以及 impl 实现适配器模式。通过定义 trait 和实现 trait 的结构，我们允许不同的类型之间进行转换，并支持不同类型的自定义实现。适配器模式进阶用法适配器模式的高级应用包括：类适配器和对象适配器。类适配器使用 Rust 继承特性实现，允许 Adapter 类继承源类并实现 interface 接口。对象适配器使用 Rust 组合特性实现，允许 Adapter 类通过持有 Source 类的对象实现 interface 接口。类适配器类适配器使用 Rust 继承特性实现，允许 Adapter 类继承源类并实现 interface 接口。这种方法相对简单，但是限制了 Adapter 类的继承关系。在 Rust 中，我们可以使用 trait 继承其他 trait。考虑下面这样一个例子，我们定义了一个 Shape trait，用于表示图形的面积和周长：1234trait Shape { fn area(&amp;self) -&gt; f64; fn perimeter(&amp;self) -&gt; f64;}现在我们需要将一个圆形转化为一个矩形，那么我们就可以使用 Adapter 实现这个功能：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct Circle { radius: f64,}impl Shape for Circle { fn area(&amp;self) -&gt; f64 { std::f64::consts::PI * self.radius * self.radius } fn perimeter(&amp;self) -&gt; f64 { 2.0 * std::f64::consts::PI * self.radius }}struct Rectangle { width: f64, height: f64,}impl Shape for Rectangle { fn area(&amp;self) -&gt; f64 { self.width * self.height } fn perimeter(&amp;self) -&gt; f64 { 2.0 * (self.width + self.height) }}struct CircleAdapter { circle: Circle,}impl Shape for CircleAdapter { fn area(&amp;self) -&gt; f64 { let r = self.circle.radius; Rectangle { width: 2.0 * r, height: 2.0 * r, } .area() } fn perimeter(&amp;self) -&gt; f64 { let r = self.circle.radius; Rectangle { width: 2.0 * r, height: 2.0 * r, } .perimeter() }}在上述代码中，我们定义了三种类型，分别来表示图形接口、圆形和矩形。这两个具体类型都实现了 Shape trait，分别用于计算它们的面积和周长。接下来，我们定义了一个 CircleAdapter，用于将一个圆形适配成一个矩形。CircleAdapter 继承 Circle 类型，并实现了 Shape trait。它的实现方式是基于一个公式，使用一个具有相同面积和周长的矩形来模拟圆形。最后，我们可以测试一下这个类适配器是否可用：12345678910111213141516fn main() { let circle = Circle { radius: 2.0 }; println!(\"Circle area = {}\", circle.area()); println!(\"Circle perimeter = {}\", circle.perimeter()); let circle_adapter = CircleAdapter { circle }; println!(\"Adapted rectangle area = {}\", circle_adapter.area()); println!( \"Adapted rectangle perimeter = {}\", circle_adapter.perimeter() );}// 输出结果为：// Circle area = 12.566370614359172// Circle perimeter = 12.566370614359172// Adapted rectangle area = 16// Adapted rectangle perimeter = 16在这个例子中，我们使用了 Rust 的 trait 继承特性，定义了一个 CircleAdapter 类型，并将其适配为一个矩形。这种方法虽然相对简单，但是限制了 Adapter 类的继承关系。对象适配器对象适配器使用 Rust 组合特性实现，允许 Adapter 类通过持有 Source 类的对象实现 interface 接口。这种方法不限制 Adapter 类的继承关系，但是需要额外的结构体成员变量来保存源类对象的引用。我们依旧采用 Shape trait 为例来讲解对象适配器的实现方式。同样，我们定义一个 Shape trait：1234trait Shape { fn area(&amp;self) -&gt; f64; fn perimeter(&amp;self) -&gt; f64;}我们同时定义了一个 Rectangle 类型来表示矩形，还有一个 Circle 类型来表示圆形。接下来，我们需要编写一个 CircleAdapter 类型来将 Circle 类型适配成 Rectangle 类型：123456789101112131415struct CircleAdapter { circle: Circle,}impl Shape for CircleAdapter { fn area(&amp;self) -&gt; f64 { let r = self.circle.radius; Rectangle { width: 2.0 * r, height: 2.0 * r }.area() } fn perimeter(&amp;self) -&gt; f64 { let r = self.circle.radius; Rectangle { width: 2.0 * r, height: 2.0 * r }.perimeter() }}在上述代码中，我们定义了一个 CircleAdapter 结构体，并引入了 Circle 类型。通过组合的方式，我们将 Circle 类型与 Rectangle 类型适配起来。最后我们可以测试一下此处的适配器是否可用：12345678fn main() { let circle = Circle { radius: 2.0 }; println!(\"Circle area = {}\", circle.area()); println!(\"Circle perimeter = {}\", circle.perimeter()); let circle_adapter = CircleAdapter { circle }; println!(\"Adapted rectangle area = {}\", circle_adapter.area()); println!(\"Adapted rectangle perimeter = {}\", circle_adapter.perimeter());}在这个例子中，我们使用了 Rust 的组合特性，通过引入一个 Circle 对象，将其适配成 Rectangle 类型。这种方法不限制 Adapter 类的继承关系，但是需要额外的结构体成员变量来保存源类对象的引用。双向适配器适配器模式也可以实现双向适配器，这意味着两个系统之间都可以使用适配器。例如，如果两个系统之间需要进行双向数据交换，则可以编写一个适配器，将两个系统之间的数据转换为一种格式。123456789101112131415161718192021222324252627282930313233343536373839trait SystemA { fn method_a(&amp;self);}trait SystemB { fn method_b(&amp;self);}struct SystemAAdapter&lt;T: SystemB&gt; { system_b: T,}impl&lt;T: SystemB&gt; SystemAAdapter&lt;T&gt; { fn new(system_b: T) -&gt; Self { Self { system_b } }}impl&lt;T: SystemB&gt; SystemA for SystemAAdapter&lt;T&gt; { fn method_a(&amp;self) { self.system_b.method_b(); }}struct SystemBAdapter&lt;T: SystemA&gt; { system_a: T,}impl&lt;T: SystemA&gt; SystemBAdapter&lt;T&gt; { fn new(system_a: T) -&gt; Self { Self { system_a } }}impl&lt;T: SystemA&gt; SystemB for SystemBAdapter&lt;T&gt; { fn method_b(&amp;self) { self.system_a.method_a(); }}最佳实践在 Rust 中使用适配器模式时，可以参考以下几点最佳实践： 使用 trait 和 impl 实现适配器模式； 对于简单适配场景，可以使用适配器模式快速处理； 对于复杂的适配场景，可以选择类适配器或对象适配器； 对于对象适配器，需要额外的结构体成员变量来保存源类对象的引用。 使用泛型实现适配器。使用泛型可以实现更通用的适配器，并使代码更加灵活。 将适配器分离到单独的文件中。将适配器代码分离到单独的文件中可以提高代码的可读性和可维护性。结论适配器模式是一种强大的结构性设计模式，它可以帮助我们解决许多不同类型之间的接口问题。在 Rust 中，我们可以使用 trait 和 impl 实现适配器，也可以选择类适配器或对象适配器来适应不同的应用场景。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 玩转“策略模式”",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 策略模式",
      "url"         : "./rust/2023/03/20/rust_lang_tutorial_300_patterns_strategy.html",
      "date"        : "2023-03-20 00:00:00 +0800",
      "description" : "",
      "content"     : "策略模式是面向对象编程中的一种设计模式，在该模式中，算法可以被独立于使用它的客户端和变化。该模式通过定义一个算法族，分别封装起来，使得它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。在Rust中，策略模式可以用于替代函数指针的使用。在本文中，我们将通过讲解常用用法和示例，进阶用法，最佳实践等几个方面探讨Rust中的策略模式实践。常用用法和示例在Rust中，我们可以将策略模式应用于以下两种场景： 能够在运行时动态地选择实现的功能。 通过实现不同的功能来清晰地描述某种实体的不同行为。接下来，我们分别介绍这两种场景对应的示例。运行时动态选择实现的功能假设我们正在构建一个程序，该程序可以计算几个数字之间的最大值。然而，我们希望用户能够自由地选择用来计算最大值的算法。我们可以通过策略模式实现这一目标。首先，我们需要定义一个MaxStrategy trait，该trait定义了求最大值的方法：1234trait MaxStrategy { /// 求一组数字的最大值 fn find_max(&amp;self, nums: &amp;[i32]) -&gt; i32;}然后，我们可以实现几种不同的求最大值的算法，如下所示：12345678910111213141516171819202122// 使用快速排序求最大值struct QuickSortStrategy;impl MaxStrategy for QuickSortStrategy { fn find_max(&amp;self, nums: &amp;[i32]) -&gt; i32 { let mut nums = nums.to_vec(); nums.sort(); *nums.last().unwrap() }}// 使用选择排序求最大值struct SelectionSortStrategy;impl MaxStrategy for SelectionSortStrategy { fn find_max(&amp;self, nums: &amp;[i32]) -&gt; i32 { let mut nums = nums.to_vec(); for i in 0..nums.len() { let max_index = (i..nums.len()).max_by_key(|&amp;j| nums[j]).unwrap(); nums.swap(i, max_index); } *nums.last().unwrap() }}现在，我们可以编写一个程序，该程序允许用户选择在运行时使用哪种算法来计算最大值。实现如下：1234567891011121314151617181920212223fn main() { // 读取用户输入 let args: Vec&lt;String&gt; = std::env::args().collect(); if args.len() &lt; 2 { eprintln!(\"Usage: ./max &lt;strategy&gt;\"); std::process::exit(1); } // 根据用户输入选择算法 let strategy: Box&lt;dyn MaxStrategy&gt; = match args[1].as_str() { \"qs\" =&gt; Box::new(QuickSortStrategy), \"ss\" =&gt; Box::new(SelectionSortStrategy), _ =&gt; { eprintln!(\"Invalid strategy\"); std::process::exit(1); } }; // 读取一组数字，计算最大值 let nums: Vec&lt;i32&gt; = read_line().split_whitespace().map(|x| x.parse().unwrap()).collect(); let max = strategy.find_max(&amp;nums); println!(\"Max: {}\", max);}这个程序允许用户在运行时选择最大值的计算方法。用户可以执行以下命令来选择计算方法：./max qs 1 2 3 4 5该命令使用快速排序计算最大值。您也可以将qs替换为ss来使用选择排序。通过实现不同的功能来清晰地描述实体的不同行为假设我们正在为一个游戏编写一个AI模块，该模块可以让NPC根据当前情况进行不同的操作。在这个游戏中，有两种可供选择的操作：战斗和逃跑。我们可以通过策略模式实现这个AI。首先，我们需要定义一个CombatStrategy trait和一个FleeStrategy trait来描述战斗和逃跑的操作：1234567trait CombatStrategy { fn execute(&amp;self);}trait FleeStrategy { fn execute(&amp;self);}然后，我们可以实现不同的战斗和逃跑策略：123456789101112131415161718192021222324252627struct NormalAttackStrategy;impl CombatStrategy for NormalAttackStrategy { fn execute(&amp;self) { println!(\"Performing normal attack\"); }}struct HeavyAttackStrategy;impl CombatStrategy for HeavyAttackStrategy { fn execute(&amp;self) { println!(\"Performing heavy attack\"); }}struct RunAwayStrategy;impl FleeStrategy for RunAwayStrategy { fn execute(&amp;self) { println!(\"Running away\"); }}struct HideStrategy;impl FleeStrategy for HideStrategy { fn execute(&amp;self) { println!(\"Hiding\"); }}现在，我们可以实现一个AI结构体，该结构体包含了一个战斗策略和一个逃跑策略。这个AI结构体可以通过选择战斗和逃跑策略来适应不同的游戏情境：123456789101112131415161718192021struct AI&lt;T: CombatStrategy, U: FleeStrategy&gt; { combat_strategy: T, flee_strategy: U,}impl&lt;T: CombatStrategy, U: FleeStrategy&gt; AI&lt;T, U&gt; { fn new(combat_strategy: T, flee_strategy: U) -&gt; Self { Self { combat_strategy, flee_strategy, } } fn attack(&amp;self) { self.combat_strategy.execute(); } fn flee(&amp;self) { self.flee_strategy.execute(); }}现在，我们可以创建不同的AI实例，该实例可以根据当前情况执行不同的操作：12345678910fn main() { // 创建一个能够攻击并逃跑的AI let ai1 = AI::new(NormalAttackStrategy, RunAwayStrategy); ai1.attack(); ai1.flee(); // 创建一个能够进行重型攻击并隐藏的AI let ai2 = AI::new(HeavyAttackStrategy, HideStrategy); ai2.attack(); ai2.flee();}进阶用法在本节中，我们将介绍一些高级用法，以提高策略模式的可定制性和代码的重用性。使用associated type在Rust中，我们可以将associated type用于定义策略模式的实现。通过关联类型，我们可以让实现具有更高的灵活性（可以定义impl中的任何类型）。使用associated type，我们可以将上面的MaxStrategy trait改写成如下的形式：12345trait MaxStrategy { /// 计算一组数字的最大值 type Output; fn find_max(&amp;self, nums: &amp;[i32]) -&gt; Self::Output;}我们可以在每个实现中定义Associated Type的类型别名：12345678910111213141516171819202122struct QuickSortStrategy;impl MaxStrategy for QuickSortStrategy { type Output = i32; fn find_max(&amp;self, nums: &amp;[i32]) -&gt; Self::Output { let mut nums = nums.to_vec(); nums.sort(); *nums.last().unwrap() }}struct SelectionSortStrategy;impl MaxStrategy for SelectionSortStrategy { type Output = i32; fn find_max(&amp;self, nums: &amp;[i32]) -&gt; Self::Output { let mut nums = nums.to_vec(); for i in 0..nums.len() { let max_index = (i..nums.len()).max_by_key(|&amp;j| nums[j]).unwrap(); nums.swap(i, max_index); } *nums.last().unwrap() }}使用泛型Rust中的策略模式还可以使用泛型来提高代码的灵活性和可重用性。例如，在上面的战斗和逃跑的示例中，我们可以将AI结构体改写成以下的形式：123456789101112131415struct AI&lt;T&gt; { combat_strategy: T,}impl&lt;T: CombatStrategy&gt; AI&lt;T&gt; { fn new(combat_strategy: T) -&gt; Self { Self { combat_strategy, } } fn execute_strategy(&amp;self) { self.combat_strategy.execute(); }}现在，我们只需要一个CombatStrategy trait来定义所有的AI操作。这使得对于AI而言，战斗和逃跑等操作可以相互替换。最佳实践在使用策略模式时，为了实现代码的可维护性和可读性，需要遵循一些最佳实践： 将策略模式的变量作为trait对象使用，而不是作为struct实例使用。 提高使用associated type定义的trait的灵活性。 对于涉及到多个策略的情况，需要使用泛型。 对于每个策略，使用单独的模块定义该策略的实现，以提高代码的可维护性。 尽量避免过度使用策略模式。结论Rust中的策略模式是一种非常灵活和可定制的设计模式，可以用于在运行时动态地选择实现、或者通过实现不同的功能来清晰地描述某种实体的不同行为。在实现策略模式时，我们可以使用associated type和泛型来增强策略模式的可定制性和代码的重用性。如果你想将这些概念应用于实际项目中，请根据最佳实践编写代码，以提高代码的可读性和可维护性。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Trait 特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Trait",
      "url"         : "./rust/2023/03/20/rust_lang_tutorial_20_Trait.html",
      "date"        : "2023-03-20 00:00:00 +0800",
      "description" : "",
      "content"     : "在 Rust 中，Trait 是一种定义方法集合的机制。Trait 可以被用来定义一个或多个类型所共享的行为。Trait 与接口相似，但是 Trait 可以拥有默认实现，这使得 Trait 在 Rust 中的使用更加灵活。在本教程中，我们将使用一个 Animal 结构体来演示 Trait 的使用。Animal 结构体将被用于实现一些基本的动物行为，例如移动、发出声音等。 类似于Java语言中的interface, 但是用法又有些区别.Animal 结构体首先，我们需要定义 Animal 结构体。Animal 结构体将包含一些基本的属性和方法，例如 name、age、move_to 和 make_sound。123456789101112131415#[derive(Debug)]struct Animal { name: String, age: u8,}impl Animal { fn move_to(&amp;self, x: u8, y: u8) { println!(\"{} is moving to ({}, {})\", self.name, x, y); } fn make_sound(&amp;self) { println!(\"{} is making a sound\", self.name); }}在上面的代码中，我们定义了一个 Animal 结构体，该结构体包含了两个属性：name 和 age。我们还定义了两个方法：move_to 和 make_sound。move_to 方法接受两个参数，x 和 y，用于指定 Animal 的目标位置。make_sound 方法不接受任何参数，用于让 Animal 发出声音。现在，我们可以创建一个 Animal 的实例，并调用 move_to 和 make_sound 方法：12345fn main() { let animal = Animal { name: String::from(\"Tiger\"), age: 3 }; animal.move_to(10, 20); animal.make_sound();}上面的代码将创建一个名为 Tiger 的 Animal 实例，年龄为 3 岁。我们随后调用了该实例的 move_to 和 make_sound 方法。使用 Trait 实现 Animal 行为现在，我们将使用 Trait 来实现 Animal 的行为。我们将定义一个叫做 AnimalBehavior 的 Trait，该 Trait 包含了 Animal 所需的所有方法。然后，我们将让 Animal 结构体实现 AnimalBehavior Trait。1234trait AnimalBehavior { fn move_to(&amp;self, x: u8, y: u8); fn make_sound(&amp;self);}在上面的代码中，我们定义了一个 AnimalBehavior Trait，该 Trait 包含了两个方法：move_to 和 make_sound。这两个方法与我们之前定义的 Animal 结构体中的方法完全相同。现在，我们将让 Animal 结构体实现 AnimalBehavior Trait：123456789impl AnimalBehavior for Animal { fn move_to(&amp;self, x: u8, y: u8) { println!(\"{} is moving to ({}, {})\", self.name, x, y); } fn make_sound(&amp;self) { println!(\"{} is making a sound\", self.name); }}在上面的代码中，我们使用 impl 关键字来实现 AnimalBehavior Trait。我们将 AnimalBehavior Trait 的方法与 Animal 结构体中的方法进行了匹配。现在，Animal 结构体可以被视为实现了 AnimalBehavior Trait。现在，我们可以创建一个 Animal 实例，并将其视为 AnimalBehavior Trait 的实现。然后，我们可以调用 AnimalBehavior Trait 中定义的方法：123456789101112fn main() { let animal = Animal { name: String::from(\"Tiger\"), age: 3, }; let animal_behavior: &amp;dyn AnimalBehavior = &amp;animal; animal_behavior.move_to(10, 20); animal_behavior.make_sound();}// 输出结果:// Tiger is moving to (10, 20)// Tiger is making a sound在上面的代码中，我们创建了一个 Animal 实例，并将其视为 AnimalBehavior Trait 的实现。我们还定义了一个名为 animal_behavior 的变量，该变量是一个指向 AnimalBehavior Trait 的引用。最后，我们调用了 animal_behavior 的 move_to 和 make_sound 方法。Trait 的默认实现Trait 可以包含默认实现。这意味着 Trait 的方法可以被实现，但是如果实现没有提供自己的实现，Trait 的默认实现将被使用。在下面的代码中，我们将为 AnimalBehavior Trait 添加一个默认实现：12345678910111213trait AnimalBehavior { fn move_to(&amp;self, x: u8, y: u8) { println!(\"{} is moving to ({}, {})\", self.name, x, y); } fn make_sound(&amp;self) { println!(\"{} is making a sound\", self.name); } fn eat(&amp;self) { println!(\"{} is eating\", self.name); }}在上面的代码中，我们为 AnimalBehavior Trait 添加了一个新的方法 eat，并为 move_to 和 make_sound 方法提供了默认实现。现在，Animal 结构体可以选择实现 eat 方法，但是如果没有提供自己的实现，Trait 的默认实现将被使用。现在，我们可以创建一个 Animal 实例，并将其视为 AnimalBehavior Trait 的实现。然后，我们可以调用 AnimalBehavior Trait 中定义的方法，包括 eat 方法：12345678910fn main() { let animal = Animal { name: String::from(\"Tiger\"), age: 3, }; let animal_behavior: &amp;dyn AnimalBehavior = &amp;animal; animal_behavior.move_to(10, 20); animal_behavior.make_sound(); animal_behavior.eat();}在上面的代码中，我们创建了一个 Animal 实例，并将其视为 AnimalBehavior Trait 的实现。我们还定义了一个名为 animal_behavior 的变量，该变量是一个指向 AnimalBehavior Trait 的引用。最后，我们调用了 animal_behavior 的 move_to、make_sound 和 eat 方法。由于 Animal 结构体没有提供自己的 eat 方法实现，Trait 的默认实现将被使用。Trait 的泛型Trait 可以与泛型一起使用。这意味着 Trait 可以被用于定义多个类型所共享的行为，而不是只能用于单个类型。在下面的代码中，我们将为 AnimalBehavior Trait 添加一个泛型类型 T。这意味着 AnimalBehavior Trait 的方法可以被用于任何类型 T：12345trait AnimalBehavior&lt;T&gt; { fn move_to(&amp;self, x: u8, y: u8); fn make_sound(&amp;self); fn eat(&amp;self, food: T);}在上面的代码中，我们为 AnimalBehavior Trait 添加了一个泛型类型 T，并为 move_to 和 make_sound 方法提供了默认实现。我们还添加了一个新的方法 eat，该方法接受一个类型为 T 的参数 food。现在，我们可以创建一个 Animal 实例，并将其视为 AnimalBehavior Trait 的实现。我们还可以创建一个名为 food 的变量，并将其传递给 AnimalBehavior Trait 中的 eat 方法：1234567891011fn main() { let animal = Animal { name: String::from(\"Tiger\"), age: 3, }; let animal_behavior: &amp;dyn AnimalBehavior&lt;&amp;str&gt; = &amp;animal; let food = \"meat\"; animal_behavior.move_to(10, 20); animal_behavior.make_sound(); animal_behavior.eat(food);}在上面的代码中，我们创建了一个 Animal 实例，并将其视为 AnimalBehavior Trait 的实现。我们还定义了一个名为 animal_behavior 的变量，该变量是一个指向 AnimalBehavior Trait 的引用，并使用 &amp;str 类型作为泛型参数。最后，我们创建了一个名为 food 的变量，并将其传递给 animal_behavior 的 eat 方法。Trait 的 where 子句Trait 可以包含 where 子句，该子句可以用于限制泛型类型的范围。where 子句通常用于限制泛型类型必须实现的 Trait。在下面的代码中，我们将为 AnimalBehavior Trait 添加一个 where 子句，该子句要求泛型类型必须实现 Display Trait：12345678910use std::fmt::Display;trait AnimalBehavior&lt;T&gt;where T: Display,{ fn move_to(&amp;self, x: u8, y: u8); fn make_sound(&amp;self); fn eat(&amp;self, food: T);}在上面的代码中，我们为 AnimalBehavior Trait 添加了一个 where 子句，该子句要求泛型类型必须实现 Display Trait。这意味着我们可以在 AnimalBehavior Trait 的 eat 方法中使用 T 类型的 to_string 方法。现在，我们可以创建一个 Animal 实例，并将其视为 AnimalBehavior Trait 的实现。我们还可以创建一个名为 food 的变量，并将其传递给 AnimalBehavior Trait 中的 eat 方法：1234567891011fn main() { let animal = Animal { name: String::from(\"Tiger\"), age: 3, }; let animal_behavior: &amp;dyn AnimalBehavior&lt;String&gt; = &amp;animal; let food = String::from(\"meat\"); animal_behavior.move_to(10, 20); animal_behavior.make_sound(); animal_behavior.eat(food);}在上面的代码中，我们创建了一个 Animal 实例，并将其视为 AnimalBehavior Trait 的实现。我们还定义了一个名为 animal_behavior 的变量，该变量是一个指向 AnimalBehavior Trait 的引用，并使用 String 类型作为泛型参数。最后，我们创建了一个名为 food 的变量，并将其传递给 animal_behavior 的 eat 方法。Trait 的继承Trait 可以继承其他 Trait。这意味着一个 Trait 可以从另一个 Trait 继承方法。在下面的代码中，我们将为 AnimalBehavior Trait 添加一个继承自 Clone Trait 的子 Trait，称为 CloneAnimalBehavior Trait：123456trait CloneAnimalBehavior&lt;T&gt;: AnimalBehavior&lt;T&gt; + Clonewhere T: Display + Clone,{ fn clone_animal(&amp;self) -&gt; Self;}在上面的代码中，我们定义了一个 CloneAnimalBehavior Trait，该 Trait 继承自 AnimalBehavior Trait 和 Clone Trait。我们还为 CloneAnimalBehavior Trait 添加了一个新的方法 clone_animal，该方法返回一个 Self 类型的实例。现在，我们可以让 Animal 结构体实现 CloneAnimalBehavior Trait：1234567891011impl&lt;T&gt; CloneAnimalBehavior&lt;T&gt; for Animalwhere T: Display + Clone,{ fn clone_animal(&amp;self) -&gt; Self { Animal { name: self.name.clone(), age: self.age.clone(), } }}在上面的代码中，我们使用 impl 关键字为 Animal 结构体实现 CloneAnimalBehavior Trait。我们为 clone_animal 方法提供了自己的实现，该方法返回一个 Animal 结构体的克隆实例。现在，我们可以创建一个 Animal 实例，并将其视为 CloneAnimalBehavior Trait 的实现。然后，我们可以调用 CloneAnimalBehavior Trait 中定义的方法：123456789101112fn main() { let animal = Animal { name: String::from(\"Tiger\"), age: 3, }; let clone_animal_behavior: &amp;dyn CloneAnimalBehavior&lt;String&gt; = &amp;animal; let cloned_animal = clone_animal_behavior.clone_animal(); println!( \"Cloned animal name: {}, age: {}\", cloned_animal.name, cloned_animal.age );}在上面的代码中，我们创建了一个 Animal 实例，并将其视为 CloneAnimalBehavior Trait 的实现。我们还定义了一个名为 clone_animal_behavior 的变量，该变量是一个指向 CloneAnimalBehavior Trait 的引用，并使用 String 类型作为泛型参数。最后，我们调用了 clone_animal_behavior 的 clone_animal 方法，并打印了克隆后的 Animal 实例的 name 和 age 属性。总结在本教程中，我们学习了如何使用 Trait 来定义方法集合，并将其用于实现 Animal 的行为。我们还学习了如何使用 Trait 的默认实现、泛型、where 子句和继承。Trait 是 Rust 中非常重要的机制，它可以使代码更加灵活和可复用。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Rust反射实战",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 反射",
      "url"         : "./rust/2023/03/20/rust_lang_tutorial_107_reflect.html",
      "date"        : "2023-03-20 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust语言的反射机制指的是在程序运行时获取类型信息、变量信息等的能力。Rust语言中的反射机制主要通过Any实现。std::any::Any traitAny trait是所有类型的超级trait，它定义了一些通用的方法，可以对任意类型的值进行操作。例如，可以使用Any trait的type_id方法获取一个值的类型ID：123456789101112131415use std::any::Any;fn main() { let a = 1; let b = \"hello\"; let c = true; println!(\"a's type id: {:?}\", a.type_id()); println!(\"b's type id: {:?}\", b.type_id()); println!(\"c's type id: {:?}\", c.type_id());}// 输出结果为：// a's type id: TypeId { t: 3735189839305137790 }// b's type id: TypeId { t: 17258340640123294832 }// c's type id: TypeId { t: 11046744883169582909 }可以看到，每个类型都有一个唯一的类型ID，可以用来判断两个值的类型是否相同。std::any::TypeIdTypeId是Rust中的一种类型，它被用来表示某个类型的唯一标识。type_id(&amp;self)这个方法返回变量的TypeId。is()方法则用来判断某个函数的类型。1234567891011121314151617use std::any::Any; fn is_string(s: &amp;dyn Any) { if s.is::&lt;String&gt;() { println!(\"It's a string!\"); } else { println!(\"Not a string...\"); }} fn main() { is_string(&amp;0); is_string(&amp;\"Tom\".to_string());}// 输出结果为：// Not a string...// It's a string!可以使用type_name方法获取一个类型的名称：12345678910111213141516use std::any::Any;use std::any::TypeId;fn main() { let a = 1; let b = \"hello\"; let c = true; println!(\"a's type name: {:?}\", std::any::type_name::&lt;i32&gt;()); println!(\"b's type name: {:?}\", std::any::type_name::&lt;&amp;str&gt;()); println!(\"c's type name: {:?}\", std::any::type_name::&lt;bool&gt;());}// 输出结果为：// a's type name: \"i32\"// b's type name: \"&amp;str\"// c's type name: \"bool\"可以看到，每个类型都有一个名称，可以用来表示该类型的具体含义。尽量避免使用typeName去做逻辑判断，因为typeName可以重复，应该尽可能使用TypeId来判断。反射的基本用法在Rust语言中，在某些场景下，需要在运行时才能确定变量的具体类型。在 Rust 中可以使用反射来进行类型检查。具体来说，可以通过Any trait将一个值转换为&amp;Any类型的引用，然后使用TypeId获取该值的类型信息。以下是一个示例代码：1234567891011121314151617181920212223use std::any::Any;use std::any::TypeId;fn main() { let x = vec![1, 2, 3]; let y = vec![\"a\", \"b\", \"c\"]; print_type(&amp;x); print_type(&amp;y);}fn print_type&lt;T: Any&gt;(val: &amp;T) { let v_any = val as &amp;dyn Any; if let Some(_) = v_any.downcast_ref::&lt;Vec&lt;i32&gt;&gt;() { println!(\"Type: Vec&lt;i32&gt;\"); } else if let Some(_) = v_any.downcast_ref::&lt;Vec&lt;&amp;str&gt;&gt;() { println!(\"Type: Vec&lt;&amp;str&gt;\"); } else { println!(\"Unknown Type\"); }}// 输出结果为：// Type: Vec&lt;i32&gt;// Type: Vec&lt;&amp;str&gt;可以看到，使用Any trait和TypeId可以打印输出了两个向量的类型信息。反射的高级应用在Rust语言中，反射机制还可以用于实现一些高级的功能，例如动态调用函数、序列化和反序列化、动态创建对象等。下面将分别介绍这些应用的具体实现方法。动态调用函数在Rust语言中，可以使用反射机制动态调用函数。具体来说，可以使用std::mem::transmute函数将函数指针转换为一个通用的函数指针，然后使用该指针调用函数。例如，可以定义一个函数指针类型FnPtr，然后将其转换为一个通用的函数指针类型*const u8，最后使用std::mem::transmute函数将其转换为一个具体的函数指针类型，然后调用该函数。例如：123456789101112131415use std::mem::transmute;fn add(a: i32, b: i32) -&gt; i32 { a + b}fn main() { let add_ptr = add as *const u8; let add_fn: fn(i32, i32) -&gt; i32 = unsafe { transmute(add_ptr) }; let result = add_fn(1, 2); println!(\"result: {}\", result);}// 输出结果为：// result: 3可以看到，使用反射机制可以动态调用函数。序列化和反序列化在Rust语言中，可以使用反射机制实现序列化和反序列化。具体来说，可以使用serde库，该库提供了一系列的宏和trait，可以将一个类型转换为一个字符串或字节数组，也可以将一个字符串或字节数组转换为一个类型。例如，可以定义一个结构体Person，然后使用serde库的Serialize和Deserialize trait实现该结构体的序列化和反序列化。首先，在Cargo.toml中添加serde依赖。12serde = { version = \"1.0\", features = [\"derive\"] }serde_json = \"1.0\"下面示例代理：123456789101112131415161718192021222324use serde::{Serialize, Deserialize};use serde_json::{Result, Value};#[derive(Clone, Serialize, Deserialize, Debug)]struct Person { name: String, age: i32,}fn main() { let person = Person { name: \"Alice\".to_string(), age: 20, }; let json = serde_json::to_string(&amp;person).unwrap(); println!(\"json: {}\", json); let person2: Person = serde_json::from_str(&amp;json).unwrap(); println!(\"person2: {:?}\", person2);}// 输出结果为：// json: {\"name\":\"Alice\",\"age\":20}// person2: Person { name: \"Alice\", age: 20 }可以看到，使用反射机制可以实现结构体的序列化和反序列化。动态创建对象在Rust语言中，可以使用反射机制动态创建对象。具体来说，可以使用std::mem::size_of函数获取一个类型的大小，然后使用std::alloc::alloc函数在堆上分配一块内存，最后使用std::mem::transmute函数将该内存转换为一个具体的对象。例如，可以定义一个结构体Person，然后使用反射机制动态创建该结构体的实例。例如：12345678910111213141516171819202122use std::mem::{size_of, transmute};use std::alloc::alloc;use std::alloc::Layout;#[derive(Debug)]struct Person { name: String, age: i32,}fn main() { let size = size_of::&lt;Person&gt;(); let ptr = unsafe { alloc(Layout::from_size_align(size, 1024).unwrap()) }; let person: &amp;mut Person = unsafe { transmute(ptr) }; person.name = \"Alice\".to_string(); person.age = 20; println!(\"person: {:?}\", person);}// 输出结果为：// person: Person { name: \"Alice\", age: 20 }可以看到，使用反射机制可以动态创建对象。扩展阅读 - bevy_reflect模块bevy_reflect 是一个Rust语言的工具库，提供了元编程（meta-programming）中非常有用的反射（reflection）功能。反射是指在程序运行时，能够动态地获取一个对象的各种信息，例如类型、结构体字段等。bevy_reflect 提供的反射功能可以让我们更加方便地读取和修改对象的属性，为开发高效、灵活的程序提供了支持。总结本教程介绍了Rust语言中的反射机制，包括基本概念、使用方法、高级应用等方面的内容。通过学习本教程，读者可以了解Rust语言中反射机制的基本原理和具体实现方法，掌握反射机制的高级应用，为实际开发中的需求提供参考。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Thread 线程",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, 线程, Thread",
      "url"         : "./rust/2023/03/20/rust_lang_tutorial_106_thread.html",
      "date"        : "2023-03-20 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust是一种强类型、高性能的系统编程语言，其官方文档中强调了Rust的标准库具有良好的并发编程支持。Thread是Rust中的一种并发编程方式，本文将介绍Rust中thread的相关概念、方法和字段。我们将从以下几个方面进行讲解： 线程的基本概念和使用方法 线程的字段和方法 常用用法和示例 进阶用法：多线程协作和锁 最佳实践：安全地使用Thread线程的基本概念和使用方法Thread是Rust中并发编程的一种基本方式。Rust中的Thread使用标准库中的std::thread::Thread结构体表示。我们可以通过下面的代码来创建一个Thread：1234567use std::thread;fn main() { let handle = thread::spawn(|| { // 子线程执行的代码 });}其中的||表示闭包，该闭包中的代码将在子线程中执行。调用thread::spawn方法会返回一个Result，该Result包含一个智能指针，该智能指针拥有对线程的所有权，如果线程执行成功则返回Ok，否则返回Err。通过这个智能指针我们可以管理线程的生命周期和操作线程。当线程中的代码执行完毕时，我们可以使用以下代码将线程加入主线程：1handle.join().expect(\"执行失败\");Thread也支持通过std::thread::Builder结构体进行创建，Builder提供了一些线程的配置项，如线程名字、线程优先级、栈大小等。12345678use std::thread;fn main() { let builder = thread::Builder::new().name(\"my_thread\".into()); let handle = builder.spawn(|| { // 子线程执行的代码 });}线程的字段和方法Thread结构体中提供了一些有用的字段和方法。线程名称Rust中的Thread对象有一个名称属性，可以通过thread::current()函数获取当前线程的名称，也可以通过std::thread::Builder结构体设置线程的名称。123456789101112131415161718use std::thread;fn main() { let thr0 = thread::current(); let thread_name = thr0.name().unwrap_or(\"unknown\"); println!(\"当前线程的名称：{}\", thread_name); let builder = thread::Builder::new().name(\"my_thread\".into()); let handle = builder.spawn(move || { let thr = thread::current(); let name = thr.name().unwrap_or(\"unknown\"); println!(\"当前线程的名称：{}\", name); }); handle.expect(\"执行失败\").join().unwrap();}// 输出结果：// 当前线程的名称：main// 当前线程的名称：my_thread线程idRust中的Thread对象还有一个id属性，可以通过thread::current()函数获取当前线程的id，也可以通过std::thread::Builder结构体设置线程的id。12345678910111213141516use std::thread;fn main() { let thread_id = thread::current().id(); println!(\"当前线程的id：{:?}\", thread_id); let builder = thread::Builder::new().name(\"my_thread\".into()); let handle = builder.spawn(|| { let id = thread::current().id(); println!(\"当前线程的id：{:?}\", id); }); handle.expect(\"执行失败\").join().unwrap();}// 输出结果：// 当前线程的id：ThreadId(1)// 当前线程的id：ThreadId(2)线程休眠Rust中Thread对象提供了一个sleep方法，用于让线程休眠指定时间。12345678910use std::{thread, time};fn main() { println!(\"线程休眠前：{:?}\", time::Instant::now()); thread::sleep(time::Duration::from_secs(2)); println!(\"线程休眠后：{:?}\", time::Instant::now());}// 输出结果：// 线程休眠前：Instant { tv_sec: 9667960, tv_nsec: 471430161 }// 线程休眠后：Instant { tv_sec: 9667962, tv_nsec: 471515229 }线程状态Rust中Thread对象表示的是系统中的一个线程，可以通过thread::JoinHandle结构体的is_finalized()和thread::Thread的panicking()方法来查看线程是否结束和是否因panic而结束。123456789101112131415use std::thread;fn main() { let handle = thread::spawn(|| { // TODO: 执行耗费时间的任务 }); while !handle.is_finished() { thread::sleep_ms(100); } if thread::panicking() { println!(\"线程因panic而结束\"); } else { println!(\"线程正常结束\"); }}常用用法和示例单线程执行我们可以使用Thread开启一个单线程，并在该线程中执行我们的代码。当该线程执行完毕后，我们通过JoinHandle.join()方法将该线程加入主线程。123456789use std::thread;fn main() { let handle = thread::spawn(|| { println!(\"Hello Thread!\"); }); handle.join().unwrap();}多线程执行我们可以使用多个Thread对象并行地执行任务，实现多线程编程。1234567891011121314151617use std::thread;fn main() { let handle1 = thread::spawn(|| { for i in 0..5 { println!(\"Thread1: {}\", i); } }); let handle2 = thread::spawn(|| { for i in 0..5 { println!(\"Thread2: {}\", i); } }); handle1.join().unwrap(); handle2.join().unwrap();}线程间通信Rust中线程间通信可以通过channel实现。在以下例子中，我们开启两个线程，一个线程向channel发送数据，另一个线程从channel接收数据。两个线程可以通过channel实现数据共享和交换。12345678910111213141516use std::thread;use std::sync::mpsc;fn main() { let (tx, rx) = mpsc::channel(); let handle1 = thread::spawn(move || { tx.send(\"Hello Thread!\".to_string()).unwrap(); }); let handle2 = thread::spawn(move || { let msg = rx.recv().unwrap(); println!(\"{}\", msg); }); handle1.join().unwrap(); handle2.join().unwrap();}进阶用法：多线程协作和锁多线程协作当线程之间需要协作执行任务时，我们可以通过Rust中提供的互斥锁Mutex和读写锁RwLock来实现。以下是一个简单的例子，在这个例子中我们开启两个线程，一个线程向共享变量加1，另一个线程向共享变量减1。由于有两个线程同时修改共享变量，我们需要使用Mutex来进行加锁和解锁操作。1234567891011121314151617181920212223242526use std::sync::{Arc, Mutex};use std::thread;fn main() { let shared_count = Arc::new(Mutex::new(0)); let thread1 = shared_count.clone(); let handle1 = thread::spawn(move || { for _ in 0..10 { let mut count = thread1.lock().unwrap(); *count += 1; } }); let thread2 = shared_count.clone(); let handle2 = thread::spawn(move || { for _ in 0..10 { let mut count = thread2.lock().unwrap(); *count -= 1; } }); handle1.join().unwrap(); handle2.join().unwrap(); println!(\"shared_count: {:?}\", *shared_count.lock().unwrap());}// 输出结果：// shared_count: 0锁在多线程编程中，锁是一种常见的同步机制，它用于保护共享数据不受到并发访问的影响。Rust标准库中提供了锁的实现Mutex、RwLock、Barrier、Condvar等等。MutexMutex是Rust中最基本的锁机制，它提供了互斥访问的机制。当多个线程同时对一个共享资源进行访问时，Mutex会对该资源进行加锁，当一个线程访问该资源时，其他线程无法访问该资源，直到该线程解锁该资源。1234567891011121314151617181920212223242526use std::sync::{Arc, Mutex};use std::thread;fn main() { let shared_data = Arc::new(Mutex::new(0)); let thread1 = shared_data.clone(); let handle1 = thread::spawn(move || { for _ in 0..10 { let mut data = thread1.lock().unwrap(); *data += 1; } }); let thread2 = shared_data.clone(); let handle2 = thread::spawn(move || { for _ in 0..10 { let mut data = thread2.lock().unwrap(); *data -= 1; } }); handle1.join().unwrap(); handle2.join().unwrap(); println!(\"shared_data: {:?}\", *shared_data.lock().unwrap());}// 输出结果：// shared_data: 0RwLockRwLock是一种读写锁，它提供了两种访问方式：读取访问和写入访问，当同时有多个读操作时，RwLock会共享锁，允许多个线程同时访问该数据，当进行写操作时，RwLock会对该数据进行排它锁，只允许一个线程进行访问。123456789101112131415161718192021222324252627282930313233343536use std::sync::{Arc, RwLock};use std::thread;fn main() { let shared_data = Arc::new(RwLock::new(0)); let thread1 = shared_data.clone(); let handle1 = thread::spawn(move || { for _ in 0..10 { let mut data = thread1.write().unwrap(); *data += 1; } }); let thread2 = shared_data.clone(); let handle2 = thread::spawn(move || { for _ in 0..10 { let data = thread2.read().unwrap(); println!(\"data: {:?}\", *data); } }); handle1.join().unwrap(); handle2.join().unwrap(); println!(\"shared_data: {:?}\", *shared_data.read().unwrap());}// 输出结果：// data: 10// data: 10// data: 10// data: 10// data: 10// data: 10// data: 10// data: 10// data: 10// data: 10// shared_data: 10RwLock还提供了一个try_read()方法，可以进行非阻塞式的读操作。BarrierBarrier是一种同步机制，它提供了一个点，当多个线程只有在该点处到达才能继续执行。Barrier有一个计数器，当计数器到达值N时，所有在该Barrier处等待的线程可以继续执行。12345678910111213141516171819202122232425use std::sync::{Arc, Barrier};use std::thread;fn main() { let barrier = Arc::new(Barrier::new(3)); let thread1 = barrier.clone(); let handle1 = thread::spawn(move || { println!(\"Thread1 step1.\"); thread1.wait(); println!(\"Thread1 step2.\"); }); let thread2 = barrier.clone(); let handle2 = thread::spawn(move || { println!(\"Thread2 step1.\"); thread2.wait(); println!(\"Thread2 step2.\"); }); handle1.join().unwrap(); handle2.join().unwrap();}// 输出结果：// Thread1 step1.// Thread2 step1.// ERROR Timeout最佳实践：安全地使用Thread在使用Thread进行多线程编程时，为了保证线程安全，我们需要注意以下几点： 在多线程程序中避免使用静态变量，单例模式和全局变量，这些变量可能被多个线程同时访问。 在多线程编程中，一定要避免使用裸指针和内存共享，这种方式可能导致数据竞争和未定义行为。 使用Rust的锁机制Mutex和RwLock等，保证共享数据的线程安全性。 编写多线程程序时，应该考虑线程池的设计，防止创建过多的线程带来的资源错乱和性能损失。 多线程程序的并发度一定要注意控制，过高的并发度反而会导致性能下降。以上都是在使用Thread时应该注意的一些安全问题，遵循这些原则可以提高多线程程序的可维护性和安全性。总结本章节通过代码示例深入的探讨了Rust中thread的线程的基本概念，线程的字段和方法，常用用法和示例，多线程协作和锁以及thread最佳实践经验。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Any 特征",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Any, 特征",
      "url"         : "./rust/2023/03/20/rust_lang_tutorial_105_Any_Trait.html",
      "date"        : "2023-03-20 00:00:00 +0800",
      "description" : "",
      "content"     : "在Rust中，Any trait表示任何类型的值，也就是说，Any trait是Rust中最抽象的类型之一。如果你有任何需要操作不确定类型的值的需求，可能就需要使用到Any trait。Any trait定义在std::any模块中，它是一个标准库中的trait，可以在任何Rust程序中使用，无需先进行导入。在Rust中，任何类型都实现了Any trait，也就是说，每个Rust值都可以转换为Any trait。通过这种方式，你可以把这个值当作任何类型来处理。例如：123456789101112use std::any::Any;fn main() { let x: i32 = 42; let any_x = &amp;x as &amp;dyn Any; match any_x.downcast_ref::&lt;i32&gt;() { Some(i) =&gt; println!(\"Matched i32 value: {}\", i), None =&gt; println!(\"Failed to match i32 value\"), }}// 输出结果：// Matched i32 value: 42在上面的示例中，我们定义了一个i32类型的变量x，然后我们通过将其引用作为Any trait的引用，创建了一个任意类型的值any_x。接着我们使用downcast_ref方法尝试将any_x转换成i32类型。如果转换成功，我们就打印匹配到的i32值；否则，我们将打印失败信息。Any trait的内部方法和属性Any trait还有一些内部方法和属性，它们可以观察和操作Any trait表示的值，包括type_id、downcast_ref、downcast_mut和is方法。type_id方法type_id方法返回一个TypeId类型的值，表示Any trait表示的值的类型信息。TypeId是一个Rust标准库中的类型，它可以用来检查两个类型是否相同，例如，在某些情况下，我们可能需要检查函数的参数类型和返回值类型是否相同。例如：123456789101112use std::any::{Any, TypeId};fn foo&lt;T: Any&gt;(x: &amp;T) -&gt; bool { let type_id = TypeId::of::&lt;T&gt;(); let any_type_id = x.type_id(); type_id == any_type_id}fn main() { let x: i32 = 42; assert!(foo(&amp;x));}在上面的示例中，我们定义了一个泛型函数foo，它接受一个实现了Any trait的引用，并返回一个bool值，表示这个引用表示的值的类型是否和函数泛型类型参数T的类型相同。为了实现这个函数，我们首先获取了T的类型信息type_id，然后使用type_id方法获取Any trait表示的值的类型信息any_type_id。最后，我们比较这两个值是否相同。downcast_ref方法downcast_ref方法尝试将Any trait表示的值转换成指定的类型的引用。如果转换成功，它将返回一个引用；否则，它将返回None。downcast_ref和downcast_mut方法都要求Any trait表示的值的类型实现了static生命周期（即，is ‘static）。这是因为这些方法返回的引用或可变引用的生命周期是 ‘static 类型，它们比任何短生命周期都要长，所以Any trait表示的值必须保证足够长的生命周期。例如：12345678use std::any::{Any, TypeId};fn main() { let x: i32 = 42; let any_x = &amp;x as &amp;dyn Any; let y = any_x.downcast_ref::&lt;i32&gt;(); assert_eq!(y, Some(&amp;42));}在上面的示例中，我们首先将一个i32类型的变量x的引用作为Any trait的引用any_x。然后我们调用了downcast_ref方法尝试将any_x转换成i32类型的引用，由于x就是i32类型的，所以这次转换是成功的，y就是Some(42)。downcast_mut方法downcast_mut方法和downcast_ref方法相似，但是它返回一个可变引用，而不是不可变的引用。1234567891011use std::any::{Any, TypeId};fn main() { let mut x: i32 = 42; assert_eq!(x, 42); let any_x = &amp;mut x as &amp;mut dyn Any; let y = any_x.downcast_mut::&lt;i32&gt;(); assert_eq!(y, Some(&amp;mut 42)); *y.unwrap() = 13; assert_eq!(x, 13);}在上面的示例中，我们定义了一个可变的i32变量x，将它的引用作为Any trait的可变引用any_x。然后我们使用downcast_mut方法将any_x转换成i32类型的可变引用y。然后我们通过*y.unwrap() = 13; 改变了x的值。注意，我们必须使用unwrap方法来从y中获取可变引用。is方法is方法检查Any trait表示的值是否属于指定类型。如果是，它将返回true；否则，它将返回false。12345678use std::any::{Any, TypeId};fn main() { let x: i32 = 42; let any_x = &amp;x as &amp;dyn Any; assert!(any_x.is::&lt;i32&gt;()); assert!(!any_x.is::&lt;bool&gt;());}在上面的示例中，我们首先将i32类型的变量x的引用作为Any trait的引用any_x。然后我们使用is方法检查any_x是否属于i32类型或bool类型。我们看到，any_x的类型是i32，所以第一个assert断言正确，而any_x不是bool类型，所以第二个assert断言不成立。常见用法Any trait在处理不确定类型的数据时非常有用。一些常见的用例包括： 将一个任意类型的值转换为一个期望的类型，并使用它。 将一个存储了不同类型值的容器作为统一类型来处理。 在Rust中使用动态类型。下面是一个常见的用法示例：将vec中的元素转换成String。12345678910111213141516171819202122232425use std::any::{Any, TypeId};fn main() { let mut vec: Vec&lt;Box&lt;dyn Any&gt;&gt; = Vec::new(); vec.push(Box::new(42)); vec.push(Box::new(\"hello\")); vec.push(Box::new(true)); for i in &amp;vec { let x = i.downcast_ref::&lt;i32&gt;(); let y = i.downcast_ref::&lt;&amp;str&gt;(); let z = i.downcast_ref::&lt;bool&gt;(); if let Some(x) = x { println!(\"Found i32: {}\", x); } else if let Some(y) = y { println!(\"Found &amp;str: {}\", y); } else if let Some(z) = z { println!(\"Found bool: {}\", z); } }}// 输出结果：// Found i32: 42// Found &amp;str: hello// Found bool: true在上面的示例中，我们定义了一个vec，它存储了不同类型值的Box。然后我们迭代vec中的每个元素，并使用downcast_ref方法将它转换成i32、&amp;str或bool类型。如果downcast_ref方法返回了Some值，我们就打印转换后的值的类型和值。进阶用法Any trait支持一些高级用法，包括： 向任何类型添加一个标记（或元数据）。 获取类型名称或其他元数据。 将类型从Any trait转换为其他trait。下面是一个高级用法示例：将任何类型添加元数据并动态分配内存。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152use std::any::{Any, TypeId};trait AddMetadata { fn set_metadata(&amp;mut self, metadata: String); fn get_metadata(&amp;self) -&gt; Option&lt;&amp;String&gt;;}impl&lt;T: Any + AddMetadata + 'static&gt; AddMetadata for Box&lt;T&gt; { fn set_metadata(&amp;mut self, metadata: String) { let any_self: &amp;mut dyn Any = self.as_mut(); let metadata_box = Box::new(metadata); any_self.downcast_mut::&lt;T&gt;().unwrap().set_metadata(metadata_box); } fn get_metadata(&amp;self) -&gt; Option&lt;&amp;String&gt; { let any_self: &amp;dyn Any = self.as_ref(); any_self.downcast_ref::&lt;T&gt;().and_then(|s| s.get_metadata()) }}struct MyType { data: String, metadata: Option&lt;Box&lt;String&gt;&gt;,}impl AddMetadata for MyType { fn set_metadata(&amp;mut self, metadata: String) { self.metadata = Some(Box::new(metadata)); } fn get_metadata(&amp;self) -&gt; Option&lt;&amp;String&gt; { self.metadata.as_ref().map(|s| &amp;**s) }}fn main() { let mut vec: Vec&lt;Box&lt;dyn Any&gt;&gt; = Vec::new(); vec.push(Box::new(MyType { data: \"hello world\".to_string(), metadata: None, })); vec.push(Box::new(42)); vec.push(Box::new(3.14)); for i in &amp;vec { if let Some(x) = i.downcast_ref::&lt;Box&lt;MyType&gt;&gt;() { let mut x = *x; x.set_metadata(\"test metadata\".to_string()); vec.push(x); } }}在上面的示例中，我们定义了一个AddMetadata trait，并实现了为Box添加元数据的方法。注意，这里我们为Box impl AddMetadata trait，而不是T本身。这是因为我们不能为不确定的T添加元数据，而Box是一个有具体类型的值，可以为它添加元数据。然后我们定义了一个MyType结构体，并为它实现了AddMetadata trait。在main函数中，我们首先向vec中添加了一些任意类型的值，然后在迭代vec中的元素时，我们尝试将它们转换成Box，如果转换成功，就为它们添加元数据，并将它们重新添加到vec中。总结本教程介绍了Rust语言中的Any trait，包括其定义、内部方法和属性、常见用法和高级用法。Any trait是一个非常有用的类型，可以在处理不确定类型的数据时灵活使用，尤其适合在Rust中使用动态类型。如果你需要处理不确定类型数据的需求，那么请尝试使用Any trait来完成。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 避免Panic程序崩溃",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Panic",
      "url"         : "./rust/2023/03/20/rust_lang_tutorial_18_handle_panic.html",
      "date"        : "2023-03-20 00:00:00 +0800",
      "description" : "",
      "content"     : "在Rust语言中，当发生一些不可修复的错误时，程序会崩溃并停止运行。这种崩溃被称为”panic”，其中包含了出现问题的文件名和行号等信息。Panic是一种紧急情况，并且它们应该尽可能地被避免。尽管它们可能是不可避免的，但是在编写代码时我们应该尝试处理尽可能多的错误。如何使用Panic？在Rust中，可以使用panic!宏来引发panic。此时，程序将停止运行并打印出错误信息，这些信息通常包括出错的文件名称和行号等信息。同时，也可以使用环境变量来获取更多的栈跟踪信息。123456789101112131415161718struct Animal { name: String, age: u8,}impl Animal { fn new(name: String, age: u8) -&gt; Animal { if age &lt; 1 { panic!(\"Age cannot be less than 1.\"); } Animal { name, age } }}fn main() { let animal = Animal::new(String::from(\"Tom\"), 0); println!(\"The animal's name is {} and age is {}.\", animal.name, animal.age);}在上述的示例代码中，我们定义了一个结构体Animal，并为它添加了一个函数new，该函数接受一个名称和一定年龄的参数。接着在new函数中，我们加入了一行代码，以检查年龄是否小于1，如果小于1，则触发panic。最后在main函数中，我们创建了一个名为animal的实例，并输出其名称和年龄。但是由于我们传递的年龄小于1，所以当运行到这里时，程序就会发生panic。当运行这段代码时，输出如下信息：thread 'main' panicked at 'Age cannot be less than 1.', src/main.rs:9:13note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace这个信息告诉我们，在执行new函数时，程序崩溃，并指出出错的源代码文件和行号。同时，它还为我们建议了一个环境变量，以获取更详细的栈跟踪信息。如何避免Panic？对于大多数情况而言，应该尽可能少使用panic。在开始一个新的项目时，首先要考虑的是如何处理错误而不是如何处理成功的情况。Result类型在Rust中，可以使用Result类型来避免panic。Result类型包括两个枚举值：Ok和Err。当一个函数返回Result类型时，它要么返回一个包含成功结果数据的Ok，要么返回一个包含错误信息的Err。这样，调用者就可以选择如何处理错误。12345678910111213141516171819202122232425struct Animal { name: String, age: u8,}impl Animal { fn new(name: String, age: u8) -&gt; Result&lt;Animal, String&gt; { if age &lt; 1 { return Err(String::from(\"Age cannot be less than 1.\")); } Ok(Animal { name, age }) }}fn main() { let animal_result = Animal::new(String::from(\"Tom\"), 0); match animal_result { Ok(animal) =&gt; { println!(\"The animal's name is {} and age is {}.\", animal.name, animal.age); } Err(error) =&gt; { println!(\"{}\", error); } }}在上面的代码中，我们对new函数进行了修改，使其返回Result类型。如果年龄小于1，则返回一个包含错误信息的Err。如果年龄大于等于1，则返回一个包含动物实例的Ok。在main函数中，我们创建了一个名为animal_result的变量，并将其设置为调用Animal结构体中的new函数的返回值。我们使用match表达式来处理animal_result，如果成功，则输出动物实例的名称和年龄，否则则输出错误信息。unwrap和expect方法在Rust中的Result类型中，还有两个用于从Ok值中提取值的方法：unwrap和expect。这两个方法都可以用于快速编写测试代码，并且在这种情况下，panic可能是可以接受的。但是在实际生产代码中，应该避免使用这两个方法，因为它们会利用panic而不是正确处理错误。1234567fn main() { let animal = Animal::new(String::from(\"Tom\"), 1).unwrap(); println!(\"The animal's name is {} and age is {}.\", animal.name, animal.age); let animal = Animal::new(String::from(\"Tom\"), 0).expect(\"Failed to create animal instance.\"); println!(\"The animal's name is {} and age is {}.\", animal.name, animal.age);}在上述示例中，我们在创建animal实例时使用了unwrap和expect方法。在使用unwrap方法时，如果返回值是Ok，则返回Ok类型的值，否则触发panic。而使用expect方法时，同样是如果返回值是Ok，则返回Ok类型的值，并输出指定的错误信息，否则触发panic。总结Rust语言的panic是一种程序崩溃的情况，应该尽可能地避免它的发生。为了避免panic，我们应该尽量使用Result类型，并且在返回错误时返回一个包含错误信息的Err。在测试代码中，可以使用unwrap和expect方法，但是在实际生产代码中应该避免它们的使用。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 文件读/写/操作",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, File",
      "url"         : "./rust/2023/03/19/rust_lang_tutorial_203_File_operation.html",
      "date"        : "2023-03-19 01:00:00 +0800",
      "description" : "",
      "content"     : "Rust语言是一种系统级、高性能的编程语言，其设计目标是确保安全和并发性。 Rust语言以C和C++为基础，但是对于安全性和并发性做出了很大的改进。在Rust语言中，操作文件是非常重要的一个功能，本教程将介绍如何在Rust中高效地操作文件，并提供多个实际应用示例。文件读取Rust语言中操作文件的第一步就是文件读取，使用Rust内置的std::fs::File类型即可。使用File类型可以打开一个文件，并且从中读取数据。12345678910use std::fs::File;use std::io::prelude::*;fn main() -&gt; std::io::Result&lt;()&gt; { let mut f = File::open(\"file.txt\")?; let mut contents = String::new(); f.read_to_string(&amp;mut contents)?; println!(\"{}\", contents); Ok(())}上面的代码中调用File::open()函数打开文件，然后向其中读取数据。读取的数据存储在contents变量中，并使用println!()函数将其输出到控制台。注意，read_to_string()函数是阻塞式的，因此当文件非常大时，应该使用每次读取一小块数据这种方式读取，而不是将整个文件读入内存。文件追加写入在Rust语言中，将数据写入文件的方法是使用write_all()函数。write_all()函数的作用是写入一个字节数组或字符串到文件中。但是使用此函数写入，是直接覆盖文件内容，即覆盖原有文件内容。如果要进行文件追加写入，应该使用Rust内置的std::fs::OpenOptions类型。1234567891011use std::fs::OpenOptions;use std::io::prelude::*;fn main() -&gt; std::io::Result&lt;()&gt; { let mut file = OpenOptions::new() .append(true) .create(true) .open(\"file.txt\")?; file.write_all(b\"Hello, world!\")?; Ok(())}上面的代码中，使用OpenOptions打开文件，并使用append()函数将文件的打开方式设置为追加。使用create()函数则用于创建不存在的文件，如果文件存在，仍然可以正常打开。然后使用write_all()函数将数据写入文件中。注意：文件追加写入是在原文件内容后追加，而不是从文件尾部开始写入。因此，如果在追加写入数据时需要将数据写入最后，应该先使用seek()函数将指针移动到文件尾部。文件写入要在Rust语言中进行文件写入，首先需要创建一个新文件或覆盖现有文件内容。这可以通过std::fs::File类型和std::fs::OpenOptions类型中的create()函数实现。另外，要将数据写入文件中，write_all()函数是不错的选择。1234567891011use std::fs::OpenOptions;use std::io::prelude::*;fn main() -&gt; std::io::Result&lt;()&gt; { let mut file = OpenOptions::new() .write(true) .create(true) .open(\"file.txt\")?; file.write_all(b\"Hello, world!\")?; Ok(())}上面的代码中使用OpenOptions打开文件，并使用write()函数将文件的打开方式设置为写入（即覆盖原有内容）。使用create()函数则用于创建不存在的文件，如果文件存在，仍然可以正常打开。然后使用write_all()函数将数据写入文件中。文件复制Rust语言中可以使用std::fs::copy()函数将一个文件复制到另一个文件中。123456use std::fs;fn main() -&gt; std::io::Result&lt;()&gt;{ fs::copy(\"file.txt\", \"file_copy.txt\")?; Ok(())}上面的代码中，Copy函数将file.txt的所有内容复制到file_copy.txt文件中。如果文件已经存在，则原有文件内容将被覆盖。文件元数据在Rust语言中，File类型还提供了一些用于获取文件元数据的函数，如metadata()函数。此函数返回一个std::fs::Metadata类型的元数据结构体，该结构体包含了文件的大小、创建时间、修改时间、权限等信息。12345678910111213141516use std::fs::metadata;use std::time::SystemTime;fn main() -&gt; std::io::Result&lt;()&gt; { let metadata = metadata(\"file.txt\")?; let created = metadata.created()?; let modified = metadata.modified()?; let size = metadata.len(); let perms = metadata.permissions(); println!(\"Created: {:?}\", created); println!(\"Modified: {:?}\", modified); println!(\"Size: {} bytes\", size); println!(\"Permissions: {:?}\", perms); Ok(())}上面的代码中，metadata()函数返回文件file.txt的元数据，并使用元数据中的created()函数和modified()函数获取创建时间和修改时间，使用len()函数来获取文件大小（字节数），使用permissions()函数获取文件的权限。文件重命名和移动在Rust语言中，使用std::fs::rename()函数可以将文件重命名或者移动到其他文件夹中。123456use std::fs::rename;fn main() -&gt; std::io::Result&lt;()&gt; { rename(\"file.txt\", \"new_file.txt\")?; Ok(())}上面的代码中，rename()函数将文件file.txt重命名为new_file.txt，如果new_file.txt文件已经存在，则重命名将失败。此外，如果要移动文件到其他文件夹中，则可以在目标文件名中指定文件夹路径。例如，如果我们将文件移动到子文件夹/path/to/subdir/中，则可以在目标文件名中指定路径：/path/to/subdir/new_file.txt。多种操作组合在Rust语言中，可以将多种文件操作组合使用，例如读取文件，删除文件内容，然后将新数据写入文件中。123456789101112131415use std::fs::OpenOptions;use std::io::prelude::*;fn main() -&gt; std::io::Result&lt;()&gt; { let mut file = OpenOptions::new() .read(true) .write(true) .open(\"file.txt\")?; let mut contents = String::new(); file.read_to_string(&amp;mut contents)?; contents = contents.replace(\"Hello\", \"World\"); file.set_len(0)?; // 清空文件 file.write_all(contents.as_bytes())?; Ok(())}上面的代码中，使用OpenOptions打开文件，并使用read()函数将文件的打开方式设置为读取，同时打开文件写入的功能。读取文件的内容，并使用replace()函数将文本中的“Hello”替换为“World”。然后使用set_len()函数将文件长度重置为0（即清空文件）。使用write_all()函数将新数据写入文件。扩展阅读 - 读取带BOM头的文件BOM (Byte Order Mark) 是一个Unicode字符，用于标识文件的编码格式（UTF-8, UTF-16LE, UTF-16BE, UTF-32LE, UTF-32BE…）。BOM通常是在文件开头的位置插入的，用于确定字符的顺序和字节顺序。 源于Unicode编码，目前被广泛使用于自定义字符集。例如：GB18030-2022读取带BOM头的文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667pub trait BOMReader { fn has_bom(&amp;self) -&gt; bool; fn read_content(&amp;mut self) -&gt; Result&lt;String, std::io::Error&gt;;}pub struct FileBOMReader { file: std::fs::File, bom: Option&lt;Vec&lt;u8&gt;&gt;,}impl FileBOMReader { pub fn new(file: std::fs::File) -&gt; Self { Self { file, bom: None } } fn read_bom(&amp;mut self) -&gt; Result&lt;(), std::io::Error&gt; { let mut bom_buf = [0u8; 3]; let bytes_read = self.file.read(&amp;mut bom_buf)?; if bytes_read &gt;= 3 &amp;&amp; bom_buf[..3] == [0xEF, 0xBB, 0xBF] { self.bom = Some(bom_buf[..3].to_vec()); } else if bytes_read &gt;= 2 &amp;&amp; bom_buf[..2] == [0xFE, 0xFF] { self.bom = Some(bom_buf[..2].to_vec()); } else if bytes_read &gt;= 2 &amp;&amp; bom_buf[..2] == [0xFF, 0xFE] { self.bom = Some(bom_buf[..2].to_vec()); } else if bytes_read &gt;= 4 &amp;&amp; bom_buf[..4] == [0x00, 0x00, 0xFE, 0xFF] { self.bom = Some(bom_buf[..4].to_vec()); } else if bytes_read &gt;= 4 &amp;&amp; bom_buf[..4] == [0xFF, 0xFE, 0x00, 0x00] { self.bom = Some(bom_buf[..4].to_vec()); } Ok(()) }}impl BOMReader for FileBOMReader { fn has_bom(&amp;self) -&gt; bool { self.bom.is_some() } fn read_content(&amp;mut self) -&gt; Result&lt;String, std::io::Error&gt; { if self.bom.is_none() { self.read_bom()?; } let mut buf = String::new(); self.file.read_to_string(&amp;mut buf)?; if self.has_bom() { match &amp;self.bom { Some(bom) if bom.starts_with([0xEF, 0xBB, 0xBF].as_ref()) =&gt; { buf.drain(..3); } Some(bom) if bom.starts_with([0xFF, 0xFE].as_ref()) =&gt; { buf = buf.as_bytes().chunks_exact(2).map(|c| c[1]).collect(); } Some(bom) if bom.starts_with([0xFE, 0xFF].as_ref()) =&gt; { buf = buf.as_bytes().chunks_exact(2).map(|c| c[0]).collect(); } Some(bom) if bom.starts_with([0x00, 0x00, 0xFE, 0xFF].as_ref()) =&gt; { buf = buf.as_bytes().chunks_exact(2).skip(2).map(|c| c[1]).collect(); } Some(bom) if bom.starts_with([0xFF, 0xFE, 0x00, 0x00].as_ref()) =&gt; { buf = buf.as_bytes().chunks_exact(4).skip(1).flat_map(|c| &amp;c[2..]).collect(); } _ =&gt; {} } } Ok(buf) }}该trait定义了一个BOMReader并提供了一个FileBOMReader的实现，可检测和读取文件中的 BOM（Byte Order Mark）。BOM 通常用于标识文件的编码格式，因为某些编码格式的字符集在读取时可能有不同的字节序。示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647use std::fs::File;use std::io::{Read, Write};fn main() { let mut file = File::create(\"test_utf8.txt\").unwrap(); let content = \"Hello, World!\\n\"; file.write_all(content.as_bytes()).unwrap(); let mut reader = FileBOMReader::new(File::open(\"test_utf8.txt\").unwrap()); let result = reader.read_content().unwrap(); assert_eq!(result, content); let mut file = File::create(\"test_utf16be.txt\").unwrap(); let bom = [0xFE, 0xFF]; file.write_all(&amp;bom).unwrap(); let content = \"Hello, World!\\n\"; file.write_all(content.as_bytes()).unwrap(); let mut reader = FileBOMReader::new(File::open(\"test_utf16be.txt\").unwrap()); let result = reader.read_content().unwrap(); assert_eq!(result, content); let mut file = File::create(\"test_utf16le.txt\").unwrap(); let bom = [0xFF, 0xFE]; file.write_all(&amp;bom).unwrap(); let content = \"Hello, World!\\n\"; file.write_all(content.as_bytes()).unwrap(); let mut reader = FileBOMReader::new(File::open(\"test_utf16le.txt\").unwrap()); let result = reader.read_content().unwrap(); assert_eq!(result, content); let mut file = File::create(\"test_utf32be.txt\").unwrap(); let bom = [0x00, 0x00, 0xFE, 0xFF]; file.write_all(&amp;bom).unwrap(); let content = \"Hello, World!\\n\"; file.write_all(content.as_bytes()).unwrap(); let mut reader = FileBOMReader::new(File::open(\"test_utf32be.txt\").unwrap()); let result = reader.read_content().unwrap(); assert_eq!(result, content); let mut file = File::create(\"test_utf32le.txt\").unwrap(); let bom = [0xFF, 0xFE, 0x00, 0x00]; file.write_all(&amp;bom).unwrap(); let content = \"Hello, World!\\n\"; file.write_all(content.as_bytes()).unwrap(); let mut reader = FileBOMReader::new(File::open(\"test_utf32le.txt\").unwrap()); let result = reader.read_content().unwrap(); assert_eq!(result, content);}通过编写这样的例子，我们可以测试我们的代码，确保它能正确地读取各种类型的文件。使用encoding_rs读取带BOM头的文件在Rust中，可以使用std::fs::File和std::io::BufReader模块读取文件，并使用encoding_rs模块解析BOM头以获取文件的编码信息。1234567891011121314151617181920use std::fs::File;use std::io::BufReader;use encoding_rs::Encoding;fn main() { let filename = \"example.txt\"; let file = File::open(filename).unwrap(); let mut reader = BufReader::new(file); // 按照Utf8读取文件 let decoder = Encoding::utf8().new_decoder_with_bom_handling(); let (result, _, _) = decoder.decode(&amp;mut reader); match result { Some(s) =&gt; { println!(\"Content: {}\", s); } None =&gt; { println!(\"Error decoding file\"); } }}这个示例使用了Utf8编码格式，但是在实现中使用了new_decoder_with_bom_handling()函数以自动检测和处理BOM头。如果需要支持其他编码类型，则需要使用不同的编码器（比如GBK）和相应的 decoder。1234// 按照GBK读取文件let decoder = Encoding::GBK.new_decoder_with_bom_handling();// 解码let (result, _, _) = decoder.decode(&amp;mut reader);根据具体的编码类型来选择对应的编码器，就可以正常读取文件内容了。总结以上是在Rust语言中操作文件的实际应用示例，涵盖了文件读取、追加写入、重命名和移动、复制、写入、获取元数据等操作。这些操作非常基础，但往往也是程序开发中必不可少的操作。在以后的程序开发中，读者可以根据需求将这些操作进行各种组合，以实现更为复杂的文件操作需求。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 自动引用和解引用",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, RwLock",
      "url"         : "./rust/2023/03/19/rust_lang_tutorial_104_auto_ref_unref.html",
      "date"        : "2023-03-19 01:00:00 +0800",
      "description" : "",
      "content"     : "Rust语言是一种静态类型的系统编程语言，具有强类型和所有权的概念。在Rust中，每个值都具有所有权，并且所有权只能有一个所有者。这种所有权模型使得Rust在内存安全方面有很好的表现。在Rust中，如果我们想要使用一个变量或值，我们需要将其分配给一个变量。这个变量可以是一个引用，也可以是一个拥有所有权的变量。当我们使用一个引用时，我们需要使用&amp;符号来创建一个指向该值的引用。在某些情况下，Rust会自动为我们创建引用或解引用。这称为自动引用和解引用。在这篇文章中，我们将讨论Rust语言的自动引用和解引用，以及如何在代码中使用它们。自动引用自动引用是指编译器在某些情况下自动为我们创建引用。这个过程被称为自动引用。当我们使用一个变量或值时，如果该变量或值不是一个引用，则编译器会自动为我们创建一个引用。这个引用的类型是根据上下文推断出来的。例如，考虑以下代码：1234567fn main() { let x = 5; let y = &amp;x; println!(\"x = {}\", x); println!(\"y = {}\", y);}在这个例子中，我们定义了一个变量x，它的值是5。然后，我们定义了一个变量y，它是指向x的引用。但是，我们可以在没有显式创建引用的情况下使用x：12345678910fn main() { let x = 5; let y = &amp;x; println!(\"x = {}\", x); // 自动引用 println!(\"y = {}\", y); println!(\"*y = {}\", *y); // 解引用}在这个例子中，我们使用了x和y。当我们使用x时，编译器会自动为我们创建一个指向x的引用。当我们使用y时，我们实际上也是在使用一个引用，因为y本身就是一个引用。在这个例子中，我们还使用了*y来解引用y。这意味着我们要访问y指向的值。当我们使用*运算符时，编译器会自动为我们解引用y。自动解引用自动解引用是指编译器在某些情况下自动为我们解引用一个引用。这个过程被称为自动解引用。当我们使用一个引用调用一个方法或访问一个字段时，编译器会自动为我们解引用该引用。这是因为方法和字段都是使用.运算符来访问的，而不是*运算符。例如，考虑以下代码：12345678910111213141516171819202122232425struct Point { x: i32, y: i32,}impl Point { fn new(x: i32, y: i32) -&gt; Point { Point { x, y } } fn distance(&amp;self, other: &amp;Point) -&gt; f64 { let dx = self.x - other.x; let dy = self.y - other.y; ((dx * dx + dy * dy) as f64).sqrt() }}fn main() { let p1 = Point::new(0, 0); let p2 = Point::new(3, 4); // 自动解引用 println!(\"distance = {}\", p1.distance(&amp;p2));}在这个例子中，我们定义了一个Point结构体，它有两个字段x和y。我们还为Point实现了一个distance方法，它计算了两个点之间的距离。在main函数中，我们创建了两个Point实例p1和p2。然后，我们使用p1的distance方法来计算p1和p2之间的距离。在这个例子中，我们使用了p1.distance(&amp;p2)来调用distance方法。这里的&amp;p2是一个引用，它传递给distance方法作为参数。但是，我们不需要在调用distance方法时显式地解引用p1。这是因为编译器会自动为我们解引用p1。所以，我们可以直接使用p1.distance(&amp;p2)，而不是(*p1).distance(&amp;p2)。自动引用和解引用的规则Rust中的自动引用和解引用有一些规则。这些规则决定了编译器何时会自动为我们创建引用或解引用。1. 方法调用当我们调用一个方法时，编译器会自动为我们解引用该方法的接收者。这是因为方法调用使用.运算符，而不是*运算符。例如，考虑以下代码：12345678910111213141516171819202122232425struct Point { x: i32, y: i32,}impl Point { fn new(x: i32, y: i32) -&gt; Point { Point { x, y } } fn distance(&amp;self, other: &amp;Point) -&gt; f64 { let dx = self.x - other.x; let dy = self.y - other.y; ((dx * dx + dy * dy) as f64).sqrt() }}fn main() { let p1 = Point::new(0, 0); let p2 = Point::new(3, 4); // 自动解引用 println!(\"distance = {}\", p1.distance(&amp;p2));}在这个例子中，我们调用了p1的distance方法。编译器会自动为我们解引用p1，因为p1是distance方法的接收者，并且方法调用使用.运算符。2. 解引用强制多态当我们使用*运算符来解引用一个实现了Deref trait的类型时，编译器会自动为我们调用该类型的deref方法。这被称为解引用强制多态。例如，考虑以下代码：1234567891011121314151617181920212223struct MyBox&lt;T&gt;(T);impl&lt;T&gt; MyBox&lt;T&gt; { fn new(x: T) -&gt; MyBox&lt;T&gt; { MyBox(x) }}impl&lt;T&gt; Deref for MyBox&lt;T&gt; { type Target = T; fn deref(&amp;self) -&gt; &amp;T { &amp;self.0 }}fn main() { let x = 5; let y = MyBox::new(x); // 解引用强制多态 assert_eq!(5, *y);}在这个例子中，我们定义了一个MyBox类型，它包装了一个值。我们还为MyBox实现了Deref trait，使得我们可以通过解引用来访问该值。在main函数中，我们创建了一个x变量，它的值是5。然后，我们使用MyBox::new方法来创建一个MyBox实例y，它包装了x的值。在assert_eq!(5, *y)这一行中，我们使用*运算符来解引用y。编译器会自动为我们调用y的deref方法，这使得我们可以访问y包装的值。3. 函数和方法参数当我们将一个值作为函数或方法的参数传递时，编译器会自动为我们创建一个引用。这是因为函数和方法的参数使用了&amp;运算符，而不是*运算符。例如，考虑以下代码：12345678910fn print(x: &amp;i32) { println!(\"x = {}\", x);}fn main() { let x = 5; // 自动引用 print(&amp;x);}在这个例子中，我们定义了一个print函数，它的参数是一个i32类型的引用。在main函数中，我们创建了一个x变量，它的值是5。然后，我们将&amp;x作为参数传递给print函数。在print(&amp;x)这一行中，我们没有显式地使用&amp;运算符来创建一个引用。但是，编译器会自动为我们创建一个引用，因为print函数的参数使用了&amp;运算符。4. 解引用可变借用当我们使用*运算符来解引用一个可变借用时，编译器会自动为我们创建一个可变引用。这是因为解引用可变借用时，我们需要访问可变借用所指向的值，而这需要一个可变引用。例如，考虑以下代码：1234567891011fn print(x: &amp;mut i32) { println!(\"x = {}\", x);}fn main() { let mut x = 5; // 解引用可变借用 *(&amp;mut x) += 1; print(&amp;mut x);}在这个例子中，我们定义了一个print函数，它的参数是一个可变借用。在main函数中，我们创建了一个x变量，它的值是5。然后，我们使用&amp;mut x来创建一个可变借用，并使用*(&amp;mut x)来解引用它。这会自动为我们创建一个可变引用，使我们可以修改x的值。在*(&amp;mut x) += 1这一行中，我们将x的值增加了1。然后，我们将&amp;mut x作为参数传递给print函数。自动引用和解引用的注意点虽然自动引用和解引用能够使代码更加简洁和易读，但是在使用它们时需要注意一些事项。1. 可能的歧义自动引用和解引用可能会导致歧义。例如，考虑以下代码：1234567891011121314151617181920212223242526272829struct Point { x: i32, y: i32,}impl Point { fn new(x: i32, y: i32) -&gt; Point { Point { x, y } } fn distance(&amp;self, other: &amp;Point) -&gt; f64 { let dx = self.x - other.x; let dy = self.y - other.y; ((dx * dx + dy * dy) as f64).sqrt() }}fn main() { let p1 = Point::new(0, 0); let p2 = Point::new(3, 4); // 没有歧义 println!(\"distance = {}\", p1.distance(&amp;p2)); // 可能的歧义 let distance = p1.distance; println!(\"distance = {}\", distance(&amp;p2));}在这个例子中，我们定义了一个Point类型和一个distance方法，它计算两个点之间的距离。在main函数中，我们创建了两个Point实例p1和p2。然后，我们使用p1的distance方法来计算p1和p2之间的距离。在第二个println!语句中，我们将p1.distance赋值给了distance变量。然后，我们使用distance(&amp;p2)来调用distance方法。这里的&amp;p2是一个引用，它传递给distance方法作为参数。在这个例子中，编译器不能确定我们想要自动为哪个对象创建引用或解引用哪个对象。所以，它会报告一个错误，要求我们明确指定使用哪个对象。2. 性能问题自动引用和解引用可能会带来一些性能问题。当我们使用自动引用时，编译器会为我们创建一个引用，这可能会导致额外的开销和内存分配。例如，考虑以下代码：12345678910111213141516171819202122232425struct Point { x: i32, y: i32,}impl Point { fn new(x: i32, y: i32) -&gt; Point { Point { x, y } } fn distance(&amp;self, other: &amp;Point) -&gt; f64 { let dx = self.x - other.x; let dy = self.y - other.y; ((dx * dx + dy * dy) as f64).sqrt() }}fn main() { let p1 = Point::new(0, 0); let p2 = Point::new(3, 4); // 自动引用 println!(\"distance = {}\", p1.distance(&amp;p2));}在这个例子中，我们使用了自动引用来调用p1的distance方法。编译器会为我们创建一个&amp;Point类型的引用，这会导致额外的开销和内存分配。如果我们手动创建一个&amp;Point类型的引用，代码可能会更加高效：1234567fn main() { let p1 = Point::new(0, 0); let p2 = Point::new(3, 4); // 手动创建引用 println!(\"distance = {}\", (&amp;p1).distance(&amp;p2));}在这个例子中，我们手动创建了一个&amp;Point类型的引用，这避免了编译器为我们创建引用所带来的开销和内存分配。总结自动引用和解引用是Rust中非常有用的特性。它们能够使代码更加简洁和易读，但是在使用它们时需要注意可能出现的歧义和性能问题。当我们使用.运算符来调用方法时，编译器会自动为我们创建一个引用。当我们使用*运算符来解引用一个值时，编译器会自动为我们创建一个引用或可变引用，具体取决于该值是否可变。自动引用和解引用可以使代码更加简洁和易读，但是在使用它们时需要注意可能出现的歧义和性能问题。为了避免可能的歧义和提高性能，我们可以手动创建引用或可变引用。最后，我们需要注意的是，Rust的所有权和借用系统是这些特性的基础。自动引用和解引用能够使我们更方便地使用借用系统，但是借用规则仍然适用。在使用自动引用和解引用时，我们仍然必须遵循借用规则，以确保代码的正确性和安全性。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - RwLock读写锁",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, RwLock",
      "url"         : "./rust/2023/03/19/rust_lang_tutorial_103_RwLock.html",
      "date"        : "2023-03-19 01:00:00 +0800",
      "description" : "",
      "content"     : "Rust是一种系统级编程语言，它带有严格的内存管理、并发和安全性规则，因此很受广大程序员的青睐。RwLock（读写锁）是 Rust 中常用的线程同步机制之一，本文将详细介绍 Rust 语言中的 RwLock 的内部实现原理、常用接口的使用技巧和最佳实践。RwLock 的内部实现原理基本概念RwLock 是一种读写分离的锁，允许多个线程同时读取共享数据，但只允许一个线程写入数据。通过这种方式，可以避免读写操作之间的竞争，从而提高并发性能。在 Rust 中，RwLock 的实现基于 std::sync::RwLock 结构体。其中，T 表示被保护的数据类型，需要满足 Send 特质以便可以在线程之间传递，并且需要满足 Sync 特质以便可以在线程之间共享。RwLock 是在 std::sync::RwLock 结构体上实现的，为了方便说明，下文中假设 T 为 u32 类型。RwLock 的基本结构RwLock 的基本结构如下：123use std::sync::RwLock;let lock = RwLock::new(0u32);该代码将创建一个 RwLock 对象，其中 T 类型为 u32，初始化值为 0，即该锁保护的是一个名为 data 的 u32 类型变量。RwLock 的锁定机制我们可以通过锁定 RwLock 来对数据进行保护。RwLock 提供了四个方法来完成锁定操作： read() 方法：获取读锁，并返回一个 RAII（资源获取即初始化）的读取守卫。多个线程可以同时获取读锁，但是不能同时持有写锁。 try_read() 方法：非阻塞地获取读锁。如果读锁已经被占用，则返回 None。 write() 方法：获取写锁，并返回一个 RAII 的写入守卫。如果有任何线程正在持有读锁或写锁，则阻塞等待直到它们释放锁。 try_write() 方法：非阻塞地获取写锁。如果写锁已经被占用，则返回 None。对于读写锁，我们需要保证写操作在读操作之前，因此，在调用 write 方法时，会等待所有的读取守卫被释放，并阻止新的读取守卫的创建。为了避免死锁和优先级反转，写入守卫还可以降低优先级。读写锁的实现主要是通过两个 Mutex 来实现的。一个 Mutex 用于保护读取计数器，另一个 Mutex 用于保护写入状态。读取计数器统计当前存在多少个读取锁，每当一个新的读取锁被请求时，读取计数器就会自增。当读取计数器为 0 时，写入锁可以被请求。RwLock 的 Poisoning类似于 Mutex，RwLock 也支持 poisoning 机制。如果 RwLock 发生 panic，那么锁就成了 poison 状态，也就是无法再被使用。任何试图获取这个锁的线程都会 panic，而不是被阻塞。1234567891011121314151617181920212223242526272829303132333435use std::sync::{Arc, RwLock};use std::thread;fn main() { let lock = Arc::new(RwLock::new(0u32)); let readers = (0..6) .map(|_| { let lock = lock.clone(); thread::spawn(move || { let guard = lock.read().unwrap(); println!(\"read: {}\", *guard); }) }) .collect::&lt;Vec&lt;_&gt;&gt;(); let writers = (0..2) .map(|_| { let lock = lock.clone(); thread::spawn(move || { let mut guard = lock.write().unwrap(); *guard += 1; println!(\"write: {}\", *guard); }) }) .collect::&lt;Vec&lt;_&gt;&gt;(); for reader in readers { reader.join().unwrap(); } for writer in writers { writer.join().unwrap(); }}运行后，可能会出现以下异常信息：1thread 'main' panicked at 'PoisonError { inner: ...这里的 inner 表示调用 RwLock 的线程 panic 时产生的错误信息。常用接口的使用技巧read() 方法read() 方法用于获取读锁，并返回一个 RAII 的读取守卫：1234let lock = RwLock::new(0u32);let r1 = lock.read().unwrap();let r2 = lock.read().unwrap();在上面的例子中，r1 和 r2 都是 RwLockWriteGuard&lt;u32&gt; 类型的对象，它们引用的数据类型是 u32。这意味着它们只允许读取 u32 类型的数据，并且无法改变它们的值。读取守卫被析构时，RwLock 的读取计数器会减少，如果读取计数器变为 0，则写入锁可以被请求。write() 方法write() 方法用于获取写锁，并返回一个 RAII 的写入守卫：1234let lock = RwLock::new(0u32);let mut w1 = lock.write().unwrap();let mut w2 = lock.write().unwrap();在上面的例子中，w1 和 w2 都是 RwLockWriteGuard&lt;u32&gt; 类型的对象，它们引用的数据类型是 u32。这意味着它们允许读写 u32 类型的数据，并且可以改变它们的值。写入守卫被析构时，写入锁立即被释放，并且所有等待读取锁和写入锁的线程都可以开始运行。try_read() 方法try_read() 方法用于非阻塞地获取读锁。如果读锁已经被占用，则返回 None。1234567let lock = RwLock::new(0u32);if let Some(r) = lock.try_read() { println!(\"read: {}\", *r);} else { println!(\"read lock is already taken\");}try_write() 方法try_write() 方法用于非阻塞地获取写锁。如果写锁已经被占用，则返回 None。12345678let lock = RwLock::new(0u32);if let Some(mut w) = lock.try_write() { *w += 1; println!(\"write: {}\", *w);} else { println!(\"write lock is already taken\");}共享所有权如果你想在多个线程之间共享一个 RwLock 对象，就需要使用 Arc（atomic reference counting，原子引用计数）来包装它：12345678910111213141516171819202122232425262728293031323334353637383940414243use std::sync::{Arc, RwLock};use std::thread;fn main() { let lock = Arc::new(RwLock::new(0u32)); let readers = (0..6) .map(|_| { let lock = lock.clone(); thread::spawn(move || { let guard = lock.read().unwrap(); println!(\"read: {}\", *guard); }) }) .collect::&lt;Vec&lt;_&gt;&gt;(); let writers = (0..2) .map(|_| { let lock = lock.clone(); thread::spawn(move || { let mut guard = lock.write().unwrap(); *guard += 1; println!(\"write: {}\", *guard); }) }) .collect::&lt;Vec&lt;_&gt;&gt;(); for reader in readers { reader.join().unwrap(); } for writer in writers { writer.join().unwrap(); }}// 输出结果：// read: 0// read: 0// read: 0// read: 0// read: 0// read: 0// write: 1// write: 2实现锁超时功能Rust标准库中的RwLock目前是不支持读/写超时功能的。我们可以利用RwLock中非阻塞方法try_read和try_write实现超时的特征。下面进一步讲解使用std::sync::RwLock和std::time::Duration来实现读超时，具体步骤如下： 创建一个名为TimeoutRwLock的trait，其中包含read_timeout方法。 在TimeoutRwLock中添加默认实现（default impl）。 在read_timeout方法中，通过RwLock的try_read_with_timeout方法来尝试获取读取器（Reader），并且指定一个等待时间。 如果在等待时间内成功获取到读取器，那么将读取器返回；否则，返回一个错误。下面是代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566use std::sync::{Arc, RwLock, RwLockReadGuard};use std::time::Duration;use std::thread;use std::thread::sleep;trait TimeoutRwLock&lt;T&gt; { fn read_timeout(&amp;self, timeout: Duration) -&gt; Result&lt;RwLockReadGuard&lt;'_, T&gt;, String&gt; { match self.try_read_with_timeout(timeout) { Ok(guard) =&gt; Ok(guard), Err(_) =&gt; Err(String::from(\"timeout\")), } } fn try_read_with_timeout(&amp;self, timeout: Duration) -&gt; Result&lt;RwLockReadGuard&lt;'_, T&gt;, ()&gt;;}impl&lt;T&gt; TimeoutRwLock&lt;T&gt; for RwLock&lt;T&gt; { fn try_read_with_timeout(&amp;self, timeout: Duration) -&gt; Result&lt;RwLockReadGuard&lt;'_, T&gt;, ()&gt; { let now = std::time::Instant::now(); loop { match self.try_read() { Ok(guard) =&gt; return Ok(guard), Err(_) =&gt; { if now.elapsed() &gt;= timeout { return Err(()); } std::thread::sleep(Duration::from_millis(10)); } } } }}fn main() { let lock = Arc::new(RwLock::new(0u32)); let reader = { let lock = lock.clone(); thread::spawn( move || match lock.read_timeout(Duration::from_millis(100)) { Ok(guard) =&gt; { println!(\"read: {}\", *guard); } Err(e) =&gt; { println!(\"error: {:?}\", e); } }, ) }; let writer = { let lock = lock.clone(); thread::spawn(move || { sleep(Duration::from_secs(1)); let mut guard = lock.write().unwrap(); *guard += 1; println!(\"write: {}\", *guard); }) }; reader.join().unwrap(); writer.join().unwrap();}// 输出结果：// read: 0// write: 1在这个实现中，trait TimeoutRwLock中定义了一个read_timeout方法，它与try_read方法具有相同的输入参数类型和输出类型。default impl方法是一个尝试在给定的等待时间内获取读取器（Reader）的循环，并在等待过程中使用线程（thread）的park_timeout方法来避免 CPU 占用过高。如果在等待时间内成功获取到读取器（Reader），则返回读取器；否则返回一个错误。当然，除了自己实现Trait外，还可以使用成熟的第三方库，例如：parking_lotRwLock最佳实践 避免使用锁锁是一种解决并发问题的基本机制，但由于锁会引入竞争条件、死锁和其他问题，因此应尽量避免使用锁。如果可能，应使用更高级别的机制，例如 Rust 的通道（channel）。 避免过度使用读写锁在某些情况下，读写锁可能会比互斥锁更慢。例如，如果有太多的读取器，并且它们在拥有读取锁时花费了大量时间，那么写入器的等待时间可能会很长。因此，使用读写锁时，应仔细考虑读写比例，以避免过度使用读写锁。 锁的可重入性RwLock 是可重入的；一个线程占有写锁时可以再次占有读锁，并且同样可以占有写锁。但这种情况要非常小心，因为可能会导致死锁。 尽量缩小锁的范围锁的范围越小，竞争就越少，性能就越好。因此，应尽量在需要的地方使用锁，而在不需要的地方释放锁。例如，在读写数据之前，可以先将数据复制到本地变量中，然后释放锁，以便其它线程可以访问该数据，而不必争夺锁。在本地变量上执行读写操作时，不需要锁定。 锁的超时设置在使用锁时，应该避免出现无限等待的情况。可以使用带超时的锁，当等待时间超过指定的时间时，会返回一个错误。这将防止出现死锁或其他问题。123456789101112131415161718192021222324252627282930313233343536// 引入第三方库处理超时// parking_lot = \"0.12.1\"use parking_lot::RwLock;use std::sync::Arc;use std::thread;use std::time::{Duration, Instant};fn main() { let rwlock = Arc::new(RwLock::new(0)); let start = Instant::now(); // 尝试在 1 秒内获取读锁 let reader = loop { if let Some(r) = rwlock.try_read_for(Duration::from_secs(1)) { break r; } if start.elapsed() &gt;= Duration::from_secs(5) { panic!(\"Failed to acquire read lock within 5 seconds.\"); } }; // 尝试在 1 秒内获取写锁 let mut writer = loop { if let Some(w) = rwlock.try_write_for(Duration::from_secs(1)) { break w; } if start.elapsed() &gt;= Duration::from_secs(5) { panic!(\"Failed to acquire write lock within 5 seconds.\"); } }; // 进行读写操作 println!(\"Reader: {}\", *reader); *writer += 1; println!(\"Writer: {}\", *writer);}在上面的例子中，读取器等待 100 毫秒后超时，写入器等待 1 秒钟才能成功完成写入。总结RwLock 是 Rust 中一种常用的线程同步机制，可以提高程序的并发性能。它只允许一个线程写入数据，但可以让多个线程同时读取同一个数据。具体来说，RwLock 在实现上使用了两个 Mutex，一个用于保护读取计数器，另一个用于保护写入状态。在使用 RwLock 时，应该注意缩小锁的范围、避免使用过多读写锁以及防止死锁等问题。"
    } ,
  
    {
      "title"       : "Spring框架实战技巧 - @Async实现代码零入侵异步化改造",
      "category"    : "",
      "tags"        : "Spring Framework, \@Async",
      "url"         : "./spring%20framework/2023/03/19/spring_framework_async_annomation.html",
      "date"        : "2023-03-19 00:00:00 +0800",
      "description" : "",
      "content"     : "Spring 框架提供了一种简单的方式实现异步调用方法。通过@Async注解，将方法标记为异步，可以在不阻塞主线程的情况下执行代码。本教程将介绍使用 Spring 框架的 @Async 注解实现方法异步调用的步骤，并通过 Person 类的例子来讲解如何在 Spring 框架中使用 @Async 注解。启用和配置@Async步骤如下：在pom.xml文件中添加Spring框架的依赖，以便使用@Async注解。12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;在 Spring 配置文件中开启异步调用。在xml配置中：12&lt;task:annotation-driven executor=\"asyncExecutor\"/&gt;&lt;task:executor id=\"asyncExecutor\" pool-size=\"5\"/&gt;在Java配置中：12345678910111213141516@Configuration@ComponentScan(\"com.example\")@EnableAsyncpublic class AppConfig implements AsyncConfigurer { @Override public Executor getAsyncExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(5); executor.setMaxPoolSize(10); executor.setQueueCapacity(25); executor.setThreadNamePrefix(\"MyAsyncExecutor-\"); executor.initialize(); return executor; }}在代码中使用@Async注解标记异步方法。123456public class Person { @Async public void sayHello() { System.out.println(\"Hello from \" + Thread.currentThread().getName() + \"!\"); }}Person 类代码示例12345678910import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Component;@Componentpublic class Person { @Async public void sayHello() { System.out.println(\"Hello from \" + Thread.currentThread().getName() + \"!\"); }}在代码中调用异步方法：1234567891011121314import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); Person p = context.getBean(Person.class); p.sayHello(); System.out.println(\"Main thread done!\"); }}// 输出结果：// Main thread done!// Hello from MyAsyncExecutor-1!在 Person 类中，我们定义了一个异步方法 sayHello()，该方法在被调用时，会打印一条消息 “Hello from !\"，其中 替换为执行该方法的线程名称。在 Main 类中，我们创建了一个 Spring 应用程序上下文，并获取了通过 AppConfig 类定义的 Person bean 的一个实例。我们调用了 Person bean 的 sayHello() 方法，然后打印一条消息“Main thread done!”（表示主线程已完成）。因为我们在 sayHello() 方法上使用了 @Async 注解，因此该方法会在异步线程池中执行（即 MyAsyncExecutor-1）。实战示例以下是一个使用@Async注解的示例代码，该示例演示了如何使用异步方法在后台计算一个数字序列的总和。代码分为三个部分：序列生成器、序列求和器和主应用程序。序列生成器在这个例子中，我们将使用一个简单的生成器来生成一个数字序列。该生成器将接收一个起始值和一个结束值，并生成一个从起始值到结束值的数字序列。12345678910@Componentpublic class NumberSequenceGenerator { public List&lt;Integer&gt; generate(int start, int end) { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for (int i = start; i &lt;= end; i++) { list.add(i); } return list; }}在这个例子中，我们定义了一个名为NumberSequenceGenerator的组件，它包含一个名为generate()的方法，该方法接收两个整数参数（start和end），并生成一个数字序列，其中第一个元素是start，最后一个元素是end。序列求和器在这个例子中，我们将使用一个异步方法来计算数字序列的总和。该方法将接收一个数字序列，并计算该序列的总和。123456789101112131415@Servicepublic class SumCalculator { @Autowired private NumberSequenceGenerator generator; @Async public Future&lt;Integer&gt; calculateSumAsync(int start, int end) { List&lt;Integer&gt; list = generator.generate(start, end); int sum = 0; for (Integer i : list) { sum += i; } return new AsyncResult&lt;Integer&gt;(sum); }}在这个例子中，我们定义了一个名为SumCalculator的服务，它包含一个异步方法calculateSumAsync()，该方法接收两个整数参数（start和end），并计算从start到end的数字序列的总和。在方法的内部，我们使用NumberSequenceGenerator生成数字序列，并迭代该序列以计算总和。最后，我们将总和封装在一个Future对象中，并返回该对象以供调用者使用。启动示例在这个例子中，我们将使用一个主应用程序来演示如何使用异步方法计算数字序列的总和。12345678910111213public class MainApplication { public static void main(String[] args) throws Exception { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); SumCalculator calculator = context.getBean(SumCalculator.class); Future&lt;Integer&gt; future = calculator.calculateSumAsync(1, 1000); while (!future.isDone()) { System.out.println(\"异步方法正在执行...\"); Thread.sleep(1000); } System.out.println(\"异步方法返回值：\" + future.get()); context.close(); }}在这个例子中，我们创建了一个Spring应用程序上下文，并从该上下文中获取SumCalculator服务。然后，我们使用calculateSumAsync()方法计算数字序列的总和，并使用while循环等待异步方法的结果。当异步方法执行完成后，我们将输出异步方法的返回值，并关闭Spring应用程序上下文。总结使用 Spring 框架的 @Async 注解，可以轻松地实现方法异步调用。虽然示例代码很简单，但实际上，异步方法比较适用于涉及复杂或长时间运行的操作。在这种情况下，异步方法可以在后台执行，而不会阻塞主线程。如果你使用 Spring 框架开发 web 应用或其他需要异步处理的场景，那么学习使用 @Async 注解将非常有用。"
    } ,
  
    {
      "title"       : "Rust_lang_tutorial_204_protobuf",
      "category"    : "",
      "tags"        : "",
      "url"         : "./2023/03/19/rust_lang_tutorial_204_protobuf.html",
      "date"        : "2023-03-19 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust是一种系统编程语言，同时也是一种编译型语言。在Rust中，我们可以使用Google Protocol Buffers（以下简称Protobuf）来进行高效的数据序列化和反序列化操作。Protobuf是基于二进制流的协议，用于结构化数据序列化和反序列化，通常被用于网络通信和持久化。它可以提供高效的序列化和反序列化操作，并且可以支持各种语言。在本篇文章中，我们将介绍如何在Rust中使用Protobuf。安装在使用Rust的Protobuf之前，我们需要安装以下工具： Rust（官网） Protocol Buffers编译器（官网）接着，我们需要安装Rust的protobuf工具库，我们可以通过在终端中输入以下命令来实现：cargo install protobuf这将安装Rust的Protobuf工具库及其所需的所有依赖项。编写.proto文件在使用Protobuf之前，我们需要先编写.proto文件。Proto文件描述了数据的结构和类型，以便将数据序列化为二进制流，并在不同的计算机之间进行传输。以下是一个简单的.proto文件示例，它定义了一个Person的结构体：syntax = \"proto3\";message Person { string name = 1; int32 age = 2; string email = 3;}在.proto文件中，我们可以定义消息（message）、枚举（enum）和服务（service）。这些元素将用于生成代码文件和数据结构，以便在Rust中使用。编译.proto文件在使用.proto文件之前，我们还需要将它们编译成Rust代码。在终端中，我们可以输入以下命令来将.proto文件编译为Rust代码：protoc --rust_out=. person.proto这将在当前目录中生成一个person.rs文件，其中包含了我们定义的Person结构体的Rust类型和方法。使用Rust的Protobuf在.proto文件中所定义的数据结构已经生成了它们的Rust类型后，我们可以在Rust中使用Rust的Protobuf来进行序列化和反序列化操作。首先，我们需要在Cargo.toml文件中添加该文件（例如，在当前目录中以一个库的形式进行管理）：[dependencies]protobuf = \"3.2.0\"然后，我们可以使用Person类型来创建一个新的实例，并填充它的字段：123456use proto::person::*;let mut person = Person::new();person.set_name(\"Alice\".to_string());person.set_age(30);person.set_email(\"alice@example.com\".to_string());在这个例子中，我们首先通过导入文件名为person.rs的模块来创建Person类型的实例。然后，我们可以通过调用其setter方法来设置Person对象的各个字段。接着，我们可以对Person对象进行序列化，并将其保存到文件中：123456use std::fs::File;use std::io::Write;let serialized = person.write_to_bytes().unwrap();let mut file = File::create(\"person.dat\").unwrap();file.write_all(&amp;serialized).unwrap();在这个例子中，我们使用write_to_bytes方法将Person对象序列化为二进制流，并将其保存到变量serialized中。接着，我们将这个二进制流写入person.dat文件中。最后，我们可以从文件中读取Person对象，并对它进行反序列化：1234567use std::fs::File;use std::io::Read;let mut file = File::open(\"person.dat\").unwrap();let mut data = Vec::new();file.read_to_end(&amp;mut data).unwrap();let person = Person::parse_from_bytes(&amp;data).unwrap();在这个例子中，我们首先通过File::open方法打开person.dat文件，并读取其中的所有数据到变量data中。接着，我们使用parse_from_bytes方法对这个二进制流进行反序列化操作，并将结果存储到person变量中。示例代码以下代码是一个完整的例子，其中包括了我们如何使用Rust的Protobuf来序列化和反序列化Person对象：1234567891011121314151617181920212223242526use proto::person::*;use std::fs::File;use std::io::Read;use std::io::Write;fn main() { // Create a new person object and fill its fields let mut person = Person::new(); person.set_name(\"Alice\".to_string()); person.set_age(30); person.set_email(\"alice@example.com\".to_string()); // Write the person object to a file let serialized = person.write_to_bytes().unwrap(); let mut file = File::create(\"person.dat\").unwrap(); file.write_all(&amp;serialized).unwrap(); // Read the person object from the file let mut file = File::open(\"person.dat\").unwrap(); let mut data = Vec::new(); file.read_to_end(&amp;mut data).unwrap(); let person = Person::parse_from_bytes(&amp;data).unwrap(); // Print the person's name println!(\"Name: {}\", person.get_name());}在这个例子中，我们首先定义了一个Person对象，并分别给它的name、age和email字段赋值，然后将这个对象序列化为二进制流，并将其保存到person.dat文件中。接着，我们从person.dat文件中读取数据，并对其进行反序列化操作，并将结果存储在person变量中。最后，我们使用get_name方法来获取反序列化后的对象的名称，并将其打印到控制台上。总结在这篇文章中，我们介绍了如何在Rust中使用Protobuf进行数据序列化和反序列化操作。我们首先编写了一个.proto文件来定义我们想要序列化和反序列化的数据结构，然后使用Protocol Buffers编译器将其编译为Rust代码。然后，我们通过在Cargo.toml文件中添加protobuf的依赖来使用Rust的Protobuf，并演示了如何在Rust中创建和填充一个Person对象，并将其序列化为二进制流，并将其保存到文件中。最后，我们还展示了如何从文件中读取数据，并将其反序列化为Person对象。本文仅仅是一个简单的介绍，更多的使用和API受限于篇幅，下一章教程讲述进阶教程。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - A*寻路算法",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Iterator",
      "url"         : "./rust/2023/03/18/rust_lang_tutorial_201_astar.html",
      "date"        : "2023-03-18 03:00:00 +0800",
      "description" : "",
      "content"     : "A算法是一种启发式搜索算法，常用于寻路问题。它的基本思路是从起点开始，每次选择一个最优的节点进行扩展，直到找到终点或者无法继续扩展。A算法的优点是可以通过启发式函数来指导搜索方向，从而提高搜索效率。A*算法A*算法的基本流程如下： 将起点加入open列表中。 从open列表中找出f值最小的节点，将其作为当前节点。 如果当前节点是终点，则搜索结束。 否则，将当前节点从open列表中移除，加入close列表中。 对当前节点的邻居节点进行扩展，计算其f值，并将其加入open列表中。 重复步骤2-5，直到找到终点或者open列表为空。A*算法的启发式函数通常使用曼哈顿距离或欧几里得距离，具体实现可以根据具体问题进行调整。Rust实现A*算法下面是使用Rust语言实现A*算法的代码，代码中使用了一个二维数组来表示地图，0表示可以通过的格子，1表示障碍物，起点和终点分别用S和E表示。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142use std::collections::BinaryHeap;use std::cmp::Ordering;#[derive(Clone, Copy, Eq, PartialEq)]struct Node { x: usize, y: usize, f: usize, g: usize, h: usize,}impl Ord for Node { fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering { other.f.cmp(&amp;self.f) }}impl PartialOrd for Node { fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; { Some(self.cmp(other)) }}fn a_star(map: &amp;Vec&lt;Vec&lt;i32&gt;&gt;, start: (usize, usize), end: (usize, usize)) -&gt; Option&lt;Vec&lt;(usize, usize)&gt;&gt; { let mut open_list = BinaryHeap::new(); let mut close_list = vec![vec![false; map[0].len()]; map.len()]; let mut parent = vec![vec![(0, 0); map[0].len()]; map.len()]; let mut g_score = vec![vec![usize::MAX; map[0].len()]; map.len()]; let mut f_score = vec![vec![usize::MAX; map[0].len()]; map.len()]; let (start_x, start_y) = start; let (end_x, end_y) = end; g_score[start_x][start_y] = 0; f_score[start_x][start_y] = manhattan_distance(start_x, start_y, end_x, end_y); open_list.push(Node { x: start_x, y: start_y, f: f_score[start_x][start_y], g: 0, h: f_score[start_x][start_y] }); while let Some(current) = open_list.pop() { if current.x == end_x &amp;&amp; current.y == end_y { let mut path = vec![]; let mut current = (end_x, end_y); while current != (start_x, start_y) { path.push(current); current = parent[current.0][current.1]; } path.push((start_x, start_y)); path.reverse(); return Some(path); } close_list[current.x][current.y] = true; // 四方向坐标系寻路, 可以根据需求改写扩展为8方向 for (dx, dy) in &amp;[(-1, 0), (1, 0), (0, -1), (0, 1)] { let x = current.x as i32 + dx; let y = current.y as i32 + dy; // 判断坐标是否超出地图边界 if x &lt; 0 || x &gt;= map.len() as i32 || y &lt; 0 || y &gt;= map[0].len() as i32 { continue; } let x = x as usize; let y = y as usize; // 判断是否可以通行，可以通过扩展类型实现更多的地图场景效果 if map[x][y] == 1 || close_list[x][y] { continue; } let tentative_g_score = g_score[current.x][current.y] + 1; if tentative_g_score &lt; g_score[x][y] { parent[x][y] = (current.x, current.y); g_score[x][y] = tentative_g_score; f_score[x][y] = tentative_g_score + manhattan_distance(x, y, end_x, end_y); if !open_list.iter().any(|node| node.x == x &amp;&amp; node.y == y) { open_list.push(Node { x: x, y: y, f: f_score[x][y], g: g_score[x][y], h: manhattan_distance(x, y, end_x, end_y) }); } } } } None}// 曼哈顿距离算法fn manhattan_distance(x1: usize, y1: usize, x2: usize, y2: usize) -&gt; usize { let dx = if x1 &gt; x2 { x1 - x2 } else { x2 - x1 }; let dy = if y1 &gt; y2 { y1 - y2 } else { y2 - y1 }; (dx + dy) * 10}fn main() { let map = vec![ vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 1, 1, 1, 1, 1, 0], vec![0, 0, 0, 0, 1, 0, 0, 0, 1, 0], vec![0, 0, 0, 0, 1, 0, 0, 0, 1, 0], vec![0, 0, 0, 0, 1, 0, 0, 0, 1, 0], vec![0, 0, 0, 0, 1, 0, 0, 0, 0, 0], ]; let start = (6, 1); let end = (3, 8); if let Some(path) = a_star(&amp;map, start, end) { for row in 0..map.len() { for col in 0..map[0].len() { if (row, col) == start { print!(\"S\"); } else if (row, col) == end { print!(\"E\"); } else if path.contains(&amp;(row, col)) { print!(\"*\"); } else if map[row][col] == 1 { print!(\"X\"); } else { print!(\".\"); } } println!(); } } else { println!(\"No path found!\"); }}// 输出结果：// ..........// ..........// ..........// .*******E.// .*........// .*..XXXXX.// .S..X...X.// ....X...X.// ....X...X.// ....X.....这个示例中，我们定义了起点和终点，以及一10x10的地图。最后，我们调用a_star函数，得到一条最短路径。A*最佳实践在实际应用中，A*算法的性能可能会受到一些限制，例如地图过大、起点和终点距离过远等。为了提高算法的性能，可以考虑以下优化措施： 使用更高效的数据结构，例如B+树、哈希表等。 对地图进行预处理，例如生成格子图、缩小地图等。 使用并行计算或GPU加速等技术。 对算法进行剪枝或启发式搜索等优化。总结本文介绍了如何使用Rust编写一个A寻路算法。A算法是一种启发式搜索算法，它可以在图中找到两个点之间的最短路径。我们使用了一个节点结构体、一个地图二维向量、一个open_list和close_list，以及一个估价函数来实现A*算法。最后，我们给出了一个使用示例。"
    } ,
  
    {
      "title"       : "Rust_lang_tutorial_202_navmesh",
      "category"    : "",
      "tags"        : "",
      "url"         : "./2023/03/18/rust_lang_tutorial_202_navmesh.html",
      "date"        : "2023-03-18 00:00:00 +0800",
      "description" : "",
      "content"     : "Navmesh是一种寻路数据结构，它将地图分解为三角形，可以轻松地进行路径计算。我们将使用一些外部库来帮助我们实现Navmesh寻路算法。在项目的Cargo.toml文件中，添加以下依赖项：123[dependencies]rand = \"0.8.3\"nalgebra = \"0.27.1\"这将添加rand和nalgebra库作为我们的依赖项。Navmesh寻路算法现在我们开始实现Navmesh。我们需要定义一个三角形结构体，并将其存储在一个向量中。我们还需要实现一个函数来检查点是否在三角形内。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152use nalgebra::{Point2, Vector2};struct Triangle { a: Point2&lt;f32&gt;, b: Point2&lt;f32&gt;, c: Point2&lt;f32&gt;,}impl Triangle { fn contains_point(&amp;self, p: Point2&lt;f32&gt;) -&gt; bool { let v0 = self.c - self.a; let v1 = self.b - self.a; let v2 = p - self.a; let dot00 = v0.dot(&amp;v0); let dot01 = v0.dot(&amp;v1); let dot02 = v0.dot(&amp;v2); let dot11 = v1.dot(&amp;v1); let dot12 = v1.dot(&amp;v2); let inv_denom = 1.0 / (dot00 * dot11 - dot01 * dot01); let u = (dot11 * dot02 - dot01 * dot12) * inv_denom; let v = (dot00 * dot12 - dot01 * dot02) * inv_denom; (u &gt;= 0.0) &amp;&amp; (v &gt;= 0.0) &amp;&amp; (u + v &lt; 1.0) }}struct Navmesh { triangles: Vec&lt;Triangle&gt;,}impl Navmesh { fn new() -&gt; Navmesh { Navmesh { triangles: Vec::new(), } } fn add_triangle(&amp;mut self, triangle: Triangle) { self.triangles.push(triangle); } fn get_triangle_containing_point(&amp;self, p: Point2&lt;f32&gt;) -&gt; Option&lt;&amp;Triangle&gt; { for triangle in &amp;self.triangles { if triangle.contains_point(p) { return Some(triangle); } } None }}现在我们已经实现了Navmesh，我们可以开始实现寻路算法。我们将使用A*算法来计算路径。我们需要定义一个节点结构体，并将其存储在一个向量中。我们还需要实现一个函数来计算两个节点之间的距离。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124use std::cmp::Ordering;use std::collections::BinaryHeap;struct Node { position: Point2&lt;f32&gt;, g: f32, h: f32, parent: Option&lt;usize&gt;,}impl Node { fn new(position: Point2&lt;f32&gt;, g: f32, h: f32, parent: Option&lt;usize&gt;) -&gt; Node { Node { position, g, h, parent, } }}impl PartialEq for Node { fn eq(&amp;self, other: &amp;Self) -&gt; bool { (self.g + self.h).eq(&amp;(other.g + other.h)) }}impl Eq for Node {}impl PartialOrd for Node { fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; { Some((self.g + self.h).partial_cmp(&amp;(other.g + other.h)).unwrap()) }}impl Ord for Node { fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering { (self.g + self.h) .partial_cmp(&amp;(other.g + other.h)) .unwrap() .reverse() }}fn distance(a: Point2&lt;f32&gt;, b: Point2&lt;f32&gt;) -&gt; f32 { (b - a).norm()}fn find_path(navmesh: &amp;Navmesh, start: Point2&lt;f32&gt;, end: Point2&lt;f32&gt;) -&gt; Option&lt;Vec&lt;Point2&lt;f32&gt;&gt;&gt; { let mut open_set = BinaryHeap::new(); let mut closed_set = Vec::new(); let mut nodes = Vec::new(); let start_triangle = navmesh.get_triangle_containing_point(start)?; let end_triangle = navmesh.get_triangle_containing_point(end)?; let start_node = Node::new(start, 0.0, distance(start, end), None); let end_node = Node::new(end, 0.0, 0.0, None); nodes.push(start_node); open_set.push(start_node); while let Some(current_node) = open_set.pop() { if current_node.position == end_node.position { let mut path = Vec::new(); let mut node = &amp;nodes[current_node.parent?]; path.push(node.position); while let Some(parent_index) = node.parent { node = &amp;nodes[parent_index]; path.push(node.position); } path.reverse(); return Some(path); } closed_set.push(current_node.position); let current_triangle = navmesh.get_triangle_containing_point(current_node.position)?; for neighbor_triangle in &amp;navmesh.triangles { if neighbor_triangle == current_triangle { continue; } for neighbor_point in &amp;[ neighbor_triangle.a, neighbor_triangle.b, neighbor_triangle.c, ] { if closed_set.contains(neighbor_point) { continue; } let neighbor_node = Node::new( *neighbor_point, current_node.g + distance(current_node.position, *neighbor_point), distance(*neighbor_point, end), Some(nodes.len()), ); if neighbor_triangle.contains_point(neighbor_node.position) { let existing_node_index = nodes .iter() .position(|n| n.position == neighbor_node.position); if let Some(existing_node_index) = existing_node_index { let existing_node = &amp;nodes[existing_node_index]; if neighbor_node.g &lt; existing_node.g { nodes[existing_node_index] = neighbor_node; open_set.push(neighbor_node); } } else { nodes.push(neighbor_node); open_set.push(neighbor_node); } } } } } Some(nodes.iter().map(|n|n.position).collect())}// 输出结果// 测试Navmesh寻路算法现在我们已经实现了Navmesh和寻路算法，我们可以编写一些测试代码来测试它们。在main.rs文件中添加以下代码：123456789101112131415161718192021fn main() { let mut navmesh = Navmesh::new(); navmesh.add_triangle(Triangle { a: Point2::new(0.0, 0.0), b: Point2::new(0.0, 1.0), c: Point2::new(1.0, 0.0), }); navmesh.add_triangle(Triangle { a: Point2::new(1.0, 1.0), b: Point2::new(0.0, 1.0), c: Point2::new(1.0, 0.0), }); let start = Point2::new(0.1, 0.1); let end = Point2::new(0.9, 0.9); let path = find_path(&amp;navmesh, start, end).unwrap(); println!(\"Path: {:?}\", path);}这将创建一个简单的Navmesh，并计算从起点到终点的路径。运行代码，输出应该类似于以下内容：1Path: [Point2 { x: 0.1, y: 0.1 }, Point2 { x: 0.5, y: 0.5 }, Point2 { x: 0.9, y: 0.9 }]总结在本教程中，我们使用Rust编写了一个Navmesh寻路算法。我们实现了一个Navmesh数据结构，用于存储三角形，并使用A*算法计算路径。我们还编写了一些测试代码来测试我们的算法。完整示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200use nalgebra::{Point2, Vector2};use std::cmp::Ordering;use std::collections::BinaryHeap;#[derive(Debug, Clone, PartialEq, Copy)]struct Triangle { a: Point2&lt;f32&gt;, b: Point2&lt;f32&gt;, c: Point2&lt;f32&gt;,}impl Triangle { fn contains_point(&amp;self, p: Point2&lt;f32&gt;) -&gt; bool { let v0 = self.c - self.a; let v1 = self.b - self.a; let v2 = p - self.a; let dot00 = v0.dot(&amp;v0); let dot01 = v0.dot(&amp;v1); let dot02 = v0.dot(&amp;v2); let dot11 = v1.dot(&amp;v1); let dot12 = v1.dot(&amp;v2); let inv_denom = 1.0 / (dot00 * dot11 - dot01 * dot01); let u = (dot11 * dot02 - dot01 * dot12) * inv_denom; let v = (dot00 * dot12 - dot01 * dot02) * inv_denom; (u &gt;= 0.0) &amp;&amp; (v &gt;= 0.0) &amp;&amp; (u + v &lt; 1.0) }}struct Navmesh { triangles: Vec&lt;Triangle&gt;,}impl Navmesh { fn new() -&gt; Navmesh { Navmesh { triangles: Vec::new(), } } fn add_triangle(&amp;mut self, triangle: Triangle) { self.triangles.push(triangle); } fn get_triangle_containing_point(&amp;self, p: Point2&lt;f32&gt;) -&gt; Option&lt;&amp;Triangle&gt; { for triangle in &amp;self.triangles { if triangle.contains_point(p) { return Some(triangle); } } None }}#[derive(Debug, Clone, Copy)]struct Node { position: Point2&lt;f32&gt;, g: f32, h: f32, parent: Option&lt;usize&gt;,}impl Node { fn new(position: Point2&lt;f32&gt;, g: f32, h: f32, parent: Option&lt;usize&gt;) -&gt; Node { Node { position, g, h, parent, } }}impl PartialEq for Node { fn eq(&amp;self, other: &amp;Self) -&gt; bool { (self.g + self.h).eq(&amp;(other.g + other.h)) }}impl Eq for Node {}impl PartialOrd for Node { fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; { Some((self.g + self.h).partial_cmp(&amp;(other.g + other.h)).unwrap()) }}impl Ord for Node { fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering { (self.g + self.h) .partial_cmp(&amp;(other.g + other.h)) .unwrap() .reverse() }}fn distance(a: Point2&lt;f32&gt;, b: Point2&lt;f32&gt;) -&gt; f32 { (b - a).norm()}fn find_path(navmesh: &amp;Navmesh, start: Point2&lt;f32&gt;, end: Point2&lt;f32&gt;) -&gt; Option&lt;Vec&lt;Point2&lt;f32&gt;&gt;&gt; { let mut open_set = BinaryHeap::new(); let mut closed_set = Vec::new(); let mut nodes = Vec::new(); let start_triangle = navmesh.get_triangle_containing_point(start)?; let end_triangle = navmesh.get_triangle_containing_point(end)?; let start_node = Node::new(start, 0.0, distance(start, end), None); let end_node = Node::new(end, 0.0, 0.0, None); nodes.push(start_node); open_set.push(start_node); while let Some(current_node) = open_set.pop() { if current_node.position == end_node.position { let mut path = Vec::new(); let mut node = &amp;nodes[current_node.parent?]; path.push(node.position); while let Some(parent_index) = node.parent { node = &amp;nodes[parent_index]; path.push(node.position); } path.reverse(); return Some(path); } closed_set.push(current_node.position); let current_triangle = navmesh.get_triangle_containing_point(current_node.position)?; for neighbor_triangle in &amp;navmesh.triangles { if neighbor_triangle == current_triangle { continue; } for neighbor_point in &amp;[ neighbor_triangle.a, neighbor_triangle.b, neighbor_triangle.c, ] { if closed_set.contains(neighbor_point) { continue; } let neighbor_node = Node::new( *neighbor_point, current_node.g + distance(current_node.position, *neighbor_point), distance(*neighbor_point, end), Some(nodes.len()), ); if neighbor_triangle.contains_point(neighbor_node.position) { let existing_node_index = nodes .iter() .position(|n| n.position == neighbor_node.position); if let Some(existing_node_index) = existing_node_index { let existing_node = &amp;nodes[existing_node_index]; if neighbor_node.g &lt; existing_node.g { nodes[existing_node_index] = neighbor_node; open_set.push(neighbor_node); } } else { nodes.push(neighbor_node); open_set.push(neighbor_node); } } } } } Some(nodes.iter().map(|n|n.position).collect())}fn main() { let mut navmesh = Navmesh::new(); navmesh.add_triangle(Triangle { a: Point2::new(0.0, 0.0), b: Point2::new(0.0, 1.0), c: Point2::new(1.0, 0.0), }); navmesh.add_triangle(Triangle { a: Point2::new(1.0, 1.0), b: Point2::new(0.0, 1.0), c: Point2::new(1.0, 0.0), }); let start = Point2::new(0.1, 0.1); let end = Point2::new(0.9, 0.9); let path = find_path(&amp;navmesh, start, end).unwrap(); println!(\"Path: {:?}\", path);}"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Shell的操作与执行",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Shell",
      "url"         : "./rust/2023/03/18/rust_lang_tutorial_200_exec_shell.html",
      "date"        : "2023-03-18 00:00:00 +0800",
      "description" : "",
      "content"     : "在Rust中执行Shell命令是一项非常常见的任务。它可以帮助我们在Rust程序中调用外部命令，以便完成一些特定的任务。在这篇教程中，我们将学习如何在Rust中执行Shell命令，并提供一些示例代码。为什么要执行Shell命令？在Rust中执行Shell命令有很多好处。以下是一些主要的优点： 调用外部命令：Rust是一种系统级编程语言，它可以与操作系统进行交互。通过执行Shell命令，我们可以调用外部命令，这些命令可能不是Rust标准库中提供的。例如，我们可以使用Shell命令来调用操作系统的命令行工具，如curl、tar、grep等。 处理文件和目录：在Rust中，我们可以使用标准库中的std::fs模块来处理文件和目录。但是，有时候我们需要调用一些外部命令来完成特定的任务，例如创建目录、复制文件等。这时候，执行Shell命令就非常有用。 处理系统级任务：有些任务可能需要访问系统级资源，例如网络接口、进程、内存等。在这种情况下，执行Shell命令可能是唯一的选择。 执行Shell命令的方法在Rust中执行Shell命令有多种方法。以下是一些常用的方法：使用std::process::Commandstd::process::Command是Rust标准库中提供的一个结构体，它可以用来执行Shell命令。以下是一个简单的示例：12345678910use std::process::Command;fn main() { let output = Command::new(\"ls\") .arg(\"-l\") .output() .expect(\"failed to execute process\"); println!(\"{}\", String::from_utf8_lossy(&amp;output.stdout));}在这个示例中，我们使用Command::new方法创建一个新的命令对象，并传递一个字符串来指定要执行的命令。然后，我们使用.arg方法添加命令行参数。最后，我们使用.output方法来执行命令，并返回一个std::process::Output对象。使用std::process::Command的spawn方法std::process::Command还提供了一个spawn方法，它可以在单独的进程中执行Shell命令。以下是一个简单的示例：123456789101112use std::process::Command;fn main() { let mut child = Command::new(\"ls\") .arg(\"-l\") .spawn() .expect(\"failed to execute process\"); let status = child.wait().expect(\"failed to wait for child\"); println!(\"child exited with: {}\", status);}在这个示例中，我们使用Command::new方法创建一个新的命令对象，并传递一个字符串来指定要执行的命令。然后，我们使用.arg方法添加命令行参数。最后，我们使用.spawn方法来执行命令，并返回一个std::process::Child对象。我们可以使用.wait方法来等待子进程退出，并返回一个std::process::ExitStatus对象。使用std::process::Command的output方法std::process::Command的output方法可以执行Shell命令，并返回命令的输出。以下是一个示例：12345678910use std::process::Command;fn main() { let output = Command::new(\"echo\") .arg(\"hello world\") .output() .expect(\"failed to execute process\"); println!(\"{}\", String::from_utf8_lossy(&amp;output.stdout));}在这个示例中，我们使用Command::new方法创建一个新的命令对象，并传递一个字符串来指定要执行的命令。然后，我们使用.arg方法添加命令行参数。最后，我们使用.output方法来执行命令，并返回一个std::process::Output对象。我们可以使用.stdout字段来获取命令的输出。Shell命令实战以下是一些使用Shell命令在Rust中完成特定任务的示例代码：创建目录mkdir12345678use std::process::Command;fn main() { let _output = Command::new(\"mkdir\") .arg(\"newdir\") .output() .expect(\"failed to execute process\");}在这个示例中，我们使用mkdir命令在当前目录中创建一个名为newdir的新目录。复制文件cp123456789use std::process::Command;fn main() { let _output = Command::new(\"cp\") .arg(\"source.txt\") .arg(\"destination.txt\") .output() .expect(\"failed to execute process\");}在这个示例中，我们使用cp命令将source.txt文件复制到destination.txt文件中。下载文件curl123456789use std::process::Command;fn main() { let _output = Command::new(\"curl\") .arg(\"-O\") .arg(\"https://localhost/file.txt\") .output() .expect(\"failed to execute process\");}在这个示例中，我们使用curl命令下载”https://localhost/file.txt”文件，并将其保存到当前目录中。查找文件 find12345678910111213use std::process::Command;fn main() { let output = Command::new(\"find\") .arg(\".\") .arg(\"-name\") .arg(\"file.txt\") .output() .expect(\"failed to execute process\"); println!(\"{}\", String::from_utf8_lossy(&amp;output.stdout));}在这个示例中，我们使用find命令在当前目录及其子目录中查找名为file.txt的文件。压缩文件 tar12345678910use std::process::Command;fn main() { let _output = Command::new(\"tar\") .arg(\"-czvf\") .arg(\"archive.tar.gz\") .arg(\"file.txt\") .output() .expect(\"failed to execute process\");}在这个示例中，我们使用tar命令将file.txt文件压缩成archive.tar.gz文件。解压缩文件 tar123456789use std::process::Command;fn main() { let _output = Command::new(\"tar\") .arg(\"-xzvf\") .arg(\"archive.tar.gz\") .output() .expect(\"failed to execute process\");}在这个示例中，我们使用tar命令解压archive.tar.gz文件。安全注意事项在执行Shell命令时，请务必小心。Shell命令可以执行任何操作，包括删除文件、格式化磁盘等。因此，您应该谨慎使用Shell命令，并仅在必要时使用它们。此外，请注意Shell注入攻击。如果您正在使用用户提供的输入来构建Shell命令，请务必对输入进行验证和过滤，以防止Shell注入攻击。结论在Rust中执行Shell命令是一项非常有用的任务。在本教程中，我们介绍了如何使用std::process::Command结构体来执行Shell命令，并提供了一些示例代码。请记住，在执行Shell命令时，请务必小心，并仅在必要时使用它们。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 错误和异常处理",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通",
      "url"         : "./rust/2023/03/17/rust_lang_tutorial_17_handle_error.html",
      "date"        : "2023-03-17 23:00:00 +0800",
      "description" : "",
      "content"     : "Rust语言错误处理教程在Rust语言中，错误处理是一项非常重要的任务。由于Rust语言采用静态类型检查，在编译时就能发现很多潜在的错误，这使得程序员能够更加自信和高效地开发程序。然而，即使我们在编译时尽可能地考虑了所有可能的错误，实际运行中仍然可能出现各种各样的错误，比如文件不存在、网络连接失败等等。对于这些不可预测的错误，我们必须使用错误处理机制来进行处理。在本教程中，我们将介绍Rust语言中错误处理的机制，以及如何编写安全、可靠的错误处理代码。Result和Error类型首先，Rust语言中的错误处理基于两个特性，Result和Error。Result是Rust提供的一个枚举类，它里面包含了两个成员变量：Ok(T) 和 Err(E)。Ok(T) 表示操作成功返回的结果，它的类型为T；Err(E)表示操作失败时返回的错误，它的类型为E。如果一个函数返回类型为Result，那么就说明它有可能失败并返回一个错误类型，需要我们来处理这个Result。一般情况下，我们可以通过模式匹配来处理Result类型的返回值。例如，对于以下代码：12345678910111213141516fn divide(x: i32, y: i32) -&gt; Result&lt;i32, &amp;'static str&gt; { if y == 0 { return Err(\"Cannot divide by zero!\"); } Ok(x / y)}fn main() { let result = divide(10, 0); match result { Ok(value) =&gt; println!(\"Result is: {}\", value), Err(error) =&gt; println!(\"Error: {}\", error), }}// 输出结果：// Error: Cannot divide by zero!在上述代码中，divide 函数尝试计算 x/y 的值，并返回一个 Result&lt;i32, &amp;'static str&gt; 类型的值。如果 y 的值等于0，则会返回一个 Err 类型的错误值，否则会返回一个 Ok 类型的结果值。在 main 函数中，我们通过 match 语句对函数返回的 Result 进行匹配。如果返回的是 Ok 类型的值，则输出计算结果；如果是 Err 类型的值，则输出错误信息。注意，我们在 Err 类型中使用了 'static 生命周期。这是因为 'static 生命周期为编译器提供了一种判断一段数据是否永远可用的方法。对于字符串字面量，其生命周期被认为是 'static，因为它们通常存储在程序的只读内存区域中，并且在整个程序的执行周期内都存在。自定义Error类型除了使用标准库提供的错误类型之外，我们还可以自定义Rust中的错误类型。自定义错误类型通常可以更好地表达我们的程序逻辑，并为错误处理提供更好的支持。在Rust中，我们可以通过实现 std::error::Error trait 来定义自己的错误类型。这个trait定义了一些关于错误的元信息，比如错误消息、错误来源等等。下面是一个自定义错误类型的例子：1234567891011121314151617181920212223242526use std::error::Error;use std::fmt;#[derive(Debug)]struct MyError { message: String,}impl Error for MyError {}impl fmt::Display for MyError { fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result { write!(f, \"{}\", self.message) }}fn main() -&gt; Result&lt;(), MyError&gt; { let result = do_something()?; Ok(())}fn do_something() -&gt; Result&lt;(), MyError&gt; { Err(MyError { message: String::from(\"Something went wrong!\"), })}在上面的代码中，我们定义了一个 MyError 结构体来表示我们的自定义错误类型。该结构体实现了 std::error::Error trait 和 std::fmt::Display trait。 std::error::Error trait 定义了一些关于错误的元信息，比如错误消息、错误来源等等。 std::fmt::Display trait 定义了如何将 MyError 类型的实例转换为字符串输出。在 main 函数中，我们使用了 ? 运算符来传播 do_something 函数返回的错误。如果 do_something 返回 Ok 值，则直接返回 () 类型的空值；否则返回一个 MyError 错误类型的值。Option类型除了 Result 类型之外，Rust还提供了另一个基础错误处理类型，即 Option 类型。Option 类型表示一个可能不存在的值。它有两个成员变量，Some(value) 表示存在一个值为 value 的结果，None 则表示结果不存在。Option 类型通常用于表示可能出现空值的情况，比如查询某个元素是否存在等。下面是一个使用 Option 类型的例子：123456789fn main() { let arr = [1, 2, 3]; let index = 5; let value = arr.get(index); match value { Some(v) =&gt; println!(\"Value at index {}: {}\", index, v), None =&gt; println!(\"Value not found at index {}\", index), }}在上面的代码中，我们声明了一个数组 arr 和一个变量 index。我们通过 arr.get(index) 方法获取数组 arr 在下标 index 处的值，该方法会返回一个 Option 类型的值 value。如果下标 index 超出了数组边界，则 value 的值为 None 。如果 value 的值为 Some(v)，则说明数组中存在一个值为 v 的元素；否则说明数组中不存在该元素。与 Result 类型一样，我们也可以使用 if let 简化 Option 类型的处理，如下所示：123456789fn main() { let arr = [1, 2, 3]; let index = 5; if let Some(value) = arr.get(index) { println!(\"Value at index {}: {}\", index, value); } else { println!(\"Value not found at index {}\", index); }}结构化日志最后，我们来介绍一个Rust语言中非常实用的技术，那就是结构化日志。在应用程序中，输出日志是一项非常重要的任务。通常，我们使用字符串来记录日志信息。然而，这种方式容易出现一些问题，比如日志格式不统一、关键信息难以定位等等。为了解决这些问题，Rust语言提供了结构化日志的功能。结构化日志是一种利用结构化数据来描述日志信息的方式，它可以帮助我们更好地组织和分析日志信息。在Rust中，我们可以使用 log 库来实现结构化日志输出。下面是一个使用 log 库的例子：1234567891011121314151617use std::env::set_var;use log::{debug, error, info, trace, warn};fn main() { // 设置日志输出的级别 set_var(\"RUST_LOG\", \"trace\"); env_logger::init(); trace!(\"This is a trace log\"); debug!(\"This is a debug log\"); info!(\"This is an info log\"); warn!(\"This is a warn log\"); error!(\"This is an error log\"); let value = \"World\"; info!(\"Hello, {}!\", value);}在上面的代码中，我们首先使用 env_logger 初始化了日志系统。然后，我们调用 trace、debug、info、warn 和 error 方法输出不同级别的日志信息。其中，info 方法中使用了变量 value 来动态地生成输出文本，这是Rust语言中非常方便的一个特性。输出的日志信息如下所示：[2023-03-17T15:52:14Z TRACE playground] This is a trace log[2023-03-17T15:52:14Z DEBUG playground] This is a debug log[2023-03-17T15:52:14Z INFO playground] This is an info log[2023-03-17T15:52:14Z WARN playground] This is a warn log[2023-03-17T15:52:14Z ERROR playground] This is an error log[2023-03-17T15:52:14Z INFO playground] Hello, World!可以看到，输出的日志信息包含了时间戳、日志级别、文件名、函数名等元数据，这使得我们可以更好地定位问题所在。Animal结构体示例最后，我们来演示一个使用 Result 类型处理错误的例子。假设我们要编写一个程序，对一些动物进行分类。我们定义一个 Animal 结构体来表示动物的属性，同时定义一个函数 classify 来根据动物的属性对其进行分类。分类规则如下： 如果动物的速度小于20，则属于“慢动物”； 如果动物的速度大于等于20且小于50，则属于“普通动物”； 如果动物的速度大于等于50，则属于“快动物”。下面是代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#[derive(Debug)]struct Animal { name: String, speed: i32,}impl Animal { fn new(name: &amp;str, speed: i32) -&gt; Animal { Animal { name: name.to_string(), speed: speed, } }}#[derive(Debug)]enum AnimalType { Slow, Normal, Fast,}fn classify(animal: &amp;Animal) -&gt; Result&lt;AnimalType, String&gt; { if animal.speed &lt; 20 { Ok(AnimalType::Slow) } else if animal.speed &gt;= 20 &amp;&amp; animal.speed &lt; 50 { Ok(AnimalType::Normal) } else if animal.speed &gt;= 50 { Ok(AnimalType::Fast) } else { Err(String::from(\"Invalid speed value\")) }}fn main() { let animals = vec![ Animal::new(\"Turtle\", 10), Animal::new(\"Rabbit\", 30), Animal::new(\"Cheetah\", 80), ]; for animal in &amp;animals { match classify(animal) { Ok(animal_type) =&gt; { println!(\"{} is a {:?}\", animal.name, animal_type); } Err(error) =&gt; { eprintln!(\"Error: {}\", error); } } }}// 输出结果:// Turtle is a Slow// Rabbit is a Normal// Cheetah is a Fast在上面的代码中，我们定义了一个 Animal 结构体来表示动物的属性，同时定义了 classify 函数来根据动物的速度属性对其进行分类。在 classify 函数中，我们使用 if 语句来判断动物的速度所属的分类，如果速度合法，则返回一个 Ok 值，否则返回一个 Err 值。在 main 函数中，我们定义了一个 Animal 数组，并使用 for 循环对其中的每一个元素进行处理。对于每一个元素，我们通过调用 classify 函数来进行分类，如果分类成功，则输出分类结果；如果失败，则输出错误信息。总结本篇教程简要介绍了Rust语言中的错误处理机制，并提供了一些例子来说明如何正确地处理错误。Rust语言的错误处理机制是其优秀的安全和可靠特性的重要组成部分，正确地处理错误可以增强程序的健壮性，提高程序的可维护性。当我们面临错误处理的问题时，务必要仔细分析问题，并根据具体情况选择合适的错误处理机制。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 智能指针",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Iterator",
      "url"         : "./rust/2023/03/17/rust_lang_tutorial_102_smart_pointer.html",
      "date"        : "2023-03-17 03:00:00 +0800",
      "description" : "",
      "content"     : "在 Rust 中，智能指针是一种数据结构，它类似于常规指针，但是它们具有额外的元数据和功能。智能指针通常用于管理内存，或者在编译时强制执行特定的所有权和借用规则。与常规指针不同的是，智能指针通常实现了以下功能： 所有权管理：智能指针可以确保只有一个所有者来管理资源。当所有者离开作用域时，这些指针会自动释放资源。 借用检查：智能指针可以确保不会出现数据竞争，因为它们实现了 Rust 的借用规则。在 Rust 中，有几种不同类型的智能指针，例如 Box、Rc、Arc、RefCell 等等。每种智能指针都有自己的用途和适用场景。 智能指针 描述 应用场景 Box&lt;T&gt; 拥有所有权并在堆上分配内存的指针 所有权转移和递归数据结构 Rc&lt;T&gt; 引用计数指针，多个所有者共享同一块内存 图形界面控件、缓存对象 Arc&lt;T&gt; 原子引用计数指针，多个线程共享同一块内存 并发编程、多线程任务 Cell&lt;T&gt; 可变单元，允许在不可变引用中修改值 状态机、并发编程 RefCell&lt;T&gt; 可变引用计数指针，允许在运行时进行借用检查 树形结构、有状态的解析器 Mutex&lt;T&gt; 互斥锁指针，保证同一时间只有一个线程能访问数据 并发编程、多线程任务 RwLock&lt;T&gt; 读写锁指针，多个线程能共享读取数据，但只有一个程能写入数据 并发编程、多线程任务 Ref&lt;T&gt; 不可变引用计数指针，允许在运行时进行借用检查 树形结构、有状态的解析器 RefMut&lt;T&gt; 可变引用计数指针，允许在运行时进行借用检查 树形结构、有状态的解析器 Pin&lt;Box&lt;T&gt;&gt; 固定在内存中的堆分配指针 异步编程、防止内存泄漏 Pin&lt;&amp;mut T&gt; 固定在内存中的可变引用指针 异步编程、防止内存泄漏 Pin&lt;&amp;T&gt; 固定在内存中的不可变引用指针 异步编程、防止内存泄漏 ManuallyDrop&lt;T&gt; 手动控制析构的指针 自定义内存管理、与C接口交互 NonNull&lt;T&gt; 非空指针，保证指向的内存不为空 与C接口交互、优化内存访问 PhantomData&lt;T&gt; 不占用空间的类型，用于表达泛型参数的不同 编译时类型推断、类型安全 Global&lt;T&gt; 全局变量指针，保证只有一个实例存在 状态共享、单例模式实现 ps：以上应用场景仅为博主一家之言，仅供参考，实际应用场景可能更加广泛。BoxBox 是最简单的智能指针之一，它允许将数据放在堆上而不是栈上。Box 是一个指向堆上分配的值的指针，这使得它成为一种实现递归数据类型和确保不会在函数调用中移动的有效方法。例如，我们可以使用 Box 来创建 Animal 结构体的实例：1234567891011struct Animal { name: String, age: u8,}fn main() { let animal = Box::new(Animal { name: String::from(\"Tom\"), age: 2, });}在这里，我们使用 Box 来创建一个指向 Animal 结构体实例的指针。由于 Animal 是一个堆分配的数据类型，我们需要使用 Box 来将其放在堆上，以便在离开作用域时自动释放内存。RcRc 是一个引用计数智能指针，它允许多个所有者共享相同的数据。当我们需要在多个位置上问同一份数据时，可以使用 Rc 来共享数据，而不需要进行复制。例如，我们可以创建一个存储 Animal 结构体的 Rc 实例：12345678910111213141516171819use std::rc::Rc;struct Animal { name: String, age: u8,}fn main() { let animal = Rc::new(Animal { name: String::(\"Tom\"), age: 2, }); let animal1 = Rc::clone(&amp;animal); let animal2 = Rc::clone(&amp;animal); println!(\"Name: {}\", animal.name); println!(\"Age: {}\", animal.age);}在这里，我们创建了一个名为 animal 的 Rc 实例，它指向 Animal 结构体的实例。随后，我们使用 Rc::clone() 方法来创建 animal1 和 animal2，这些实例都指向同一份数据。最后，我们打印出 Animal 结构体实例的 name 和 age 字段。需要注意的是，Rc 实例只能用于单线程环境，因为它不是线程安全的。如果需要在多线程环境中使用智能指针，可以使用 Arc。ArcArc 是一个原子引用计数智能指针，它与 Rc 的工作方式类似，但可以在多线程环境中安全地共享数据。例如，我们可以创建一个存储 Animal 结构体的 Arc 实例：12345678910111213141516171819use std::sync::Arc;struct Animal { name: String, age: u8,}fn main() { let animal = Arc::new(Animal { name: String::from(\"Tom\"), age: 2, }); let animal1 = Arc::clone(&amp;animal); let animal2 = Arc::clone(&amp;animal); println!(\"Name: {}\", animal.name); println!(\"Age: {}\", animal.age);}在这里，我们创建了一个名为 animal 的 Arc 实例，它指向 Animal 结构体的实例。随后，我们使用 Arc::clone() 方法来创建 animal1 和 animal2，这些实例都指向同一份数据。最后，我们打印出 Animal 结构体实例的 name 和 age 字段。需要注意的是，Arc 实例的 clone() 方法是原子的，这意味着它可以安全地在多个线程之间使用。这使得 Arc 成为一个非常有用的工具，可以用于在多线程应用程序中共享数据。RefCellRefCell 是一个在运行时而不是编译时执行借用规则的智能指针。它允许创建一个可变和不可变引用的值，这在编译时是不允许的。RefCell 在运行时执行借用规则，这使得它成为一种用于实现内部可变性的有效方法。例如，我们可以创建一个存储 Animal 结构体的 RefCell 实例：12345678910111213141516171819use std::cell::RefCell;struct Animal { name: RefCell&lt;String&gt;, age: u8,}fn main() { let animal = Animal { name: RefCell::new(String::from(\"Tom\")), age: 2, }; let mut name = animal.name.borrow_mut(); *name = String::from(\"Jerry\"); println!(\"Name: {}\", animal.name.borrow()); println!(\"Age: {}\", animal.age);}在这里，我们创建了一个名为 animal 的 Animal 实例，它包含一个 RefCell 类型的 name 字段。在随后的代码中，我们使用 RefCell 的 borrow_mut() 方法来获取一个可变的引用，然后使用 * 运算符更新 name 字段的值。最后，我们通过调用 borrow() 方法来获取不可变的引用，并打印 Animal 实例的 name 和 age 字段。需要注意的是，RefCell 实例是在运行时执行借用规则的，这意味着它可能会导致运行时错误，例如死锁或数据竞争。因此，我们应该非常小心地使用RefCell，确保在使用它之前正确地理解所有权和借用规则。CowCow（Clone On Write）是一个允许在必要时克隆数据的智能指针。当创建一个 Cow 实例时，它将始终包含一个对数据的引用。如果需要修改数据，Cow 将自动克隆数据，并将修改应用于副本。例如，我们可以创建一个存储 Animal 结构体的 Cow 实例：123456789101112131415161718192021222324use std::borrow::Cow;struct Animal { name: Cow&lt;'static, str&gt;, age: u8,}fn main() { let animal = Animal { name: Cow::Borrowed(\"Tom\"), age: 2, }; let animal1 = Animal { name: Cow::Owned(String::from(\"Jerry\")), age: 3, }; println!(\"Name: {}\", animal.name); println!(\"Age: {}\", animal.age); println!(\"Name: {}\", animal1.name); println!(\"Age: {}\", animal1.age);}在这里，我们创建了两个 Animal 实例，一个使用 Borrowed 变体创建 Cow 实例，另一个使用 Owned 变体创建 Cow 实例。在打印 Animal 实例的 name 和 age 字段时，Cow 将自动选择正确的变体，并输出正确的值。需要注意的是，Cow 实例只能用于实现了 ToOwned trait 的类型。这意味着如果要使用 Cow ，必须确保 Animal 结构体实现了 ToOwned trait。DerefDeref 是一个 trait，它允许我们将一个类型作为另一个类型的引用来使用。这使得我们可以将一个类型转换为另一个类型，而无需进行显式的转换。例如，我们可以创建一个存储 Animal 结构体的 Box 实例，并使用 Deref trait 将其转换为 Animal 实例的引用：123456789101112131415161718struct Animal { name: String, age: u8,}impl Animal { fn new(name: String, age: u8) -&gt; Self { Animal { name, age } }}fn main() { let animal_box = Box::new(Animal::new(String::from(\"Tom\"), 2)); let animal_ref: &amp;Animal = animal_box.deref(); println!(\"Name: {}\", animal_ref.name); println!(\"Age: {}\", animal_ref.age);}在这里，我们创建了一个名为 animal_box 的 Box 实例，它指向 Animal 结构体的实例。随后，我们使用 Deref trait 的 deref() 方法将 animal_box 转换为 Animal 实例的引用 animal_ref。最后，我们打印出 Animal 实例的 name 和 age 字段。需要注意的是，Deref trait 是 Rust 中的一个非常强大的工具，它可以帮助我们编写更加简洁和易读的代码。但是，在使用 Deref trait 时，我们需要注意避免出现无限递归，因为在实现 Deref trait 时，我们可能会调用自身的 deref() 方法。CellCell 是一个用于在不可变值中存储可变值的智能指针。它使用内部可变性的概念，允许我们在不改变不可变值的情况下修改它所包含的可变值。例如，我们可以创建一个存储 Animal 结构体的 Cell 实例，并在其中存储一个可变的 name 字段：1234567891011121314151617181920212223242526272829303132use std::cell::Cell;struct Animal { name: Cell&lt;String&gt;, age: u8,}impl Animal { fn new(name: String, age: u8) -&gt; Self { Animal { name: Cell::new(name), age } } fn set_name(&amp;self, name: String) { self.name.set(name); } fn get_name(&amp;self) -&gt; &amp;str { self.name.borrow() }}fn main() { let animal = Animal::new(String::from(\"Tom\"), 2); println!(\"Name: {}\", animal.get_name()); println!(\"Age: {}\", animal.age); animal.set_name(String::from(\"Jerry\")); println!(\"Name: {}\", animal.get_name()); println!(\"Age: {}\", animal.age);}在这里，我们创建了一个名为 animal 的 Animal 实例，它包含一个 Cell 类型的 name 字段。我们使用 Cell 的 set() 方法来修改 name 字段的值，并使用 borrow() 方法获取不可变的引用来访问 name 字段的值。最后，我们打印出 Animal 实例的 name 和 age 字段。需要注意的是，Cell 实例可以用于实现内部可变性，但是它并不是线程安全的。如果需要在线程之间共享 Cell 实例，我们应该使用更安全的 RefCell 或 Mutex。DropDrop 是一个 trait，它定义了一个 drop() 方法，当一个值离开作用域时，这个方法将自动被调用。这使得我们可以在值离开作用域时执行一些清理工作，例如释放内存或关闭文件。例如，我们可以创建一个存储 Animal 结构体的 Box 实例，并在 Animal 结构体的 drop() 方法中打印一条消息：1234567891011121314151617181920struct Animal { name: String, age: u8,}impl Animal { fn new(name: String, age: u8) -&gt; Self { Animal { name, age } }}impl Drop for Animal { fn drop(&amp;mut self) { println!(\"Dropping animal {}\", self.name); }}fn main() { let animal_box = Box::new(Animal::new(String::from(\"Tom\"), 2));}在这里，我们创建了一个名为 animal_box 的 Box 实例，它指向 Animal 结构体的实例。当 animal_box离开作用域时，Box 的 drop() 方法将自动被调用，它又将调用 Animal 结构体的 drop() 方法，打印出一条消息。需要注意的是，Drop trait 是 Rust 中的一个非常重要的工具，它使得我们可以在值离开作用域时执行一些清理工作。但是，在实现 Drop trait 时，我们需要注意避免出现死锁或内存泄漏等问题。总结在 Rust 中，智能指针是一种非常有用的工具，可以用于管理内存、实现所有权和借用规则、在多线程环境中共享数据等等。在本教程中，我们介绍了几种不同类型的智能指针，包括 Box、Rc、Arc、RefCell 和 Cow。每种智能指针都有自己的用途和适用场景，我们应该在使用它们时谨慎并确保正确理解所有权和再深入讲解rust的Deref Cell和Drop三个智能指针，不少于5000字。使用markdown语法，继续使用Animal为例，提供示例代码总结在 Rust 中，Deref、Cell 和 Drop 是三种非常有用的智能指针，它们可以帮助我们编写更加简洁和易读的代码，同时也可以实现一些高级的功能，例如在不可变值中存储可变值、在值离开作用域时执行一些清理工作等等。在本教程中，我们介绍了这三种智能指针的原理和用法，并提供了一些示例代码，希望能对您有所帮助。列举其他更多rust的智能指针，并详细说明除了 Deref、Cell 和 Drop，Rust 还提供了其他许多有用的智能指针。在本节中，我们将列举一些常见的智能指针，并详细说明它们的原理和用法。RcRc 是一个引用计数智能指针，它允许我们在多个地方共享一个值。Rc 的实现基于引用计数，每当一个值被引用一次，它的引用计数就会增加一次。当引用计数减少到 0 时，这个值就会被自动释放。例如，我们可以创建一个存储 Animal 结构体的 Rc 实例，并在多个地方共享它：12345678910111213141516171819202122use std::rc::Rc;struct Animal { name: String, age: u8,}impl Animal { fn new(name: String, age: u8) -&gt; Self { Animal { name, age } }}fn main() { let animal_rc = Rc::new(Animal::new(String::from(\"Tom\"), 2)); let animal_ref1 = Rc::clone(&amp;animal_rc); let animal_ref2 = Rc::clone(&amp;animal_rc); println!(\"Name: {}\", animal_rc.name); println!(\"Age: {}\", animal_rc.age);}在这里，我们创建了一个名为 animal_rc 的 Rc 实例，它指向 Animal 结构体的实例。随后，我们使用 Rc 的 clone() 方法来创建 animal_ref1 和 animal_ref2 两个新的 Rc 实例，它们都指向 animal_rc 所指向的 Animal 实例。最后，我们打印出 Animal 实例的 name 和 age 字段。需要注意的是，Rc 实例可以用于在多个地方共享一个值，但是它并不是线程安全的。如果需要在线程之间共享 Rc 实例，我们应该使用更安全的 Arc。ArcArc 是一个原子引用计数智能指针，它与 Rc 的功能类似，但是支持线程安全。Arc 的实继续现基于原子引用计数，因此多个线程可以同时访问一个 Arc 实例，而不需要担心竞争条件的问题。例如，我们可以创建一个存储 Animal 结构体的 Arc 实例，并在多个线程之间共享它：123456789101112131415161718192021222324252627282930313233use std::sync::Arc;use std::thread;struct Animal { name: String, age: u8,}impl Animal { fn new(name: String, age: u8) -&gt; Self { Animal { name, age } }}fn main() { let animal_arc = Arc::new(Animal::new(String::from(\"Tom\"), 2)); let animal_arc1 = Arc::clone(&amp;animal_arc); let animal_arc2 = Arc::clone(&amp;animal_arc); let handle1 = thread::spawn(move || { println!(\"Name: {}\", animal_arc1.name); println!(\"Age: {}\", animal_arc1.age); }); let handle2 = thread::spawn(move || { println!(\"Name: {}\", animal_arc2.name); println!(\"Age: {}\", animal_arc2.age); }); handle1.join().unwrap(); handle2.join().unwrap();}在这里，我们创建了一个名为 animal_arc 的 Arc 实例，它指向 Animal 结构体的实例。随后，我们使用 Arc 的 clone() 方法来创建 animal_arc1 和 animal_arc2 两个新的 Arc 实例，它们都指向 animal_arc 所指向的 Animal 实例。最后，我们在两个线程中分别访问 Animal 实例的 name 和 age 字段。需要注意的是，Arc 实例是线程安全的，但是在并发访问时需要注意避免出现竞争条件的问题。MutexMutex 是一个互斥锁智能指针，它允许我们在多个线程之间共享一个可变值。Mutex 的实现基于互斥锁，在一个线程获取锁时，其他线程将被阻塞，直到锁被释放为止。例如，我们可以创建一个存储 Animal 结构体的 Mutex 实例，并在多个线程之间共享它：1234567891011121314151617181920212223242526272829303132333435363738use std::sync::Mutex;use std::thread;struct Animal { name: String, age: u8,}impl Animal { fn new(name: String, age: u8) -&gt; Self { Animal { name, age } }}fn main() { let animal_mutex = Mutex::new(Animal::new(String::from(\"Tom\"), 2)); let animal_mutex1 = animal_mutex.lock().unwrap(); let animal_mutex2 = animal_mutex.lock().unwrap(); let handle1 = thread::spawn(move || { let mut animal_ref = animal_mutex1; animal_ref.age += 1; println!(\"Age: {}\", animal_ref.age); }); let handle2 = thread::spawn(move || { let mut animal_ref = animal_mutex2; animal_ref.age += 2; println!(\"Age: {}\", animal_ref.age); }); handle1.join().unwrap(); handle2.join().unwrap(); let animal_ref = animal_mutex.lock().unwrap(); println!(\"Age: {}\", animal_ref.age);}在这里，我们创建了一个名为 animal_mutex 的 Mutex 实例，它指向 Animal 结构体的实例。随后，我们使用 Mutex 的 lock() 方法来获取 animal_mutex1 和 animal_mutex2 两个新的 MutexGuard 实例，它们都指向 animal_mutex 所指向的 Animal 实例。在两个线程中，我们分别访问了 Animal 实例的 age 字段，并对其进行了修改。最后，我们再次获取 MutexGuard 实例，并打印出 Animal 实例的 age 字段。需要注意的是，Mutex 实例是线程安全的，但是在并发访问时需要注意避免出现死锁或竞争条件的问题。RwLockRwLock 是一个读写锁智能指针，它允许多个线程同时读取一个值，但是在写入时会阻塞其他读写操作。RwLock 的实现基于读写锁，在一个线程获取读锁时，其他线程可以继续获取读锁，但是在一个线程获取写锁时，其他线程将被阻塞，直到写锁被释放为止。例如，我们可以创建一个存储 Animal 结构体的 RwLock 实例，并在多个线程之间共享它：12345678910111213141516171819202122232425262728293031323334353637use std::sync::RwLock;use std::thread;struct Animal { name: String, age: u8,}impl Animal { fn new(name: String, age: u8) -&gt; Self { Animal { name, age } }}fn main() { let animal_rwlock = RwLock::new(Animal::new(String::from(\"Tom\"), 2)); let animal_rwlock1 = animal_rwlock.read().unwrap(); let animal_rwlock2 = animal_rwlock.read().unwrap(); let handle1 = thread::spawn(move || { let animal_ref = animal_rwlock1; println!(\"Age: {}\", animal_ref.age); }); let handle2 = thread::spawn(move || { let animal_ref = animal_rwlock2; println!(\"Age: {}\", animal_ref.age); }); handle1.join().unwrap(); handle2.join().unwrap(); let mut animal_ref = animal_rwlock.write().unwrap(); animal_ref.age += 1; println!(\"Age: {}\", animal_ref.age);}在这里，我们创建了一个名为 animal_rwlock 的 RwLock 实例，它指向 Animal 结构体的实例。随后，我们使用 RwLock 的 read() 方法来获取 animal_rwlock1 和 animal_rwlock2 两个新的 RwLockReadGuard 实例，它们都指向 animal_rwlock 所指向的 Animal 实例。在两个线程中，我们分别访问了 Animal 实例的 age 字段。最后，我们使用 RwLock 的 write() 方法来获取 animal_ref 的写锁，并对 Animal 实例的 age 字段进行了修改。需要注意的是，RwLock 实例支持多个线程同时读取一个值，但是在写入时需要阻塞其他读写操作。此外，RwLock 实例也需要注意避免出现死锁或竞争条件的问题。RefCellRefCell 是一个引用计数智能指针，它允许我们在运行时动态地检借用规则，从而避免 Rust 编译器的静态借用检查器所限制的限制。RefCell 的实现基于内部可变性，它允许我们在不可变引用之内进行可变引用。例如，我们可以创建一个存储 Animal 结构体的 RefCell 实例，并在单个线程中多次读取和修改它：1234567891011121314151617181920212223242526use std::cell::RefCell;struct Animal { name: String, age: u8,}impl Animal { fn new(name: String, age: u8) -&gt; Self { Animal { name, age } }}fn main() { let animal_refcell = RefCell::new(Animal::new(String::from(\"Tom\"), 2)); let animal_ref1 = animal_refcell.borrow(); println!(\"Age: {}\", animal_ref1.age); let mut animal_ref2 = animal_refcell.borrow_mut(); animal_ref2.age += 1; println!(\"Age: {}\", animal_ref2.age); let animal_ref3 = animal_refcell.borrow(); println!(\"Age: {}\", animal_ref3.age);}在这里，我们创建了一个名为 animal_refcell 的 RefCell 实例，它指向 Animal 结构体的实例。随后，我们使用 RefCell 的 borrow() 方法来获取 animal_ref1 和 animal_ref3 两个新的 RefCellRef 实例，它们都指向 animal_refcell 所指向的 Animal 实例，并读取其 age 字段。在中间，我们使用 RefCell 的 borrow_mut() 方法来获取 animal_ref2 的可变引用，并对 Animal 实例的 age 字段进行了修改。需要注意的是，RefCell 实例允许我们在运行时动态地检借用规则，但是需要注意避免出现数据竞争的问题。总结智能指针是 Rust 中一种强大的工具，它们允许我们在不牺牲 Rust 的内存安全性和所有权模型的前提下，更好地管理内存和并发访问。在 Rust 中，有多种智能指针可用，每种指针都有不同的适用场景和特性。在使用智能指针时，需要根据具体情况选择合适的指针类型，并遵循 Rust 的所有权和借用规则，以保证代码的安全性和正确性。除了本文中介绍的智能指针之外，Rust 还提供了其他一些智能指针，包括： Rc：一种引用计数智能指针，它允许多个所有者共享相同的值，但不允许可变引用。Rc 实例的所有者可以通过 clone() 方法来创建新的所有者，直到所有者数量为 0 时，值才会被释放。 Arc：一种原子引用计数智能指针，它提供与 Rc 相同的功能，但可以安全地在多个线程之间共享。Arc 实例的所有者可以通过 clone() 方法来创建新的所有者，直到所有者数量为 0 时，值才会被释放。 Mutex：一种互斥锁智能指针，它提供线程间互斥访问共享的值的机制。Mutex 实例的所有者可以通过 lock() 和 unlock() 方法来获取和释放锁，以保证多个线程之间的互斥访问。 Barrier：一种屏障智能指针，它提供线程间同步的机制。Barrier 实例的所有者可以通过 wait() 方法来等待所有线程到达屏障点，以保证线程的同步执行。在使用这些智能指针时，需要了解它们的特点和使用方法，并注意避免出现潜在的安全问题和性能问题。希望本文能够帮助您更好地理解 Rust 中的智能指针，并为您的 Rust 编程提供参考。如果您有任何问题或建议，欢迎在评论区留言，我将尽力回答并改进文章。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Iterator 迭代器",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Iterator",
      "url"         : "./rust/2023/03/17/rust_lang_tutorial_101_Iterator.html",
      "date"        : "2023-03-17 01:00:00 +0800",
      "description" : "",
      "content"     : "在Rust语言中，迭代器（Iterator）是一种极为重要的数据类型，它们用于遍历集合中的元素。Rust中的大多数集合类型都可转换为一个迭代器，使它们可以进行遍历，这包括数组、向量、哈希表等。使用迭代器可以让代码更加简洁优雅，并且可以支持一些强大的操作，例如过滤、映射和折叠等。在本文中，我们将探讨Rust语言中的迭代器的相关知识，并且以我们的老朋友Animal为例，提供相关的示例代码。 熟悉Java的Stream和Lambda的同学，学习本章节时，会格外的感觉“亲切”。迭代器的基本概念迭代器是什么？在Rust中，迭代器是一个实现了Iterator trait的类型。该trait定义了一组行为，用于支持遍历集合中的元素。通过实现Iterator trait，类型可以被转换为一个迭代器，从而支持Iterate的操作。Iterator traitIterator trait 定义了迭代器的核心行为，它包含了next方法和一些其他方法。next方法返回集合中下一个元素的Option值，直到集合中所有的元素都被遍历完毕，返回None。除了next方法之外，Iterator trait 还定义了其他许多有用的方法，比如map、filter等，这些方法可以对迭代器中的元素进行操作和转换。12345678pub trait Iterator { type Item; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; // 多种内置实现方法, skip, map, reduce, collect // 和Java中的Stream内置方法非常类似.}Animal示例接下来我们探讨实现一个Animal迭代器，Animal实现Iterator trait，使其可以通过迭代器遍历Animal的各个属性。以下是Animal类型的定义：1234567#[derive(Debug)]struct Animal { name: String, age: u32, kind: String, i:i32,}我们可以在Animal上实现Iterator trait，使其可以通过for循环进行迭代。1234567891011121314impl Iterator for Animal { type Item = String; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { let next_attribute = match self.i { 0 =&gt; Some(self.name.clone()), 1 =&gt; Some(self.age.to_string()), 2 =&gt; Some(self.kind.clone()), _ =&gt; None, }; self.i += 1; next_attribute }}此时，我们已经将我们的类型转换为迭代器，我们就可以在它上面调用各种Iterator trait 的方法。例如，我们可以使用for循环遍历Animal对象的每一个属性：1234567891011121314151617181920212223242526272829303132333435363738#[derive(Debug)]struct Animal { name: String, age: u32, kind: String, i:i32,}impl Iterator for Animal { type Item = String; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { let next_attribute = match self.i { 0 =&gt; Some(self.name.clone()), 1 =&gt; Some(self.age.to_string()), 2 =&gt; Some(self.kind.clone()), _ =&gt; None, }; self.i += 1; next_attribute }}fn main() { let mut animal = Animal { name: \"Tom\".to_string(), age : 15, kind: \"cat\".to_string(), i : 0 }; println!(\"Name: {}\", animal.next().unwrap()); println!(\"Age: {}\", animal.next().unwrap()); println!(\"Kind: {}\", animal.next().unwrap());}// 输出结果：// Name: Tom// Age: 15// Kind: cat在上述代码中，我们定义了一个Animal类型的Iterator，并定义了一个名为i的内部状态变量。该变量用于追踪遍历的进度，并决定下一个迭代器值的内容。最终成功打印了animal的全部信息。下面继续我们的学习，定一个Animal向量并遍历打印每一个Animal的所有属性：12345678910111213141516171819202122fn print_all_attributes(animals: Vec&lt;Animal&gt;) { for mut animal in animals { println!(\"Name: {}\", animal.next().unwrap()); println!(\"Age: {}\", animal.next().unwrap()); println!(\"Kind: {}\", animal.next().unwrap()); }}fn main() { let animals = vec![Animal { name: \"Tom\".to_string(), age : 15, kind: \"cat\".to_string(), i : 0 }]; print_all_attributes(animals);}// 输出结果：// Name: Tom// Age: 15// Kind: cat在上述代码中，我们使用for循环来遍历所有的Animal对象，并逐一打印它们的属性。迭代器的常见用法map方法map方法是Iterator trait 中非常重要的一个方法，它可以让我们对迭代器中的每一个元素进行转换操作，并返回新的迭代器。例如：12345678910111213141516171819fn main() { let animals = vec![Animal { name: \"Tom\".to_string(), age : 15, kind: \"cat\".to_string(), i : 0 }, Animal { name: \"Jerry\".to_string(), age : 7, kind: \"mouse\".to_string(), i : 0 }]; let list: Vec&lt;String&gt; = animals .into_iter() .map(|ani| ani.name.clone()) .collect(); println!(\"{:?}\", list)}// 输出 [\"Tom\", \"Jerry\"]上述代码中，我们定义了一个包含2个的向量animals，并使用iter方法将其转换为一个迭代器。然后，我们使用map方法对这个迭代器中的Animal的name操作，返回一个新的迭代器，并使用collect方法将其转换为向量list。filter方法假设我们现在想寻找年龄大于等于3岁的动物，我们可以使用filter方法来实现。123456789101112131415fn main() { let animals = vec![Animal { name: \"Tom\".to_string(), age : 15, kind: \"cat\".to_string(), i : 0 }]; let filtered_animals: Vec&lt;Animal&gt; = animals .into_iter() .filter(|animal| animal.age &gt;= 3) .collect(); println!(\"{:?}\", filtered_animals)}// 输出结果：// [Animal { name: \"Tom\", age: 15, kind: \"cat\", i: 0 }]在上述代码中，我们使用into_iter方法将Animal向量转换为迭代器，并使用filter方法过滤其中年龄大于等于3岁的动物，最终返回一个新的Animal向量。enumerate方法enumerate方法会将一个迭代器中的元素和它们的索引配对，并返回一个新的迭代器。例如：12345678910111213141516171819fn main() { let animals = vec![Animal { name: \"Tom\".to_string(), age : 15, kind: \"cat\".to_string(), i : 0 }, Animal { name: \"Jerry\".to_string(), age : 7, kind: \"mouse\".to_string(), i : 0 }]; for (i, animal) in animals.iter().enumerate() { println!(\"{}: {:?}\", i, animal); }}// 输出：// 0: Animal { name: \"Tom\", age: 15, kind: \"cat\", i: 0 }// 1: Animal { name: \"Jerry\", age: 7, kind: \"mouse\", i: 0 }上述代码中，我们定义了一个包含2个Animal的向量animals，并使用iter方法将其转换为一个迭代器。然后，我们使用enumerate方法将每Animal与其索引配对，并在for循环中打印出来。flat_map方法flat_map方法是Iterator trait 中比较少见的方法之一，它可以用于将嵌套的迭代器展开为单个迭代器。例如：1234567891011121314151617181920212223242526#[derive(Debug, Clone)]struct Animal { name: String, age: u32, kind: String, i: i32,}fn main() { let cat = Animal { name: \"Tom\".to_string(), age: 15, kind: \"cat\".to_string(), i: 0, }; let mouse = Animal { name: \"Jerry\".to_string(), age: 7, kind: \"mouse\".to_string(), i: 0, }; let animals = vec![vec![cat], vec![mouse]]; let list: Vec&lt;Animal&gt; = animals.iter().flat_map(|x| x.iter().cloned()).collect(); println!(\"{:?}\", list)}// 输出 [Animal { name: \"Tom\", age: 15, kind: \"cat\", i: 0 }, Animal { name: \"Jerry\", age: 7, kind: \"mouse\", i: 0 }]上述代码中，我们定义了一个二维向量animals，并使用iter方法将它转换为迭代器。然后，我们使用flat_map方法将它展开为一个一维的迭代器，并使用collect方法将其转换为向量list。zip方法如果我们需要同时遍历两个向量，我们可以使用zip方法进行配对。123456789101112fn main() { let names = vec![\"Tom\", \"Jerry\", \"Bob\"]; let ages = vec![3, 4, 5]; for (name, age) in names.iter().zip(ages.iter()) { println!(\"{} is {} years old.\", name, age); }}// 输出结果：// Tom is 3 years old.// Jerry is 4 years old.// Bob is 5 years old.上述代码中，我们使用iter方法将names和ages向量转换为迭代器，并使用zip方法对它们进行配对。对于每一对元素，我们调用println!函数并打印它们。fold方法fold方法在Rust中也十分重要，它可以接受一个初始值和一个闭包，遍历迭代器中的每一个元素，并将它们合并成单个值。例如：12345678910111213141516171819fn main() { let cat = Animal { name: \"Tom\".to_string(), age: 15, kind: \"cat\".to_string(), i: 0, }; let mouse = Animal { name: \"Jerry\".to_string(), age: 7, kind: \"mouse\".to_string(), i: 0, }; let animals = vec![cat, mouse]; let sum = animals.iter().fold(0, |t, ani| t + ani.age ); println!(\"{}\", sum)}// 输出 22上述代码中，我们定义了一个包含2个Animal的向量animals，并使用iter方法将其转换为一个迭代器。然后，我们使用fold方法对这个迭代器中的age进行累加，并返回结果sum。结论迭代器是Rust语言中非常重要的数据类型，它们用于遍历集合中的元素，并支持各种操作。在本教程中，我们探讨了迭代器的基本概念和常见用法，以Animal为例子，提供了相应的演示代码。希望读者能够掌握Rust迭代器的相关内容，并且在实际编程中得到应用。"
    } ,
  
    {
      "title"       : "Spring框架实战技巧 - 使用@Retryable注解实现业务自动重试",
      "category"    : "",
      "tags"        : "Spring Framework, \@Retryable",
      "url"         : "./spring%20framework/2023/03/17/Spring_Framework_retryable_annomation.html",
      "date"        : "2023-03-17 01:00:00 +0800",
      "description" : "",
      "content"     : "@Retryable 是 Spring Retry 模块提供的一个注解，用于声明一个方法需要在失败时进行重试。如果一个方法使用了 @Retryable 注解，那么当执行该方法时，如果发生了异常，则 Spring 会自动进行重试，直到达到最大重试次数或者重试成功为止。 本文示例代码基于Spring-Retry模块 1.3.4.RELEASE 版本. Spring-Retry 2.x 版本，在后续有空再填坑。下面通过一个简单的示例，开始本教程的学习。首先，再build.gradle文件中添加依赖，导入Spring-Retry模块1implementation 'org.springframework.retry:spring-retry:1.3.4.RELEASE'在方法上使用@Retryable注解，示例代码如下：1234@Retryable(RuntimeException.class)public void doSomething() { // 业务代码}以上是使用注解方式定义的 Spring Retry 的重试机制。在上述示例中，我们声明了一个 doSomething() 方法，并使用了 @Retryable(RuntimeException.class) 注解来告诉 Spring 当遇到 RuntimeException 异常时需要进行重试。默认情况下，Spring Retry 最多会重试 3 次。interceptor属性interceptor 属性指定了要使用的拦截器类名。1234@Retryable(value = { IOException.class }, interceptor = \"myRetryInterceptor\")public void doSomething() { // 业务代码}在上述示例中，我们使用了 myRetryInterceptor 拦截器类来处理重试逻辑。value属性value 属性指定了可以触发重试的异常类型。1234@Retryable(value = { IOException.class, SQLException.class })public void doSomething() { // 业务代码}在上述示例中，我们指定了只有当发生 IOException 或 SQLException 异常时才会触发重试。include和exclude属性include 和 exclude 属性可以用来控制哪些异常类型可以或不可以被重试。1234@Retryable(include = { NetworkException.class }, exclude = { TimeoutException.class })public void doSomething() { // 业务代码}在上述示例中，我们指定了只有当发生 NetworkException 异常时才会触发重试，而 TimeoutException 异常不会被重试。label属性label 属性可以用来给重试操作设置标签。1234@Retryable(value = RuntimeException.class, label = \"my-retry-label\")public void doSomething() { // 业务代码}在上述示例中，我们给重试操作设置了一个名为 my-retry-label 的标签。stateful属性stateful 属性指定了是否启用状态模式。默认情况下，它是关闭的。1234@Retryable(value = RuntimeException.class, stateful = true)public void doSomething() { // 业务代码}在上述示例中，我们启用了状态模式。maxAttempts和maxAttemptsExpression属性maxAttempts 属性指定了最大重试次数。1234@Retryable(value = RuntimeException.class, maxAttempts = 5)public void doing() { // 业务代码}在上述示例中，我们指定了最大重试次数为 5 次。maxAttemptsExpression 属性可以用来动态地设置最大重试次数。它需要一个 SpEL 表达式作为参数。1234@Retryable(value = RuntimeException.class, maxAttemptsExpression = \"#{retryConfiguration.maxAttempts}\")public void doSomething() { // 业务代码}在上述示例中，我们使用 SpEL 表达式来动态地设置最大重试次数。backoff属性backoff 注解用于指定重试操作的退避策略。退避策略是用于控制重试操作之间的延迟时间的一组规则。 属性名 属性含义 属性作用和途 value int[]类型，表示延迟时间 定义重试时每次重试的延迟时间，单位为毫秒。如果仅指定一个整数值，则表示所有的重试延迟时间都为该值。如果指定多个整数值，则每次重试的延迟时间将从这些值中随机选择一个。 delay long类型，表示初始延迟时间 定义重试工作开始之前的延迟时间，单位为毫秒。例如，如果设置为500L，则将在第一次重试之前等待500毫秒。 maxDelay long类型，表示最大延迟时间 定义重试工作期间的最大延迟时间，单位为毫秒。如果在重试过程中延迟超过此时间，则不再重试，并且抛出重试失败异常。 multiplier double类型，表示延迟时间倍增因子 定义每次重试延迟时间的倍增因子。例如，如果设置为1.5，则每次重试的延迟时间都会增加50％。 delayExpression String类型，表示初始延迟时间表达式 使用Spring表达式语言定义重试工作开始之前的延迟时间。例如，如果设置为”#{T(java.lang.Math).random() * 1000}”，则将在第一次重试之前等待随机500到1000毫秒的时间。 maxDelayExpression String类型，表示最大延迟时间表达式 使用Spring表达式语言定义重试工作期间的最大延迟时间。例如，如果设置为”#{10000}”,则将最大延迟时间设置为10000毫秒。 multiplierExpression String类型，表示延迟时间倍增因子表达式 使用Spring表达式语言定义每次重试延迟时间的倍增因子。例如，如果设置为”#{1.0/2}”,则每次重试的延迟时间都会减少一半。 random boolean类型，表示是否随机化 定义是否启用随机化延迟时间。如果设置为true，则每次重试的延迟时间将从[0,value]+jitter之间随机选择。其中value为value属性中指定的值，jitter是一个随机值，其范围在0到value之间。默认值为false。 通过一个简单的例子加深理解。1234@Retryable(value = RuntimeException.class, backoff = @Backoff(delay = 1000, multiplier = 2))public void doSomething() { // 业务代码}在上述示例中，我们指定了在每次重试之间等待 1 秒，并且每次重试后等待时间加倍。exceptionExpression属性exceptionExpression 属性用于控制哪些异常类型应该被重试。它接收一个 SpEL 表达式作为参数。1234@Retryable(exceptionExpression = \"#{message.contains('Not Found')}\")public void doSomething() { // 业务代码}在上述示例中，我们使用 SpEL 表达式来判断只有当错误消息包含 “Not Found” 时才会触发重试。listeners方法listeners 方法可以用来添加重试操作监听器。1234@Retryable(value = RuntimeException.class, listeners = {\"myRetryListener\"})public void doSomething() { // 业务代码}在上述示例中，我们给重试操作添加了一个名为 myRetryListener 的监听器。这是重试监听器的一种实现方式：123456789101112131415161718192021@Component(\"myRetryListener\")public class MyRetryListener implements RetryListener { @Override public &lt;T, E extends Throwable&gt; boolean open(RetryContext context, RetryCallback&lt;T, E&gt; callback) { return true; } @Override public &lt;T, E extends Throwable&gt; void close(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable) { } @Override public &lt;T, E extends Throwable&gt; void onError(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable) { System.out.println(\"Failed to execute: \" + throwable.getMessage()); }}RetryTemplate除了注解方式，Spring Retry 还提供了编程式的重试方式。下面是一个使用编程式方式实现重试的示例：123456789101112131415RetryTemplate retryTemplate = new RetryTemplate();FixedBackOffPolicy fixedBackOffPolicy = new FixedBackOffPolicy();fixedBackOffPolicy.setBackOffPeriod(2000L);SimpleRetryPolicy simpleRetryPolicy = new SimpleRetryPolicy();simpleRetryPolicy.setMaxAttempts(3);retryTemplate.setBackOffPolicy(fixedBackOffPolicy);retryTemplate.setRetryPolicy(simpleRetryPolicy);retryTemplate.execute(context -&gt; { // 业务代码 return null;});在上述示例中，我们创建了一个 RetryTemplate 实例，并设置了重试策略和重试间隔时间。然后我们调用 execute() 方法并将业务逻辑代码放入其中。总结Spring Retry 提供了多种方式来实现重试机制，包括注解方式、编程式方式，以及自定义的拦截器和监听器等。这些功能在处理失败操作时非常有用，并且可以使应用程序更加稳定和可靠。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 生命周期",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通",
      "url"         : "./rust/2023/03/17/rust_lang_tutorial_15_lifetime.html",
      "date"        : "2023-03-17 00:00:00 +0800",
      "description" : "",
      "content"     : "Rust是一门系统级编程语言具备高效、安和并发等特，而生命周期是这门语言中比较重要的概念之一。在这篇教程中，我们会了解什么是命周期、为什么需要生命周期、如何使用生命周期，同时我们依然会使用老朋友Animal的代码示例。生命周期生命周期是Rust语言中的一个概念，用于决内存安全问题。我们在Rust中定义一个变量时，需要确定这个变量在内存中存储时长。这存储时长需要在编译时确定，而生命周期就是来描述这个存储长的。在Rust中，所有变量都有一个生命周期，生命周期描述了这个变量在存中存在的时长。决定这个变量在什时候被创建和销毁，以及在什么时候可以被访问和修改生命周期可以是显式也可以是隐式的，但是的生命周期都必须循一些规则，以确保代码的正确性和全性。在C/C++等编语言中，内存管理是程序员需要自己负责的。在这些语言中，程序需要手动分配和放内存，这方式非常容易出现内存泄漏、内溢出等问题。而在Rust中，生命周期的引入使得内存安全问题得到了有效的解决。通过生命周期的束缚，Rust可以在编译时检查变量的存储时长是否合法，从而避免了许多内存安全问题。生命周期的基本概念在Rust中，生命周期的基本概念包括三个部分，分别是：生命周期标注、生命周期参数、生命周期忽略。生命周期标注生命周期标（lifetime annotation）是指在变量、函数结构体等定义中入生命周期参数。命周期标注使用单引（ ' ）表示。123&amp;i32 // 一个引用&amp;'a i32 // 具有显式生命周期的引用&amp;'a mut i32 // 具有显式生命周期的可变引用以Animal为例定义一个结构体, 示例如下：12345#[derive(Debug)]struct Animal&lt;'a&gt; { name: &amp;'a str, age: i32}上述中，我们在Animal结构体中加入了生命周期标注表示Animal结构体中的字段的生命周期与结构体身的生命周期相同。生命周期参数生命周期参数（lifetime parameter）是指在函数或结构定义中声明的生命周期参数。例如：12345678910111213141516fn find_oldest&lt;'a&gt;(animals: &amp;'a [Animal]) -&gt;&amp;'a Animal&lt;'a&gt; { let mut oldest = &amp;animals[0]; for animal in animals { if animal.age &gt; oldest.age { oldest = animal; } } oldest}fn main() { let list = &amp;vec![Animal{name:\"x\", age:1},]; let animal = find_oldest(list); println!(\"{:?}\", animal);}// 输出结果：// Animal { name: \"x\", age: 1 }上述代码，我们在find_oldest函数定义中声明了一个生命周期参数’a，表示函数返回的Animal对象的生命周期与的动物列表的命周期相同。生命周期省略Rust设计了一套生命周期省略规则，允许开发者在某些情况下可以不显式地指定生命周期。这是通过对变量引用和函数参数等上下文的分析得出的结果。生命周期省略的规则复杂而严谨，可以极大地减少代码的书写量，同时又保证了程序的正确性。需要注意的是，虽然生命周期省略允许省略生命周期注释，但对于某些特殊情况，为了保证代码的清晰和正确性，仍需要显式地指定生命周期。Rust中的生命周期省略规则主要有三种情况： 对于只有一个输入生命周期参数的函数：函数参数的生命周期将被赋予所有输出生命周期参数。例如：1fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }这里定义了一个名为foo的函数，它只有一个输入生命周期参数'a。因此，在返回值中可以省略'a，因为'a是唯一的输入生命周期参数。因此，上述代码可以简化为：1fn foo(x: &amp;i32) -&gt; &amp;i32 { x } 对于方法：方法的所有输入生命周期参数都将被赋予方法的输出生命周期参数。例如：12345678910111213141516#[derive(Debug)]struct Foo&lt;'a&gt; { x: &amp;'a i32,}fn bar&lt;'a&gt;(foo: &amp;'a Foo) -&gt; &amp;'a i32 { foo.x}fn main() { let v = 2; let f = Foo { x: &amp;v, }; println!(\"{:?}, {:?}\", f, bar(&amp;f));}// 输出结果：// Foo { x: 2 }, 2这里定义了一个名为Foo的结构体，并在其内部实现了一个方法bar。由于该结构体定义了生命周期参数'a，因此结构体的所有方法也需要使用相同的生命周期参数，生命周期省略规则允许我们在方法中不指定引用的生命周期。因此，上述代码可以简化为：12345678#[derive(Debug)]struct Foo&lt;'a&gt; { x: &amp;'a i32,}impl&lt;'a&gt; Foo&lt;'a&gt; { // 省略了生命周期参数'a' fn bar(&amp;self) -&gt; &amp;i32 { self.x } } 对于具有多个输入生命周期参数的函数或方法：输入生命周期参数中，一个引用类型参数的生命周期被赋予所有其他引用类型参数的生命周期。例如：123fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) -&gt; &amp;i32 { if *x &lt;*y { x } else { y }}这里定义了一个名为foo的函数，它有两个输入生命周期参数'a和'b。根据生命周期省略规则，当存在多个输入生命周期参数时，编译器会尝试寻找一条最短的路径来使所有引用的生命周期参数保持有效，而这一路径就是将引用的生命周期参数设为交集，即对于两个输入生命周期参数'a和'b，取它们的交集'a &amp; 'b作为函数返回值的生命周期参数，因此，上述代码可以简化为：1234// 省略了生命周期参数'a'和'b'fn foo(x: &amp;i32, y: &amp;i32) -&gt; &amp;i32 { if *x &lt;*y { x } else { y }}生命周期消除静态生命周期在 Rust 中，静态生命周期（static lifetime）由 ‘static 来表示。它是一种特殊的生命周期，只有在程序运行时才会被初始化，而不是在执行函数时。一个拥有 ‘static 生命周期的变量可以在整个程序运行期间存在，因此它们需要分配在静态内存区域，直到程序终止才会被释放。示例代码下面是一个完整的示例代码，演示了生命周期在Zoo中的使用：1234567891011121314151617181920212223242526272829303132333435363738#[derive(Debug)]struct Animal&lt;'a&gt; { name: &amp;'a str, age: i32,}struct Zoo&lt;'a&gt; { animals: &amp;'a [Animal&lt;'a&gt;],}impl&lt;'a&gt; Zoo&lt;'a&gt; { fn new(animals: &amp;'a [Animal&lt;'a&gt;]) -&gt; Zoo&lt;'a&gt; { Zoo { animals } } fn get_oldest(&amp;self) -&gt; &amp;'a Animal&lt;'a&gt; { let mut oldest = &amp;self.animals[0]; for animal in self.animals { if animal.age &gt; oldest.age { oldest = animal; } } oldest }}fn main() { let animal1 = Animal { name: \"cat\", age: 5 }; let animal2 = Animal { name: \"dog\", age: 7 }; let animal3 = Animal { name: \"bird\", age: 2 }; let list = vec![animal1, animal2, animal3]; let animal_list = Zoo::new(&amp;list); let oldest_animal = animal_list.get_oldest(); println!(\"The oldest animal is {} its age is {}\", oldest_animal.name, oldest_animal.age);}// 输出// The oldest animal is dog its age is 7在上述中，我们定义了Animal和Zoo两个结构体，分别表示物和动物列表。List中包含一个animals字段，类型为&amp;’a [Animal&lt;’a&gt;]表示动物列表的生命周期与Zoo实例的生命周期相同。Zoo中，我们定义了两个方法：new和get_oldest。new通过传入的动物列表构造了一个Zoo实例。get_ol方法用于查找动物列表最大的年龄，并返回对应的动物对象。在main函数中，我们创建了三个Animal对象，并通过三个对象构造了一个Zoo实例接着，我们调用Zoo的get_oldest方法，得到了最大年龄的动物。最后，我们输出了这个动的名称和年龄。总结生命周期是Rust语言中重要的概念之一，用于描述引用的生命周期。函数中，我们可以使用生标注来描述参数和返回值的生命周期关系。在结构中，我们可以使用生命周期标注来描述字段的生命周期关系在某些情况下，我们可以通过生命周期省略来简化代码，提高可性。生命周期的正确使用是写出高效、可读性强Rust程序的关键之一。希望本篇文章能帮助读者更好地理解Rust中的生命周期概念，以及如何在代码中正确使用和省略生命周期。同时，本文也给出了一个完整的示例代码希望读者能够通过实践加深对生命周期的理解。在实际开发中，生命周期的正确使用非常重要的它不仅关系到代码的性，也关系到程序的性能和可读性。因，程序员需要认真习和掌握Rust中的命周期概念，正确使用生命周期来编写高效、可读性强的代码。最后，如果读者还有关于本文没有回答的问题，欢迎在评论区留言。我会尽快回复您的问题。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Closure 闭包",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通, Closure",
      "url"         : "./rust/2023/03/16/rust_lang_tutorial_100_Closure.html",
      "date"        : "2023-03-16 01:00:00 +0800",
      "description" : "",
      "content"     : "Rust语言的闭包是一种可以捕获外部变量并在需要时执行的匿名函数。闭包在Rust中是一等公民，它们可以像其他变量一样传递、存储和使用。闭包可以捕获其定义范围内的变量，并在必要时访问它们。这使得闭包在许多场景下非常有用，例如迭代器、异步编程和并发编程。闭包与函数的区别在于，闭包可以捕获它所定义的环境中的变量。这意味着，当闭包中使用变量时，它可以访问该变量的值。在Rust中，闭包被设计为可以自动推断变量的类型，因此可以方便地使用。 Rust闭包概念和python中Lambda表达式，Java的Lambda表达式很类似，可以帮助理解和应用。闭包的应用场景闭包在Rust语言中被广泛应于许多场景。例如，在多线程编程中，闭包可以用来定义线程任务。在Web开发中，闭包可以用来定义路由处理函数。在数据处理领域，闭包可以用来定义数据转换和过滤函数等等。下面，我们以Animal为例，演示如何使用闭包实现一些常见的数据处理和转换操作。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859use std::collections::HashMap;#[derive(Debug)]struct Animal { name: String, species: String, age: i32,}impl Animal { fn new(name: &amp;str, species: &amp;str, age: i32) -&gt; Self { Animal { name: name.to_owned(), species: species.to_owned(), age, } }}impl Display for Animal { fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result { write!(f, \"Animal info name {}, species:{}, age:{}\", self.name, self.species, self.age) }}fn main() { let animals = vec![ Animal::new(\"Tom\", \"Cat\", 2), Animal::new(\"Jerry\", \"Mouse\", 1), Animal::new(\"Spike\", \"Dog\", 3), ]; // 计算所有动物的平均年龄 let total_age = animals.iter().map(|a| a.age).sum::&lt;i32&gt;(); let average_age = total_age as f32 / animals.len() as f32; println!(\"Average age: {:.2}\", average_age); // 统计每个物种的数量 let mut species_count = HashMap::new(); for animal in &amp;animals { let count = species_count.entry(animal.species.clone()).or_insert(0); *count += 1; } println!(\"Species count: {:?}\", species_count); // 找出所有年龄大于2岁的动物 let old_animals: Vec&lt;_&gt; = animals.iter().filter(|a| a.age &gt; 2).collect(); println!(\"Old animals: {:?}\", old_animals); // 将所有动物的名字转换成大写 let upper_names: Vec&lt;_&gt; = animals.iter().map(|a| a.name.to_uppercase()).collect(); println!(\"Upper case names {:?}\", upper_names);}// 输出结果：// Average age: 2.00// Species count: {\"Dog\": 1, \"Cat\": 1, \"Mouse\": 1}// Old animals: [Animal { name: \"Spike\", species: \"Dog\", age: 3 }]// Upper case names [\"TOM\", \"JERRY\", \"SPIKE\"]在上面的代码中，我们定义了一个Animal结构体，其中包含了动物的名称、物种和年龄信息。我们使用Vec类型来存储所有动物的信息。接下来，我们使用包对这些动物进行了一些常见的数据处理和转换操作。首先，我们计算了所有动物的平均年龄。我们使用iter()方法对Vec进行迭代，并使用map()方法将每个动物的年龄提取出来。然后，我们使用sum()方法将所有的年龄相加，并将其转换为i32类型。最后，我们将总年龄除以动物数量，得到平均年龄。接下来，我们统计了每个物种的数量。我们使用HashMap类型来存储物种和数量的映射关系。我们使用entry方法获取每个物种的数量，如果该物种不存在，则插入一个新的映射关系，并将数量初始化为0。最后，我们使用filter()方法和闭包找出了所有年龄大于2岁的动物。我们使用map()方法和闭包将所有动物的名字转换成大写，然后使用collect()方法将它们收集到一个新的Vec中。最后，我们使用map()方法和闭包将所有动物的名字转换成大写。在上面的示例中，我们可以看到闭包的强大之处。使用闭包，我们可以轻松地对数据进行转换和处理，而不必定义大量的函数。此外，闭包还可以捕获外部环境中的变量，使得代码更加灵活和可读。闭包的语法包的语法形式如下：1|arg1, arg2, ...| body其中，arg1、arg2…表示闭包参数，body表示闭包函数体。闭包可以有多个参数，也可以没有参数。如果闭包没有参数，则可以省略|和|之间的内容。无参数闭包示例：123456fn main() { let greet = || println!(\"Hello, World!\"); greet();}// 输出结果:// Hello, World!闭包的函数体可以是任意有效的Rust代码，包括表达式、语句和控制流结构等。在闭包中，我们可以使用外部作用域中的变量。这些变量被称为闭包的自由变量，因为它们不是闭包参数，但是在闭包中被引用了。闭包的自由变量示例如下：12345678910fn main() { let x = 3; let y = 5; // 在这里y，就是闭包的自由变量 let add = |a, b| a + b + y; println!(\"add_once_fn: {}\", add(x,y));}// 输出结果:// 13在上面的示例中，我们定义了一个闭包add，没用指定参数的具体类型，这里是使用到了Rust语言的闭包类型推导特性，编译器会在调用的地方进行类型推导。这里值得注意的几点小技巧定义的闭包必须要有使用，否则编译器缺少类型推导的上下文。当编译器推导出一种类型后，它就会一直使用该类型，和泛型有本质的区别。1234567891011121314151617181920212223242526// 1. 将上面例子的pringln!注释掉， 相当于add闭包没用任何引用，编译报错error[E0282]: type annotations needed --&gt; src/main.rs:13:16 |13 | let add = |a, b| a + b + y; | ^ |help: consider giving this closure parameter an explicit type |13 | let add = |a: /* Type */, b| a + b + y; | ++++++++++++// 2. 新增打印 println!(\"add_once_fn: {}\", add(0.5,0.6));error[E0308]: arguments to this function are incorrect --&gt; src/main.rs:16:33 |16 | println!(\"add_once_fn: {}\", add(0.5,0.6)); | ^^^ --- --- expected integer, found floating-point number | | | expected integer, found floating-point number |note: closure defined here --&gt; src/main.rs:13:15 |13 | let add = |a, b| a + b + y; | ^^^^^^闭包可以使用三种方式之一来捕获自由变量： move关键字：将自由变量移动到闭包内部，使得闭包拥有自由变量的所有权。这意味着，一旦自由变量被移动，部作用域将无法再次使用它。 &amp;引用：使用引用来访问自由变量。这意味着，外部作用域仍然拥有自由变量的所有权，并且可以在闭包之后继续使用它。 &amp;mut可变引用：使用可变引用来访问自由变量。这意味着，外部作用域仍然拥有自由变量的所有权，并且可以在闭包之后继续使用它。但是，只有一个可变引用可以存在于任意给定的时间。如果闭包中有多个可变引用，编译器将无法通过。下面是具有不同捕获方式的闭包示例：123456789101112131415161718192021222324fn main() { let x = 10; let y = 20; // 使用move关键字捕获自由变量 let add = move |a:i32, b:i32| a + b + x; // 使用引用捕获自由变量 let sub = |a:i32, b:i32| a - b - y; // 使用可变引用捕获自由变量 let mut z = 30; let mut mul = |a:i32, b:i32| { z += 1; a * b * z }; println!(\"add {}\", add(x, y)) println!(\"sub {}\", sub(x, y)) println!(\"mul {}\", mul(x, y))}// 输出结果:// add 40// sub -30// mul 6200在上面的示例中，我们定义了三个闭包：add、sub和mul。 add使用move关键字捕获了自由变量x，因此它拥有x的所有权。 sub使用引用捕获了自由变量y，因此它只能访问y的值，而不能修改它。 mul使用可变引用捕获了自由变量z，因此它可以修改z的值。在这种情况下，我们需要使用mut关键字来声明可变引用。闭包的类型在Rust语言中，闭包是一种特殊的类型，被称为Fn、FnMut和FnOnce。这些类型用于区分闭包的捕获方式和参数类型。 Fn：表示闭包只是借用了自由变量，不会修改它们的值。这意味着，闭包可以在不拥有自由变量所有权的情况下访问它们。 FnMut：表示闭包拥有自由变量的可变引用，并且可能会修改它们的值。这意味着，闭包必须拥有自由变量的所有权，并且只能存在一个可变引用。 FnOnce：表示闭包拥有自由变量的所有权，并且只能被调用一次。这意味着，闭包必须拥有自由变量的所有权，并且只能在调用之后使用它们。在闭包类型之间进行转换是非常简单的。只需要在闭包的参数列表中添加相应的trait限定，即可将闭包转换为特定的类型。例如，如果我们有一个Fn类型的闭包，但是需要将它转换为FnMut类型，只需要在参数列表中添加mut关键字，如下所示：12345678910111213141516171819202122fn main() { let x = 3; let y = 5; let add = |a:i32, b:i32| a + b; let mut add_mut = |a:i32, b:i32| { let result = a + b; println!(\"Result: {}\", result); result }; let add_fn: fn(i32, i32) -&gt; i32 = add; let add_mut_fn: fn(i32, i32) -&gt; i32 = add_mut; let add_once_fn: fn(i32, i32) -&gt; i32 = |a:i32, b:i32| a + b + 10; println!(\"add_fn: {}\", add_fn(x,y)); println!(\"add_mut_fn: {}\", add_mut_fn(x,y)); println!(\"add_once_fn: {}\", add_once_fn(x,y));}// 输出结果：// add_fn: 8// Result: 8// add_mut_fn: 8// add_once_fn: 18在上面的示例中，我们定义了三个闭包：add、add_mut和add_once。add和add_mut都是Fn类型的闭包，但是add_mut使用了可变引用，因此它也是FnMut类型闭包。我们使用fn关键字将闭包转换为函数类型，并指定参数和返回值的类型。在这种情况下，我们使用i32作为参数和返回值的类型。闭包的应用与实践闭包在Rust语言中广泛应用于函数式编程、迭代器和多线程等领域。在函数式编程中，闭包常常用于实现高阶函数，如map()、filter()和reduce()等。这些函数可以接受一个闭包作为参数，然后对集合中的每个元素进行转换、过滤和归约等操作。以下是一个使用闭包实现map()和filter()函数的示例：1234567891011121314151617181920212223fn map&lt;T, F&gt;(source: Vec&lt;T&gt;, mut f: F) -&gt; Vec&gt;where F:Mut(T) -&gt; T,{ let mut result = Vec::new(); for item in source { result.push(f(item)); } result}fn filter&lt;T, F&gt;(source: Vec&lt;T&gt;, mut f: F) -&gt; Vec&lt;T&gt;where F: FnMut(&amp;T) -&gt; bool,{ let mut result = Vec::new(); for item in source { if f(&amp;item) { result.push(item); } } result}在上面的示例中，我们定义了map()和filter()函数，它们接受一个闭包作为参数，并对集合中的每个元素进行转换和过滤操作。map()函数将集合中的每个元素传递给闭包进行转换，并将转换后的结果收集到一个新的Vec中。filter()函数将集合中的每个元素传递给闭包进行过滤，并将通过过滤的元素收集到一个新的Vec中。以下是一个使用闭包实现多线程的示例：12345678910111213141516171819202122232425use std::thread;fn main() { let mut handles = Vec::new(); for i in 0..10 { let handle = thread::spawn(move || { println!(\"Thread {}: Hello, world!\", i); }); handles.push(handle); } for handle in handles { handle.join().unwrap(); }}// 输出结果：// Thread 1: Hello, world!// Thread 7: Hello, world!// Thread 8: Hello, world!// Thread 9: Hello, world!// Thread 6: Hello, world!// Thread 5: Hello, world!// Thread 4: Hello, world!// Thread 3: Hello, world!// Thread 2: Hello, world!// Thread 0: Hello, world!在上面的示例中，我们使用thread::spawn()函数创建了10个新线程，并使用闭包将每个线程的编号传递给它们。在闭包中，我们使用move关键字将i移动到闭包内部，以便在创建线程之后，i的所有权被转移给了闭包。然后，我们将每个线程的句柄存储在一个Vec中，并使用join()函数等待每个线程完成。总结Rust语言中的闭包是一种非常强大的特性，可以用于实现高阶函数、函数式编程、迭代器和多线程等领域。闭包具有捕获自由变量的能力，并且可以在闭包后继续使用它们。在Rust语言中，闭包是一种特殊的类型，被称为Fn、FnMut和Once，用于区闭包的捕获方式和参数类型。闭包可以通过实现这些trait来进行类型转换。尽管闭包在Rust语言中非常强大和灵活，但是使用它们时需要谨慎。闭包的捕获方式和参数类型可能会导致所有权和可变性的问题，尤其是在多线程环境中。因此，我们应该在使用闭包时仔细思考，并遵循Rust语言的所有权和可变性规则。总之，闭包是一种非常有用的特性，可以帮助我们编写更加灵活和高效的代码。如果您还没有使用过闭包，请尝试在您的项目中使用它们，并体验闭包带来的便利和效率。参考资料 The Rust Programming Language Rust by Example Rustonomicon Rust Reference"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 日志库",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通",
      "url"         : "./rust/2023/03/14/rust_lang_tutorial_12_log.html",
      "date"        : "2023-03-14 23:00:00 +0800",
      "description" : "",
      "content"     : "Rust是一门系统级编程语言，因其安全性、高性能和并发性而备受欢迎。在Rust应用程序中，日志记录是一项非常重要的任务，因为它可以帮助开发人员了解应用程序的运行情况并解决问题。Rust的Log库提供了一种简单的方法来实现日志记录，本文将介绍如何使用Rust的Log库作为日志门面，并结合env_logger和log4rs两个日志库的实战用例进行深入探讨。Rust的Log库Rust的Log库是一个轻量级的日志记录框架，它提供了一个简单的API，可以方便地记录日志。Log库允许您将日志消息发送到控制台、文件或任何其他自定义目标。Log库还提供了一些有用的功能，如日志级别、日志过滤器和日志格式化。 类似于Java语言中的Slf4j日志库，可以零开销的帮助开发者切换底层依赖的日志库实现。引入Log库依赖在本系列教程的Cargo篇，我们提到了管理依赖，我们就引入过log库，这里回顾一下。在Cargo.toml文件中添加以下依赖项, 引入Rust的Log库依赖，具体配置如下：1234[dependencies]log = \"0.4.0\"## 引入env_logger库env_logger = \"0.9.0\"使用Log库在使用Rust的Log库之前，您需要初始化日志记录系统。这可以通过调用 log::set_logger() 函数来完成，该函数将日志记录器注册到全局日志记录器中。下面是通过简单的示例：123456789101112use log::{info, LevelFilter};use std::io::Write;fn main() { // 使用env_logger日志库，详细的时候后续会深入讲解 env_logger::init(); log::set_logger(&amp;LOGGER).unwrap(); log::set_max_level(LevelFilter::Info); info!(\"Hello, world!\");}在这个示例中，我们使用了 env_logger 库来初始化日志记录系统。 env_logger 库是一个流行的Rust日志记录库，它提供了一个简单的方法来配置日志记录器。在这个示例中，我们将日志记录器注册到全局日志记录器中，并设置日志级别为 info 。最后，我们使用 info!() 宏来记录日志消息。日志级别Rust的Log库提供了五个日志级别，从最高到最低分别是： Error Warn Info Debug Trace默认情况下，Log库将记录所有级别的日志消息。您可以通过调用 log::set_max_level() 函数来设置日志级别的阈值。例如，如果您只想记录 warn 级别及以上的日志消息，可以使用以下代码：1log::set_max_level(LevelFilter::Warn);日志过滤器Rust的Log库还提供了一种过滤器机制，可以根据日志记录器的名称和日志级别来过滤日志消息。过滤器可以通过调用 log::set_logger() 函数时传递给日志记录器。例如，如果您只想记录名为 myapp::database 的记录器的 info 级别及以上的日志消息，可以使用以下代码：12345678910111213141516use log::{info, LevelFilter};use std::io::Write;fn main() { env_logger::init(); let filter = log::FilterBuilder::new() .target(\"myapp::database\") .level(LevelFilter::Info) .build(); log::set_logger(&amp;LOGGER).unwrap(); log::set_max_level(LevelFilter::Info); info!(\"Hello, world!\");}在这个示例中，我们使用了 log::FilterBuilder 来创建一个过滤器，该过滤器将仅记录名为 myapp::database 的记录器的 info 级别及以上的日志消息。日志格式化Rust的Log库允许您自定义日志消息的格式。默认情况下，Log库将使用 {level} {message} 格式化日志消息。您可以通过调用 log::set_logger() 函数时传递一个自定义的格式字符串来自定义日志消息的格式。例如，以下代码将使用自定义的格式字符串来格式化日志消息：1234567891011121314151617use log::{info, LevelFilter};use std::io::Write;fn main() { env_logger::init(); let format = log::FormatBuilder::new() .format(|buf, record| { writeln!(buf, \"{} [{}] - {}\", chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\"), record.level(), record.args()) }) .build(); log::set_logger(&amp;LOGGER).unwrap(); log::set_max_level(LevelFilter::Info); info!(\"Hello, world!\");}在这个示例中，我们使用了 log::FormatBuilder 来创建一个自定义的格式化程序，该程序将在日志消息中包含时间戳。我们将自定义的格式化程序传递给 log::set_logger() 函数，以便在记录日志消息时使用它。log4rs库log4rs是一个强大的日志记录库，它提供了许多高级功能，如多个日志记录器、多个输出目标和灵活的日志过滤器。log4rs库是基于Rust的Log库构建的，因此您可以使用Rust的Log库的所有功能以及log4rs库的高级功能。 ps：假如你曾经接触过log4j, 那么你会发现log4rs很多概念和设计都和log4j相似。引入log4rs依赖要使用log4rs库，您需要在Cargo.toml文件中添加以下依赖项：12[dependencies]log4rs = \"1.2.0\"配置yamllog4rs库使用YAML或JSON格式的配置文件来配置日志记录器。以下是一个简单的log4rs配置文件示例：123456789101112131415161718192021222324refresh_rate: 30 secondsappenders: stdout: kind: console encoder: pattern: \"{d} [{l}] - {m}\\n\" file: kind: file path: \"logs/myapp.log\" encoder: pattern: \"{d} [{l}] - {m}\\n\"root: level: info appenders: - stdout - fileloggers: myapp::database: level: info appenders: - file在这个示例中，我们定义了两个输出目标：一个是控制台，另一个是文件。我们还定义了一个名为 myapp::database 的记录器，它将日志消息发送到文件输出目标。最后，我们将根记录器配置为将日志消息发送到控制台和文件输出目标。使用log4rs库要使用log4rs库，您需要在应用程序中初始化日志记录器。以下是一个简单的示例：123456789use log::{info, LevelFilter};use log4rs::config::{Config, ConfigHandle};fn main() { let config: Config = log4rs::load_config_file(\"log4rs.yaml\", Default::default()).unwrap(); let handle: ConfigHandle = log4rs::init_config(config).unwrap(); info!(\"Hello, world!\");}在这个示例中，我们使用 log4rs::load_config_file() 函数从文件中加载配置文件。然后，我们使用 log4rs::init_config() 函数初始化日志记录器。最后，我们使用 info!() 宏来记录日志消息。log4rs日志过滤器log4rs库提供了灵活的过滤器机制，可以根据记录器的名称、级别和其他属性来过滤日志消息。以下是一个示例配置文件，其中定义了一个过滤器，该过滤器将仅记录名为 myapp::database 的记录器的 info 级别及以上的日志消息：12345678910111213141516171819202122232425appenders: stdout: kind: console encoder: pattern: \"{d} [{l}] - {m}\\n\" file: kind: file path: \"logs/myapp.log\" encoder: pattern: \"{d} [{l}] - {m}\\n\"root: level: info appenders: - stdout - fileloggers: myapp::database: level: info appenders: - file filters: - kind: threshold level: info在这个示例中，我们定义了一个过滤器，该过滤器将仅记录名为 myapp::database 的记录器的 info 级别及以上的日志消息。log4rs日志格式化log4rs库允许您自定义日志消息的格式。您可以通过在配置文件中设置输出目标的 encoder.pattern 属性来自定义日志消息的格式。例如，以下配置将使用自定义的格式字符串来格式化日志消息：12345678910appenders: stdout: kind: console encoder: pattern: \"{d} [{l}] - {m}\\n\" file: kind: file path: \"logs/myapp.log\" encoder: pattern: \"{d} [{l}] - {m}\\n\"在这个示例中，我们在输出目标的 encoder.pattern 属性中使用了自定义的格式字符串。扩展阅读 - tracing一般来说，env_logger和log4rs已经能够满足绝大部门开发者的日志需求。但是在分布式应用，异步编程领域，log4rs输出的日志由于没有上下文环境信息，异步错落的日志输出，让我们排查问题变得很痛苦，这种情况下，log4rs就显得不太够专业了，而tracing恰恰就有了用武之地。不过鉴于tracing日志库是一个非常庞杂的日志库，要讲透整个知识点需要先掌握分布式日志，链路追踪等等一些列的基础知识，所以博主先在这里提一句，挖个坑，后续针对tracing专门开一篇教程讲解。总结Rust的Log库和log4rs库都是非常有用的日志记录库，它们提供了许多功能，可以帮助开发人员了解应用程序的运行情况并解决问题。Rust的Log库是一个轻量级的日志记录框架，它提供了一个简单的API，可以方便地记录日志。Log库允许您将日志消息发送到控制台、文件或任何其他自定义目标。Log库还提供了一些有用的功能，如日志级别、日志过滤器和日志格式化。log4rs库是一个强大的日志记录库，它提供了许多高级功能，如多个日志记录器、多个输出目标和灵活的日志过滤器。log4rs库是基于Rust的Log库构建的，因此您可以使用Rust的Log库的所有功能以及log4rs库的高级功能。使用Rust的Log库和log4rs库可以帮助您更好地了解应用程序的运行情况，更快地解决问题，并提高应用程序的可靠性和可维护性。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 格式化输出",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通",
      "url"         : "./rust/2023/03/14/rust_lang_tutorial_11_println_format.html",
      "date"        : "2023-03-14 22:00:00 +0800",
      "description" : "",
      "content"     : "Rust提供了许多方式来格式化输出。其中，最常用的方式是使用println!宏。该宏使用类似于C语言的格式字符串，允许使用占位符来表示输出的变量。除了println!宏，Rust还提供了其他格式化输出的宏，如print!、eprint!、format!、panic!等。这些宏都支持类似于println!宏的格式字符串语法。本篇文章我们将已Rust中println的格式化输出为例，和大家一起探讨学习使用格式字符串和占位符，以及如何格式化数字和日期时间。格式化输出格式字符串和占位符在Rust中，格式化输出使用格式字符串和占位符。格式字符串是一个包含占位符的字符串，占位符指定了输出的格式。下面是一个简单的例子：123let name = \"Alice\";let age = 30;println!(\"My name is {} and I am {} years old.\", name, age);在这个例子中，我们使用了两个占位符 {}，它们分别对应变量 name 和 age。当程序运行时，println! 宏会将这些变量的值插入到占位符中，并输出结果。占位符可以包含格式说明符，格式说明符指定了输出的格式。例如，我们可以使用 {:.2} 来指定输出浮点数的小数点后两位。下面是一个例子：12let pi = 3.14159265358979323846;println!(\"Pi is approximately {:.2}\", pi);在这个例子中，我们使用了 {:.2} 来指定输出浮点数的小数点后两位。当程序运行时，println! 宏会将 pi 的值插入到占位符中，并输出结果。除了浮点数，Rust还支持格式化输出整数、字符串和布尔值。下面列举了一些常用的占位符：|占位符|类型|说明||:–:|:–:|:–:||{} |任意类型 |默认格式|{:&lt;N} |任意类型 |左对齐，总宽度为N|{:&gt;N} |任意类型 |右对齐，总宽度为N|{:^N} |任意类型 |居中对齐，总宽度为N|{:.N} |浮点数 |小数点后N位|{:.0} |浮点数 |四舍五入取整|{:+} 整数/|浮点数 |显示符号|{:#b} |整数 |二进制|{:#o} |整数 |八进制|{:#x} |整数 |十六进制|{:#X} |整数 |十六进制（大写）|{} |布尔值 |默认格式|{} |字符串 |默认格式|{:&lt;N} |字符串 |左对齐，总宽度为N|{:&gt;N} |字符串 |右对齐，总宽度为N|{:^N} |字符串 |居中对齐，总宽度为N结合代码示例动手尝试一下这些占位符。1234567891011121314151617181920let name = \"Alice\";let age = 30;println!(\"{:&lt;10} | {:^10} | {:&gt;10}\", \"Name\", \"Age\", \"Gender\");println!(\"{:&lt;10} | {:^10} | {:&gt;10}\", name, age, \"Female\");let pi = 3.14159265358979323846;println!(\"Pi is approximately {:.2}\", pi);let x = 42;println!(\"x = {:#x}\", x);let s = \"Hello, world!\";println!(\"{:^20}\", s);// 输出结果如下：// Name | Age | Gender// Alice | 30 | Female// Pi is approximately 3.14// x = 0x2a// Hello, world! 格式化整数Rust中的整数默认使用十进制表示，但是也支持二进制、八进制和十六进制。可以使用 {:b}、{:\\o} 和 {:x} 来分别表示二进制、八进制和十六进制。例如：123let x = 42;println!(\"x = {:#x}\", x);// 输出结果为：x = 0x2aRust还支持在占位符中指定整数的宽度和对齐方式。可以使用 {:N}、{:&lt;N}、{:&gt;N} 和 {:^N} 来分别表示总宽度为N的默认、左对齐、右对齐和居中对齐。例如：123456let x = 42;println!(\"{:&lt;10} | {:^10} | {:&gt;10}\", \"Name\", \"Age\", \"Gender\");println!(\"{:&lt;10} | {:^10} | {:&gt;10}\", \"Alice\", x, \"Female\");// 输出结果为：// Name | Age | Gender// Alice | 42 | Female格式化浮点数Rust中的浮点数默认使用科学计数法表示，但是也支持固定点表示法和十进制表示法。可以使用 {:e}、{:E}、{:f} 和 {:a} 来分别表示科学计数法、科学计数法（大写）、固定点表示法和十六进制浮点数。例如：1234let pi = 3.14159265358979323846;println!(\"Pi is approximately {:.2}\", pi);// 输出结果为：// Pi is approximately 3.14Rust还支持在占位符中指定浮点数的小数点后的位数。可以使用 {:N} 来表示小数点后N位。例如：1234let pi = 3.14159265358979323846;println!(\"Pi is approximately {:.5}\", pi);// 输出结果为：// Pi is approximately 3.14159格式化日期时间Rust中的日期时间格式化使用了 chrono 库。可以使用 {:?} 来表示日期时间。例如：123456use chrono::prelude::*;let dt = Utc::now();println!(\"The current date and time is {:?}\", dt);// 输出结果为：// The current date and time is 2023-03-14 01:27:43.123456 UTC可以使用 {:?} 中的格式说明符来指定日期时间的格式。例如：1234567use chrono::prelude::*;let dt = Utc::now();println!(\"The current date is {:02}/{:02}/{}\", dt.month(), dt.day(), dt.year());// 输出结果为：// The current date is 03/14/2023格式化输出的实现原理Rust中的格式化输出是通过Formatter实现的。Formatter是一个结构体，用于控制输出的格式和位置。Formatter提供了一系列方法，用于获取输出格式、设置输出宽度、精度和填充字符等。以下是一些常用的Formatter方法： width：获取输出宽度。 precision：获取浮点数输出精度。 fill：获取填充字符。 align：设置对齐方式。 sign_plus：设置输出符号为正号。 alternate：启用备用格式。以下代码演示了如何使用Formatter方法来控制输出格式：12345let pi = 3.14159265359;println!(\"{:+010.3}\", pi);// 输出结果：// +003.142以上代码中，:+010.3表示输出符号为正号，输出宽度为10个字符，小数点后保留3位，如果需要填充，则使用0填充。使用println!宏和参数pi输出结果。自定义类型的格式化输出在Rust中，除了使用内置的格式化选项和自定义格式化字符串外，Rust还支持自定义输出格式。自定义输出格式包括三个部分：实现std::fmt::Display 、std::fmt::Debug trait和定义输出格式。上面的章节讲解了内置定义的输出格式和实现原理，下面学习另外两种类型的自定义输出。通过实现 std::fmt::Display 或 std::fmt::Debug trait 都可以实现自定义类型的格式化输出。区别就是Display trait 用于产生环境用户友好的输出，例如运行时错误，用户输入异常告警日志之类的，而 Debug trait 用于产生调试输出，主要是开发阶段，开发者打印信息帮助调试程序的问题。下面是一个例子，演示如何实现 Display trait：12345678910111213141516171819use std::fmt;struct Person { name: String, age: u32,}impl fmt::Display for Person { fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result { write!(f, \"{} ({})\", self.name, self.age) }}fn main() { let p = Person { name: String::from(\"Alice\"), age: 30 }; println!(\"Person: {}\", p);}// 输出结果为：// Person: Alice (30)在这个例子中，我们定义了一个 Person 结构体，并实现了 Display trait。在 fmt 方法中，我们使用 write! 宏来将格式化后的字符串写入到 f 中。f 是一个 Formatter 类型的对象，它提供了很多方法来格式化输出。类似地，我们也可以实现 Debug trait 来产生调试输出。下面是一个例子：12345678910111213141516171819202122use std::fmt;struct Person { name: String, age: u32,}impl fmt::Debug for Person { fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result { f.debug_struct(\"Person\") .field(\"name\", &amp;self.name) .field(\"age\", &amp;self.age) .finish() }}fn main() { let p = Person { name: String::from(\"Alice\"), age: 30 }; println!(\"Debug: {:?}\", p);}// 输出结果为：// Debug: Person { name: \"Alice\", age: 30 }在这个例子中，我们实现了 Debug trait，并使用 debug_struct 方法来创建一个 DebugStruct 类型的对象。然后，我们使用 field 方法来添加字段，并使用 finish 方法来完成格式化输出。结论在这个教程中，我们介绍了Rust中的格式化输出，包括使用格式字符串和占位符，以及如何格式化数字和日期时间。我们还演示了如何自定义类型的格式化输出。希望这个教程能够帮助你更好地理解Rust中的格式化输出。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 标准库集合",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通",
      "url"         : "./rust/2023/03/14/rust_lang_tutorial_10_collections.html",
      "date"        : "2023-03-14 19:01:00 +0800",
      "description" : "",
      "content"     : "Rust 的标准集合库提供了最常见的通用编程数据结构的高效实现，帮助开发者快速实现存储和操作一系列值。在本教程中，我们将介绍Rust语言标准库中的集合类型，包括数组、向量、哈希表等。我们将详细介绍常用集合的用法，并提供代码示例，以便您更好地理解和学习。集合Rust 的集合可以分为四大类： 有序集合：Vec, VecDeque, LinkedList Map(键值对/字典)：HashMap, BTreeMap Set：HashSet, BTreeSet 其他：BinaryHeapVec 和 VecDeque 都是序列容器，它们的主要区别在于内部实现的数据结构不同。Vec 是基于动态数组实现的，支持在尾部添加和删除元素，还支持在任意位置插入和删除元素。VecDeque 则是基于双端队列实现的，支持在头部和尾部添加和删除元素，但是插入和删除元素的时间复杂度会比 Vec 高一些。LinkedList 是链表容器，它支持在任意位置插入和删除元素，但是访问元素的时间复杂度会比 Vec 和 VecDeque 高一些。HashMap 和 BTreeMap 都是关联容器，它们都支持通过键来访问值。HashMap 是基于哈希表实现的，支持快速的插入、查找和删除操作，但是不保证元素的顺序。BTreeMap 则是基于 B 树实现的，支持有序的插入、查找和删除操作，但是相比于 HashMap，它的性能会略低一些。HashSet 和 BTreeSet 都是集合容器，它们都支持快速的插入、查找和删除操作。HashSet 是基于哈希表实现的，不保证元素的顺序，而 BTreeSet 则是基于 B 树实现的，保证元素按照顺序排列。BinaryHeap 是堆容器，它支持快速的插入和删除操作，并且保证堆的性质。堆是一种树形数据结构，每个节点的值都大于等于（或小于等于）它的子节点的值，因此可以用来实现优先队列等数据结构。向量（Vec）Vec是一种动态长度、存储相同类型元素的集合类型。在Rust中，Vec是通过以下语法定义的：1let vector: Vec&lt;i32&gt; = vec![1, 2, 3, 4, 5];在这个例子中，我们定义了一个包含5个整数的向量。与数组不同，向量的长度可以在运行时改变。我们可以使用[]运算符来访问向量中的元素，例如：12let first = vector[0];let second = vector[1];我们还可以使用for循环遍历向量中的元素：123for element in &amp;vector { println!(\"{}\", element);}这将输出向量中的每个元素。Rust标准库中的向量类型提供了许多有用的方法，用于操作向量中的元素。下面是一些常用的方法：12345678910111213141516171819use std::vec::Vec;fn main() { let vector = vec![1, 2, 3]; // push方法：将一个元素添加到向量的末尾。 vector.push(4); // pop方法：从向量的末尾移除一个元素，并返回该元素的值。 let last = vector.pop(); // len方法：返回向量中元素的数量。 let length = vector.len(); // is_empty方法：检查向量是否为空。 let is_empty = vector.is_empty(); // contains方法：检查向量中是否包含指定的元素。 let contains_two = vector.contains(&amp;2); // sort方法：对向量中的元素进行排序。 let mut vector = vec![3, 2, 1]; vector.sort();}数组(Array)于Vec 有些类似的数组是一种固定长度、存储相同类型元素的集合类型。在Rust中，数组是通过以下语法定义的：1let array: [i32; 5] = [1, 2, 3, 4, 5];在这个例子中，我们定义了一个包含5个整数的数组。注意，数组的长度是在定义时确定的，不能在运行时改变。我们可以使用[]运算符来访问数组中的元素，例如：12let first = array[0];let second = array[1];我们还可以使用for循环遍历数组中的元素：123for element in &amp;array { println!(\"{}\", element);}哈希表（HashMap）哈希表是一种存储键值对的集合类型，其中每个键都必须是唯一的。在Rust中，哈希表是通过以下语法定义的：123let mut hashmap = HashMap::new();hashmap.insert(\"key1\", \"value1\");hashmap.insert(\"key2\", \"value2\");在这个例子中，我们定义了一个包含两个键值对的哈希表。我们可以使用get方法来检索哈希表中的值，例如：12let value1 = hashmap.get(\"key1\");let value2 = hashmap.get(\"key2\");我们还可以使用for循环遍历哈希表中的键值对：123for (key, value) in &amp;hashmap { println!(\"{}: {}\", key, value);}这将输出哈希表中的每个键值对。哈希表的常用方法Rust标准库中的哈希表类型提供了许多有用的方法，用于操作哈希表中的键值对。下面是一些常用的方法：1234567891011121314151617use std::collections::HashMap;fn main() { let mut hashmap = HashMap::new(); // insert方法：将一个键值对添加到哈希表中。 hashmap.insert(\"key\", \"value\"); // remove方法：从哈希表中移除指定的键值对。 let removed_value = hashmap.remove(\"key\"); // get方法：检索哈希表中指定键的值。 let value = hashmap.get(\"key\"); // contains_key方法：检查哈希表中是否包含指定的键。 let contains_key = hashmap.contains_key(\"key\"); // len方法：返回哈希表中键值对的数量。 let length = hashmap.len(); // is_empty方法：检查哈希表是否为空。 let is_empty = hashmap.is_empty();}B树集合容器 (BTreeSet)BTreeSet可以存储不重复的元素，并且可以快速地进行插入、删除和查找操作。BTreeSet内部使用B树来存储元素，因此可以支持快速的有序遍历。查询的时间复杂度为 O(log(n))。BTreeSet中的元素必须实现Ord trait，这是因为BTreeSet需要对元素进行排序。如果要存储自定义类型的元素，也需要为该类型实现Ord trait。123456789101112131415161718192021222324252627282930use std::collections::BTreeSet;fn main() { // 使用new方法来创建一个空的BTreeSet： let set: BTreeSet&lt;i32&gt; = BTreeSet::new(); // 使用from_iter方法从一个可迭代的集合中创建BTreeSet： let set: BTreeSet&lt;i32&gt; = vec![1, 2, 3].into_iter().collect(); // 向BTreeSet中插入元素，可以使用insert方法： let mut set = BTreeSet::new(); set.insert(1); set.insert(2); set.insert(3); // 删除元素，可以使用remove方法： let mut set = BTreeSet::new(); set.insert(1); set.insert(2); set.insert(3); set.remove(&amp;2); // 使用contains方法查找是否存在某个元素： let set = vec![1, 2, 3].into_iter().collect::&lt;BTreeSet&lt;i32&gt;&gt;(); assert!(set.contains(&amp;2)); // BTreeSet支持快速的有序遍历。可以使用iter方法来获取一个迭代器，然后使用for循环来遍历BTreeSet中的元素： let set = vec![1, 2, 3].into_iter().collect::&lt;BTreeSet&lt;i32&gt;&gt;(); for x in set.iter() { println!(\"{}\", x); }}扩展阅读 - Ord 特征在BTreeSet中我们提到了Ord Trait，本小节作为扩展阅读，进一步讲解Ord特征。仅对Rust 集合内容感兴趣的童鞋们，可以忽略本小节。Ord trait是一种用于比较两个值的trait。它定义了一组方法，这些方法允许我们比较不同类型的值。使用Ord trait，我们可以比较数字、字符串、结构体等各种类型的值。12345678910111213141516pub trait Ord: Eq + PartialOrd&lt;Self&gt; { fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering; fn max(self, other: Self) -&gt; Self where Self: Sized, { ... } fn min(self, other: Self) -&gt; Self where Self: Sized, { ... } fn clamp(self, min: Self, max: Self) -&gt; Self where Self: Sized + PartialOrd&lt;Self&gt;, { ... }}查看Rust的Ord trait源码，它继承了Eq 和 PartialOrd trait。定义了一个方法cmp，它接受一个参数other，该参数是一个与self相同类型的引用。该方法返回一个Ordering类型的值，该值表示self和other之间的大小关系。Ordering类型是一个枚举类型，定义了三个变量：Less、Equal和Greater。这些变量表示比较两个值时的大小关系。Ordering枚举源码如下：12345pub enum Ordering { Less, Equal, Greater,}例如，如果我们比较两个整数a和b，并且a小于b，则比较结果为Less；如果a等于b，则比较结果为Equal；如果a大于b，则比较结果为Greater。下面我进一步通过为类型实现Ord trait来定义该类型的大小关系。例如：12345678910111213141516171819202122232425262728293031323334353637use std::cmp::Ordering;#[derive(Debug)]struct Person { name: String, age: u8,}impl Ord for Person { fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering { self.age.cmp(&amp;other.age) }}impl PartialOrd for Person { fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; { Some(self.cmp(other)) }}impl Eq for Person {}impl PartialEq for Person { fn eq(&amp;self, other: &amp;Self) -&gt; bool { self.age == other.age }}fn main() { let alice = Person { name: String::from(\"Alice\"), age: 30 }; let bob = Person { name: String::from(\"Bob\"), age: 25 }; let charlie = Person { name: String::from(\"Charlie\"), age: 30 }; let people = vec![alice, bob, charlie]; let mut sorted_people = people.clone(); sorted_people.sort(); println!(\"Sorted people: {:?}\", sorted_people);}在这个例子中，我们定义了一个Person结构体，它有两个字段：name和age。我们为Person结构体实现了Ord trait、PartialOrd trait、Eq trait和PartialEq trait。这些trait定义了Person结构体的大小关系和相等性。在Ord trait的实现中，我们比较了Person结构体的age字段。如果self.age小于other.age，则返回Ordering::Less；如果self.age等于other.age，则返回Ordering::Equal；如果self.age大于other.age，则返回Ordering::Greater。在PartialOrd trait的实现中，我们调用了Ord trait的cmp方法，并将其结果包装在Some中返回。PartialOrd trait定义了Ord trait的部分实现，它允许我们比较可能不完全可排序的值。在Eq trait的实现中，我们比较了Person结构体的age字段。如果self.age等于other.age，则返回true；否则返回false。在PartialEq trait的实现中，我们调用了Eq trait的eq方法，并将其结果返回。PartialEq trait定义了Eq trait的部分实现，它允许我们比较可能不完全可比较的值。在main函数中，我们创建了三个Person结构体，并将它们存储在一个Vec中。然后，我们克隆了该Vec并对其进行排序。在排序之后，我们打印了排序后的Vec。在Rust中，我们还可以使用泛型来实现通用的比较函数。例如：12345678910111213141516use std::cmp::Ordering;fn max&lt;T: Ord&gt;(a: T, b: T) -&gt; T { if a &gt;= b { a } else { b }}fn main() { let a = 1; let b = 2; let c = max(a, b); println!(\"The maximum value is {}\", c);}在这个例子中，我们传递了两个i32类型的参数a和b给max函数，并将返回值存储在变量c中。然后，我们打印了c的值。下面是一个使用Ord trait和泛型的示例代码，它比较了两个字符串和两个整数的大小关系：123456789101112131415161718192021use std::cmp::Ord;fn max&lt;T: Ord&gt;(a: T, b: T) -&gt; T { if a &gt;= b { a } else { b }}fn main() { let a = String::from(\"hello\"); let b = String::from(\"world\"); let c = max(a.clone(), b.clone()); println!(\"The maximum value is {}\", c); let x = 1; let y = 2; let z = max(x, y); println!(\"The maximum value is {}\", z);}在这个例子中，我们创建了两个字符串a和b，并比较它们的大小关系。然后，我们创建了两个整数x和y，并比较它们的大小关系。在每个比较中，我们调用了max函数，并将结果打印到控制台。总结在本教程中，我们主要介绍Rust语言标准库中的集合类型，包括数组、向量、哈希表、B树Set, 并结合代码示例详细深入的探讨了Vec HashMap BTreeSet三个常用集合，最后延申扩展的讲解了Rust的Ord trait。希望本教程能够帮助您更好地掌握Rust语言中的集合类型。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Rust泛型",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通",
      "url"         : "./rust/2023/03/13/rust_lang_tutorial_06_struct_generic.html",
      "date"        : "2023-03-13 19:01:00 +0800",
      "description" : "",
      "content"     : "泛型是一种非常强大的特性，它是现代编程语言中必不可少的特性之一。它允许我们最大限度的编写通用和可重用的代码。在本文中，我们将深入探讨Rust中Struct和泛型，并学习如何使用它们来创建更加灵活和可扩展的代码。Rust中的泛型泛型是一种在编程语言中广泛使用的概念，它允许我们编写可以适用于多种不同类型的代码。在Rust中，我们可以使用泛型来编写更加通用和可重用的代码。在Rust中，我们使用尖括号&lt;&gt;来指定泛型类型。下面是一个使用泛型的简单示例：12345678fn print&lt;T&gt;(x: T) { println!(\"{}\", x);}fn main() { print(1); print(\"hello\");}在上面的示例中，我们定义了一个名为print的函数，并使用泛型类型T来表示函数参数的类型。在函数体中，我们使用println!宏来打印出函数参数的值。在main函数中，我们分别调用了print函数，并传入了一个整数和一个字符串作为参数。由于print函数使用了泛型类型，因此它可以适用于任何类型的参数。在Rust中，我们还可以使用泛型来定义struct、enum和trait。下面回顾一下，我们上一篇中提到的泛型Pair结构体：123456789struct Pair&lt;T&gt; { first: T, second: T,}fn main() { let pair_of_ints = Pair { first: 1, second: 2 }; let pair_of_strings = Pair { first: \"hello\".to_string(), second: \"world\".to_string() };}在上面的示例中，我们定义了一个名为Pair的struct，并使用泛型类型T来表示数据项的类型。在main函数中，我们分别创建了一个存储两个整数的Pair对象和一个存储两个字符串的Pair对象。泛型约束在Rust中，我们可以使用泛型约束来限制泛型类型的范围。泛型约束允许我们指定泛型类型必须满足的条件，例如实现了某个trait或者是某个特定类型。下面是一个使用泛型约束的示例：12345678910use std::fmt::Display;fn print&lt;T: Display&gt;(x: T) { println!(\"{}\", x);}fn main() { print(1); print(\"hello\");}在上面的示例中，我们使用use语句导入了std::fmt::Display trait，然后在print函数中使用了泛型约束&lt;T: Display&gt;来表示函数参数必须实现Display trait。在函数体中，我们使用println!宏来打印出函数参数的值。在main函数中，我们分别调用了print函数，并传入了一个整数和一个字符串作为参数。由于整数和字符串都实现了Display trait，因此它们都可以作为参数传递给print函数。在Rust中，我们还可以使用where关键字来指定泛型约束。下面是一个使用where关键字的示例：12345678910111213use std::fmt::Display;fn print&lt;T&gt;(x: T)where T: Display,{ println!(\"{}\", x);}fn main() { print(1); print(\"hello\");}在上面的示例中，我们使用where关键字来指定泛型约束，与使用&lt;T: Display&gt;的方式相同。使用where关键字的方式通常更加清晰和易读，特别是当我们需要指定多个泛型约束时。常见的泛型结构体在Rust中，我们可以使用泛型来编写更加通用和可重用的代码。下面是一些常见的泛型应用：Vec是Rust标准库中的一个动态数组类型，它可以存储任何类型的元素。下面是一个使用Vec的示例：123456789let mut v: Vec&lt;i32&gt; = Vec::new();v.push(1);v.push(2);v.push(3);for i in &amp;v { println!(\"{}\", i);}在上面的示例中，我们首先创建了一个空的Vec对象，并使用push方法向其中添加了三个整数。然后，我们使用for循环遍历Vec对象中的每个元素，并打印出它们的值。Option是Rust标准库中的一个枚举类型，它可以表示一个值存在或不存在的情况。下面是一个使用Option的示例：1234567891011let x: Option&lt;i32&gt; = Some(5);let y: Option&lt;i32&gt; = None;match x { Some(i) =&gt; println!(\"x is {}\", i), None =&gt; println!(\"x is None\"),}match y { Some(i) =&gt; println!(\"y is {}\", i), None =&gt; println!(\"y is None\"),}在上面的示例中，我们首先创建了一个存储整数5的Some对象，并将它赋值给变量x。然后，我们创建了一个None对象，并将它赋值给变量y。最后，我们使用match表达式来匹配x和y的值，并打印出相应的信息。Result&lt;T, E&gt;是Rust标准库中的一个枚举类型，它可以表示一个操作成功或失败的情况，并可以携带一个成功的结果或一个错误信息。下面是一个使用Result&lt;T, E&gt;的示例：1234567891011121314151617use std::fs::File;use std::io::ErrorKind;fn main() { let f = File::open(\"hello.txt\"); let f = match f { Ok(file) =&gt; file, Err(error) =&gt; match error.kind() { ErrorKind::NotFound =&gt; match File::create(\"hello.txt\") { Ok(fc) =&gt; fc, Err(e) =&gt; panic!(\"Failed to create file: {:?}\", e), }, other_error =&gt; panic!(\"Failed to open file: {:?}\", other_error), }, };}在上面的示例中，我们使用File::open函数来打开一个名为hello.txt的文件。如果文件存在，则返回一个Ok对象，其中包含文件的句柄；否则，返回一个Err对象，其中包含一个io::Error对象，表示文件不存在的错误。在match表达式中，我们使用ErrorKind::NotFound模式匹配来检查错误类型，并使用File::create函数来创建一个新文件。如果创建成功，则返回一个新的文件句柄；否则，使用panic!宏来抛出一个错误。如果文件存在或创建成功，则返回一个文件句柄。const 泛型Const泛型，也称“常量泛型”，参数允许程序项在常量值上泛型化。const标识符为常量参数引入了一个名称，并且该程序项的所有实例必须用给定类型的值去实例化该参数。常量参数类型值允许为：u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize, char 和 bool 这些类型。Animal泛型示例现在，结合上一篇定义的Animal类。我们扩展它并将Animal扩展成一个通用抽象的结构体，并让这个类可以适用于任何类型的动物，它可以存储动物的名称、年龄、性别、物种和体重等信息。首先，我们定义一个泛型类型T，用于表示动物的类型。然后，我们定义一个名为Animal的struct，并使用泛型类型T来表示动物的类型。在Animal struct中，我们定义了五个数据项，分别是名称、年龄、性别、物种和体重。我们还为Animal struct实现了一个new关联函数，用于创建一个新的Animal对象。在new函数中，我们传入五个参数，分别是名称、年龄、性别、物种和体重，并使用它们来创建一个新的Animal对象。123456789101112131415161718192021struct Animal&lt;T&gt; { name: String, age: u8, is_male: bool, species: String, weight: f32, animal_type: std::marker::PhantomData&lt;T&gt;,}impl&lt;T&gt; Animal&lt;T&gt; { fn new(name: String, age: u8, is_male: bool, species: String, weight: f32) -&gt; Animal&lt;T&gt; { Animal { name, age, is_male, species, weight, animal_type: std::marker::PhantomData, } }}在上面的示例中，我们还使用了一个名为PhantomData的标记类型，用于表示泛型类型T的存在。由于Rust中的泛型是在编译时实现的，因此编译器需要知道泛型类型的存在，才能正确地生成代码。使用PhantomData标记类型可以告诉编译器，泛型类型T确实存在，从而使编译器能够正确地生成代码。现在，我们可以使用Animal类来创建不同类型的动物对象。下面是一个使用Animal类创建猫和狗对象的示例：1234567struct Cat;struct Dog;fn main() { let cat = Animal::&lt;Cat&gt;::new(\"Tommy\".to_string(), 3, true, \"cat\".to_string(), 4.5); let dog = Animal::&lt;Dog&gt;::new(\"Buddy\".to_string(), 5, true, \"dog\".to_string(), 12.3);}在上面的示例中，我们首先定义了Cat和Dog两个类型，用于表示猫和狗。然后，我们使用Animal::语法创建一个猫对象，并传入相应的参数。使用Animal::语法创建一个狗对象，并传入相应的参数。由于Animal类使用了泛型类型T，因此它可以适用于任何类型的动物。泛型约束和trait结合泛型约束通常都是和trait一起使用的，用来限制泛型类型的范围。例如，我们可以使用std::fmt::Display trait来限制泛型类型必须实现Display trait。下面是一个使用泛型约束和trait的示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354use std::fmt::Display;struct Animal&lt;T: Display&gt; { name: String, age: u8, is_male: bool, species: String, weight: f32, animal_type: std::marker::PhantomData&lt;T&gt;,}impl&lt;T: Display&gt; Animal&lt;T&gt; { fn new(name: String, age: u8, is_male: bool, species: String, weight: f32) -&gt; Animal&lt;T&gt; { Animal { name, age, is_male, species, weight, animal_type: std::marker::PhantomData, } } fn print_info(&amp;self) { println!(\"Name: {}\", self.name); println!(\"Age: {}\", self.age); println!(\"Is male: {}\", self.is_male); println!(\"Species: {}\", self.species); println!(\"Weight: {}\", self.weight); }}struct Cat;struct Dog;impl Display for Cat { fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result { write!(f, \"cat\") }}impl Display for Dog { fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result { write!(f, \"dog\") }}fn main() { let cat = Animal::&lt;Cat&gt;::new(\"Tommy\".to_string(), 3, true, Cat.to_string(), 4.5); let dog = Animal::&lt;Dog&gt;::new(\"Buddy\".to_string(), 5, true, Dog.to_string(), 12.3); cat.print_info(); dog.print_info();}在上面的示例中，我们使用&lt;T: Display&gt;泛型约束来限制泛型类型必须实现Display trait。然后，我们为Animal类实现了一个print_info方法，用于打印出动物的信息。在main函数中，我们首先定义了Cat和Dog两个类型，并为它们实现了Display trait。然后，我们使用Animal::和Animal::语法创建了一个猫对象和一个狗对象，并传入相应的参数。由于Cat和Dog类型都实现了Display trait，因此它们可以作为Animal类的类型参数。最后，我们分别调用了cat.print_info()和dog.print_info()方法，打印出它们的信息。接下来，我们可以使用泛型特性来重新定义Zoo类和print_animals函数。首先，我们可以使用一个泛型类型T来表示动物的类型，如下所示：123struct Zoo&lt;T&gt; { animals: Vec&lt;Animal&lt;T&gt;&gt;,}这个Zoo类使用了一个泛型类型T，它表示动物的类型。这个类可以用来容纳不同种类的动物，例如：12let zoo1 = Zoo { animals: vec![cat, dog, elephant] };let zoo2 = Zoo { animals: vec![elephant, dog, cat] };接下来，我们定义支持使用泛型特性的print_animals函数，如下所示：1234567891011121314151617fn print_animals&lt;T&gt;(zoo: &amp;Zoo&lt;T&gt;) { for animal in &amp;zoo.animals { println!(\"{} ({}) is {} years old.\", animal.name, animal.animal_type, animal.age); }}fn main() { let cat = Animal { name: \"Tommy\".to_string(), age: 3, animal_type: \"Cat\" }; let dog = Animal { name: \"Buddy\".to_string(), age: 5, animal_type: \"Dog\" }; let elephant = Animal { name: \"Dumbo\".to_string(), age: 10, animal_type: \"Elephant\" }; let zoo1 = Zoo { animals: vec![cat, dog, elephant] }; let zoo2 = Zoo { animals: vec![elephant, dog, cat] }; print_animals(zoo1); print_animals(zoo2);}这个函数使用了一个泛型类型T，它表示动物的类型。这个函数可以遍历Zoo中的所有动物，并打印它们的名字、类型和年龄。现在我们可以使用Animal和Zoo类的泛型特性来实现更加灵活和可复用的代码。例如，我们可以使用Animal来定义字符串类型的动物，使用Animal来定义整数类型的动物，等等。同时，我们学习使用Zoo来容纳不同类型的动物。通过这两个泛型示例，相信大家都已经掌握了泛型的使用。Rust泛型最佳实践Rust 中泛型是零成本的抽象，意味着你在使用泛型时，完全不用担心性能上的问题。因为是在编译阶段为泛型对应的多个类型，生成各自的代码，所以增加了编译耗时，增大了最终生成二进制文件的大小。当我们需要在内存资源比较紧张的机器上允许rust时，可以尝试使用const泛型进行优化。结论在本文中，我们深入探讨了Rust中的泛型和struct，并学习了如何使用它们来创建更加灵活和可扩展的代码。我们还讨论了泛型约束和trait，以及如何使用它们来限制泛型类型的范围。最后，我们使用Animal类作为示例，演示了如何使用泛型和trait来创建通用的类，并限制类的类型参数必须满足某些条件。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 结构体Struct",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通",
      "url"         : "./rust/2023/03/13/rust_lang_tutorial_05_struct.html",
      "date"        : "2023-03-13 19:01:00 +0800",
      "description" : "",
      "content"     : "在Rust语言中，struct是一种自定义类型，类似于Java或者C#语言中Class类概念，它允许我们将多个相关的数据项组合在一起。struct是Rust中的一种复合类型，它可以包含多个数据项，这些数据项可以是不同的类型，例如整数、浮点数、字符串、布尔值等。在这篇教程中，我们将学习如何定义和使用Rust语言中的struct。定义Struct在Rust语言中，使用关键字struct来定义一个struct。下面是一个定义animal对象的示例：1234567struct Animal { name: String, age: u8, is_male: bool, species: String, weight: f32,}在上面的示例中，我们定义了一个名为Animal的struct，它包含了5个数据项，分别是name、age、is_male、species和weight。其中，name和species是字符串类型，age是一个8位无符号整数，is_male是一个布尔值，weight是一个浮点数。在定义struct时，我们可以为每个数据项指定一个类型。在上面的示例中，我们使用了不同的类型来表示不同的数据项。我们还可以在定义struct时使用泛型来表示数据项的类型，例如：1234struct Pair&lt;T&gt; { first: T, second: T,}在上面的示例中，我们定义了一个名为Pair的struct，它包含了两个数据项，分别是first和second，它们的类型都是泛型类型T。这意味着我们可以在创建Pair对象时指定T的具体类型，例如：12let pair_of_ints = Pair { first: 1, second: 2 };let pair_of_strings = Pair { first: \"hello\".to_string(), second: \"world\".to_string() };在上面的示例中，我们创建了两个Pair对象，一个存储了两个整数，另一个存储了两个字符串。实例化Struct在Rust语言中，我们可以使用花括号{}来初始化一个struct对象。下面是一个初始化animal对象的示例：1234567let animal = Animal { name: \"Tommy\".to_string(), age: 3, is_male: true, species: \"cat\".to_string(), weight: 4.5,};在上面的示例中，我们创建了一个名为animal的Animal对象，并为它的每个数据项指定了一个值。注意，我们必须使用to_string()方法将字符串字面量转换为String类型，因为在Rust中，字符串字面量是不可变的。我们还可以使用结构体更新语法来初始化一个struct对象。结构体更新语法允许我们从一个已有的struct对象中创建一个新的struct对象，并可以修改其中的一些数据项。下面是一个使用结构体更新语法初始化animal对象的示例：1234567891011121314let mut animal = Animal { name: \"Tommy\".to_string(), age: 3, is_male: true, species: \"cat\".to_string(), weight: 4.5,};let new_animal = Animal { name: \"Jerry\".to_string(), age: 2,// 从animal复制数据 ..animal};在上面的示例中，我们首先创建了一个名为animal的Animal对象，然后使用结构体更新语法创建了一个名为new_animal的新的Animal对象。在结构体更新语法中，我们使用..来指定从哪个已有的struct对象中复制数据项，然后可以修改其中的一些数据项。在上面的示例中，我们将name和age数据项修改为新的值，其他数据项保持不变。访问Struct的数据项在Rust语言中，我们可以使用 “.” 操作符来访问struct对象的数据项。下面是一个访问animal对象数据项的示例：12345678910111213let animal = Animal { name: \"Tommy\".to_string(), age: 3, is_male: true, species: \"cat\".to_string(), weight: 4.5,};println!(\"Name: {}\", animal.name);println!(\"Age: {}\", animal.age);println!(\"Is male: {}\", animal.is_male);println!(\"Species: {}\", animal.species);println!(\"Weight: {}\", animal.weight);在上面的示例中，我们首先创建了一个名为animal的Animal对象，然后使用.操作符访问了它的每个数据项，并打印出了它们的值。在Struct定义方法在Rust语言中，我们可以为struct对象定义方法。方法是一种与struct相关的函数，它可以访问struct对象的数据项，并可以对其进行操作。下面是一个定义animal对象方法的示例：1234567891011impl Animal { // 定义eat方法 fn eat(&amp;mut self, food_weight: f32) { self.weight += food_weight; } // 定义sleep方法 fn sleep(&amp;self) { println!(\"{} is sleeping\", self.name); }}在上面的示例中，我们为Animal对象实现了两个方法，分别是eat和sleep。在eat方法中，我们传入一个food_weight参数，然后将它加到weight数据项上。注意，我们必须将self参数标记为可变引用&amp;mut self，因为我们要修改weight数据项的值。在sleep方法中，我们只是简单地打印出name数据项的值，表示该Animal对象正在睡觉。我们可以在创建Animal对象后调用这些方法。下面是一个调用eat和sleep方法的示例：12345678910let mut animal = Animal { name: \"Tommy\".to_string(), age: 3, is_male: true, species: \"cat\".to_string(), weight: 4.5,};animal.eat(0.5);animal.sleep();在上面的示例中，我们首先创建了一个名为animal的Animal对象，然后调用了它的eat方法，并传入了0.5作为food_weight参数。最后，我们调用了sleep方法，打印出name数据项的值。Struct的关联函数关联函数有点类似于Java中静态方法或者类方法，rust中常常用于返回一个结构体的新实例。在Rust语言中，我们还可以为struct对象实现关联函数。关联函数是一种与struct相关的函数，但它不需要访问struct对象的数据项。关联函数通常用于创建新的struct对象。下面是一个实现animal对象关联函数的示例：1234567891011impl Animal { fn create(name: String, age: u8, is_male: bool, species: String, weight: f32) -&gt; Animal { Animal { name, age, is_male, species, weight, } }}在上面的示例中，我们为Animal对象实现了一个关联函数create。在create函数中，我们传入了5个参数，分别是name、age、is_male、species和weight，然后创建了一个新的Animal对象，并将这些参数作为数据项的值。注意，我们可以使用简写语法，将参数名作为数据项名，而不需要写成name: name的形式。我们可以使用关联函数来创建新的Animal对象。下面是一个使用关联函数创建Animal对象的示例：1let animal = Animal::create(\"Tommy\".to_string(), 3, true, \"cat\".to_string(), 4.5);在上面的示例中，我们使用Animal::create语法调用了create函数，并传入了5个参数。create函数返回一个新的Animal对象，我们将它赋值给animal变量。附上完整的代码示例：12345678910111213141516171819202122232425struct Animal { name: String, weight: f32}impl Animal { // 定义eat方法 fn eat(&amp;mut self, food_weight: f32) { self.weight += food_weight; } // 定义sleep方法 fn sleep(&amp;self) { println!(\"{} is sleeping\", self.name); } fn create(name:String, weight:f32) -&gt; Animal { Animal {name, weight} }}fn main() { let mut s1 = Animal::create(\"ABC\".to_string(), 0.0); s1.eat(100.0); println!(\" {}\", s1.weight);}总结在本教程中，我们学习了如何定义和使用Rust语言中的struct。我们学习了如何定义struct、初始化struct、访问struct的数据项、实现struct的方法和关联函数。struct是Rust语言中非常重要的一个概念，它允许我们将多个相关的数据项组合在一起，并且可以为它们实现方法和关联函数。通过学习本教程，相信你已经掌握了Rust语言中struct的基本用法。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 所有权",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通",
      "url"         : "./rust/2023/03/12/rust_lang_tutorial_07_borrowing.html",
      "date"        : "2023-03-12 12:01:00 +0800",
      "description" : "",
      "content"     : "Rust是一门系统级编程语言，它的设计目标是安全、速度和并发。Rust中的引用和借用是其独特的特性之一，它们使得Rust能够在保证安全的前提下实现高效的内存管理。在本教程中，我们将介绍Rust中的引用和借用，以及如何使用它们来管理内存。引用在Rust中，引用是一种轻量级的指针，它允许我们在不拥有值的情况下访问它。引用可以是可变的或不可变的，它们分别对应于可变和不可变的数据。不可变引用不可变引用使用 &amp; 符号来声明，例如：123456fn main() { let x = 5; let y = &amp;x; println!(\"x = {}, y = {}\", x, y);}在上面的代码中，我们声明了一个不可变的整数 x ，然后创建了一个指向 x 的不可变引用 y 。我们可以通过 y 来访问 x 的值，但不能修改它。在打印 x 和 y 的值时，我们使用了 {} 占位符，这是Rust中的字符串插值语法。可变引用可变引用使用 &amp;mut 符号来声明，例如：12345678fn main() { let mut x = 5; let y = &amp;mut x; *y = 10; println!(\"x = {}, y = {}\", x, y);}在上面的代码中，我们声明了一个可变的整数 x ，然后创建了一个指向 x 的可变引用 y 。我们使用 *y 来访问 x 的值，并将其修改为 10 。注意，在修改可变引用所指向的值时，我们需要使用 * 符号来解引用引用。最后，我们打印 x 和 y 的值。引用的作用域引用的作用域是指引用所在的代码块，它决定了引用在代码中的可用性。例如：1234567891011fn main() { let x = 5; { let y = &amp;x; println!(\"x = {}, y = {}\", x, y); } let z = &amp;x; println!(\"x = {}, z = {}\", x, z);}在上面的代码中，我们声明了一个整数 x ，然后在一个代码块中创建了一个指向 x 的不可变引用 y 。在该代码块结束后， y 的作用域就结束了，我们不能再使用它。然后，我们在另一个代码块中创建了一个指向 x 的不可变引用 z ，并打印了 x 和 z 的值。借用在Rust中，借用是一种将值的所有权转移给函数或代码块的方式。借用可以是可变的或不可变的，它们分别对应于可变和不可变的数据。不可变借用不可变借用使用 &amp; 符号来声明，例如：12345678fn print_value(x: &amp;i32) { println!(\"value = {}\", x);}fn main() { let x = 5; print_value(&amp;x);}在上面的代码中，我们声明了一个函数 print_value ，它接受一个指向不可变整数的借用。在 main 函数中，我们创建了一个整数 x ，然后将其借用给 print_value 函数。在函数中，我们使用 {} 占位符来打印借用的值。可变借用可变借用使用 &amp;mut 符号来声明，例如：123456789fn modify_value(x: &amp;mut i32) { *x = 10;}fn main() { let mut x = 5; modify_value(&amp;mut x); println!(\"x = {}\", x);}在上面的代码中，我们声明了一个函数 modify_value ，它接受一个指向可变整数的借用。在 main 函数中，我们创建了一个可变整数 x ，然后将其借用给 modify_value 函数。在函数中，我们使用 *x 来解引用借用，并将其修改为 10 。最后，我们打印 x 的值。借用的生命周期借用的生命周期是指借用所在的代码块，它决定了借用在代码中的可用性。例如：12345678910111213fn main() { let x = 5; { let y = &amp;x; println!(\"x = {}, y = {}\", x, y); } let z = &amp;mut x; *z = 10; println!(\"x = {}\", x);}在上面的代码中，我们声明了一个整数 x ，然后在一个代码块中创建了一个指向 x 的不可变借用 y 。在该代码块结束后， y 的生命周期就结束了，我们不能再使用它。然后，我们在另一个代码块中创建了一个指向 x 的可变借用 z ，并将 x 的值修改为 10 。注意，当我们创建可变借用时，不能同时存在其他的借用，因为这会导致数据竞争。这是Rust的内存安全机制的一部分。借用和引用的比较借用和引用都是Rust中的重要概念，它们有一些相似之处，但也有一些不同之处。相似之处: 借用和引用都是一种不拥有值的方式来访问数据。 借用和引用都有不可变和可变的版本。 借用和引用都有作用域和生命周期的概念。不同之处: 引用是一种轻量级的指针，它可以在任何地方创建，而借用只能在函数或代码块中创建。 借用是一种所有权的转移，它可以更改数据的值，而引用只能访问数据的值。 借用有一个额外的限制，即不能同时存在多个可变借用或一个可变借用和任何其他借用。示例代码下面是一个示例代码，它演示了如何使用引用和借用来管理内存。12345678910111213141516fn main() { let mut x = 5; let y = &amp;x; let z = &amp;mut x; println!(\"x = {}, y = {}, z = {}\", x, y, z); modify_value(y); modify_value(z); println!(\"x = {}, y = {}, z = {}\", x, y, z);}fn modify_value(x: &amp;mut i32) { *x = 10;}在上面的代码中，我们创建了一个可变整数 x ，然后创建了一个指向 x 的不可变引用 y 和一个指向 x 的可变借用 z 。我们打印了 x 、 y 和 z 的值。然后，我们使用 modify_value 函数来修改 y 和 z 所指向的值。最后，我们再次打印 x 、 y 和 z 的值。注意，在修改可变借用所指向的值时，我们也需要使用 * 符号来解引用借用。结论引用和借用是Rust中的重要特性，它们使得Rust能够实现高效的内存管理。在本教程中，我们介绍了Rust中的引用和借用，以及如何使用它们来管理内存。我们还比较了引用和借用的异同点，并提供了示例代码来演示它们的用法。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 所有权",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通",
      "url"         : "./rust/2023/03/12/rust_lang_tutorial_04_ownership.html",
      "date"        : "2023-03-12 12:01:00 +0800",
      "description" : "",
      "content"     : "Rust是一种系统编程语言，它在内存安全和并发性方面具有很高的保证。其中最重要的特性之一是所有权系统。所有权系统是一种内存管理方式，它可以避免常见的内存问题，如空指针、内存泄漏和数据竞争。在本教程中，我们将深入了解Rust的所有权系统。所有权在Rust中，每个值都有一个所有者。所有者是一个变量，它拥有该值并负责释放该值。当所有者超出范围时，它们拥有的值将被释放。这种方式确保了内存的安全和高效使用。让我们看一个简单的例子：1234fn main() { let s = String::from(\"hello\"); println!(\"{}\", s);}在这个例子中，我们创建了一个字符串hello并将其赋值给变量s。变量s是该字符串的所有者。当程序执行到println!宏时，它打印字符串s的值。当程序执行完毕时，变量s超出了其作用域，该值将被自动释放。所有权的转移在Rust中，值的所有权可以通过将其赋值给另一个变量来转移。例如：1234567fn main() { let s1 = String::from(\"hello\"); let s2 = s1; println!(\"{}\", s2);}// 输出内容：// hello在这个例子中，我们创建了一个字符串hello并将其赋值给变量s1。然后，我们将变量s1赋值给变量s2。这导致s1失去了对该字符串的所有权，而s2现在是该字符串的所有者。当程序执行到println!宏时，它打印字符串s2的值。当程序执行完毕时，变量s2超出了其作用域，该值将被自动释放。需要注意的是，当值的所有权转移时，原始变量将不再有效。例如：123456789101112131415161718192021222324fn main() { let s1 = String::from(\"hello\"); let s2 = s1; println!(\"{}\", s1);}// 编译错误：// error[E0382]: borrow of moved value: `s1`// --&gt; src/main.rs:9:20// |// 7 | let s1 = String::from(\"hello\");// | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait// 8 | let s2 = s1;// | -- value moved here// 9 | println!(\"{}\", s1);// | ^^ value borrowed here after move// |// = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)// help: consider cloning the value if the performance cost is acceptable// |// 8 | let s2 = s1.clone();// | ++++++++// For more information about this error, try `rustc --explain E0382`.在这个例子中，我们尝试打印变量s1的值，但是由于该值的所有权已经转移到s2，所以编译器会报错。这强制我们在编写代码时考虑所有权的转移。所有权的借用在Rust中，我们可以将值的所有权借给一个变量，而不是转移所有权。这称为借用。例如：1234567891011fn main() { let s1 = String::from(\"hello\"); let len = calculate_length(&amp;s1); println!(\"The length of '{}' is {}.\", s1, len);}fn calculate_length(s: &amp;String) -&gt; usize { s.len()}// 输出内容：// The length of 'hello' is 5.在这个例子中，我们创建了一个字符串hello并将其赋值给变量s1。然后，我们通过将变量s1的引用传递给函数calculate_length来借用该字符串的所有权。该函数返回字符串的长度，该长度存储在变量len中。当程序执行到println!宏时，它打印字符串s1的值和变量len的值。当程序执行完毕时，变量s1超出了其作用域，但由于我们只是借用了它，所以该值并没有被释放。需要注意的是，在借用时，我们需要使用引用符号&amp;来指示我们要借用该值的所有权，而不是转移所有权。例如：1234567fn main() { let s1 = String::from(\"hello\"); let s2 = &amp;s1; println!(\"{}\", &amp;s1);}// 输出内容：// hello在这个例子中，我们尝试打印变量s1的值，但是由于我们只是借用了该值的所有权，所以编译器会报错。这强制我们在编写代码时考虑所有权的借用。可变借用在Rust中，我们可以通过可变借用来允许修改借用的值。例如：1234567891011fn main() { let mut s = String::from(\"hello\"); change(&amp;mut s); println!(\"{}\", s);}fn change(s: &amp;mut String) { s.push_str(\", world\");}// 输出内容：// hello, world在这个例子中，我们创建了一个可变字符串hello并将其赋值给变量s。然后，我们通过将变量s的可变引用传递给函数change来可变借用该字符串的所有权。该函数将字符串world添加到字符串s的末尾。当程序执行到println!宏时，它打印字符串s的值，该值现在是hello, world。当程序执行完毕时，变量`s超出了其作用域，但由于我们只是可变借用了它，所以该值并没有被释放。需要注意的是，在可变借用时，我们需要使用可变引用符号&amp;mut来指示我们要可变借用该值的所有权，而不是转移所有权。例如：12345fn main() { let mut s = String::from(\"hello\"); let s_ref = &amp;mut s; println!(\"{}\", s);}在这个例子中，我们尝试打印变量s的值，但是由于我们只是可变借用了该值的所有权，所以编译器会报错。这强制我们在编写代码时考虑所有权的可变借用。所有权和函数在Rust中，函数可以接受值的所有权、借用值的所有权或返回值的所有权。例如：123456789101112fn main() { let s = String::from(\"hello\"); let (s, len) = calculate_length(s); println!(\"The length of '{}' is {}.\", s, len);}fn calculate_length(s: String) -&gt; (String, usize) { let len = s.len(); (s, len)}// 输出内容：// The length of 'hello' is 5.在这个例子中，我们创建了一个字符串hello并将其赋值给变量s。然后，我们将变量s传递给函数calculate_length，该函数接受该字符串的所有权。该函数返回该字符串的长度和该字符串本身。我们使用元组来返回这两个值。当程序执行到println!宏时，它打印字符串s的值和变量len的值。当程序执行完毕时，变量s超出了其作用域，该值将被自动释放。需要注意的是，在函数中接受值的所有权时，该值将被移动。如果我们想在函数中使用该值的引用而不是移动它，我们可以使用借用。例如：123456789fn main() { let s = String::from(\"hello\"); let len = calculate_length(&amp;s); println!(\"The length of '{}' is {}.\", s, len);}fn calculate_length(s: &amp;String) -&gt; usize { s.len()}在这个例子中，我们创建了一个字符串hello并将其赋值给变量s。然后，我们将变量s的引用传递给函数calculate_length，该函数借用该字符串的所有权。该函数返回该字符串的长度。当程序执行到println!宏时，它打印字符串s的值和变量len的值。当程序执行完毕时，变量s超出了其作用域，但由于我们只是借用了它，所以该值并没有被释放。所有权和结构体在Rust中，结构体可以拥有值的所有权。例如：123456789101112struct Person { name: String, age: u8,}fn main() { let p = Person { name: String::from(\"Alice\"), age: 30, }; println!(\"{} is {} years old.\", p.name, p.age);}在这个例子中，我们定义了一个结构体Person，它有两个字段：name和age。name字段是一个字符串，age字段是一个无符号8位整数。然后，我们创建了一个Person实例并将其赋值给变量p。该实例拥有name字段的所有权和age字段的所有权。当程序执行到println!宏时，它打印变量p的name字段和age字段的值。当程序执行完毕时，变量p超出了其作用域，该值将被自动释放。需要注意的是，在结构体中拥有值的所有权时，该值将被移动。如果我们想在结构体中使用该值的引用而不是移动它，我们可以使用借用。例如：12345678910111213struct Person&lt;'a&gt; { name: &amp;'a str, age: u8,}fn main() { let name = String::from(\"Alice\"); let p = Person { name: &amp;name, age: 30, }; println!(\"{} is {} years old.\", p.name, p.age);}在这个例子中，我们定义了一个结构体Person，它有两个字段：name和age。name字段是一个字符串的引用，age字段是一个无符号8位整数。然后，我们创建了一个字符串Alice并将其赋值给变量name。然后，我们创建了一个Person实例并将其赋值给变量p。该实例借用了变量name的值。当程序执行到println!宏时，它打印变量p的name字段和age字段的值。当程序执行完毕时，变量name和变量p超出了其作用域，但由于我们只是借用了它们，所以这些值并没有被释放。所有权和Vec在Rust中，Vec是一个动态数组，它可以拥有值的所有权。例如：123456fn main() { let v = vec![1, 2, 3]; for i in &amp;v { println!(\"{}\", i); }}在这个例子中，我们创建了一个Vec实例并将其赋值给变量v。该实例拥有三个整数的所有权。然后，我们使用for循环遍历v的引用并打印每个值。当程序执行完毕时，变量v超出了其作用域，该值将被自动释放。需要注意的是，在Vec中拥有值的所有权时，该值将被移动。如果我们想在Vec中使用该值的引用而不是移动它，我们可以使用借用。例如：123456fn main() { let v = vec![String::from(\"hello\"), String::from(\"world\")]; for s in &amp;v { println!(\"{}\", s); }}在这个例子中，我们创建了一个Vec实例并将其赋值给变量v。该实例拥有两个字符串的所有权。然后，我们使用for循环遍历v的引用并打印每个字符串。当程序执行完毕时，变量v超出了其作用域，但由于我们只是借用了它们，所以这些值并没有被释放。所有权和闭包在Rust中，闭包可以拥有值的所有权。例如：1234567891011fn main() { let v = vec![1, 2, 3]; let sum = |v: Vec&lt;i32&gt;| -&gt; i32 { let mut total = 0; for i in v { total += i; } total }; println!(\"{}\", sum(v));}在这个例子中，我们创建了一个Vec实例并将其赋值给变量v。然后，我们创建了一个闭包sum，它接受一个Vec并返回一个i32。该闭包拥有v的所有权。然后，我们调用闭包sum并将变量v作为参数传递给它。该闭包计算v中所有整数的总和并返回该总和。当程序执行到println!宏时，它打印变量sum(v)的值。当程序执行完毕时，变量v超出了其作用域，该值将被自动释放。需要注意的是，在闭包中拥有值的所有权时，该值将被移动。如果我们想在闭包中使用该值的引用而不是移动它，我们可以使用借用。例如：1234567891011fn main() { let v = vec![1, 2, 3]; let sum = |v: &amp;Vec&lt;i32&gt;| -&gt; i32 { let mut total = 0; for i in v { total += i; } total }; println!(\"{}\", sum(&amp;v));}在这个例子中，我们创建了一个Vec实例并将其赋值给变量v。然后，我们创建了一个闭包sum，它接受一个&amp;Vec并返回一个i32。该闭包借用了v的值。然后，我们调用闭包sum并将变量v的引用作为参数传递给它。该闭包计算v中所有整数的总和并返回该总和。当程序执行到println!宏时，它打印变量sum(&amp;v)的值。当程序执行完毕时，变量v超出了其作用域，但由于我们只是借用了它们，所以这些值并没有被释放。自动引用和解引用总结在Rust中，所有权系统是一种内存管理方式，它可以避免常见的内存问题，如空指针、内存泄漏和数据竞争。在本教程中，我们深入了解了Rust的所有权系统，并了解了如何使用它来管理内存。我们学习了值的所有权、所有权的转移、所有权的借用、可变借用、所有权和函数、所有权和结构体、所有权和Vec、所有权和闭包等概念。希望本教程能够帮助你更好地理解Rust的所有权系统。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - 包管理和编译工具Cargo",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通",
      "url"         : "./rust/2023/03/12/rust_lang_tutorial_02_cargo.html",
      "date"        : "2023-03-12 12:01:00 +0800",
      "description" : "",
      "content"     : "Cargo是Rust语言的包管理器和构建工具。它能够帮助我们管理依赖、构建项目、运行测试和发布程序等。在Rust社区中，Cargo已经成为了标准的构建工具，它为Rust的开发者提供了极大的便利。安装和使用 cargo在安装Rust时，Cargo也已经随之安装。如果你还没有安装Rust，可以参考系列教程的第一篇 Rust语言从入门到精通系列 - Hello World!, 也可以前往官网 下载安装包进行安装。安装完成后，可以通过以下命令来检查Cargo是否安装成功：12cargo --version# cargo 1.68.0 (115f34552 2023-02-26)输出了Cargo的版本号，说明安装成功。环境检查完成，下面开始Cargo的学习。我们先回顾一下上一篇文章中使用过的Cargo命令。第一个使用Cargo命令是”cargo new”, 创建了我们的第一个Rust项目。没看过第一篇的同学可以尝试如下命令创建：1cargo new hello_world这条命令会在当前目录下创建一个名为hello_world的新项目。其中，hello_world是项目的名称，可以根据自己的需要进行修改。创建完成后，打开项目的目录hello_world。目录结构如下图所示：12345678/├── Cargo.lock├── Cargo.toml├── crate-information.json├── src/│ ├── main.rs└── target/└── tools/Cargo生成的最基本的项目结构，包括src目录(用于存放开发的源代码)和Cargo.toml文件(管理项目元数据、编译构建、第三方库依赖等等)。在src目录下，我们看到一个名为main.rs的文件，它是Rust程序的入口文件，内部实现一个默认的main()方法：123fn main() { println!(\"Hello, world!\");}在main()方法体中输入 println!(\"Hello, world!\");这就是一个非常简单的程序，它的功能是再命令提示符窗口打印输出一句话“Hello, world!”。在VS Code中按 F5 运行你的第一个程序吧。假如你没有配置VS Code启动配置，那么再运行程序之前，Cargo会先使用build命令来构建项目，生成可执行文件。至此，我们又新接触了一个cargo命令 build：1cargo buildcargo build 命令会在项目的根目录下生成一个target目录，其中包含了构建后的二进制文件。在默认情况下，Cargo会生成一个名为hello_world的二进制文件。如果只想编译项目而不生成二进制文件，可以使用以下命令：1cargo check这条命令会检查代码是否可以编译通过，但不会生成二进制文件。在构建完成后，我们可以使用以下命令来运行程序：1cargo run这条命令会自动编译并运行项目。如果一切正常，你应该能够看到和Vs Code按F5启动一样的“Hello, world!”的输出。常用指令上一小节，我们使用了Cargo的new，build, run, check四个指令，除了这几个指令外，Cargo 还提供了更多的指令，下面列举并注释其中最常用的一些指令： new: 指令可以创建一个新的 Rust 项目。它有两个参数，第一个参数是项目名称，第二个参数是项目类型，可以是 bin 或 lib。默认情况下，new 会创建一个二进制bin项目。 init: 指令可以将当前目录初始化为一个 Rust 项目。它会创建一个默认的 src 目录和 Cargo.toml 文件。 check: 指令可以检查代码是否可以编译通过，但 不会生成二进制文件。 build: 指令可以编译 Rust 项目，并生成二进制文件。如果项目已经编译过，build 指令会跳过编译过程。 run: 指令可以编译并运行 Rust 项目。如果项目已经编译过，run 指令会跳过编译过程。 test: 指令可以运行项目中的测试。测试代码通常放在 src/test.rs 或 src/lib.rs 中。 bench: 指令可以运行项目中的基准测试。基准测试用来测试代码的性能。 doc: 指令可以生成项目的文档。文档通常使用 Rust 内置的文档工具 rustdoc 来生成。 clean: 指令可以清除项目的构建文件和生成的二进制文件。 update: 指令可以更新项目中的依赖。 publish: 指令可以将项目发布到 crates.io 上，供其他人使用。更多指令可以通过 cargo –help 或 cargo &lt;command&gt; –help 查看。自定义扩展指令依赖管理在Rust项目中，我们可以使用Cargo来管理依赖。可以通过编辑Cargo.toml文件来添加依赖。例如，我们想要使用rand库来生成随机数，可以在Cargo.toml文件中添加以下内容：12[dependencies]rand = \"0.8.4\"这条语句告诉Cargo，我们需要使用rand库，并且希望使用版本号为0.8.4的版本。在保存文件后，可以使用以下命令来安装依赖：1cargo build这条命令会自动下载并安装依赖。在代码中使用依赖时，我们需要在main.rs文件中添加以下语句：1234567use rand::Rng;fn main() { let mut rng = rand::thread_rng(); let n: u8 = rng.gen(); println!(\"Random number: {}\", n);}这里，我们使用了rand库中的Rng trait和thread_rng函数来生成随机数。版本号控制上面的示例我们引入了指定0.8.4版本的rand库依赖，并在命令提示符中打印了随机数。这里我们进一步对依赖管理进行学习。除了指定依赖的特定版本外，我们还可以使用逻辑运算符控制版本范围, 具体如下： =: 等于某个版本。等同于直接填写版本号 &gt;: 大于某个版本。 &lt;=: 小于等于某个版本。 ~: 大约等于某个版本，例如~1.2.3表示大约等于1.2.3，但是允许最后一位数字不同，例如1.2.4。 \\^: 兼容某个版本，例如^1.2.3表示兼容1.2.x系列的所有版本，但是不兼容2.0.0及以上版本。假如我们想指定依赖库的版本号大于等于0.7.3版本 且 小于0.8.4，示例：12[dependencies]rand = \"&gt;=0.7.3, &lt;0.8.4\"指定依赖项的特性有些库提供了多个特性，可以用来启用或禁用某些功能。例如，serde库提供了一个名为derive的特性，用于启用派生宏。为了指定依赖项的特性，可以使用如下语法：12[dependencies]库名称 = { version = \"版本号\", features = [\"特性名称\"] }log是一个用于日志记录的库。它提供了多个特性，可以用来启用或禁用某些功能。下面是一些常见的特性及其用途： std: 用于启用log的标准库支持，可以在标准库环境中使用log。 env_logger: 用于启用log的环境变量支持，可以使用环境变量来控制日志输出。 log4rs: 用于启用log的log4rs支持，可以使用log4rs库来配置日志输出。 simplelog: 用于启用log的simplelog支持，可以使用simplelog库来配置日志输出。下面是一个示例：12[dependencies]log = { version = \"0.4\", features = [\"std\"] }除了启用特性之外，还可以禁用特性，例如：12[dependencies]log = { version = \"0.4\", default-features = false }指定依赖项的路径在某些情况下，我们可能需要使用本地文件系统中的库。为了指定依赖项的路径，可以使用如下语法：12[dependencies]rand = { path = \"../rand\" }在这个例子中，我们指定了一个名为rand的库，路径为../rand。这告诉Cargo编译器，我们的项目需要使用本地文件系统中的rand库。当我们运行cargo build命令时，Cargo会自动编译指定路径下的rand库，并将它添加到我们的项目中。除了使用本地文件系统中的库之外，我们还可以使用git仓库中的库。为了指定依赖项的git仓库，可以使用如下语法：12[dependencies]rand = { git = \"https://github.com/rust-lang-nursery/rand.git\" }项目元数据本文的前面章节介绍了Cargo的常用质量，依赖管理特性。本小节主要讲解Cargo.toml文件中定义的程序元数据，例如：程序的名称、版本号、作者和描述等信息：1234567891011[package]## 项目名(程序名称)name = \"hello_world\"## 版本号version = \"0.1.0\"## 作者, 多个按逗号分隔authors = [\"Your Name &lt;your_email@example.com&gt;\"]## 项目描述description = \"A hello world program in Rust.\"## Rust语言的版本，目前支持2015、2018和2021 三个版本。edition = \"2021\"除了基础的元数据外，我们还可以在[package.metadata]下自定义专属的元数据：1234[package.metadata]url = \"https://github.com/username/hello-world\"doc = \"https://docs.rs/hello-world\"repository = \"https://github.com/username/hello-world.git\"总结通过本文的介绍，我们了解了Rust语言的包管理器和构建工具Cargo。学习了如何创建一个新的Rust项目、编写Rust程序、构建和运行程序、添加依赖等操作。"
    } ,
  
    {
      "title"       : "Rust语言从入门到精通系列 - Hello World!",
      "category"    : "",
      "tags"        : "Rust, 从入门到精通",
      "url"         : "./rust/2023/03/12/rust_lang_tutorial_01.html",
      "date"        : "2023-03-12 12:00:00 +0800",
      "description" : "",
      "content"     : "Rust是一种系统级编程语言，由Mozilla开发，旨在提供安全性、并发性和性能。它具有内存安全和无数据竞争的特性，可以用于编写高性能的服务器端应用、操作系统、游戏等。本教程将一步一步的讲解Windows 10 操作系统下，使用Visual Studio Code编辑器搭建Rust语言开发环境。 初学者可以使用 官方提供的在线编辑器Play Rust Online 学习搭建Rust开发环境首先，打开Rust官网下载地址见如下截图，选择对应的32位或64位安装包，博主安装的是64位的安装包。安装完成后，可以使用Win+R输入cmd 打开命令提示符，输入以下命令验证Rust是否安装成功：123rustc --version# 输出类似于下方的信息，则说明安装成功# rustc 1.68.0 (2c8cc3432 2023-03-06)接下来就是安装官网维护的VS Code市场里面的Rust语言服务器插件插件提供代码补全，代码引用、定义导航，错误提示，代码高亮，单元测试等等，极大的改善开发者的开发环境，提高开发效率。其次，推荐微软推出的rust anycode插件：第三个推荐better-toml插件，提供 TOML 文件格式的语法高亮和代码补全等方面的支持，对于 Rust 项目中的 Cargo.toml 文件非常有用Rust的Hello World!在VS Code中，可以使用“Terminal”菜单下的“New Terminal”命令打开一个终端窗口。在终端中输入以下命令创建一个新的Rust项目：1cargo new myproject这个命令会在当前目录下创建一个名为“myproject”的文件夹，其中包含一个默认的Rust项目。目录结构如下图所示：12345678/├── Cargo.lock├── Cargo.toml├── crate-information.json├── src/│ ├── main.rs└── target/└── tools/使用VS Code打开“myproject”文件夹，可以看到其中包含一个名为“main.rs”的文件。这个文件是Rust项目的入口文件，可以在其中编写代码。以下是一个简单的Rust程序，可以输出“Hello, world!”：123fn main() { println!(\"Hello, world!\");}在终端中进入“myproject”文件夹，使用以下命令编译并运行代码：12cargo run# Hello World!到这一步，我们基本上已经把Rust的开发、编译环境搭建完成，也成功的开发了我们的第一个Rust程序。VS Code设置在项目根目录下 .vscode 文件夹中创建 launch.json 文件。以下是一个示例的 launch.json 文件：123456789101112131415161718192021{ \"version\": \"0.2.0\", \"configurations\": [ {// 配置名称，用于在 VS Code 中显示。 \"name\": \"Debug Rust\",// 调试器类型，Rust 语言的调试器类型是 lldb。 \"type\": \"lldb\",// 调试请求类型，Rust 语言的调试请求类型是 launch。 \"request\": \"launch\",// 可执行文件路径，需要指定到 target/debug 目录下的可执行文件。 \"program\": \"${workspaceFolder}/target/debug/myproject\",// 可执行文件的参数，可以为空。 \"args\": [],// 工作目录，需要指定为项目根目录。 \"cwd\": \"${workspaceFolder}\",// 调试前需要执行的任务，一般为编译任务。 \"preLaunchTask\": \"cargo build\" } ]}配置完成后，在 VS Code 中按下 F5 键即可启动 Rust 代码的调试。总结本教程介绍了如何使用VS Code搭建Rust语言开发环境，并提供了一些示例代码和配置。通过学习本教程，读者可以了解如何创建Rust项目、编写代码、运行代码和调试代码。"
    } ,
  
    {
      "title"       : "OpenJDK时代更迭，CMS落寞与新王G1GC的崛起",
      "category"    : "",
      "tags"        : "jdk, g1gc, cms",
      "url"         : "./jdk/g1gc/cms/2023/03/10/OpenJDK_GC_CMS.html",
      "date"        : "2023-03-10 12:00:00 +0800",
      "description" : "",
      "content"     : "本文主要讲解G1GC和CMS两者的区别。善始善终的GC算法 - CMSCMS算法原理 JDK 17 LTS已经彻底移除此GC算法.CMS算法的核心思想是通过将垃圾回收过程拆分为多个阶段来减少垃圾回收对应用程序执行的影响，这些阶段包括： 初始标记阶段：在此阶段中，垃圾回收器仅扫描可达对象和GC Roots（如静态变量、本地变量、活动线程的堆栈中的引用）来确定哪些对象是需要被保留的。此阶段需暂停应用程序。 并发标记阶段：在此阶段中，垃圾回收器扫描所有的对象，并且跟踪所有的引用（包括被标记为可达的对象），同时应用程序在运行。 重新标记阶段：在此阶段中，GC运行在停止所有应用程序线程的情况下，以便找到在并发标记期间发生的新引用，并对其进行标记。这个阶段需要关闭应用程序线程，但持续的时间比初始标记阶段更短。 并发清除阶段：在此阶段中，GC运行在应用程序线程的同时释放以这些程序为根的所有已标记为不可达的对象。 失败保护：如果在并发标记或并发清除期间发现分配失败或分配缓慢，则进入失败保护阶段。在此阶段，GC暂停应用程序线程，使清除过程继续进行，并在必要时重新开始整个垃圾回收过程。 在CMS算法中，应用程序线程与垃圾回收线程并发执行，从而尽可能减少应用程序的停顿时间。但需要注意的是，CMS会消耗一部分的处理器资源，因此需要在性能和吞吐量之间做出权衡。CMS算法的流程下面是CMS算法执行的大体流程：graph LR; A[初始化GC] --&gt; B[初始标记] B --&gt; C[并发标记] C --&gt; D[重新标记] D --&gt; E[并发清除] E --&gt; F[失败保护]注：箭头的方向从上到下，表示流程的先后顺序。CMS算法的重要参数以下是一些关键的CMS算法参数和示例代码： -XX:CMSInitiatingOccupancyFraction：触发执行CMS的占用率百分比。默认为68。 1-XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSInitiatingOccupancyOnly：表示仅在CMS触发执行时才调用垃圾回收器。默认为false。 1-XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCMSCompactAtFullCollection：在执行完一次Full GC的时候，对整个Heap进行压缩，减少Heap的碎片。 1-XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction：表示执行多少次Full GC之后，就会执行一次Heap压缩。 1-XX:CMSFullGCsBeforeCompaction=3 -XX:ConcGCThreads：并发执行GC的线程数。 1-XX:ConcGCThreads=2 -XX:-CMSConcurrentMTEnabled：关闭CMS的多线程并发执行。默认为true。 1-XX:-CMSConcurrentMTEnabled 以上参数可以通过在启动Java应用程序时指定相应的命令行参数来设置。JVM垃圾回收的柱石 - G1GCG1是一种设计用于多核和大容量内存系统的垃圾回收器，它的主要目标是提供稳定的低延迟和高吞吐量，在尽可能短的时间内回收垃圾。G1算法原理G1算法将堆内存按照Region（固定大小的内存块）进行划分，然后通过几个阶段来回收垃圾： 初始标记阶段：在此阶段中，垃圾回收器初步扫描GC Roots（如静态变量、本地变量、活动线程的堆栈中的引用）和部分可达对象，用于确定哪些Region中有垃圾需要回收。此阶段暂停应用程序。 并发标记阶段：在此阶段中，垃圾回收器并发进行扫描和标记所有可达对象，同时应用程序在运行。在此过程中，垃圾回收器记录Region的垃圾情况，以便后续的回收。 最终标记阶段：在此阶段中，垃圾回收器再次暂停应用程序，进一步标记所有垃圾对象，并清除被标记为垃圾的Region。 重置阶段：在此阶段中，垃圾回收器对未清除的Region进行清除，并将这些Region添加到空闲列表中。此阶段需要暂停应用程序。 G1算法的特点是将垃圾回收过程拆分为多个阶段，并且在整个过程中都与应用程序并发运行，以便减少应用程序的停顿时间。此外，G1还能够根据下一次垃圾回收分配时间，智能选择回收目标和回收的内存区域，以最小化回收垃圾的时间和影响。G1算法的流程下面是G1算法执行的大体流程：graph LR; A[初始化GC] --&gt; B[初始标记] B --&gt; C[并发标记] C --&gt; D[最终标记] D --&gt; E[重置]注：箭头的方向从上到下，表示流程的先后顺序。G1算法的重要参数以下是一些关键的G1算法参数和示例代码： -XX:MaxGCPauseMillis：指定最大GC停顿时间，G1会尽可能满足这个要求。默认是200ms。 1-XX:MaxGCPauseMillis=100 -XX:G1HeapRegionSize：指定Region的大小。默认为堆大小的1/2000。可以根据情况进行调整。 1-XX:G1HeapRegionSize=2m -XX:G1NewSizePercent：指定G1的新生代大小占比。默认为5%。 1-XX:G1NewSizePercent=10 -XX:G1MaxNewSizePercent：指定G1的最大新生代大小占比。默认为60%。 1-XX:G1MaxNewSizePercent=70 -XX:MaxGCPauseMillis：指定最大GC停顿时间。默认为200ms。 1-XX:MaxGCPauseMillis=100 -XX:G1HeapWastePercent：指定堆浪费的最大百分比。默认为5%。 1-XX:G1HeapWastePercent=10 以上参数可以通过在启动Java应用程序时指定相应的命令行参数来设置。对比G1GC和CMS的差异 内存区域: G1GC和CMS的内存区域划分方式不同。G1GC将堆内存划分为大小相等的Region，而CMS则将堆内存划分为两个区域：年轻代和老年代。 执行过程: G1GC采用了一种增量回收的方式，将整个垃圾回收过程分为多个周期，每个周期内仅回收部分区域的垃圾。而CMS算法则是一种基于标记清除的算法，其回收过程可分为四个阶段：初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。 低延迟: G1GC算法的一个重要特点是低延迟，它可以根据用户指定的最大停顿时间来调整回收策略，从而尽可能减少应用程序的停顿时间。而CMS算法也具备低延迟的优势，它的并发标记和清理过程不需要停止应用程序，因此可以减少应用程序的停顿时间。 压缩机制: G1GC算法具有自动压缩机制，它可以定期对需要压缩的Region进行压缩，从而减少内存碎片，提高内存利用率。而CMS算法则没有内存压缩机制，因此当出现内存碎片时，可能需要重新分配连续的内存空间，这可能会导致应用程序对内存资源的争夺，从而影响应用程序的性能。 可控性: G1GC算法具有高度的可控性，用户可以通过指定多个参数来控制垃圾回收过程，从而适应不同的性能需求和场景。而CMS算法的可控性相对较低，用户可以指定的参数较少，因此可能需要使用更高级的工具和技术来优化和调整垃圾回收过程。"
    } ,
  
    {
      "title"       : "简单的Golang泛型教程",
      "category"    : "",
      "tags"        : "golang, 泛型",
      "url"         : "./golang/%E6%B3%9B%E5%9E%8B/2023/03/10/golang_generic_program.html",
      "date"        : "2023-03-10 12:00:00 +0800",
      "description" : "",
      "content"     : "Golang泛型教程Golang是一门比较年轻的编程语言，在经过长期的发展之后，其在各个领域都已经得到了广泛应用。Golang的1.17版本开始引入泛型特性的支持。Golang泛型主要有以下几个方面的应用： 函数和方法的泛型声明 接口的泛型声明 结构体和嵌入的泛型接下来，我们将会深入探究这些方面的内容，并且通过简单的示例代码来演示Golang泛型的用法。函数和方法的泛型声明在Golang 1.17之前，Golang的函数和方法中只支持使用具体类型进行声明，在函数内部也都只能使用特定类型的变量或参数。而引入泛型之后，Golang的函数和方法中就可以使用泛型类型进行声明了。泛型函数在函数中使用泛型类型进行声明的语法为：123func 函数名[T any](参数列表) 返回值类型 { // 函数体}其中，T代表任意类型，可以在函数内部用于声明变量或参数。下面是一个示例代码，演示了如何在函数中使用泛型：1234567891011func Swap[T any](a, b *T) { *a, *b = *b, *a}func main() { // 使用泛型函数 a := 1 b := 2 Swap(&amp;a, &amp;b) fmt.Println(a, b)}这段代码中，我们声明了一个名为Swap的泛型函数，该函数接收两个指向任意类型的变量的指针，并且使用*操作符进行变量内容的交换。在实际调用该函数的时候，我们传递了两个int类型的指针，使得a和b的值进行了交换。泛型方法对于方法而言，我们同样可以使用泛型类型进行声明。在方法中使用泛型类型进行声明的语法为：1234func (接收者类型) 方法名[T any](参数列表) 返回值类型 { // 函数体}其中，T代表任意类型，并且可以在方法内部用于声明变量或参数。下面是一个示例代码，演示了如何在方法中使用泛型：12345678910111213141516171819202122type Stack[T any] []Tfunc (s *Stack[T]) Push(v T) { *s = append(*s, v)}func (s *Stack[T]) Pop() T { index := len(*s) - 1 res := (*s)[index] *s = (*s)[:index] return res}func main() { // 使用泛型方法 var s Stack[int] s.Push(1) s.Push(2) s.Push(3) fmt.Println(s.Pop()) fmt.Println(s.Pop())}这段代码中，我们声明了一个名为Stack的泛型类型，并且在其中声明了两个泛型方法Push和Pop。这两个方法都使用了T作为自己的泛型类型，使得方法可以适用于任意类型。在实际使用的时候，我们通过Stack[int]来声明一个类型为int的栈，并且对其进行了相应的操作。接口的泛型声明在Golang 1.17后，我们还可以使用泛型类型来声明接口。在这种情况下，我们可以使用type关键字来定义一个代表任意类型的泛型类型，并且在接口中使用该类型来进行声明。下面是一个示例代码，演示了如何在接口中使用泛型：12345678910111213141516171819202122232425262728293031323334type Container[T any] interface { Get() T Put(v T)}type Stack[T any] []Tfunc (s *Stack[T]) Push(v T) { *s = append(*s, v)}func (s *Stack[T]) Pop() T { index := len(*s) - 1 res := (*s)[index] *s = (*s)[:index] return res}func (s *Stack[T]) Get() T { return s.Pop()}func (s *Stack[T]) Put(v T) { s.Push(v)}func main() { // 使用泛型接口 var c Container[int] = new(Stack[int]) c.Put(1) c.Put(2) fmt.Println(c.Get()) fmt.Println(c.Get())}这段代码中，我们声明了一个名为Container的泛型接口，并且在其中声明了Get和Put两个方法，这两个方法都使用了T作为自己的泛型类型。而在Stack类型的实现中，我们同样实现了Get和Put方法，并且额外声明了一个方法Pop，用于从栈中获取元素。在实际使用中，我们通过Container[int]声明了一个类型为int的容器，并且使用Stack[int]实现了该容器。结构体和嵌入的泛型在Golang 1.17后，我们还可以在结构体和嵌入中使用泛型类型进行声明。这种情况下，我们可以使用与函数和方法类似的语法进行声明。下面是一个示例代码，演示了如何在结构体和嵌入中使用泛型：1234567891011121314type Pair[T any] struct { first T second T}type IntPair struct { Pair[int]}func main() { // 使用结构体和嵌入的泛型 p := IntPair{Pair[int]{1, 2}} fmt.Println(p.first, p.second)}这段代码中，我们声明了一个名为Pair的泛型结构体，并且定义了一个包含两个成员变量first和second的结构体。在IntPair类型的定义中，我们嵌入了Pair[int]，使得IntPair类型包含了两个类型为int的成员变量。在实际使用中，我们通过IntPair{Pair[int]{1, 2}}来创建一个类型为IntPair的变量p，并且获取了其中的两个成员变量。总结到此为止，我们已经讲解了在Golang 1.17中泛型的主要应用场景，包括函数、方法、接口、结构体和嵌入。在实际开发中，我们可以使用这些泛型来提高程序的可扩展性和可重用性，从而让程序更加灵活和具有适应性。如果您还没有尝试过使用Golang中的泛型，那么不妨在接下来的代码中尝试一下吧！"
    } ,
  
    {
      "title"       : "详解Rust语言的trait关键字",
      "category"    : "",
      "tags"        : "rust, trait",
      "url"         : "./rust/trait/2023/03/06/Rust_lang_trait.html",
      "date"        : "2023-03-06 22:22:00 +0800",
      "description" : "",
      "content"     : "trait是Rust中非常重要的关键字，借助这个关键字可以实现多重继承，使得Rust程序员可以使用它来为不同的类型创建行为。Traits通过定义可被其他类型实现的方法，来实现“ Mixins”模式：将行为加载到不同的类型上。trait关键字可以用来定义traits，traits代表了一组具有相同特征的集合，指定trait的实现者必须提供实现每一个成员函数的具体实现。例如，如果你定义了一个Comparator trait，那么它的实现者必须实现equal、greater和less三个函数。trait关键字的优缺点traits有三大优点： 代码复用。 traits可以避免重复地实现相同的逻辑，而是可以被不同的实现者共享。 动态调用。 traits实现的函数可以有动态多态，这意味着在编译时不需要知道实现者，而只需要确保trait被实现即可。 更好的设计。使用traits来对实现进行抽象，可以更好的将实现和概念分离，这样既可以更好的理解代码，也可以更好的扩展代码。traits也有一些缺点，例如：它的实现是静态绑定的，而且在涉及到大量traits的实现时，容易造成膨胀性和代码冗余。无法实现动态多态，导致的动态多态的潜在性能开销。trait 基础用法示例1234567891011121314151617以下是一个示例trait，它定义了一个\"swim\"函数，用来描述如何游泳：// Define a trait for swimming trait Swimming { fn swim(&amp;self); }// Implement the trait for a type struct Fish; impl Swimming for Fish { fn swim(&amp;self) { println!(\"Fish is swimming!\"); } }// Use the traitfn do_something&lt;T: Swimming&gt;(x: T) { x.swim(); }fn main() { // Create a value of type Fish let fish = Fish;// Pass the fish to the functiondo_something(fish);} 实现多重继承，示例代码如下：123456789101112131415161718192021222324252627282930313233343536// Define two traits for swimming and flyingtrait Swimming { fn swim(&amp;self);} trait Flying { fn fly(&amp;self);}// Implement the two traits for a typestruct Fish;impl Swimming for Fish { fn swim(&amp;self) { println!(\"Fish is swimming!\"); }}impl Flying for Fish { fn fly(&amp;self) { println!(\"Fish is flying!\"); }}// Use the traitfn do_something&lt;T: Swimming + Flying&gt;(x: T) { x.swim(); x.fly();}fn main() { // Create a value of type Fish let fish = Fish; // Pass the fish to the function do_something(fish);}trait 泛型约束trait约束是Rust中一种非常有用的特性，它可以让程序员定义更具体的类型要求，而不是使用通用的类型。Rust中的trait约束通过一个where子句指定，可以用来定义函数参数类型必须实现的trait。例如，假设你有一个trait Summable， 它定义了一个sum方法：123trait Summable { fn sum(&amp;self);}现在你想定义一个函数，它的参数必须是Summable trait的实现者，那么可以使用trait约束：123fn foo&lt;T: Summable&gt;(x: T) { x.sum();}这样 foo 函数就只能接受 Summable trait 的实现者作为参数，而其他类型则会导致编译错误。trait 别名trait 别名是Rust中另一种有用的特性，它可以为trait创建别名，从而更容易地使用多个trait作为类型参数。例如，假设你有一个trait Swimmable，它定义了一个 swim 方法：123trait Swimmable { fn swim(&amp;self);}现在你想定义一个函数，它的参数必须是Swimmable trait或者Flyable trait的实现者，为此可以使用trait别名：1234567// Create a trait alias for Swimmable and Flyabletrait CanMove = Swimmable + Flyable;fn foo&lt;T: CanMove&gt;(x: T) { x.swim(); x.fly();}这样foo函数就可以接受Swimmable和Flyable trait的实现者作为参数，而其他类型则会导致编译错误。derivederive是Rust中一种特殊语法，它可以自动实现某些trait。 当使用derive时，Rust会在编译阶段自动分析代码，并为你生成所需的 trait 实现。 这允许开发者更快速地实现那些已经被编写过多次的 trait。例如，有一个Traversable trait，它可以用来表示访问器。它包含一个traverse函数，用来指定一个访问器应该如何遍历一个容器：123trait Traversable { fn traverse(&amp;self);}如果想要为Vec类型实现这个trait，可以使用#[derive]标记：1234# [derive(Traversable)]struct Vec&lt;T&gt; { // ...}这意味着Rust会在编译阶段自动为 Vec 生成 Traversable trait 的实现，而不需要程序员自己实现它。总结本文详细的讲解了trait关键字优缺点，通过示例介绍了基础语法，讲解了泛型约束和别名。并扩展的介绍了derive属性，以及如何结合trait关键字工作。"
    } ,
  
    {
      "title"       : "详解Redis的发布订阅模式",
      "category"    : "",
      "tags"        : "rust, trait",
      "url"         : "./rust/trait/2023/03/06/Redis_Pub_Sub_Commands.html",
      "date"        : "2023-03-06 22:22:00 +0800",
      "description" : "",
      "content"     : "Redis发布订阅（Pub/Sub）是Redis的一个功能，用于支持系统之间传递消息。它使用“订阅者”和“发布者”模式，允许发布者将消息发送到一组订阅者，而无需知道谁是订阅者。这种模式可以用来构建多个客户端的复杂的通信拓扑。Redis发布者和订阅者模式Redis发布订阅（Pub/Sub）是Redis提供的一种消息传递机制，它使用“发布者-订阅者”（publisher-subscriber）模式来处理消息传递。在这种模式下，发布者将消息发布到一组订阅者中，而无需关心谁是订阅者，也不需要知道订阅者是否收到了消息。发布者和订阅者模式允许多个客户端之间建立一个复杂的通信拓扑。在这种模式下，发布者可以发布消息到一个特定的主题，订阅者可以订阅一个或多个主题，并在发布者发布消息时收到消息。由于发布者和订阅者不必直接连接，因此发布者和订阅者可以完全独立地运行，只要它们都连接到Redis实例即可。Redis发布订阅支持多种消息类型，包括文本、字节数组和数字等。 Redis还支持订阅者识别特定消息，通过模式匹配功能，可以基于主题模式或模式来检索消息。Redis还提供了许多API来帮助您实现发布/订阅模式，因此您可以使用Redis的发布/订阅功能来构建分布式应用程序。以下列举几个比较常见业务场景： 多用户即时消息：使用Redis的发布/订阅功能，可以实现多用户即时聊天服务。 事件处理：Redis发布订阅可以用来处理应用程序中的事件，例如文件上传、数据库更新等。 在线投票：Redis发布订阅可以用于在线投票，可以向所有投票者实时发送最新的投票结果。 日志收集：Redis发布订阅可以用于收集日志，可以将日志信息发送到一个中央服务器，进行日志分析。 分布式缓存：Redis发布订阅可以用于实现分布式缓存，可以在多台服务器之间共享缓存。Redis Pub/Sub 命令Redis发布订阅（Pub/Sub）分为两种，第一种基于频道(Channel)的发布/订阅。第二种基于模式(pattern)的发布/订阅。相关的命令如下： PUBLISH：用于将消息发布到特定的主题。允许发布者将消息发送到一组订阅者中 SUBSCRIBE：用于订阅一个或多个主题，并在发布者发布消息时收到消息。 UNSUBSCRIBE：用于停止监听一个或多个主题。 PSUBSCRIBE：用于使用模式订阅主题，它允许订阅者使用模式来识别特定消息，而不必直接订阅每个消息。 PUNSUBSCRIBE：用于停止使用模式订阅主题。自Redis 7.x开始提供一套新的Sharded Pub/Sub功能，新增 SSUBSCRIBE, SUNSUBSCRIBE 和 SPUBLISH 三个命令。Sharded Pub/Sub是一种基于分片的发布/订阅模式，它允许将多个Redis服务器集群中的消息传递结合在一起，以便实现大规模消息传递。Sharded Pub/Sub可以实现大规模消息传递，使用者可以根据自己的情况来指定要使用的Redis服务器数量，也可以指定不同的Redis服务器来处理不同的消息流。 Sharded Pub/Sub还可以支持多个Sharded实例，以支持跨多个Data Center或Region的消息传递。另外，Sharded Pub/Sub还可以支持容错性，如果某个Redis服务器出现问题，其他Redis服务器可以继续处理消息。此外，Sharded Pub/Sub还可以支持动态负载平衡，可以自动将消息分发到不同的Redis集群服务器上，以最大限度地利用Redis服务器的性能。Redis客户端API实现Pub/Sub使用Jedis库实现最基础的发布/订阅功能。123456789101112131415161718// 创建Jedis实例Jedis jedis = new Jedis(\"localhost:6379\");// 创建一个消息监听器JedisPubSub listener = new JedisPubSub() { // 消息到来时调用onMessage @Override public void onMessage(String channel, String message) { System.out.println(message); }};// 订阅消息jedis.subscribe(listener, \"channel1\");// 发布消息jedis.publish(\"channel1\", \"Hello World!\");使用Redission库的异步API，可以实现扩展性更好，吞吐量更高的发布/订阅功能。客户端和服务端的示例代码如下：客户端代码：1234567891011121314151617181920212223// 创建Redisson实例Config config = new Config();config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");RedissonClient redisson = Redisson.create(config);// 订阅消息RTopic&lt;String&gt; topic = redisson.getTopic(\"channel1\");topic.addListenerAsync((channel, msg) -&gt; { System.out.println(msg);});// 用户输入消息并发送Scanner scanner = new Scanner(System.in);while (true) { String message = scanner.nextLine(); if (message.equals(\"exit\")) { break; } topic.publishAsync(message);}// 退出聊天redisson.shutdown();聊天服务端代码：12345678910111213// 创建Redisson实例Config config = new Config();config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");RedissonClient redisson = Redisson.create(config);// 发布消息RTopic&lt;String&gt; topic = redisson.getTopic(\"channel1\");topic.publishAsync(\"Welcome to the chat room!\");// 接收消息topic.addListenerAsync((channel, msg) -&gt; { System.out.println(msg);});总结保证Redis服务器的性能，避免大量的客户端连接影响Redis的性能。要尽量减少消息的大小，以减少网络传输所需的时间。要注意处理消息的容错性，避免因网络问题而导致消息丢失。如果要处理大量消息，可以考虑使用Sharded Pub/Sub技术，以提高性能和可用性。"
    } ,
  
    {
      "title"       : "详解linux文本搜索和操作工具 - EGREP",
      "category"    : "",
      "tags"        : "linux, egrep",
      "url"         : "./linux/egrep/2023/03/06/linux_command_egrep.html",
      "date"        : "2023-03-06 12:00:00 +0800",
      "description" : "",
      "content"     : "在 Linux 世界中，有许多工具可以帮助您操作文本文件。 EGREP 就是这样一种工具，以其强大的正则表达式搜索功能脱颖而出。在这篇博文中，我们将探讨 EGREP 命令的基础知识以及如何使用它来搜索和操作文本。基本语法和用法EGREP 命令是 GREP 命令的变体，代表全局正则表达式打印。 EGREP 命令的基本语法如下：1egrep [options] [pattern] [file]这里，[options] 是可以与命令一起使用的各种选项，[pattern] 是要搜索的正则表达式模式，[file] 是要搜索的文件的名称。EGREP 命令有许多可用于修改其行为的选项。以下是一些最常用的选项： i : 执行不区分大小写的搜索 v : 反转搜索，即打印所有与模式不匹配的行 w : 仅匹配构成一个完整单词的模式 n : 打印行号和匹配的行 c : 只打印匹配行的数量，而不是行本身 o : 只打印行的匹配部分，而不是整行 r : 执行递归搜索，即搜索指定目录及其子目录中的所有文件 l : 只打印包含模式的文件名，而不是行本身这些选项可以结合起来创建强大的搜索命令。例如，要在目录及其子目录中的所有文件中搜索单词“apple”，同时忽略大小写并仅打印包含该单词的文件名，可以使用以下命令：1egrep -irl 'apple' /path/to/directory这将递归搜索指定目录及其子目录中的所有文件以查找单词“apple”，同时忽略大小写，并仅打印包含该单词的文件的名称。请记住，这些只是 EGREP 命令可用的众多选项中的几个示例。通过一些练习和实验，您可以熟练使用 EGREP 在 Linux 中搜索和操作文本文件。例如，要在名为“fruits.txt”的文件中搜索单词“apple”，命令为：1egrep 'apple' fruits.txt此命令的输出将是文件中包含单词“apple”的所有行。以下是 EGREP 命令的语法和用法的一些其他示例： 要搜索多个模式，您可以使用“|”运算符。例如，要搜索包含“apple”或“banana”的行，命令为：1egrep 'apple|banana' fruits.txt 要搜索不包含特定模式的行，您可以使用 v 选项。例如，要搜索不包含单词“apple”的行，命令为：1egrep -v 'apple' fruits.txt 要搜索以特定模式开头的行，您可以使用 ^ 运算符。例如，要搜索以单词“apple”开头的行，命令为：1egrep '^apple' fruits.txt 要搜索以特定模式结尾的行，您可以使用“$”运算符。例如，要搜索以单词“apple”结尾的行，命令为：1egrep 'apple$' fruits.txt 要执行不区分大小写的搜索，您可以使用“i”选项。例如，要搜索包含单词“apple”而不区分大小写的行，命令为：1egrep -i 'apple' fruits.txt请记住，这些只是 EGREP 命令可用的众多选项和功能中的几个示例。通过一些练习和实验，您可以熟练使用 EGREP 在 Linux 中搜索和操作文本文件。正则表达式如前所述，EGREP 命令的关键特性之一是它能够使用正则表达式搜索模式。正则表达式是定义搜索模式的字符序列。正则表达式可用于在较大的文本中搜索特定的字符串、字符或字符模式。以下是可与 EGREP 命令一起使用的正则表达式的一些示例： [a-z] - 匹配从 a 到 z 的任何小写字母 [0-9] - 匹配从 0 到 9 的任何数字 . - 匹配任何单个字符 `` - 匹配前一个字符或模式的零次或多次出现 + - 匹配前一个字符或模式的一次或多次出现使用正则表达式，您可以在文本文件中搜索复杂的模式，例如电子邮件地址、电话号码或 URL。总结EGREP 命令是 Linux 中搜索和操作文本文件的强大工具。它可用于使用正则表达式搜索特定的单词、字符或模式。凭借其高级功能和选项，EGREP 可以帮助您快速有效地搜索大量文本。无论您是 Linux 初学者还是经验丰富的用户，EGREP 都是您绝对应该添加到工具包中的命令。"
    } ,
  
    {
      "title"       : "使用docsify快速生成精美电子书(文档)",
      "category"    : "",
      "tags"        : "Docsify, Github Pages",
      "url"         : "./docsify/github%20pages/2023/02/23/docsify.html",
      "date"        : "2023-02-23 12:00:00 +0800",
      "description" : "",
      "content"     : "docsify 可以快速帮你生成文档网站。不同于 GitBook、Hexo 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。如果你想要开始使用它，只需要创建一个 index.html 就可以开始编写文档并直接部署在 GitHub Pages。下载并安装docsifydocsify运行时生成页面，所以下载和安装环境很简单，只需要在页面中引入 docsify.min.js 即可.1&lt;script src=\"//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js\"&gt;&lt;/script&gt;博主个人示例 Intellij IDEA修炼指南（2020版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"shortcut icon\" href=\"./web/intellij-idea.png\" type=\"image/x-icon\"/&gt; &lt;link rel=\"stylesheet\" href=\"./web/themes/css/theme-simple-dark.css\"&gt; &lt;link rel=\"stylesheet\" href=\"./web/themes/css/theme-search.css\"&gt; &lt;link rel=\"stylesheet\" href=\"./web/themes/css/theme-pagination.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- Global site tag (gtag.js) - Google Analytics --&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script&gt; window.$docsify = { name: 'Intellij IDEA修炼指南', logo: './web/intellij-idea.png', // 加载侧边栏 loadSidebar: true, // 侧边栏目录最大层级 subMaxLevel: 3, // 自定义封面页 coverpage: true, // 切换页面自动跳转到页面顶部 auto2top: true, // 右上角渲染github挂件 repo: 'https://github.com/TinyZzh/Intellij-IDEA-Master', // 主页 homepage: 'README.md', // 全文搜索插件配置 search: 'auto', search: { depth: 3, noData: 'No results!', placeholder: 'Search...' } } &lt;/script&gt; &lt;script src=\"//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js\"&gt;&lt;/script&gt; &lt;script src=\"./web/js/docsify-pagination.min.js\"&gt;&lt;/script&gt; &lt;script src=\"./web/js/docsify-search.min.js\"&gt;&lt;/script&gt; &lt;script src=\"./web/js/disqus.min.js\"&gt;&lt;/script&gt; &lt;script src=\"./web/themes/js/docsify-themeable@0.js\"&gt;&lt;/script&gt; &lt;script src=\"./web/themes/js/zoom-image.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;定制书籍封面新建一个名称为 _coverpage.md 的md文件。_coverpage.md 示例：123456789101112131415&lt;!-- _coverpage.md --&gt;![logo](./web/intellij-idea.png)# Intellij IDEA修炼指南# &gt; 旨在帮助Intellij IDEA用户更好的掌握IDEA。- **上卷 - 内功篇** : 讲解Intellij IDEA内置集成的功能。- **下卷 - 外功篇** : 主要介绍常用或有特色的插件。- 环境 : `Windows 10`, `Intellij IDEA 2020.1`[内功](/)[外功](/)定制书籍目录(导航栏)新建一个名称为 _navbar.md 的md文件。_sidebar.md 示例：12345678910111213141516171819202122* [首页](/)* 内功篇* [**新手引导**](zh-cn/000_新用户.md)* [常用快捷键](zh-cn/001_常用快捷键.md)* [常用设置](zh-cn/301_常用设置.md)* [菜单栏](100_菜单栏.md)* [代码提示和补全](400_代码提示和补全.md)* [代码重构](700_代码重构.md)* [`Alt`+`Enter`快捷键实战](499_Alt_Enter快捷键实战.md)* [静态代码检查](450_静态代码检查.md)* [代码覆盖率](410_代码覆盖率.md)* [版本控制](zh-cn/111_版本控制.md)* [Emmet](zh-cn/209_Emmet.md)* [FAQ](900_FAQ.md)* 外功篇* [阿里巴巴Java代码规范](zh-cn/1000_阿里巴巴Java代码规范.md)* [Lombok](zh-cn/1001_Lombok.md)* [AiXcoder代码补全插件](zh-cn/1002_AIXcoder.md)* [Google Protocol Buffer](zh-cn/1003_Google_Protocol_Buffer.md)* [Material Theme UI](zh-cn/1004_Material_Theme_UI.md)* [静态代码检查](zh-cn/1100_静态代码检查扩展.md)* [Custom Postfix Templates](1300_Custom_Postfix_Templates.md)支持emoji表情引入 emoji插件1&lt;script src=\"//cdn.jsdelivr.net/npm/docsify/lib/plugins/emoji.min.js\"&gt;&lt;/script&gt;支持多语言本地化默认读取根目录的全部文档，并根据国家，组织你的markdown文档或者html网页。示例：支持mermaidmermaidjs是一种基于JavaScript语言的将文本和代码（DSL）转为图表的绘图制图工具。在线体验1234567891011121314151617var num = 0;mermaid.initialize({ startOnLoad: false });window.$docsify = { markdown: { renderer: { code: function(code, lang) { if (lang === \"mermaid\") { return ( '&lt;div class=\"mermaid\"&gt;' + mermaid.render('mermaid-svg-' + num++, code) + \"&lt;/div&gt;\" ); } return this.origin.code.apply(this, arguments); } } }}自定义404页面在配置项中 notFoundPage 指定对应的路径和文件。123456window.$docsify = { notFoundPage: { '/': '_404.md', '/de': 'de/_404.md', },};接入Github Pages创建一个空的Github仓库并提交。并根据下图修改Github Pages设置，允许Github自动编译和发布你的仓库。参考资料 docsify"
    } ,
  
    {
      "title"       : "实用工具 - 免费开源的AI转换图片风格工具 - AnimeGANv3",
      "category"    : "",
      "tags"        : "AnimeGANv3, AI, AnimeGANv2, Photos",
      "url"         : "./animeganv3/ai/2023/02/22/AI_Convert_Photos_Anime_Style_AnimeGANv3.html",
      "date"        : "2023-02-22 12:00:00 +0800",
      "description" : "",
      "content"     : "AnimeGAN 是一种新型轻量级生成GAN(对抗网络)模型，可以实现图片、照片、动画等作品的快速动画风格迁移。AnimeGANv2AnimeGANv2 相比于前一代 AnimeGAN, 判别器从实力归一化修改特征层归一化。AnimeGANv2中生成器的网络结构如图2所示，K代表卷积核大小，S代表步长，C代表卷积核个数，IRB代表倒残差块，resize代表插值up-采样方法，SUM表示逐元素相加。AnimeGANv2 的生成器参数大小为 8.6MB，AnimeGAN 的生成器参数大小为 15.8MB。AnimeGANv2 使用与 AnimeGAN 相同的判别器，区别在于判别器使用层归一化而不是实例归一化。AnimeGANv3AnimeGANv3 的主要动画生成风格依然还是宫崎骏和新海诚风格的，相比之前的AnimeGAN和AnimeGANv2，在动画生成效果上，它的改进在于：更小的生成器模型大小，仅有4点几MB；生成的动画效果不再包含训练风格图片中的颜色和色调，能够原本的保持输入照片中的色彩和亮度。通过网站免费在线使用AnimeGANv3 Online 或者手机扫描下方二维码打开使用示例可以选择转换结果的风格，内置提供以下8种风格的输出。分别对应 宫崎骏、新海诚、双城之战、迪士尼卡通、美式卡通、漫画、北欧神话、肖像速写八种风格。展示转换结果图参考资料 Jie Chen、Gang Liu、Xin Chen “AnimeGAN：一种用于照片动画的新型轻量级 GAN。” ISICA 2019：人工智能算法和应用，第 242-256 页，2019 年。 AnimeGANv3，史诗级的AI动画生成器 AnimeGAN将现实照片动漫化，超越清华的CartoonGAN"
    } ,
  
    {
      "title"       : "Windows无界鼠标(Mouse without Borders)",
      "category"    : "",
      "tags"        : "Windows, 无界鼠标",
      "url"         : "./windows/%E6%97%A0%E7%95%8C%E9%BC%A0%E6%A0%87/2023/02/16/Microsoft_Garage_Mouse_without_Borders-copy.html",
      "date"        : "2023-02-16 12:16:00 +0800",
      "description" : "",
      "content"     : "当仅有一台电脑主机多个显示器 时，我们可以很轻松的通过HDMI等连接线，使用一套键盘鼠标设备，在扩展我们的显示屏的同时，在多个屏幕中操作。但是假如有多台电脑主机，多个显示器，每台主机都有其单独的用处，如何才能使用一套键盘鼠标外设操作多台电脑呢？本文分享微软开发的Windows下的无界鼠标驱动下载地址。仅需要简单的几步，就可以一套键鼠无缝切换操作多台电脑。安装微软无界鼠标需要无缝切换键鼠的主机或笔记本都需要安装无界鼠标驱动。安装步骤掠过，一路Next即可。配置首次打开弹出界面为主电脑和 其他电脑 选项界面，主要使用的电脑点 “YES” 即可。主机界面会跳转到 安全码 和 电脑名 界面，无界鼠标软件通过电脑名链接局域网内的其他电脑。其他主机生成安全码之后在主机中输入，连接成功之后。拖动电脑icon可以控制显示屏鼠标切换顺序和位置。默认为 右侧边无缝切换副主机。点击“Two Row”可以切换为两行的显示屏模式。其他设置登录成功之后，建议 IP Mappings 设置一下电脑主机名和ip地址的映射，避免电脑主机名找不到的问题。FAQ问题基本上就是局域网网络连不上。"
    } ,
  
    {
      "title"       : "简析Spring Boot启动时控制台打印logo的实现原理",
      "category"    : "",
      "tags"        : "JAVA, SpringBoot, Banner",
      "url"         : "./java/springboot/banner/2023/02/10/Spring_Boot_Banner.html",
      "date"        : "2023-02-10 12:16:00 +0800",
      "description" : "",
      "content"     : "Spring Boot应用程序启动之后都会在输出的日志中打印具有独特表示的logo和版本信息。示例如下：1234567 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.5.14)那么它究竟是如何实现的呢？带着这种好奇和疑问，开始正文。Spring Boot实现方案打印输出的核心关键工具类是SpringBootBanner。源码如下：12345678910111213141516171819202122232425262728class SpringBootBanner implements Banner { private static final String[] BANNER = { \"\", \" . ____ _ __ _ _\", \" /\\\\\\\\ / ___'_ __ _ _(_)_ __ __ _ \\\\ \\\\ \\\\ \\\\\", \"( ( )\\\\___ | '_ | '_| | '_ \\\\/ _` | \\\\ \\\\ \\\\ \\\\\", \" \\\\\\\\/ ___)| |_)| | | | | || (_| | ) ) ) )\", \" ' |____| .__|_| |_|_| |_\\\\__, | / / / /\", \" =========|_|==============|___/=/_/_/_/\" }; private static final String SPRING_BOOT = \" :: Spring Boot :: \"; private static final int STRAP_LINE_SIZE = 42; @Override public void printBanner(Environment environment, Class&lt;?&gt; sourceClass, PrintStream printStream) { for (String line : BANNER) { printStream.println(line); } String version = SpringBootVersion.getVersion(); version = (version != null) ? \" (v\" + version + \")\" : \"\"; StringBuilder padding = new StringBuilder(); while (padding.length() &lt; STRAP_LINE_SIZE - (version.length() + SPRING_BOOT.length())) { padding.append(\" \"); } printStream.println(AnsiOutput.toString(AnsiColor.GREEN, SPRING_BOOT, AnsiColor.DEFAULT, padding.toString(), AnsiStyle.FAINT, version)); printStream.println(); }}自定义Spring Boot BannerSpring Boot提供了 spring.banner.location 支持玩家自定义banner，支持图片格式（banner.gif, banner.jpg, banner.png），也支持文本格式(banner.txt)。1234567891011spring: banner: charset: utf-8 location: classpath:banner.txt # banner文本文件路径 image: # banner图片文件路径 location: classpath:banner.png width: 80 margin: 1 invert: false main: banner-mode: \"off\"可以通过Banner生成器 在线生成想要的字符文字效果。Banner中提供了几个变量占位符，用来丰富打印的数据内容。列表如下： 变量 描述 ${application.version} 应用程序的版本号 ${application.formatted-version}   ${spring-boot.version} Spring Boot版本号 ${spring-boot.formatted-version}   ${Ansi.NAME} (or ${AnsiColor.NAME}, ${AnsiBackground.NAME}, ${AnsiStyle.NAME}) ANSI设置 ${application.title} 应用程序标题 Banner有一个输出模式的控制开关，内置三种模式 OFF(关闭)， CONSOLE(仅控制台), LOG(追加日志)1234567891011121314151617181920212223242526272829303132333435public interface Banner { /** * Print the banner to the specified print stream. * @param environment the spring environment * @param sourceClass the source class for the application * @param out the output print stream */ void printBanner(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out); /** * An enumeration of possible values for configuring the Banner. */ enum Mode { /** * Disable printing of the banner. */ OFF, /** * Print the banner to System.out. */ CONSOLE, /** * Print the banner to the log file. */ LOG }}// 通过SpringApplication设置定制的Banner实例// SpringApplication.setBanner(…​)控制Banner输出的核心业务方法如下：123456789101112private Banner printBanner(ConfigurableEnvironment environment) { if (this.bannerMode == Banner.Mode.OFF) { return null; } ResourceLoader resourceLoader = (this.resourceLoader != null) ? this.resourceLoader : new DefaultResourceLoader(null); SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(resourceLoader, this.banner); if (this.bannerMode == Mode.LOG) { return bannerPrinter.print(environment, this.mainApplicationClass, logger); } return bannerPrinter.print(environment, this.mainApplicationClass, System.out);}定制个人项目的专属Banner了解Spring Boot的实现方案后，我就可以在项目中实现自定义的Banner。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public enum StructBanner { INSTANCE; private static final Logger LOGGER = LoggerFactory.getLogger(StructBanner.class); /** * font: doom * content: \"*Struct&gt;&gt;&gt;\" */ private static final String[] BANNER = { \" _ _____ _ _ ______ \", \" /\\\\| |/\\\\/ ___| | | | \\\\ \\\\ \\\\ \\\\ \", \" \\\\ ` ' /\\\\ `--.| |_ _ __ _ _ ___| |_ \\\\ \\\\ \\\\ \\\\ \", \"|_ _|`--. \\\\ __| '__| | | |/ __| __| &gt; &gt; &gt; &gt;\", \" / , . \\\\/\\\\__/ / |_| | | |_| | (__| |_ / / / / \", \" \\\\/|_|\\\\/\\\\____/ \\\\__|_| \\\\__,_|\\\\___|\\\\__/_/_/_/ \" }; private static final String STRUCT_STORE_SERVICE = \" :: Struct Store Service :: \"; private static final String VERSION = loadVersionProperties(); /** * Print struct store service banner. */ public void print() { PrintStream ps = System.out; for (String line : BANNER) { ps.println(line); } ps.println(STRUCT_STORE_SERVICE + \" (\" + getVersion() + \")\"); } /** * Get struct library version. * * @return Struct library version. */ public String getVersion() { return VERSION; } static String loadVersionProperties() { Properties prop = new Properties(); try (InputStream in = StructBanner.class.getResourceAsStream(\"/META-INF/maven/org.structutil/struct-spring/pom.properties\")) { prop.load(in); return prop.getProperty(\"version\", \"Unknown\"); } catch (Throwable e) { LOGGER.error(\"\"); } return \"Unknown\"; }}打印输出结果：1234567 _ _____ _ _ ______ /\\| |/\\/ ___| | | | \\ \\ \\ \\ \\ ` ' /\\ `--.| |_ _ __ _ _ ___| |_ \\ \\ \\ \\ |_ _|`--. \\ __| '__| | | |/ __| __| &gt; &gt; &gt; &gt; / , . \\/\\__/ / |_| | | |_| | (__| |_ / / / / \\/|_|\\/\\____/ \\__|_| \\__,_|\\___|\\__/_/_/_/ :: Struct Store Service :: (Unknown)"
    } ,
  
    {
      "title"       : "梳理Spring Framework 6.0的新特性",
      "category"    : "",
      "tags"        : "JAVA, Spring Framework 6, Gradle, 虚拟线程",
      "url"         : "./java/spring_framework_6/2022/11/22/Spring_framework_6_GA_release.html",
      "date"        : "2022-11-22 14:16:00 +0800",
      "description" : "",
      "content"     : "Spring Framework在Java应用层长期的占据市场统治地位。在2022年11月16号发布的6.0 GA版本也是颠覆性的改动。本文梳理Spring Framework 6.0的重大变动，已经总结变动带来的革新以及我们如何迁移到6.0版本。目前服务端正在着手相关的工作，逐步将现有的子系统迁移到Spring Framework 6上。:stars:Spring Framework 6.0:one: 基于Java 17Spring框架代码全面升级到Java 17。得益于Java版本的升级，意味着下游用户可以使用更多更新的语法（Record、文本块、增强的Switch表达式、密封类sealed）和系统工具（Flight Recorder、JShell），同时还能享受JVM特性增强、String增强、NPE提示增强、更现代化的GC（G1，ZGC等）算法等诸多的隐形福利。:two: 全面拥抱云原生Spring Native项目已经默默孵化3年多时间，全面支持Spring Framework 6和Spring Boot 3，支持GraalVM即时编译。使用AOT可以实现亚毫秒级启动时间，大幅降低堆内存占用。详见Initial AOT support in Spring Framework 6.0.0-M3:three: 拥抱虚拟线程Virtual Thread还记得在Spring Framework 5.0引入的响应式web框架WebFlux吗？ Spring WebFlux是一个异步非阻塞式的Web框架。WebFlux相比于Spring MVC可以让服务器占用内存更少，使用线程数更少，在IO密集型业务中，吞吐量更高，应用有更好的伸缩性。虚拟线程补充和完善了Java生态中的反应式编程模型的短板，进一步消除和缓解阻塞I/O的影响，对于服务器而言，或者能进一步提高CPU利用率，增加应用吞吐量, 降低响应延迟也犹未可知。通过 AsyncTaskExecutor 和 TomcatProtocolHandlerCustomizer启用虚拟线程。详见Embracing Virtual Threads：1234567891011@Bean(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME)public AsyncTaskExecutor asyncTaskExecutor() { return new TaskExecutorAdapter(Executors.newVirtualThreadPerTaskExecutor());}@Beanpublic TomcatProtocolHandlerCustomizer&lt;?&gt; protocolHandlerVirtualThreadExecutorCustomizer() { return protocolHandler -&gt; { protocolHandler.setExecutor(Executors.newVirtualThreadPerTaskExecutor()); };}业务侧虚拟线程可以 当作线程池来使用，可以实现Actor并发模型等。123456789// https://openjdk.org/jeps/425try (var executor = Executors.newVirtualThreadPerTaskExecutor()) { IntStream.range(0, 10_000).forEach(i -&gt; { executor.submit(() -&gt; { Thread.sleep(Duration.ofSeconds(1)); return i; }); });} // executor.close() is called implicitly, and waits:four: 其他J2EE现在正式迁移到jakarta, 由eclipse基金会管理。完全开源，无任何商业使用风险。实践总结这块内容主要以自身服务端项目升级为例，由于迁移的时候Spring Framework 6还没发布，所以本总结是基于今年升级到Spring Framework 5.3和Java 17 LTS的。，仅供参考。页游目前的持续集成环境中依旧使用的Gralde 4.10版本，这个版本很明显是不支持Java 17的。第一个任务就是 升级Gradle版本到7.3，以支持最新的Java版本编译。值的额外提一句的时，升级Gradle并且开启并发编译，让项目的编译耗时减少50%甚至更多，也算是意外之喜。第二个较大改动就是J2EE相关的内容，例如：JAXB等被移除出标准库，还有一部分被捐赠给Exlipse基金会包名被修改为jakarta。jaxb需要引入老的兼容包，避免业务代码变动：12implementation(\"javax.servlet:javax.servlet-api:4.0.1\")implementation(\"javax.annotation:javax.annotation-api:1.3.2\")第三项是Spring Framework框架从4.x升级到5.3.x版本，全面引入Spring Boot框架 2.5.x版本。核心业务进程login、logic等全部迁移到Spring Boot技术栈。兼容老项目的common-web和jamon指标监控项目。第四项是关于包路径和访问权限的，使用到反射的类库或多或少的都受到影响。lightmc中的HackedObjectInputStream无法使用。使用变量句柄VarHandle和Unsafe工具绕过底层的访问权限检查。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class HackedObjectInputStream extends ObjectInputStream { /** * Migration table. Holds old to new classes representation. */ private static final Map&lt;String, Class&lt;?&gt;&gt; MIGRATION_MAP = new HashMap&lt;String, Class&lt;?&gt;&gt;(); private static VarHandle handle; static { MIGRATION_MAP.put(ApcMigration.JOBJ_NAME, APC.class); try { handle = UnsafeUtils.trusted().findVarHandle(ObjectStreamClass.class, \"name\", String.class); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IllegalAccessException e) { throw new RuntimeException(e); } } public HackedObjectInputStream(final InputStream stream) throws IOException { super(stream); } @Override protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException { ObjectStreamClass resultClassDescriptor = super.readClassDescriptor(); for (final String oldName : MIGRATION_MAP.keySet()) { if (resultClassDescriptor.getName().equals(oldName)) { String replacement = MIGRATION_MAP.get(oldName).getName(); try { handle.set(resultClassDescriptor, replacement); } catch (Exception e) { throw new IllegalArgumentException(e); } } } Map&lt;String, String&gt; m = ApcMigration.JOBJ_INPUT_RENAME; for (final String oldName : m.keySet()) { if (resultClassDescriptor.getName().equals(oldName)) { String replacement = m.get(oldName); try { handle.set(resultClassDescriptor, replacement); } catch (Exception e) { throw new IllegalArgumentException(e); } } } return resultClassDescriptor; }}项目中其他杂七杂八第三方依赖，这个只能根据项目的实际情况，以及依赖库对Java 17的兼容程度分别单独处理。参考资料 What’s New in Spring Framework 6.x Embracing Virtual Threads 压测对比: Spring WebFlux VS. Spring MVC Java Flight Recorder"
    } ,
  
    {
      "title"       : "详解Java的 Stream",
      "category"    : "",
      "tags"        : "JAVA, Stream",
      "url"         : "./java/stream/2022/11/19/Java_Stream.html",
      "date"        : "2022-11-19 14:16:00 +0800",
      "description" : "",
      "content"     : "Stream是Java 8引入的语法特性。 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。 以下博文基于JAVA 17 LTS版本.Stream流Stream的操作可以分为两大类：中间操作、终结操作 中间操作 无状态（Stateless）操作：指元素的处理不受之前元素的影响 有状态（Stateful）操作：指该操作只有拿到所有元素之后才能继续下去 终结操作 短路（Short-circuiting）操作：指遇到某些符合条件的元素就可以得到最终结果 非短路（Unshort-circuiting）操作：指必须处理完所有元素才能得到最终结果 graph LRStream--&gt;A(中间操作)A--&gt;A1(无状态操作)A--&gt;A2(状态操作)A1--&gt;filterA1--&gt;mapA1--&gt;flatMapA1--&gt;mapMultiA1--&gt;peekA2--&gt;distinctA2--&gt;sortedA2--&gt;skipA2--&gt; A21(短路有状态操作)A21--&gt;limitA21--&gt;takeWhileA21--&gt;dropWhileStream--&gt;B(终结操作)B--&gt;B1(非短路操作)B1--&gt;forEachB1--&gt;forEachOrderedB1--&gt;reduceB1--&gt;toArrayB1--&gt;collectB1--&gt;toListB1--&gt;minB1--&gt;maxB1--&gt;countB--&gt;B2(短路操作)B2--&gt;anyMatchB2--&gt;allMatchB2--&gt;noneMatchB2--&gt;findFirstB2--&gt;findAnyStream 中间操作中间操作会逐一获取元素并进行处理。可有可无。所有中间操作都是 惰性的，因此，流在管道中流动之前，任何操作都不会产生任何影响。无状态操作 filter：筛选元素，按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。 map: 将集合中的元素A转换成想要得到的B flatMap: 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 peek: 操作接收的是一个 Consumer 函数12345678910111213141516171819202122232425// 串行流和并行流设置只会有一个生效，根据调用顺序最终确定。S sequential(); // 串行流S parallel(); // 并行流S unordered(); // 无序化S onClose(Runnable closeHandler); // 流关闭时处理// 元素处理Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action);&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);// mapMulti系列接口, Java 16增加default &lt;R&gt; Stream&lt;R&gt; mapMulti(BiConsumer&lt;? super T, ? super Consumer&lt;R&gt;&gt; mapper) { Objects.requireNonNull(mapper); return flatMap(e -&gt; { SpinedBuffer&lt;R&gt; buffer = new SpinedBuffer&lt;&gt;(); mapper.accept(e, buffer); return StreamSupport.stream(buffer.spliterator(), false); });}有状态操作 distinct: 元素去重。（根据 Object.equals(Object), 需要重写hashCode()和equals()方法） sorted：元素排序。 limit：获取流中n个元素返回的流。 skip：在丢弃流的第一个n元素之后，返回由该流的其余元素组成的流。12345678910111213141516171819Stream&lt;T&gt; distinct();Stream&lt;T&gt; sorted();Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);Stream&lt;T&gt; limit(long maxSize);Stream&lt;T&gt; skip(long n);// Java 9default Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate) { Objects.requireNonNull(predicate); return StreamSupport.stream( new WhileOps.UnorderedWhileSpliterator.OfRef.Taking&lt;&gt;(spliterator(), true, predicate), isParallel()).onClose(this::close);}default Stream&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate) { Objects.requireNonNull(predicate); return StreamSupport.stream( new WhileOps.UnorderedWhileSpliterator.OfRef.Dropping&lt;&gt;(spliterator(), true, predicate), isParallel()).onClose(this::close);}Stream 终结操作短路操作 anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true; allMatch：Stream 中全部元素符合传入的 predicate，返回 true; noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true. findFirst：用于返回满足条件的第一个元素（但是该元素是封装在Optional类中） findAny：返回流中的任意元素（但是该元素也是封装在Optional类中）12345boolean anyMatch(Predicate&lt;? super T&gt; predicate);boolean allMatch(Predicate&lt;? super T&gt; predicate);boolean noneMatch(Predicate&lt;? super T&gt; predicate);Optional&lt;T&gt; findFirst();Optional&lt;T&gt; findAny();非短路操作 forEach：该方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式 forEachOrdered：该方法接收一个Lambda表达式，然后按顺序在Stream的每一个元素上执行该表达式 reduce：方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值 collect：称为收集器，是一个终端操作,它接收的参数是将流中的元素累积到汇总结果的各种方式 max：根据提供的Comparator返回此流的最大元素 min：根据提供的Comparator返回此流的最小元素 count：返回此流中的元素计数1234567891011121314151617181920void forEach(Consumer&lt;? super T&gt; action);void forEachOrdered(Consumer&lt;? super T&gt; action);Object[] toArray();&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner);&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);default List&lt;T&gt; toList() { return (List&lt;T&gt;) Collections.unmodifiableList(new ArrayList&lt;&gt;(Arrays.asList(this.toArray())));}Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator);Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);long count();"
    } ,
  
    {
      "title"       : "详解Java的 ArrayList",
      "category"    : "",
      "tags"        : "JAVA, ArrayList",
      "url"         : "./java/arraylist/2022/11/18/Java_ArrayList.html",
      "date"        : "2022-11-18 10:16:00 +0800",
      "description" : "",
      "content"     : "ArrayList 作为最基础、最常见的Java集合之一。你是否有过疑惑ArrayList是如何自动扩容的？使用remove移除元素后，是怎么进行缩容的呢？非线程安全，不安全在哪些方面呢？ArrayList又是如何检测变更的呢？ 本文使用Java 17 LTS版本构造函数ArrayList在不指定初始容量和初始集合的情况下，默认使用长度为0的空数组。12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); }}/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) { Object[] a = c.toArray(); if ((size = a.length) != 0) { if (c.getClass() == ArrayList.class) { elementData = a; } else { elementData = Arrays.copyOf(a, size, Object[].class); } } else { // replace with empty array. elementData = EMPTY_ELEMENTDATA; }}扩容列表扩容是ArrayList面试问题中出现频率非常高的一个问题。当前size和元素长度相等时，列表已满时，才会触发扩容。123456private void add(E e, Object[] elementData, int s) { if (s == elementData.length) elementData = grow(); elementData[s] = e; size = s + 1;}12345678910111213141516171819/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity * @throws OutOfMemoryError if minCapacity is less than zero */private Object[] grow(int minCapacity) { int oldCapacity = elementData.length; if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { int newCapacity = ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, /* minimum growth */ oldCapacity &gt;&gt; 1 /* preferred growth */); return elementData = Arrays.copyOf(elementData, newCapacity); } else { return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)]; }}使用ArraysSupport工具计算新的所需的数组长度。 参数分别为（扩容前的长度，最小增长长度，推荐增长长度），根据grow()方法中的使用, 最小申请列表仅需的长度(minCapacity - oldCapacity), 推荐增长长度为（oldCapacity » 1 = oldCapacity/2)，相当于默认每次扩容都是老的长度的1.5倍。已知的固定长度的列表尽可能指定长度，避免默认扩容导致内存空间浪费。12345678910111213141516171819202122232425public static int newLength(int oldLength, int minGrowth, int prefGrowth) { // preconditions not checked because of inlining // assert oldLength &gt;= 0 // assert minGrowth &gt; 0 int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow if (0 &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) { return prefLength; } else { // put code cold in a separate method return hugeLength(oldLength, minGrowth); }}private static int hugeLength(int oldLength, int minGrowth) { int minLength = oldLength + minGrowth; if (minLength &lt; 0) { // overflow throw new OutOfMemoryError( \"Required array length \" + oldLength + \" + \" + minGrowth + \" is too large\"); } else if (minLength &lt;= SOFT_MAX_ARRAY_LENGTH) { return SOFT_MAX_ARRAY_LENGTH; } else { return minLength; }}移除ArrayList的移除操作，通过移动元素在列表中的位置，占用老的元素的位置，并将末尾元素设置为NULL。1234567private void fastRemove(Object[] es, int i) { modCount++; final int newSize; if ((newSize = size - 1) &gt; i) System.arraycopy(es, i + 1, es, i, newSize - i); es[size = newSize] = null;}列表的容量不会减少，不会自动缩容。缩容ArrayList不主动缩容。那假如我们业务场景中使用的列表不定长，同时伴随一系列增删改动，但最终结果是稳定的。这个时候我们该如何避免空间浪费呢？这个时候trimToSize方法就有作用了。观其名知其意，截断列表数值的NULL值。12345678910111213/** * Trims the capacity of this {@code ArrayList} instance to be the * list's current size. An application can use this operation to minimize * the storage of an {@code ArrayList} instance. */public void trimToSize() { modCount++; if (size &lt; elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); }}非线程安全ArrayList是非线程安全的。多线程环境下，列表被修改会抛出ConcurrentModificationException异常。以对象序列化为例，其检测原理时，在变更操作开始前记录modCount值，当操作结束时检测到modCount和序列化之前不同时，不同时则说明被修改，同步抛出异常。12345678910111213141516171819@java.io.Serialprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioral compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); }}线上项目需要临时紧急处理，该如何应急处理呢？12// 1. 使用同步块装饰Collections.synchronizedList(new ArrayList&lt;&gt;())参考资料 Data Structure Visualizations"
    } ,
  
    {
      "title"       : "开源跨平台终端模拟器 - Tabby",
      "category"    : "",
      "tags"        : "Tabby, 终端模拟器, 跨平台",
      "url"         : "./tabby/2022/11/17/Modern_Terminal_Tools_Tabby.html",
      "date"        : "2022-11-17 00:16:00 +0800",
      "description" : "",
      "content"     : "Tabby是一款跨平台高度配置化的终端模拟器。在使用Tabby之前博主使用的XShell 6这款古董级软件的绿色免安装版。本文主要总结弃用XShell，使用Tabby的近半年的回顾和总结。为什么弃用XShell 6？以前用的绿色版，商业版收费，绿色版时不时的提示升级，付费广告，最终不想继续折腾绿色版。其次开原生态逐渐成熟，所谓的平替产品层出不穷，截至目前位置，Tabby在Github累计标星40k+，算是生态中已经比较成熟一款，想尝尝鲜。Tabby 集成 SSH，Telnet 客户端和连接管理器 集成 串行终端 定制主题和配色方案 完全可配置的快捷键和多键快捷键 分体式窗格 自动保存标签页 支持 PowerShell（和 PS Core）、WSL、Git-Bash、Cygwin、MSYS2、Cmder 和 CMD 在 SSH 会话中通过 Zmodem 进行直接文件传输 完整的 Unicode 支持，包括双角字符 不会因快速的输出而卡住 Windows 上舒适的 shell 体验，包括 tab 自动补全（通过 Clink） 为 SSH secrets 和设置集成了加密容器 SSH、SFTP 和 Telnet 客户端可用作 Web 应用（也可托管）创建一个新的SSH链接Tabby体验回顾相比于其他C或C++开发的工具，工具使用TypeScript编写，便携版（离线版）内置Chrome的V8引擎，使用开发网站前端的思路开发终端模拟器，虽然内存占用较大，但是同时可以享受积年累积的JS和CSS的成果。也确实得益于网站样式的迅猛发展和丰富多彩，Tabby可以轻松的定制样式和主题风格。高度可配置的特性让Tabby更轻松的实现跨设备同步和共享配置。保存好配置可以在任意地点在线SSH办公、排查问题、解决BUG。随时随地都可以联网就可以访问的 Tabby Web 在线工具实用的窗口分栏功能，当我们一般要对照查看数据时，很方便。Tabby是通关tags分组管理链接信息的，配合搜索功能，可以帮助开发中在一大堆机器中快速找到对应的那一台。目前依旧有不少BUG还没来得及修复，版本稳定度不足，。虽然有公共开源的在线服务帮助开发组测试，但是ISSUE反馈到修复整个流程还是比较冗长的，另外开源社区用爱发电，和纯商业公司还是有区别的。时不时的会出现意外全屏的情况，需要重启客户端。支持SFTP文件传输，但是不稳定，经常莫名其妙的会出现异常，可以使用sz和rz代替。参考资料 Tabby 官网 Tabby Web App"
    } ,
  
    {
      "title"       : "游戏萌新快速入门之《枪火重生》",
      "category"    : "",
      "tags"        : "Game, 枪火重生",
      "url"         : "./game/%E6%9E%AA%E7%81%AB%E9%87%8D%E7%94%9F/2022/11/13/Gunfire_Reborn_Game.html",
      "date"        : "2022-11-13 20:16:00 +0800",
      "description" : "",
      "content"     : "《枪火重生》是一款融合了第一人称射击、Roguelite随机元素和RPG策略选择的国风冒险闯关游戏。玩家在游戏里可以操纵不同英雄体验多种流派玩法，使用随机掉落的武器在随机性关卡中进行冒险挑战。既可以单人畅玩，也可以最多四人组队，享受共同冒险闯关的乐趣。最近一段时间沉迷于枪火重生，本文总结一下新手快速入门攻略。一周目（普通难度）刚入门的童鞋，在这个阶段打小怪，收集秘卷，熟悉地图和基础玩法，这个阶段陷阱机关比较少，小怪也没有特别的强化词缀，整体节奏比较轻快。稍微有难度的也就3个BOSS战。一般没人指导的情况下，大多会死在第一周目的BOSS战中贡献几个人头。这里主要梳理BOSS的几个输出技能，基本上只需要闪躲BOSS的几个固定的大招，过关难度不大。陆吾主要技能列表：打法关键点核心尽可能的远离BOSS。带雷电属性的枪可以快速打掉BOSS的护盾，当BOSS跳跃攻击的时候，脚下会出现红圈，使用Shift快速移动躲避即可。鱼龙后裔主要技能列表：打法关键点带腐蚀武器，一阶段BOSS的物理护甲一管血，使用腐蚀武器打起来比较高效。躲激光技能，根据BOSS摇头的方向反向移动。腐蚀毒球，毒球是可以打破的，未来得及打破，注意地面的毒圈减速。拍地技能，会有烟尘扩散，跳起来躲闪就可以。夜姬丸主要技能列表：打法关键点三阶段BOSS战，BOSS会出现无敌状态。无敌阶段，需要打地图上刷新的物理护甲小怪会掉落炮弹，拾取炮弹跑到地图中间的炮塔发射，打破BOSS的无敌状态。极乐世界的火炮一阶段时连续一排，需要及时shift快速躲避，很容易破盾暴毙。二阶段是全图随机的。精英、噩梦难度连城主要技能列表：打法关键点BOSS打法较简单，主要伤害是射线，可以利用BOSS生成的石柱来躲避射线。石头可以用远程打破。弱点是眼睛和中心的核心，命中会出现弱点伤害增强。石柱发光时，注意远离，被对附近的人造成爆炸伤害。风神主要技能列表：打法关键点BOSS会不断释放龙飓风，带有跟踪性，躲避即可。尽量使用火系枪械对血肉类怪物有1.5倍增伤。虬蛇主要技能列表：打法关键点二阶段BOSS，一阶段简单的释放技能，会出现红色路径的提示，注意使用Shift快速躲避。弱点是BOSS出水之后的身体。第二阶段是多个头发动攻击。极地妖王打法关键点一阶段BOSS血量降低会开启无敌并持续的站桩打吊瓶，打掉吊瓶就好，重启BOSS战。二阶段BOSS站在中间使用全屏弹幕球攻击，注意走位躲避即可。三阶段BOSS会护盾回满，并开始倒计时，计时阶段使用强力输出武器打，推荐使用雷电属性枪械，计时结束BOSS开启狂暴模式，输出非常狂暴，目前只能硬扛着输出打死BOSS。轮回难度怪物的数值膨胀的很厉害。前期玩家数值和BUFF比较弱，正式进入轮回之前，尽可能的把天赋中的高效施法，秘能大师，福至心灵，防爆装甲等输出和生存的天赋都点满级。通过解锁轮回基本上已经初步入门，轮回1-8只是单纯的数值的不同。剩下的就是无尽的刷刷刷，攒精魄，灵佑使和奇货商。等博主攻略完成轮回八再出进阶教程。游戏总结整体来说前期入门门槛比较低，轻快的游戏节奏，rougelike元素前期提供趣味性。个人感觉主要是内容丰富度不足。主要以下几个方面： 地图通过随机场景顺序和随机进出入口实现随机。很容易出现重复感。 枪械玩法和特性较少，可靠的枪械方案不多（手感好，反馈及时，输出稳定等几个方面），近战武器在后期可搭配性较弱。目前博主主要使用织云和玉追龙等少数几种枪械。 怪物和BOSS较少，目前仅有4大关，7个BOSS。 双子铭刻种类，地图怪物属性词缀搭配很少。枪火重生素材提取枪火重生是Unity3D开发游戏。使用AssetStudio可以完美提取动画，模型和贴图等。详细信息参考博主的另外一个文章逆向实验室 - 使用AssetStudio提取Unity3D素材资源。"
    } ,
  
    {
      "title"       : "详解Cuckoo过滤器原理",
      "category"    : "",
      "tags"        : "Redis, Cuckoo过滤器, 布隆过滤器, BloomFilter",
      "url"         : "./redis/2022/11/10/Redis_Cuckoo_Filter.html",
      "date"        : "2022-11-10 09:00:00 +0800",
      "description" : "",
      "content"     : "参考资料 Cuckoo Filter Try Redis IO"
    } ,
  
    {
      "title"       : "简单但不平凡的加密算法 - XXTEA",
      "category"    : "",
      "tags"        : "JAVA, XXTEA, 加密算法",
      "url"         : "./java/xxtea/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/2022/11/08/Java_XXTEA.html",
      "date"        : "2022-11-08 10:16:00 +0800",
      "description" : "",
      "content"     : "微型加密算法（Tiny Encryption Algorithm，TEA）是剑桥大学计算机实验室的David Wheeler与Roger Needham于1994年发明。算法以加密解密速度快，实现简单著称。TEA算法每一次可以操作64bit(8byte)，采用128bit(16byte)作为key，算法采用迭代的形式，推荐的迭代轮数是64轮，最少32轮。XXTEA 是TEA系列算法中的最新版本，也是其第三个版本，发表于1998年，进一步提高了TEA算法的安全性，避免了密钥表攻击。TXTEA是腾讯QQ和微信中常用的加密算法，算法原理不变，降低加密轮次到16轮。其轻量，易实现、易跨平台特性使XXTEA而被广泛应用于各个领域。例如：游戏（Cocos2d-x）、通信（QQ和微信）、嵌入式、芯片卡等等。TEA算法初版源码 - C语言12345678910111213141516171819202122232425#include &lt;stdint.h&gt;void encrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i &lt; 32; i++) { /* basic cycle start */ sum += delta; v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); } /* end cycle */ v[0]=v0; v[1]=v1;}void decrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i&lt;32; i++) { /* basic cycle start */ v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); sum -= delta; } /* end cycle */ v[0]=v0; v[1]=v1;}Java中实现将byte[]类型的加密内容转换为int[]，方便处理运算。12345678910111213141516171819/*** Convert byte array to int array.*/private static int[] toIntArray(byte[] data, boolean includeLength) { int n = (((data.length &amp; 3) == 0) ? (data.length &gt;&gt;&gt; 2) : ((data.length &gt;&gt;&gt; 2) + 1)); int[] result; if (includeLength) { result = new int[n + 1]; result[n] = data.length; } else { result = new int[n]; } n = data.length; for (int i = 0; i &lt; n; i++) { result[i &gt;&gt;&gt; 2] |= (0x000000ff &amp; data[i]) &lt;&lt; ((i &amp; 3) &lt;&lt; 3); } return result;}加密：12345678910111213141516171819202122232425262728/*** Encrypt data with key.*/public static int[] encrypt(int[] v, int[] k) { int n = v.length - 1; if (n &lt; 1) { return v; } if (k.length &lt; 4) { int[] key = new int[4]; System.arraycopy(k, 0, key, 0, k.length); k = key; } int z = v[n], y = v[0], delta = 0x9E3779B9, sum = 0, e; int p, q = 6 + 52 / (n + 1); while (q-- &gt; 0) { sum = sum + delta; e = sum &gt;&gt;&gt; 2 &amp; 3; for (p = 0; p &lt; n; p++) { y = v[p + 1]; z = v[p] += (z &gt;&gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt;&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[p &amp; 3 ^ e] ^ z); } y = v[0]; z = v[n] += (z &gt;&gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt;&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[p &amp; 3 ^ e] ^ z); } return v;}解密：12345678910111213141516171819202122232425262728/*** Decrypt data with key.*/public static int[] decrypt(int[] v, int[] k) { int n = v.length - 1; if (n &lt; 1) { return v; } if (k.length &lt; 4) { int[] key = new int[4]; System.arraycopy(k, 0, key, 0, k.length); k = key; } int z = v[n], y = v[0], delta = 0x9E3779B9, sum, e; int p, q = 6 + 52 / (n + 1); sum = q * delta; while (sum != 0) { e = sum &gt;&gt;&gt; 2 &amp; 3; for (p = n; p &gt; 0; p--) { z = v[p - 1]; y = v[p] -= (z &gt;&gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt;&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[p &amp; 3 ^ e] ^ z); } z = v[n]; y = v[0] -= (z &gt;&gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt;&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[p &amp; 3 ^ e] ^ z); sum = sum - delta; } return v;}解密完成将int[]转换为byte[].12345678910111213141516171819/*** Convert int array to byte array.*/private static byte[] toByteArray(int[] data, boolean includeLength) { int n = data.length &lt;&lt; 2; if (includeLength) { int m = data[data.length - 1]; if (m &gt; n) { return null; } else { n = m; } } byte[] result = new byte[n]; for (int i = 0; i &lt; n; i++) { result[i] = (byte) ((data[i &gt;&gt;&gt; 2] &gt;&gt;&gt; ((i &amp; 3) &lt;&lt; 3)) &amp; 0xff); } return result;}"
    } ,
  
    {
      "title"       : "漫谈伪随机数生成器算法",
      "category"    : "",
      "tags"        : "JAVA, HttpClient",
      "url"         : "./java/httpclient/2022/11/03/Random_Genertor.html",
      "date"        : "2022-11-03 12:16:00 +0800",
      "description" : "",
      "content"     : "LCG线性同余生成器算法（LCG）PCG置换同余生成器算法（PCG），于2014年由                             参考资料"
    } ,
  
    {
      "title"       : "详解Java的 不可变集合工厂方法of()",
      "category"    : "",
      "tags"        : "JAVA, Collection",
      "url"         : "./java/collection/2022/11/03/Java_17_Collection.html",
      "date"        : "2022-11-03 12:16:00 +0800",
      "description" : "",
      "content"     : "从 Java 9 开始针对 List，Map，Set 引入一组新的静态工厂方法 of() 用来简化创建 不可变集合。Java 9 以前java.util.Collections 是Java集合的常用工具，内置提供了很多集合相关的有用方法。12345678Collections.unmodifiableList();Collections.unmodifiableCollection();Collections.unmodifiableMap();Collections.unmodifiableSet();Collections.unmodifiableSortedSet();Collections.unmodifiableNavigableMap();Collections.unmodifiableNavigableSet();Collections.unmodifiableSortedMap();Collections提供的 unmodifiable 前缀的一系列方法实现原理是通过装饰器模式，屏蔽掉全部变动相关的接口。Java 17的不可变集合在Java 9以前unmodifiable虽然修饰了屏蔽掉修改方法。但是由于是装饰器模式，所以原始集合是可以修改的, 当原始集合的变动会反馈到不可变包装的集合的显示。而Java 9通过重写并实现了一整套的不可变集合，解决了原始集合的问题。新的不可变集合在元素数量小于等于2时，采用了很精简的结构，降低了内存开销。123456789101112131415161718192021222324252627282930313233343536373839// Liststatic final class List12&lt;E&gt; extends AbstractImmutableList&lt;E&gt; implements Serializable { @Stable private final E e0; @Stable private final Object e1; List12(E e0) { this.e0 = Objects.requireNonNull(e0); // Use EMPTY as a sentinel for an unused element: not using null // enables constant folding optimizations over single-element lists this.e1 = EMPTY; } List12(E e0, E e1) { this.e0 = Objects.requireNonNull(e0); this.e1 = Objects.requireNonNull(e1); } @Override public int size() { return e1 != EMPTY ? 2 : 1; }}// Mapstatic final class Map1&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt; { @Stable private final K k0; @Stable private final V v0; Map1(K k0, V v0) { this.k0 = Objects.requireNonNull(k0); this.v0 = Objects.requireNonNull(v0); }}第二点由于是不可变集合，且字段使用finnal修饰，所以是线程安全的创建不可变列表List.of()12345678910111213141516@Testpublic void testListOf() { System.out.println(List.of()); System.out.println(List.of(1)); System.out.println(List.of(1,2)); System.out.println(List.of(1,2,3)); System.out.println(List.of(1,2,3,4)); System.out.println(List.of(1,2,3,4,5,6,7,8,9, 10, 11,12));}// []// [1]// [1, 2]// [1, 2, 3]// [1, 2, 3, 4]// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]创建不可变映射Map.of()12345678910111213141516171819202122232425262728293031@Testpublic void testMapOf() { System.out.println(Map.of()); System.out.println(Map.of(1, 2)); System.out.println(Map.of(1,2,3, 4)); System.out.println(Map.of(1,2,3,4)); System.out.println(Map.of(1,2,3,4,5,6,7,8,9, 10, 11,12)); System.out.println(Map.ofEntries(new Map.Entry&lt;Integer, Integer&gt;() { @Override public Integer getKey() { return 1; } @Override public Integer getValue() { return 2; } @Override public Integer setValue(Integer value) { throw new UnsupportedOperationException(); } }));}// {}// {1=2}// {3=4, 1=2}// {3=4, 1=2}// {5=6, 7=8, 9=10, 11=12, 1=2, 3=4}// {1=2}创建不可变集Set.of()12345678910111213141516@Testpublic void testSetOf() { System.out.println(Set.of()); System.out.println(Set.of(1)); System.out.println(Set.of(1,2)); System.out.println(Set.of(1,2,3)); System.out.println(Set.of(1,2,3,4)); System.out.println(Set.of(1,2,3,4,5,6,7,8,9, 10, 11,12));}// []// [1]// [2, 1]// [1, 2, 3]// [1, 2, 3, 4]// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]序列化/反序列化值得注意的一点是，新的不可变集合序列化/反序列化和普通的java.util.ArrayList, java.util.HashMap, java.util.HashSet有很大不同。 不可变集合本身不支持直接反序列化，是通过使用 CollSer 来实现。12345678910111213141516static final class List12&lt;E&gt; extends AbstractImmutableList&lt;E&gt; implements Serializable { @java.io.Serial private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { throw new InvalidObjectException(\"not serial proxy\"); } @java.io.Serial private Object writeReplace() { if (e1 == EMPTY) { return new CollSer(CollSer.IMM_LIST, e0); } else { return new CollSer(CollSer.IMM_LIST, e0, e1); } }}CollSer将集合转换为数据更紧凑的数组结构，更利于序列化/反序列化。源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140final class CollSer implements Serializable { @java.io.Serial private static final long serialVersionUID = 6309168927139932177L; static final int IMM_LIST = 1; static final int IMM_SET = 2; static final int IMM_MAP = 3; static final int IMM_LIST_NULLS = 4; /** * Indicates the type of collection that is serialized. * The low order 8 bits have the value 1 for an immutable * {@code List}, 2 for an immutable {@code Set}, 3 for * an immutable {@code Map}, and 4 for an immutable * {@code List} that allows null elements. * * Any other value causes an * {@link InvalidObjectException} to be thrown. The high * order 24 bits are zero when an instance is serialized, * and they are ignored when an instance is deserialized. * They can thus be used by future implementations without * causing compatibility issues. * * &lt;p&gt;The tag value also determines the interpretation of the * transient {@code Object[] array} field. * For {@code List} and {@code Set}, the array's length is the size * of the collection, and the array contains the elements of the collection. * Null elements are not allowed. For {@code Set}, duplicate elements * are not allowed. * * &lt;p&gt;For {@code Map}, the array's length is twice the number of mappings * present in the map. The array length is necessarily even. * The array contains a succession of key and value pairs: * {@code k1, v1, k2, v2, ..., kN, vN.} Nulls are not allowed, * and duplicate keys are not allowed. * * @serial * @since 9 */ private final int tag; /** * @serial * @since 9 */ private transient Object[] array; CollSer(int t, Object... a) { tag = t; array = a; } /** * Reads objects from the stream and stores them * in the transient {@code Object[] array} field. * * @serialData * A nonnegative int, indicating the count of objects, * followed by that many objects. * * @param ois the ObjectInputStream from which data is read * @throws IOException if an I/O error occurs * @throws ClassNotFoundException if a serialized class cannot be loaded * @throws InvalidObjectException if the count is negative * @since 9 */ @java.io.Serial private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ois.defaultReadObject(); int len = ois.readInt(); if (len &lt; 0) { throw new InvalidObjectException(\"negative length \" + len); } SharedSecrets.getJavaObjectInputStreamAccess().checkArray(ois, Object[].class, len); Object[] a = new Object[len]; for (int i = 0; i &lt; len; i++) { a[i] = ois.readObject(); } array = a; } /** * Writes objects to the stream from * the transient {@code Object[] array} field. * * @serialData * A nonnegative int, indicating the count of objects, * followed by that many objects. * * @param oos the ObjectOutputStream to which data is written * @throws IOException if an I/O error occurs * @since 9 */ @java.io.Serial private void writeObject(ObjectOutputStream oos) throws IOException { oos.defaultWriteObject(); oos.writeInt(array.length); for (int i = 0; i &lt; array.length; i++) { oos.writeObject(array[i]); } } private Object readResolve() throws ObjectStreamException { try { if (array == null) { throw new InvalidObjectException(\"null array\"); } // use low order 8 bits to indicate \"kind\" // ignore high order 24 bits switch (tag &amp; 0xff) { case IMM_LIST: return List.of(array); case IMM_LIST_NULLS: return ImmutableCollections.listFromTrustedArrayNullsAllowed( Arrays.copyOf(array, array.length, Object[].class)); case IMM_SET: return Set.of(array); case IMM_MAP: if (array.length == 0) { return ImmutableCollections.EMPTY_MAP; } else if (array.length == 2) { return new ImmutableCollections.Map1&lt;&gt;(array[0], array[1]); } else { return new ImmutableCollections.MapN&lt;&gt;(array); } default: throw new InvalidObjectException(String.format(\"invalid flags 0x%x\", tag)); } } catch (NullPointerException|IllegalArgumentException ex) { InvalidObjectException ioe = new InvalidObjectException(\"invalid object\"); ioe.initCause(ex); throw ioe; } }}"
    } ,
  
    {
      "title"       : "如何用Redis实现高性能高可用排行榜服务？",
      "category"    : "",
      "tags"        : "Redis, 排行榜",
      "url"         : "./redis/%E6%8E%92%E8%A1%8C%E6%A6%9C/2022/10/29/Redis_SortedSet_Rank.html",
      "date"        : "2022-10-29 09:00:00 +0800",
      "description" : "",
      "content"     : "微博点赞榜，粉丝/观众活跃榜，直播打赏/热度榜，关键词热搜榜等等，你是否曾经和我一样好奇这些排行榜是怎么实现的？到底是怎样一个工具或方案支撑了这些充斥在我们生活日常方方面面的“排行榜”。本文就介绍如何使用Redis实现高性能高可用排行榜服务。Redis 有序集合(Sorted Sets)有序集合(Sorted Sets)是Redis内置的一种基于跳跃表(skip list)，时间复杂度为O(log(N))数据类型。本文的基础都是基于Redis的有序集合。Redis相关命令ZADD插入一条排行榜记录，当记录存在时，替换key对应的score。12345678910redis&gt; ZADD myrank 1 \"lucy\"(integer) 1redis&gt; ZRANGE myrank 0 -1 WITHSCORES1) \"lucy\"2) \"1\"redis&gt; ZADD myrank 2 \"lucy\"(integer) 0redis&gt; ZRANGE myrank 0 -1 WITHSCORES1) \"lucy\"2) 2.0ZINCRBY当记录存在时，值为正数时，累加score的值, 当值为负数时，减少score值.当记录不存在时，和 ZADD 类似插入一条新记录。1ZINCRBY key increment member12345678910redis&gt; ZADD myrank 1 \"lucy\"(integer) 1redis&gt; ZRANGE myrank 0 -1 WITHSCORES1) \"lucy\"2) \"1\"redis&gt; ZINCRBY myrank 2 \"lucy\"3.0redis&gt; ZRANGE myrank 0 -1 WITHSCORES1) \"lucy\"2) 3.0ZRANGE根据起始和结束索引获取列表，可以实现排行榜数据的分页查询。默认是根据score值从小到大排序。1ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES] 参数 描述 start 开始位置。 0 stop 结束位置。负数表示倒序计数，-1表示获取全部 REV 获取逆序排序的数据。Redis 6.2开始替代 ZREVRANGE 命令。 WITHSCORES 在返回的列表的每个key之后追加对应的score数据 ZRANGE 排行榜的key start(开始位置) stop(结束位置) REV(逆序排序) (同时返回分数)12345&gt; ZRANGE myrank 0 -1 WITHSCORES1) \"lucy\"2) 2.03) \"mike\"4) 3.0ZRANK获取个人再排行榜的排名。返回从小到大排序的排行榜位置索引(排名)。往往排行榜的业务都是从大到小排序的，可以通过使用ZREVRANK命令获取从大到小排序的排名。1ZREVRANK key member12&gt; ZRANGE myrank lucy2更多内容命令说明见Redis文档 - 有序集合ZCARD获取有序集合的元素数量。获取排行榜的总长度。12&gt; ZCARD myrank2排行榜业务实践Redis的有序集合提供了高可用、高效的查询，那如何将它和我们实际业务结合起来呢？Redis只有一个score值但是业务中有4、5个排序影响因子该怎么处理呢？有序集合根据一个 IEEE 754标准的双精度浮点数表示分数进行从小到大排序，数据范围为 -2^1024^ ~ +2^1024^。其中精确表示整数的范围为2^-53^(-9007199254740992) ~ 2^52^(90071992547409992) 。超过精确范围的值将根据IEEE 754取/舍之后表示。一般平台的长整型范围为-(2^63^) ~ (2^63^ - 1)游戏通关记录排行榜根据关卡通关耗时从小到大排序, 根据VIP等级从大到小排序，上榜时间从小到大三个条件进行排序。首先将排序规则是从小到大还是从大到小进行统一，统一规则就可以，两种方式差别不大。根据本示例来讲，将VIP等级通过某种算法，转换为从小到大排序是比较合适的，例如：将VIP等级上限设定为100级，使用100级减去当前VIP等级的差值从小到大排序。统一规则之后，下一步就是通过算法将排序影响因子数据转换为有序集合的score。这里博主提供两个简单的实现思路以供参考。假定本示例的三个影响因子的有效值分别为等级经验值上限为整型（32位），vip等级上限为15级（8位），时间戳（32位）按bit划分计算将双精度浮点数的64位的拆分并用于表达3个排序条件值。很明显数据所需的位数（32+8+32=72）超过64位。这种情况下，需要业务上做一些适当的妥协，缩减数值范围。例如缩减等级经验值的数值范围。最简单的办法，按照一定比例换算经验值和分值计算做一次除法运算，例如：将10000游戏经验值转换为1”排行榜经验分数”，这样24bits的的”经验分”就可以涵盖32bits的整数的数值范围。第一个排序条件等级经验值，使用最高的24位，有效值范围为[0, 16777216]。第二个当前，占用8位，有效取值[0, 127]。剩余的32位，用于时间戳。12345678910int cost = 185215;int vipLv = 10;long mills = System.currentTimeMillis();// 分别偏移40位, 32位long redisScore = ((cost &amp; 0xFFFFFFL) &lt;&lt; 40) | (((100 - vipLv) &amp; 0xFFL) &lt;&lt; 32) | (mills &amp; 0xFFFFFFFFL);long tMills = redisScore &amp; 0xFFFFFFFFL;int tVipLv = (redisScore &gt;&gt; 32) &amp; 0xFFL;int tCost = (redisScore &gt;&gt; 40) &amp; 0xFFFFFFL;当然也可以从上榜的时间戳字段入手, 假如游戏排行榜是按照赛季分，且一个周期时间为2个月，将时间戳换算为上榜时间至玩法赛季截至时间的秒数，数据有效范围为[0, 24 * 3600 * 60 = 5_184_000]，只需要23bits（2^23^=8,388,608）就满足需求。数值字符串拼接成大整数第二种方案就更简单粗暴了，将数值字符串进行拼接，然后将字符串转换为为双精度浮点数 Double。这个方案和上例一样会有丢失精度的问题，在大于2^53^的整数方面，情况尤其突出。123456789101112131415161718// 排行榜分数计算公式double score = Double.parseDouble(String.valueOf(cost) + (100 - vipLv) + mills);int cost = 185215;int vipLv = 10;long mills = 1667212407355L; // System.currentTimeMillis();System.out.println(mills);System.out.println(\"\" + cost + vipLv + mills);System.out.printf(\"score:%f\", Double.parseDouble(String.valueOf(cost) + vipLv + mills));System.out.println();System.out.printf(\"score:%f\", Double.parseDouble(String.valueOf(cost) + vipLv + (mills + 4_000L)));System.out.println();System.out.printf(\"score:%f\", Double.parseDouble(String.valueOf(cost) + vipLv + (mills + 30_000L)));// 185215101667212407355// score:185215101667212400000.000000// score:185215101667212430000.000000// score:185215101667212430000.000000// score:9223372036854775807当通关耗时，VIP等级相同时，创建记录的时间(mills + 4s)和(mills + 30s)算出来的浮点数是一样的, 而实际上这两种中间相差26s的实际时间。分段百分比拼接结合上面两种方案，将数据通过除法换算，在根据实际需求按照十进制偏移n位后取整，再复用字符串拼接，组合出最终的Score分数。 例如将等级经验转换为最大值的比例程度，再精确到小数点后6位，：101w/10e = 0.001在进行十进制位偏移6位，转换为1010，无论是使用bits亦或是字符串拼接，数值范围都不是很大。这种方法更需要不断调整和结合实际业务需求。仅提供一种思路。合理的缩减数值范围一方面，在不影响业务效果的情况，应该尽可能的进行各种各样形式的缩减数值范围，达到优化排行榜Score的目的。另一方面，缩减数值范围虽然方便Score的生成和排序，也或多或少的影响了排序的数据精度。不断调整，逐步在数值和Score算法之间取得一个平衡，才能将Redis更好的应用于我们的排行榜。参考资料 Redis Sorted Sets Docs Try Redis IO"
    } ,
  
    {
      "title"       : "逆向实验室 - 使用AssetStudio提取Unity3D素材资源",
      "category"    : "",
      "tags"        : "逆向工程, Unity3D, AssetStudio",
      "url"         : "./%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/unity3d/assetstudio/2022/10/27/Unity3D_AssetStudio_Resources.html",
      "date"        : "2022-10-27 10:16:00 +0800",
      "description" : "",
      "content"     : "目前Unity3D引擎开发的游戏产品越来越多，对于游戏中的音频，ICON，模型和动画时常会感觉很惊艳，想提取这些资源素材。本期以我之前一段时间比较沉迷的地下城堡3：魂之诗为例，演示并介绍素材提取工具 AssetStudio 。AssetStudio是一个用于探索、提取和导出资产和资产包的工具。主要针对Unity3D 逆向有法律风险，不要将逆向素材应用于任何形式的商业活动。AssetStudio支持Unity3D 3.4 - 2022.1版本。 基本上涵盖至今为止的全部可能遇到的Unity3D发行版。具体的技术实现原理，不是很了解，希望了解的小伙伴可以移步到Github仓库查看源码。 素材类型   Texture2D 转换为 png, tga, jpeg, bmp Sprite 将 Texture2D 裁剪为 png、tga、jpeg、bmp AudioClip mp3、ogg、wav、m4a、fsb。支持将 FSB 文件转换为 WAV(PCM) Font ttf、otf Mesh obj TextAsset   Shader   MovieTexture   VideoClip   MonoBehaviour   Animator 使用绑定的 AnimationClip 导出到 FBX 文件 Scene Hierarchy(场景层次结构)游戏中场景和模型相关列表视图。可预览游戏场景和模型，地下城堡3使用的2D场景2D贴图动画。Asset List(资产列表)提取出来的贴图，动画，字体等游戏资产的列表视图。提取地下城堡3：魂之诗素材首先需要从官网或者第三方渠道下载对应的APK包。解压缩APK包到本地磁盘目录，使用“File” -&gt; “Load folder”, 选中解压缩的文件夹，然后等待AssetStudio索引解压资源完成。博主只需要提取地下城堡3的游戏ICON和音效，所以直接选中切换到“Asset List”查看全部资产列表。如下图所示：根据名称或者类型进行筛选，批量选中需要导出的资源，鼠标右键单击，选中Export即可。展示导出结果图：提取无神之界素材以导出宠物怒狮模型为例。在Scene Hierarchy视图选中模型，在Asset List视图中选中对应的动画。点击后输出为FBX格式的模型加动画。怒狮.fbx"
    } ,
  
    {
      "title"       : "部署Spring Boot Admin实现基础的服务器监控和告警",
      "category"    : "",
      "tags"        : "JAVA, SpringBootAdmin, SBA",
      "url"         : "./java/springbootadmin/sba/2022/10/26/Spring_Boot_Admin_2-7-6.html",
      "date"        : "2022-10-26 10:16:00 +0800",
      "description" : "",
      "content"     : "Spring Boot AdminSpring Boot Actuator模块提供了生产级别的功能，比如健康检查，审计，指标收集，HTTP 跟踪等，帮助我们监控和管理Spring Boot 应用。这个模块是一个采集应用内部信息暴露给外部的模块。支持HTTP和JMX两种方式访问。Spring Boot Admin（SBA）是在Actuator模块的基础上实现的UI界面，提供直观的UI和仪表盘方便开发者观察应用状态和简单的健康监控。启动Spring Boot Admin服务build.grdle中依赖设置为最新的Spring Boot 2.7.4和Spring Boot Admin 2.7.6。123456&lt;!-- pom.xml --&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;version&gt;2.7.6&lt;/version&gt;&lt;/dependency&gt;1234567891011// build.gradleapply plugin: 'io.spring.dependency-management'dependencies { implementation(\"org.springframework.boot:spring-boot:2.7.4\") implementation(\"org.springframework.boot:spring-boot-starter:2.7.4\") implementation(\"org.springframework.boot:spring-boot-starter-web:2.7.4\") implementation(\"org.springframework.boot:spring-boot-starter-actuator:2.7.4\") implementation(\"de.codecentric:spring-boot-admin-starter-server:2.7.6\")}创建应用启动类MonitorApplication.class。12345678@SpringBootApplication()@EnableAdminServer()public class MonitorApplication { public static void main(String[] args) { SpringApplication.run(MonitorApplication.class, args); }}默认监听8080端口，启动之后通过 http://127.0.0.1:8080查看面板。首页如下如所示：应用接入Spring Boot Admin项目中接入SBA也很简单，启动时会自动注入配置并注册到SBA。在应用程序目录中引入Client包。12// build.gradleimplementation(\"de.codecentric:spring-boot-admin-starter-client:2.7.6\")123456&lt;!-- pom.xml --&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;2.7.6&lt;/version&gt;&lt;/dependency&gt;设置启动配置和参数。一下提供基础的简单配置。更多配置见 Client Options123456789#===================================== Spring Boot Admin ======================================spring.boot.admin.client.url=http://127.0.0.1:9005spring.boot.admin.client.instance.prefer-ip=truespring.boot.admin.client.instance.service-url=http://127.0.0.1:2789spring.boot.admin.client.instance.metadata.tags.environment=services-my# Spring Securityspring.boot.admin.client.instance.metadata.user.name=spring.boot.admin.client.instance.metadata.user.password=management.endpoints.web.exposure.include=*启动测试程序。Spring Cloud服务发现上例中通过引入client包并注册到SBA。本例主要演示通过Spring Cloud全家桶的服务发现自动注册到SBA。SBA支持全部Spring Cloud的服务发现组件。首先确定你的项目中引入了Spring Cloud依赖。12// build.gradleimplementation(\"org.springframework.cloud:spring-cloud-starter:...\")12345&lt;!-- pom.xml --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;&lt;/dependency&gt;配置在application.yml文件即可。12345678910111213spring: cloud: discovery: client: simple: instances: test: - uri: http://instance1.intern:8080 metadata: management.context-path: /actuator - uri: http://instance2.intern:8080 metadata: management.context-path: /actuator健康状态告警SBA内置许多通知方式，例如：Microsoft Teams、邮件。也允许用户自定义通知，通过继承实现 AbstractEventNotifier。本小节主要以钉钉告警通知为例，更多其他类型的告警通知配置见 Spring Boot Admin Notifications相比于普罗米修斯这种重量级的监控和日志收集方案，SBA无法追溯查看历史数据，仅仅是针对状态变更的当前状态做一个告警和通知。作为重量级监控方案的补充，更灵活使用。钉钉告警通知 属性名 描述 缺省值 spring.boot.admin.notify.dingtalk.enabled 是否开启钉钉通知 true spring.boot.admin.notify.dingtalk.webhook-url 钉钉机器人的webhookUrl   spring.boot.admin.notify.dingtalk.secret 钉钉机器人的密钥   spring.boot.admin.notify.dingtalk.message 通知文本，支持SpEL表达式 ”#{instance.registration.name} #{instance.id} is #{event.statusInfo.status}” 其他SBA的另外一大亮点就是支持定义端点，允许嵌入外部网页。有助于用户扩展自定义的监控维度，也有助于支持各种各样的其他第三方库的监控管理后台，例如:Dubbo Admin。参考资料 Spring Boot Admin Reference Guide"
    } ,
  
    {
      "title"       : "XSS攻击实战 - 破解网站水印，右键复制屏蔽，打印屏蔽等等",
      "category"    : "",
      "tags"        : "XSS",
      "url"         : "./xss/2022/10/21/The_First_XSS_Attack.html",
      "date"        : "2022-10-21 22:04:00 +0800",
      "description" : "",
      "content"     : "你是否有过这样一段类似的经历。想复制网页上的文字，提示你需要登录! 内容被强制追加了宣传广告！想保存网页上的图片，确发现右键被禁用，单击右键没反应！想打印网页，但是打印预览无法正确预览内容！想下载mp3，网站只提供试听，不提供下载！看过的视频，想保存确找不到下载地址！本文带你走近XSS跨站脚本攻击（浅谈跨站脚本攻击(XSS)那些事儿）的世界。用常见的几个场景示例，带你理解XSS攻击, 学习和简单使用XSS攻击技术。存储型XSS和反射型XSS不在本文讨论范围内，至于为什么不在本文分享，⭐懂的都懂 :star: 。本文开始之前需要感兴趣的同学对Html、CSS、JavaScript有基础的了解和概念。本文以Chrome浏览器为例，使用方法适用于市场上所有主流的浏览器。主要工具是 浏览器内置的Chrome DevTool涉及演示的网站：Hi库、CSDN、360doc、起点中文网Chrome DevTool工欲善其事必先利其器。在开始操作之前，需要简单介绍一下我们需要使用的工具。浏览器自带的开发调试工具，本文主要就是Chrome DevTool。打开网站，按F12打开开发者工具。浏览器的下方会弹出如下图所示的界面。本文主要会涉及Elements、Sources、Network三个子页签，分别对象网页元素，网站资源和网站下载内容。解除网页的各种限制本小节主要分享和演示通过修改DOM以接触各种网页的限制。例如：复制按钮被劫持、鼠标右键失效，无法打印等等。解除Hi库乐问无法复制回答的限制乐问题主的问题是可以复制的，但是问答的回复是不能复制的，假如你收到下图所示的回复，回复的是网址url而不是超链接时，就尴尬了。由于无法复制打开网址，我该怎么查看呢？按F12打开调试工具，在乐问无法复制的地方鼠标右键选择查看，下方Elements面板就会定位到需要复制的内容，在面板中复制即可。如何让避免这种尴尬的问题呢？在回答里面使用超链接类型，替代直接粘贴网站地址。去除Hi库的防泄密水印我一般写文章是会写到个人博客里面，然后再使用Chrome Print打印导出为PDF再发布到Hi库中。有时候会相反。此时就需要把Hi库的文档导出出来。然而很明显受限于Hi库的防泄密水印这个想法并不好实现。那有没有办法处理呢？ 答案肯定是有的。关于水印有非常多的实现方案，本小节只讨论Hi库的方案，它是通过watermark.vue的插件实现的，原理就是使用和生成一张透明背景的png图片，内嵌到网页中。只需要在Elements中删除这些内嵌的元素即可。Ctrl+F搜索watermark关键字，你会搜到如下图所示的结构：使用Delete删除这些内容即可。同一个网页会有多个此类型的元素，按需求删除就可以了。解决Hi库的导出打印限制有些同学可能没使用过Chrome Print功能。这是浏览器自带的一种打印接口工具，可以连接打印机打印网页，也可以打印导出为PDF格式文件，属于非常实用的工具功能之一。有空我会针对Chrome浏览器的实用插件进行一期分享。Hi库的方案是再网页的头部增加一个名称为print的media。浏览器打印会根据这个标签控制打印的样式，将打印的内容和样式设置为空白。源码如下：1&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"print\" href=\"//static.lexiang-asset.com/build/css/common/print-a52d141bed.css\"&gt;1234567891011121314.breadcrumb,.comment-container,.footer,.header-general-container,.like-favorite,.team-top-section { box-shadow:none; display:none}.exam-paper.block-container { box-shadow:none}body { background-color:#fff}@page { size:auto; margin:.8cm 0 1cm 0}了解其实现方案，破解也就变得很简单了，在我们使用Ctrl+P后预览打印的内容为空白的页面，此时Hi库的js脚本监听了我们的安检，并给页面的根节点app-layout增加一个class class=”disable-print” 打开打印预览，然后移除这个属性，再打印预览里面刷新一下就可以正确的看到预览。解除360doc的防未登录复制的限制使用搜索引擎时，经常会搜到360doc的结果词条，点入之后，鼠标右键被劫持，使用Ctrl+C时强制弹窗提示登录和付费。解除CSDN登录限制javascript:document.body.contentEditable=’true’;document.designMode=’on’;原理资源和素材提取本节主要演示通过Network面板提取资源素材，下载mp3音乐，mp4视频等等。提取mp3音频文件很多音乐网站都提供完整音频试听服务。1分钟试听的这种除外，这种类型的试听往往整个音频文件是切割过的，只有1分钟有效数据，无法简单的破解提取。这也算XSS攻击？没错，以上的例子在广义上讲都属于XSS攻击范畴。属于危害相对较轻的DOM型攻击，虽然我们可能自认为没有进行破坏性的攻击网站。但是违背网站站长原意的操作，何尝不是一种破坏呢？且用且珍惜。DOM攻击的原理基本上都是一样的，只不过网络黑产使用的手段更隐蔽，更自动化，工业化。给大家再举一个场景🌰。现在的博客很多都会有打赏看全文的限制，假如通过一些手段劫持并修改转账的按钮的链接，此时域名显示的支付是二维码，二维码图片读者也不太可能去验证真伪，这个时候你的打赏被错误的转给攻击者，造成作者的直接经济损失。是不是很可怕？更深入的一些手法例如：通过盗取你浏览器里面的认证信息，并冒用你的凭证，去破坏你的用户数据，使用你的账户余额等等。要如何防御呢？假如说要改进，增加防破解的门槛，有哪些途径和路子呢？这里举简单的两个方向🌰。更多详细内容，见浅谈跨站脚本攻击(XSS)那些事儿这篇文章。最简单，最有效，最直接的方案莫过于架构修改为服务器渲染，仅下发展示所需的最小数据集。这种方式有效且很难被破解。但是缺点也很明显和目前主流的前后端分离开发的思想不一致（目前htmlx有抬头的趋势）。粗俗点说，都改成服务器渲染了，你还想顺着网线爬过来，然后跳起来打我膝盖？怕不是想屁吃。 假如有熟悉HtmlX的大佬，期待大佬深入剖析一下。客户端的套路，基本上治标不治本，防君子不防小人，只是无谓的增加破解门槛，没有真正意义的防御作用。例如：检测到打开console就使用setInterval()开始一个定时弹窗提示或清空界面数据。通过sources面板找到源码，并用断点debug就可以绕过。"
    } ,
  
    {
      "title"       : "漫谈生死狙击页游排行榜服务的迭代演进",
      "category"    : "",
      "tags"        : "JAVA, Redis, 排行榜",
      "url"         : "./java/redis/%E6%8E%92%E8%A1%8C%E6%A6%9C/2022/10/21/Java_Rank_Service_Impl.html",
      "date"        : "2022-10-21 16:16:00 +0800",
      "description" : "",
      "content"     : "微博点赞榜，粉丝/观众活跃榜，直播打赏/热度榜，关键词热搜榜等等，你是否曾经和我一样好奇这些排行榜是怎么实现的？到底是怎样一个工具或方案支撑了这些充斥在我们生活日常方方面面的“排行榜”。本期就通过回顾生死狙击页游排行榜迭代演进，漫谈生死一是如何实现排行榜业务的，为什么选中这样的技术方案。远古时期的排行榜我是2016年入职的，所以这里的远古也仅仅代指我入职初期这段时间。实话讲，当时的排行榜实现方案还比较简陋，整个业务逻辑流程大概分为以下四个阶段： 收集阶段：在业务代码中打点记录并收集玩家的原始数据，并写入MySQL数据库备用 整理阶段：每日凌晨排行榜的定时更新任务，通过对数据的过滤和整理，筛选出有效数据， 排序阶段：通过 Collection.sort() 对数据进行一次排序。 输出阶段：将玩家的当前排名信息curRank、上次排名、玩家信息等结果信息写入到排行榜数据表中。值得注意的是由于每个排行榜记录中都包含一个名为curRank字段，表示记录在排行榜中的排名情况，所以在Collection.sort()后, 需要对每一个排行榜记录的curRank字段进行更新和赋值。石器时代这个时期，策划童鞋引入跳跃模式，专注于游戏身法练习的特殊模式，并且希望有一种更及时一点的排行榜，帮助玩家更早更及时的关注到排名或者成绩的变化。而彼时生死狙击的排行榜业务数据更新周期是每日，显然不能满足策划童鞋的预期。自此，博主也开始了和排行榜的不解之缘。并首次着手重构改进排行榜业务。实现实时排序必须追踪每次数据变动，并根据数据变动堆排行榜数据更新。但是每次变动都调用Collection.sort()进行全量排序显然是一种极其消耗和浪费服务器性能的做法。跳跃排行榜有一个业务特点玩家创造的排行榜数据只增不减，后续创造的较差的记录，不会影响以及记录在排行榜的记录。梳理一下业务，概括成以下三个情况： 排行榜上榜记录未达到上限时，上报的玩家记录必定上榜。 排行榜记录达到上限时，未上榜玩家的上报记录超过排行榜最后一名时，必定上榜。 已经上榜的玩家，创造更好的记录，排名只会向前变动。这个方案的目的，支持实时排序的同时避免使用Collection.sort()进行全量的排序，减少同步更新玩家curRank字段的成本，避免遍历全排行榜记录。排序的核心算法如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 实时排行榜排序. * 从排行榜最后一名开始向前检查并更新排名。 * &lt;p&gt;1. 当var1等于null时, 比最后一名优秀, 排行榜一定变更&lt;/p&gt; * &lt;p&gt;2. 当排行榜的length为0时, 排行榜一定变更， 第一名入榜&lt;/p&gt; * &lt;p&gt;3. 当var1排序在bean右侧时, 玩家刷新个人记录，排行榜可能变更. 否则玩家排名不变&lt;/p&gt; * * @param bean 新纪录 * @param var0 旧记录 * @param copyRank 排行榜列表 */protected boolean sortRank0(final B bean, final B var0, List&lt;B&gt; copyRank) { B var1 = var0; int endIndex; boolean isDirty = false; if (var1 == null) { var1 = bean; endIndex = copyRank.size() - 1; isDirty = true; } else { if (var1.isChanged(bean)) { var1.updateInfo(bean); setChanged(true); } if (var1.compareTo(bean) &gt; 0) { var1.updateValue(bean); setChanged(true); endIndex = var1.curRank - 1; copyRank.remove(endIndex); endIndex--; } else { // 排名未改变 return false; } } int startIndex; if (copyRank.isEmpty()) { var1.curRank = 1; var1.lastRank = 0; copyRank.add(var1); } else { for (int i = endIndex; i &gt;= 0; i--) { B next = copyRank.get(i); if (next.compareTo(var1) &lt; 0) { startIndex = i + 1; var1.lastRank = var1.curRank; var1.curRank = startIndex + 1; copyRank.add(startIndex, var1); isDirty = true; break; } else { next.lastRank = next.curRank; next.curRank += 1; if (i == 0) { var1.lastRank = var1.curRank; var1.curRank = 1; copyRank.add(0, var1); isDirty = true; } } } } return isDirty;}工业时代显然石器时代的方案比较落后。首先，不支持有自动排名下降的需求，只能和老方案一样通过 Collection.sort() 来处理。第二点，虽然方案中使用了泛型特性，一定程度上提高了代码的复用率，但是也引入了对记录类的泛型约束，记录类必须继承BaseRankInfo，这种实践随着时间推移，项目迭代，也被证明依旧不方便扩展，同时限制了父类的公共字段，创建和实现大量特异的子类数据类，增加了排行榜记录类的维护成本。第三点就是排行榜都是硬编码实现的，每次新增需求都会设计到技术排期、开发。演进到“工业化时代”，我们试图对旧有业务进行抽象。抽象DB处理接口，数据Bean处理结构接口以及特定注解@GameRankTemplate等等对排行榜功能进行整合打包。将打包后的排行榜定义为一个Rank特定的结构方案，并暴露给策划童鞋填模板表进行复用。12345678910111213141516171819202122232425262728293031323334353637383940@Inherited@Documented()@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface GameRankTemplate { /** * 排行榜的长度上限 */ int length() default Constant.RANK_MAX_LENGTH; /** * 数据库操作组件 * * @return the bean's mybatis mapper. */ Class&lt;? extends GameRankBeanMapper&gt; mapper() default DefaultGameRankBeanMapper.class; /** * Bean处理器. 数据加载完成后调用handler处理排行榜的数据. */ Class&lt;? extends GameRankBeanHandler&gt; beanHandler() default RpgCharNameHandler.class;}public interface GameRankBeanMapper&lt;T&gt; { void createTable(int group); List&lt;T&gt; selectById(int group); void deleteById(int group); void batchInsert(int group, List&lt;T&gt; ranks);}public interface GameRankBeanHandler&lt;T&gt; { void handle(List&lt;T&gt; beans);}有一定的改进成果，首先引入模板表配置，通过策划童鞋配置来复用排行榜结构，更灵活，其次通过配置，一定程度上解决硬编码问题，提高排行榜业务代码的复用率。但是很明显，基于Rank的打包方案依旧不够通用，会因为排序规则，排序影响因子等而导致Rank结构不复用，后续迭代中技术定义的越来越多的Rank结构就足以说明一切。后工业化时代这次是一个颠覆性的重构，重写了生死狙击页游的排行榜业务，并借鉴Redis的Sorted Set（跳表）的一些思路，引入并使用skipList。统一的排行榜的数据结构 ReducedGameRank，通过descriptor策划配置的模板表数据, 可以控制排行榜行为(e.g. 发奖，清榜 .etc)，mappingMap管理玩家排行榜记录，sortedMap是根据记录有序排序的玩家信息map。主要结构如下：1234567891011121314151617181920public class ReducedGameRank implements Serializable { /** * Unique rank identify. */ private final RankConfig config; /** * The rank struct description. */ private final ReducedGameRankStructDescriptor descriptor; /** * Unique player's identify and rank score mapping map. * Unique Id - Sorted Key. */ protected final ConcurrentHashMap&lt;Object, Comparable&gt; mappingMap; /** * player's rank goal and displayed rank info map. */ protected final ConcurrentSkipListMap&lt;Comparable, RankBean&gt; sortedMap;}本次重构的另外一个重大变动是弱化排行榜记录和个人信息两个对象类的各种限制，同时客户端同步重构为通过反射获取排行榜记录各个字段的数据值，将各个业务中繁花似锦的对象bean结构和排行榜界面显示彻底解耦。核心排序算法和sortRank0类似，源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public boolean update(final Object uniqueId, final Comparable score, final Object displayInfo) { Assert.isInstanceOf(this.descriptor.getClzOfUniqueId(), uniqueId); Assert.isInstanceOf(this.descriptor.getClzOfScore(), score); Assert.isInstanceOf(this.descriptor.getClzOfInfo(), displayInfo); Comparable lastScore = this.mappingMap.get(uniqueId); if (lastScore != null &amp;&amp; lastScore.compareTo(score) &lt; 0) { // if display info changed. replace by newly info. RankBean bean = this.sortedMap.get(lastScore); boolean infoChanged = bean != null &amp;&amp; !Objects.equals(bean.getInfoBean(), displayInfo); if (infoChanged) { bean.setInfoBean(displayInfo); this.updateWithIncremental(bean, CHANGED); } return infoChanged; } if (hasMaxRankLength()) { Comparable lowest = this.lowest; if (lowest != null &amp;&amp; lowest.compareTo(score) &lt; 0) { return false; } } if (this.sortedMap.containsKey(score)) { LOG.error(\"player's rank data is conflicted. uniqueId:{}, score:{}, info:{}\", uniqueId, score, displayInfo); return false; } RankBean bean = new RankBean(identify(), uniqueId, score, displayInfo, rank(uniqueId), GameClock.currentTimeMillis(), 0L, 0, true); this.lock.writeLock().lock(); try { this.mappingMap.put(uniqueId, score); if (lastScore != null) { // replace the prevent player's rank goal. RankBean prev = this.sortedMap.remove(lastScore); if (prev != null) { bean.setLastChangeDisplayFlag(prev.getLastChangeDisplayFlag()); bean.setUpdateDisplayCount(prev.getUpdateDisplayCount()); bean.setDisplay(prev.isDisplay()); } this.updateWithIncremental(bean, CHANGED); this.sortedMap.putIfAbsent(score, bean); } else if (hasMaxRankLength()) { // remove the lowest player's rank goal. RankBean removed = this.sortedMap.remove(this.sortedMap.lastKey()); if (removed != null) { this.updateWithIncremental(removed, REMOVED); } this.updateWithIncremental(bean, ADDED); this.sortedMap.putIfAbsent(score, bean); this.lowest = this.sortedMap.lastEntry().getKey(); } else { this.updateWithIncremental(bean, ADDED); this.sortedMap.putIfAbsent(score, bean); this.currentRankLength++; } this.rankChanged = true; return true; } finally { this.lock.writeLock().unlock(); }}相比较sortRank0，使用skipList解决了分数变动无法降低排名的问题。为什么选择自研而不是引入Redis呢？Redis是缓存中间件领域的佼佼者，是主流的缓存中间件之一。从网站的服务器的技术架构方案上说，一个网站或多或少的都会使用到缓存中间件，用来缓存用户数据，在各个服务共享状态，降低DB的访问压力等等。与此同时，Redis提供的多种数据类型中有一个名为Sorted Set有序集合。通过有序集合可以快速的对数据进行排序，查询时间复杂度为O(log(n))，核心原理是使用跳表，通过多层索引实现高效率的查询。有序集合特性让Redis成为优先选则为实现涉及到排序类型的业务的根本原因，可以在不增加架构复杂度的基础上，快速可靠的实现新需求。另外，网站的技术架构也让不少的公司使用Redis做分布式锁。而生死一页游不选择的主要原因有一下几点： 架构上需要单独引入Redis这个第三方中间件。增加架构复杂度。 Redis的sorted set通过一个长整型数值来排序。当排序条件超过4-5个时，需要业务层妥协(e.g. 缩减数据规模，降低精度 .etc)，此时就有些捉襟见肘了。 相比于Redis的高可用架构，使用Java标准库的ConcurrentSkipListMap可以实现更高效且低成本的并发。接入目前的技术架构比较简单。现今排行榜服务实现了独立部署，快速启动，动态缓存截至目前为止，排行榜服务接入超过1500+游戏排行榜。经历多代演进，排行榜服务被剥离出主服务进程，作为一个单独的服务用于支撑全服的排行业务。展望列举一部分未尽的设想和未来展望。等后续有空的时候开发。 排行榜模板和周期性重复模板，例如：按照赛季时间滚动的排行榜，赛季过期老的排行榜也就废弃了，但是新赛季配置基本一致。目前都需要重复的配置。 排行榜服务负载不均衡。目前可以通过客户端负载均衡来协调排行榜服务的负载，但存在热点排行榜数据的问题，在高负载情况下，会出现响应慢等问题。 支持无限长度排行榜。 参考资料 Java 17 JVM logging framework Embracing JVM unified logging"
    } ,
  
    {
      "title"       : "详解Java的 统一JVM日志框架",
      "category"    : "",
      "tags"        : "JAVA, 统一日志框架, jvm, logging",
      "url"         : "./java/%E7%BB%9F%E4%B8%80%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/jvm/logging/2022/10/20/JVM_Xlog.html",
      "date"        : "2022-10-20 16:16:00 +0800",
      "description" : "",
      "content"     : "JAVA 9引入的统一JVM日志框架，旨在解决JVM内部各种各种混乱的打印日志和配置, 增强日志框架的功能（e.g. 滚动日志文件，异步日志.etc）并简化配置。JEP-158、JEP-271在1.8和以前的JVM参数调优中时不时会看到 -Xloggc:gc.log、-XX:+PrintClassHistogram、-XX:+PrintGCDetails、-XX:+PrintHeapAtGC之类信息，这些信息到底是干什么的呢？到底该怎么迁移这些配置和参数呢？统一JVM日志框架本文使用OpenJDK 17 LTS。统一日志框架很明显能看出来很多现代化日志框架的影子，包括日志分级，按标签分类，滚动日志文件以及异步写等等，是JVM内部的一大重要变更和升级。以前项目组使用的Java 1.8，今年准备升级到Java 17，不可避免的这些优化和新特性都可以使用起来。通过java -Xlog:help查看JVM统一日志框架的帮助文件。日志等级支持trace, debug, info, warning, error五个日志级别， 使用off禁用日志。日志装饰器根据设置的顺序装饰日志信息。设置为 none 不使用任何装饰器。   描述 time(t),timemillis(tm),timenanos(tn) 当前时间和日期（ISO-8601 格式 uptime(u),uptimemillis(um),uptimenanos(un) 自JVM启动以来的时间，时间单位分别为秒，毫秒，纳秒 pid(p) 进程标识符 hostname(hn) 主机的hostname tid(ti) 线程标识符 level(l) 与日志消息关联的级别 tags(tg) 与日志消息关联的标签 日志标签统一日志框架应用于JVM内部的各个模块。 使用all开启全部。Github OpenJDK LogTag.hpp定义了169个标签在OpenJDK中-XX:Print…相关的参数缺省值都是false, 并且推荐使用log进行配置。 模块 日志标签 描述 add redefine 重新定义方法时的日志。 age gc GC 任期分布及相关统计。 alloc gc GC 区域或空间分配。 annotation redefine 重新定义期间有关注释的日志，此标记似乎仅与redefine. aot aot 提前机制日志。 arguments   JVM 选项警告或错误（只有错误，除非 level 是trace），例如，当使用应使用统一日志记录而不推荐使用的日志记录选项时。 attach   JVM 附件监听器 barrier gc,xxx GC 写屏障覆盖率 biasedlocking   偏向锁定机制src/hotspot/share/runtime/biasedLocking.hpp blocks oopstorage,gc   bot gc 块偏移表（带有偏移信息的侧数据结构，指示 GC 需要回溯多远才能找到对象的开头）。 breakpoint jvmti（重新定义） 断点设置或清除 JVMTI 的一部分，但记录在redefine?log 标记 root下。 bytecode jfr 有关由 执行的字节码修改的日志JFR，始终与jfr. cds cds 类数据共享日志 census gc CMS 日志freelist信息。 class ,class,aot 类相关信息 classhisto gc   cleanup safepoint 安全点清洁信息 codecache codecache,compilation 生成代码的代码缓存：已编译的 java 方法、运行时存根、转换帧等。隔离在 3 个堆中（非 nmethods，如缓冲区、适配器和运行时存根，已分析的 nmethods，未分析的 nmethods）。src/hotspot/share/code/codeCache.cpp compaction gc G1GC 和 Parallel 的 GC 压缩 compilation compilation,jit 汇编 constantpool class,redefine, 常量池，主要在redefine constraints class 类加载器约束 container os 容器 (CGroup) 相关 (cpu,cpuset,memory,mountinfo等等) coops gc 压缩普通对象指针 cpu gc,os 记录时的 CPU 特性os，CPU 时间 igc cset gc G1中的收藏集 data class 类加载器数据（分配空间或元空间） datacreation perf 与 perf 数据创建相关 dcmd jfr JFR 诊断命令日志始终与日志标记根结合在一起jfr decoder   与 Linux 上的 ELF 解码（可执行和可链接格式）相关。 defaultmethods   默认方法的运行时支持。类的一部分，但作为独立标签记录。 director gc ZGC相关 dump redefine 重新定义后重新定义有关旧方法或过时方法的调试日志记录。 ergo gc 人体工程学，通常与 结合gc，但可以单独找到（例如，关于线程本地握手的 2 个日志） event jfr 关于 JFR 事件 exceptions exceptions,redefine 关于不同部分（解释器、安全点期间、编译器……）中的 Java 异常处理。与redefine. exit gc GC 之后的 GC/heap 相关信息。LogStreamHandle(Debug, gc, heap, exit) fingerprint class,aot 类指纹 free malloc 记录任何 C stdlib或调用，总是通过malloc标签记录。realloc free malloc, free freelist gc 应该是空闲的内存块，用于 CMS 和元空间 gc gc GC 日志标签根。 handshake thread 线程本地握手src/hotspot/share/runtime/handshake.hpp hashtables   独立时，它是内部分桶哈希表，是 a 的远亲HashMap，Hotspot 将它用于字符串和其他符号。CDS 使用另一个内部实现进行统计，因此该标签可以与cds?日志标签 root结合使用。 heap gc 各种GC堆相关的日志 humongous gc G1GC 中的巨大对象 ihop gc G1GC 中的堆占用（初始、当前、目标） iklass class,redefine 内部类实例表示，日志标签根：redefine，classes init gc,class log tag root主要是关于什么时候的类初始化class。关于结合gc. inlining jit 方法内联信息 interpreter interpreter 解释日志，只记录带有oopmap和safepoint子标签的日志。 itables   JVM 开发过程中接口调用的 JVM 虚拟调用机制（需要非产品构建）。另见vtables标签。热点维基 jfr jfr JDK飞行记录器 jit jit inlining关于方法和的日志compilation jni gc 仅在GC locker期间记录。 jvmti jvmti   liveness gc G1GC 区域活跃度（死对象与活对象） load gc,class,redefine 跟踪所有加载的类，包括重新定义的类。 loader class 类加载器data和constraints logging   关于统一日志记录 malloc malloc 记录任何 C stdlib或调用，总是通过malloc标签记录。realloc free malloc mark redefine 期间标记obsolete方法redefine marking gc G1GC、CMS、ZGC的标识信息 membername   重定义用来替换方法的哈希表。与 结合使用table，但没有redefine?日志标记 root。 memops perf 内存操作日志initialize和mmap_attach_shared metadata jfr,redefine 当日志标记根为时，有关类重新定义的日志redefine。或有关 JFR 事件元数据的日志，当日志标记根为jfr. metaspace gc 关于元空间内存空间的日志 methodcomparator redefine 重新定义期间有关方法等效的日志。 mirror cds cds关于类镜像处理的日志。java 镜像是java.lang.Class. mmu gc Minimum Mutator Utilization是 G1GC 和 ZGC 的 GC 工作的（时间）目标。G1GC 将此定义为MaxGCPauseMillis时间片 ( ) 上的暂停时间目标 (GCPauseIntervalMillis)。 module   模块系统 monitorinflation   运行时同步支持 monitormismatch   在 OopMapGeneration 期间监控匹配失败 nestmates class,redefine Nestmate 属性日志记录，使用日志标记根?class或redefine. nmethod gc,class,redefine 本机方法（如在 Java 方法的编译代码版本中）记录在各种子系统中：gc、classredefine normalize redefine 重定义过程中方法添加、删除、替换后的日志 objecttagging jvmti JVMTI 对象标记调用 obsolete redefine 主要用于重定义（和 JVMTI）的过时方法入口 oldobject jfr 旧对象采样，当前仅记录由于锁争用而跳过的示例。日志标记根是jfr. oom gc metaspace内存不足时报告。 oopmap interpreter,redefine 记录普通对象指针缓存，结合 byinterpreter和redefine. oops gc CMS和ZGC中的普通对象指针日志 oopstorage   用于管理对 Java 堆中分配的对象的引用的内部堆外数据结构 os os 操作系统交互日志。 pagesize   有关页面大小的日志。独立标签。 parser jfr 读取录音时在 JFR 解析器中使用的事件。日志标记根是jfr. patch module 日志记录–patch-module path class 类路径或模块路径处理 perf perf 有关 JVM 性能计数器的日志。但是当与它结合使用时，stringtable它是关于字符串 (String.intern()) 的。 phases gc 作为 GC 阶段的一部分的日志，特别是对于 ZGC 和 G1GC。 plab gc 有关每个 GC 线程分配缓冲区的日志，这些日志在 GC 期间用于防止线程在同一内存空间上竞争。 preorder class 跟踪按引用顺序加载的所有类（未加载） preview   预览特征类型的跟踪加载 promotion gc GC 期间的对象提升日志。 protectiondomain class 类保护域验证。 purge redefine 重新定义期间有关先前类版本卸载的日志。 redefine redefine 类重定义子系统，特别是用于 JVMTI（例如调试时）和使用 Java 代理进行类转换/重新转换的子系统。 ref gc GC对象或类引用相关日志 refine gc G1GC 记录 RSet (Remembered set) 的细化线程 region gc G1GC 关于区域的日志。级别的allocandheap组合debug将打印区域统计信息，trace级别记录 GC 在区域上执行的操作和更多详细信息。 reloc gc ZGC 对象集重定位。 remset gc G1GC 记忆组。如果 level 是，trackingandexit标签可以出现trace。 resolve class,aot 关于常量池分辨率的日志，例如在加载类、lambda、进行反射、jni 时 safepoint safepoint JVM stop-the-world 操作 Heap Dump、一些 GC 任务、反优化、偏向锁撤销、库加载等……安全点虽然）。具体的操作日志可以用standalone?vmoperation. sampling jfr JFR 中的旧对象采样。trace仅水平。 scavenge gc CMS、并行和串行 GC 清除跟踪。 setting jfr 的一部分jfr，主要是关于 JFR 配置。 smr thread 线程安全内存回收（Thread-SMR），危险指针。src/hotspot/share/runtime/threadSMR.cpp。 stackmap redefine 重新定义期间方法堆栈图中的常量池更改 stacktrace   期间记录Throwable.fillInStackTrace()。 stackwalk   使用时的日志StackWalker。 start gc,codecache 表示 ZGC 阶段开始，因此与gc.?但也可以指示其他操作开始，例如 for?codecache。 startuptime   记录 JVM 子系统的启动时间（解释器、GC、模块系统、类加载、aot、关于内存区域的创世……） state gc CMS GC 状态。 stats gc GC 统计日志。也可以看到（oopstorage, blocks标签集）。 stringdedup gc G1GC 字符串去重（老年代） stringtable   当 G1GC 用于记录字符串和符号清理时String.intern()，可以在gc?日志标记根中看到关于实习字符串 ( )。 subclass class,redefine 子类卸货。重新定义期间受影响的子类。 survivor gc CMS GC 幸存者信息。 sweep gc,codecache CMS GC 清扫活动。并且代码缓存本地方法根据日志标记 root刷新。 system jfr JFR 系统记录、记录开始/停止、紧急转储等。 table membername 仅与membername, 关于哈希表一起使用来记录方法，并在重新定义时替换它们。” task gc 主要与 GC 任务相关，查看phases标签很有用。还与线程本地握手结合使用handshake。 thread os 当用作日志标签根时，它是关于smr，当它与os日志标签根结合使用时，它是关于线程生命周期和守卫的。 time gc 定时并行 GC 操作 timer thread,redefine 定时重定义操作和线程退出 tlab gc 线程本地分配缓冲区统计信息 (trace) tracking gc G1GC 记忆集跟踪 unload class 类或模块卸载 unshareable cds 对于无法共享的类，在 CDS 存档创建期间特别有趣 update redefine 有关类、方法、常量池、vtable、itable 等的重新定义更改的日志。 verification   类字节码验证器，当独立时。与cds. verify gc 在 GC 操作期间完成的验证操作。 vmoperation   记录 VM 操作 vmthread   执行 VM 操作的 JVM 线程（通常在安全点期间） vtables   Java 的虚拟调用机制（虚拟表允许在类层次结构中为当前实例找到正确的方法地址）。以前学过 C++ 的人会记得。 vtablestubs   Java 的虚拟调用机制，用于多态调用站点（即，由于对象层次结构不同，在连续执行中执行的方法不同时）。热点维基1?2 workgang gc GC 工作线程。 日志输出方式支持stdout、stderr和file三种输出方式。stdout/stderr没什么特殊的。file增强了很多，文件名中包含 %p和%t 会被替换为 进程标识符和时间戳。filesize设置按照文件大小滚动日志，filecount设置滚动日志文件的数量。1...:file=/var/log/gc-%t.log:time,tags,level:filecount=5,filesize=10M这段参数含义是输出日志文件gc-2022-10-20_16-07-18.log, 使用time tags level装饰器, 文件每10MB拆分一个新日志文件,最大保持5个日志文件。开启日志异步写入-Xlog:async启用异步日志写入，减少写日志导致的应用线程阻塞。示例123456789101112-XX:+PrintGCDetails \\-XX:+PrintGCApplicationStoppedTime \\-XX:+PrintGCApplicationConcurrentTime \\-XX:+PrintGCCause \\-XX:+PrintGCID \\-XX:+PrintClassHistogram \\-XX:+PrintTenuringDistribution \\-XX:+PrintGCDateStamps \\-XX:+UseGCLogFileRotation \\-XX:NumberOfGCLogFiles=5 \\-XX:GCLogFileSize=10M \\-Xloggc:/var/log/`date +%FT%H-%M-%S`-gc.log \\123456789101112-Xlog: gc*, gc+heap=debug, gc+ref=debug, gc+ergo*=trace, gc+age*=trace, gc+phases*=debug, classhisto*=debug, safepoint* :file=/var/log/%t-gc.log :time,tags,level :filecount=5,filesize=10M参数 -verbose:gc1gc=trace gc+heap=trace gc+heap+exit=trace gc+metaspace=trace gc+sweep=debug gc+heap+ergo=debug参数 -XX:+PrintGCTimeStamps等同于启用uptime装饰器参数 -XX:+PrintClassHistogram等同于classhisto*=trace参数 -XX:+PrintHeapAtGC等同于gc+heap=debug1234567891011[2022-10-20T16:07:27.311+0800][20044][gc,heap ] GC(2) Min Capacity: 512M(50%)[2022-10-20T16:07:27.311+0800][20044][gc,heap ] GC(2) Max Capacity: 1024M(100%)[2022-10-20T16:07:27.311+0800][20044][gc,heap ] GC(2) Soft Max Capacity: 1024M(100%)[2022-10-20T16:07:27.311+0800][20044][gc,heap ] GC(2) Mark Start Mark End Relocate Start Relocate End High Low [2022-10-20T16:07:27.311+0800][20044][gc,heap ] GC(2) Capacity: 512M (50%) 512M (50%) 512M (50%) 512M (50%) 512M (50%) 512M (50%) [2022-10-20T16:07:27.311+0800][20044][gc,heap ] GC(2) Free: 700M (68%) 652M (64%) 702M (69%) 894M (87%) 894M (87%) 650M (63%) [2022-10-20T16:07:27.311+0800][20044][gc,heap ] GC(2) Used: 324M (32%) 372M (36%) 322M (31%) 130M (13%) 374M (37%) 130M (13%) [2022-10-20T16:07:27.311+0800][20044][gc,heap ] GC(2) Live: - 39M (4%) 39M (4%) 39M (4%) - - [2022-10-20T16:07:27.311+0800][20044][gc,heap ] GC(2) Allocated: - 48M (5%) 52M (5%) 55M (5%) - - [2022-10-20T16:07:27.311+0800][20044][gc,heap ] GC(2) Garbage: - 284M (28%) 230M (22%) 34M (3%) - - [2022-10-20T16:07:27.311+0800][20044][gc,heap ] GC(2) Reclaimed: - - 54M (5%) 249M (24%) - - 参考资料 Java 17 JVM logging framework Embracing JVM unified logging"
    } ,
  
    {
      "title"       : "如何让Java的文件加载支持有BOM的文件？",
      "category"    : "",
      "tags"        : "JAVA, FileInputStream, BOM",
      "url"         : "./java/fileinputstream/bom/2022/10/15/Java_Remove_BOM.html",
      "date"        : "2022-10-15 16:32:00 +0800",
      "description" : "",
      "content"     : "Java的FileInputStream提供最基本的文件加载功能。不支持BOM头，直接使用会错误的将无意义的BOM信息当做正文内容加载进来。本文旨在找到通用的方式处理BOM头，并以UTF系列编码为例。需要扩展支持GB 18030等其他字符编码规范定义的特殊BOM，可以自行扩展。有很多开源库和工具支持UTF系列编码。例如：Apache Commons-io。但是不支持GB 18030或者其他编码的BOM，这也是为什么写本文重要原因之一。12345678try (FileInputStream fis = new FileInputStream(file); BomInputStream bis = new BomInputStream(fis); BufferedReader reader = new BufferedReader(new InputStreamReader(bis, bis.getBomCharset()))) { reader.lines() .forEach(line -&gt; /*...*/);} catch (Exception e) { // handle exception.}在BOM_PREFIX_ARRAY中定义你所需的BOM头格式。详细的BomInputStream实现源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public final class BomInputStream extends PushbackInputStream { private static final int MAX_BOM_SIZE = 4; private static final ByteOrderMark[] BOM_PREFIX_ARRAY = new ByteOrderMark[]{ new ByteOrderMark(Charset.forName(\"UTF-32BE\"), (byte) 0x00, (byte) 0x00, (byte) 0xFE, (byte) 0xFF), new ByteOrderMark(Charset.forName(\"UTF-32LE\"), (byte) 0xFF, (byte) 0xFE, (byte) 0x00, (byte) 0x00), new ByteOrderMark(StandardCharsets.UTF_8, (byte) 0xEF, (byte) 0xBB, (byte) 0xBF), new ByteOrderMark(StandardCharsets.UTF_16BE, (byte) 0xFE, (byte) 0xFF), new ByteOrderMark(StandardCharsets.UTF_16LE, (byte) 0xFF, (byte) 0xFE) }; private final Charset charset; public BomInputStream(InputStream in) throws IOException { super(in, MAX_BOM_SIZE); this.charset = this.checkAndSkipBom(in); } Charset checkAndSkipBom(InputStream in) throws IOException { // if file without BOM mark, unread all bytes Charset encoding = StandardCharsets.UTF_8; int n, unread; byte[] bom = new byte[MAX_BOM_SIZE]; unread = n = in.read(bom, 0, bom.length); // for (ByteOrderMark mark : BOM_PREFIX_ARRAY) { boolean match = true; for (int i = 0; i &lt; mark.bytes.length; i++) { if (mark.bytes[i] != bom[i]) { match = false; break; } } if (match) { encoding = mark.charset; unread = n - mark.bytes.length; break; } } if (unread &gt; 0) this.unread(bom, (n - unread), unread); return encoding; } public Charset getBomCharset() { return this.charset; } static class ByteOrderMark { private final Charset charset; private final byte[] bytes; public ByteOrderMark(Charset charset, byte... bytes) { this.charset = charset; this.bytes = bytes; } }}snakeyaml假如你的项目中使用Spring Framework，那么使用yaml内置的UnicodeReader是一个不错的选择。支持UTF-16和UTF-8，不支持UTF-32的BOM头。 很多类库会提供UnicodeReader，UnicodeReader核心方法如下：12345678910111213141516171819202122232425262728protected void init() throws IOException { if (this.internalIn2 == null) { byte[] bom = new byte[3]; int n = this.internalIn.read(bom, 0, bom.length); Charset encoding; int unread; if (bom[0] == -17 &amp;&amp; bom[1] == -69 &amp;&amp; bom[2] == -65) { encoding = UTF8; unread = n - 3; } else if (bom[0] == -2 &amp;&amp; bom[1] == -1) { encoding = UTF16BE; unread = n - 2; } else if (bom[0] == -1 &amp;&amp; bom[1] == -2) { encoding = UTF16LE; unread = n - 2; } else { encoding = UTF8; unread = n; } if (unread &gt; 0) { this.internalIn.unread(bom, n - unread, unread); } CharsetDecoder decoder = encoding.newDecoder().onUnmappableCharacter(CodingErrorAction.REPORT); this.internalIn2 = new InputStreamReader(this.internalIn, decoder); }}Apache Commons-io使用BOMInputStream替代。核心加载方法如下：12345678910111213141516public int read(byte[] buf, int off, int len) throws IOException { int firstCount = 0; int b = 0; while(len &gt; 0 &amp;&amp; b &gt;= 0) { b = this.readFirstBytes(); if (b &gt;= 0) { buf[off++] = (byte)(b &amp; 255); --len; ++firstCount; } } int secondCount = this.in.read(buf, off, len); return secondCount &lt; 0 ? (firstCount &gt; 0 ? firstCount : -1) : firstCount + secondCount;}"
    } ,
  
    {
      "title"       : "详解Java的 GCRoot",
      "category"    : "",
      "tags"        : "JAVA, GCRoot",
      "url"         : "./java/gcroot/2022/10/12/JVM_GCRoot.html",
      "date"        : "2022-10-12 23:57:00 +0800",
      "description" : "",
      "content"     : "GCRoot是什么？GCRoot是Java实现精准式GC算法的基石。在了解GCRoot之前就必须对 GC、可达性分析、精准式GC的概念有所了解。GC是垃圾回收的简称。是Java对堆栈进行内存管理的重要手段。将开发者的内存管理权限收归Jvm统一托管，降低开发者维护内存的心智成本，提高开发进度，降低技术开发者的上手门槛。GC算法从提出方案到成为正式生产特性，不是一蹴而就的，完善的GC算法都是经历过长久的版本孵化、功能迭代和一些列的优化提案，并逐步的新增、暴露GC实现细节的用户自定义配置项，以便于用户去在一定范围内根据自身的实际业务需求进行调整，找到自身应用的GC和内存管理开销的平衡点。Jvm也会给GC算法提供一些列的缺省参数，简化用户的配置。精准式GC是指通过算法精准区别识别对象指针，精准区分垃圾和存活对象的GC算法。可达性分析算法是GC中用于快速区分垃圾的算法，而GCRoot是可达性分析的根节点，是算法的初始点。GCRoot有哪些？在OpenJDK的源码中搜索GC_ROOT。可以在Hprof工具相关的代码中查到 HeapHprofBinWriter， 列举9种类型GCRoot， 包含8种类型和未知类型(为了兼容其他JVM实现的Dump)，相关源码如下：12345678910111213141516public class HeapHprofBinWriter extends AbstractHeapGraphWriter { // hprof binary file header private static final String HPROF_HEADER_1_0_2 = \"JAVA PROFILE 1.0.2\"; // ..... private static final int HPROF_GC_ROOT_UNKNOWN = 0xFF; private static final int HPROF_GC_ROOT_JNI_GLOBAL = 0x01; private static final int HPROF_GC_ROOT_JNI_LOCAL = 0x02; private static final int HPROF_GC_ROOT_JAVA_FRAME = 0x03; private static final int HPROF_GC_ROOT_NATIVE_STACK = 0x04; private static final int HPROF_GC_ROOT_STICKY_CLASS = 0x05; private static final int HPROF_GC_ROOT_THREAD_BLOCK = 0x06; private static final int HPROF_GC_ROOT_MONITOR_USED = 0x07; private static final int HPROF_GC_ROOT_THREAD_OBJ = 0x08; // .....} Hprof 是Jvm堆内存快照文件. 通过jmap、jconsole等工具将内存快照保存下来，有助于开发中排查内存泄露等问题。源码中定义的Hprof版本标识为JAVA PROFILE 1.0.2，这个很重要，后续还会在提到。很多博客和文章中会提到Eclipse的内存分析工具Eclipse Memory Analyzer(MAT)，MAT的文档中描述的GCRoot的类型和OpenJDK中的不一致，多了6个枚举 (INTERNED_STRING、FINALIZING、DEBUGGER、REFERENCE_CLEANUP、VM_INTERNAL、JNI_MONITOR)。怎么会出现不一致的情况呢？多方查找资料，也没有得到很明确的解答，甚至可以说没有找到任何相关的回答，就好像全世界除了我没有人对此有疑问一样。一头莫展之际，灵光一闪的想到VisualVM这个堆dump分析工具。VisualVM的Commit解惑VisualVM 1.4.4是最后一个集成在JDK中的版本，支持JDK 1.8及以下版本。VisualVM 2.x支持JDK 1.8以上的版本。不再集成在JDK中，作为独立开源项目发布和使用。在历史提交记录的备注中查到端倪，OpenJDK和现行的JVM基本上都是遵循JAVA PROFILE 1.0.2规范，Android操作系统中使用的是Dalvik虚拟机遵循JAVA PROFILE 1.0.3。2.x版本支持Android的Dalvik虚拟机的内快照存堆Dump解析，VisualVM升级支持JAVA PROFILE 1.0.3并支持新增的6个GCRoot类型。 早期由于MAT和VisualVM等分析查看工具，不支持1.0.3规范，会使用hprof-conv input.hprof out.hprof将dump文件转换为1.0.2规范格式。以下截取VisualVM 2.1.4版本的GCRoot.java部分源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public interface GCRoot { //~ Static fields/initializers ----------------------------------------------------------------------------------------------- /** * JNI global GC root kind. */ public static final String JNI_GLOBAL = \"JNI global\"; // NOI18N /** * JNI local GC root kind. */ public static final String JNI_LOCAL = \"JNI local\"; // NOI18N /** * Java frame GC root kind. */ public static final String JAVA_FRAME = \"Java frame\"; // NOI18N /** * Native stack GC root kind. */ public static final String NATIVE_STACK = \"native stack\"; // NOI18N /** * Sticky class GC root kind. */ public static final String STICKY_CLASS = \"sticky class\"; // NOI18N /** * Thread block GC root kind. */ public static final String THREAD_BLOCK = \"thread block\"; // NOI18N /** * Monitor used GC root kind. */ public static final String MONITOR_USED = \"monitor used\"; // NOI18N /** * Thread object GC root kind. */ public static final String THREAD_OBJECT = \"thread object\"; // NOI18N /** * Unknown GC root kind. */ public static final String UNKNOWN = \"unknown\"; // NOI18N // ================================ // 以下为HPROF HEAP 1.0.3新增 // ================================ /** * Interned string GC root kind. */ public static final String INTERNED_STRING = \"interned string\"; // NOI18N /** * Finalizing GC root kind. */ public static final String FINALIZING = \"finalizing\"; // NOI18N /** * Debugger GC root kind. */ public static final String DEBUGGER = \"debugger\"; // NOI18N /** * Reference cleanup GC root kind. */ public static final String REFERENCE_CLEANUP = \"reference cleanup\"; // NOI18N /** * VM internal GC root kind. */ public static final String VM_INTERNAL = \"VM internal\"; // NOI18N /** * JNI monitor GC root kind. */ public static final String JNI_MONITOR = \"JNI monitor\"; // NOI18N}VisualVM GCRoot详解 GC Root 描述   JNI_GLOBAL native本地方法代码中的全局变量, JNI或者Jvm内部方法   JNI_LOCAL native本地方法代码中的本地变量, JNI或者Jvm内部方法   JAVA_FRAME Jvm虚拟机栈帧中引用对象。线程调用的方法参数，局部变量等等   NATIVE_STACK native本地方法栈中引用对象, JNI或者Jvm内部方法。文件/网络/IO相关的低层方法或反射   STICKY_CLASS bootstrap/system类加载器加载的类。例如：jr.jar中java.util包下类   THREAD_BLOCK An object that was referenced from an active thread block.   MONITOR_USED 调用wait()或notify()方法的对象，synchronized关键字监控的对象   THREAD_OBJ 调用start()启动之后未停止的线程对象   UNKNOWN 未知类型, 不同平台的Dump文件输出的信息可能会不同   INTERNED_STRING     FINALIZING     DEBUGGER     REFERENCE_CLEANUP     VM_INTERNAL     JNI_MONITOR     总结一下，JNI相关（本地/全局/引用变量）, 虚拟机相关（运行时的类对象，静态对象，常量池），线程相关（对象，栈帧，同步） 都可以作为GC Root。参考资料 Eclipse Memory Analyzer OpenJDK HprofReader Oracle Visualvm HPROF Agent hprof manual"
    } ,
  
    {
      "title"       : "浅谈跨站脚本攻击(XSS)那些事儿",
      "category"    : "",
      "tags"        : "JAVA, XSS, 跨站脚本攻击, CSP, OWASP",
      "url"         : "./java/xss/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/2022/10/09/XSS_Java.html",
      "date"        : "2022-10-09 10:16:00 +0800",
      "description" : "",
      "content"     : "随着互联网的高速发展，各种网络黑产的技术使用门槛也在逐步降低，这些年来，针对用户的个人信息被盗用，密码泄露等网络安全问题层出不穷，随着问题的暴露，人们对个人信息的安全问题愈发的重视。开发者不仅要面对传统的XSS，CSRF攻击手段，还要面对网络劫持，中间人攻击，非法调用API等等各种新型的攻击方式挑战。本文就浅谈Java服务端中XSS相关的那点事情。什么是XSS？跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。若受害者运行这些恶意代码，攻击者就可以突破网站的访问限制并冒充受害者。根据开放式 Web 应用安全项目（OWASP），XSS在2017年被认为7种最常见的Web应用程序漏洞之一。如果Web应用程序没有部署足够的安全验证，那么，这些攻击很容易成功。浏览器无法探测到这些恶意脚本是不可信的，所以，这些脚本可以任意读取 cookie，session tokens，或者其它敏感的网站信息，或者让恶意脚本重写HTML内容。XSS 攻击可以分为 3 类：存储型（持久型）、反射型（非持久型）、DOM 型。存储型 XSS一般是指注入恶意内容，且服务器由于没有过滤或拦截，导致恶意内容存储到数据库。再经由其他用户访问下发给其他访问的用户执行。例如：论天的聊天，微博的回复等等。存储型也是危害影响最严重的一种XSS反射型 XSS应用程序或 API 包括未经验证和未经转义的用户输入作为 HTML 输出的一部分。成功的攻击可以让攻击者在受害者的浏览器中执行任意 HTML 和 JavaScript。通常，用户需要与一些指向攻击者控制页面的恶意链接进行交互，例如论坛、微博评论，访问日志等。基于 DOM 的 XSS通过劫持或注入等手段修改原始的客户端代码(HTML, JavaScript, CSS, URL)，页面本身可能并没有变化，实际一串包含恶意的代码已经被意外执行。 相对来说，最难避免，同时也是危害相对较轻的一种XSSXSS检测1jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\\x3e更多更详细的使用这段 恶意代码 的攻击策略和演示，请查看 Unleashing-an-Ultimate-XSS-Polyglot。XSS预防反射型XSS和存储型XSS的预防主要是输入数据校验和HTML属性，HTML正文, Javascript，CSS，URL上下文的输出编码, 避免将不可信数据当作代码下发给浏览器，被浏览器错误的执行。详细的XSS防护规则总结 OWASP基于DOM的XSS预防主要是前端的一些防御措施 避免直接用 .innerHTML, .outerHTML, .write, .innerHTML, 使用 .innerText, .textContent和 element.setAttribute()(对部分属性(e.g. width, height, ref .etc)是安全的，对href，onclick等属性也是不安全的) 避免将不可信数据拼接字符串传入给那些能将字符串当代码执行的API。e.g. onlick, onload,eval(), setTimeout(), setInterval(), href.etc 避免不可信数据对对象属性的访问, 仅将不可信数据当作右值使用。例如：object[x] 避免直接使用eval()将json转换为javascript对象。使用JSON.toJSON()和JSON.paree() 使用安全沙箱执行JavaScript脚本目前主流的前端框架都针对XSS攻击有相关的防护和最佳实践文档, 例如：Vue.js 3.x, Angular JS。Java服务端相关在服务端方面，更多是针对反射型和存储型XSS的防护，主要由以下几个方面的内容。不可信数据的HTML编码使用编码库直接将不可信数据(e.g. url参数名/参数值，header，attributes .etc)进行编码检查。可以使用现有的一些第三方编码库Apache Commons Text, Apache Commons Lang3 StringEscapeUtils工具或者OWASP Java 编码器 等。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 使用common-lang3 3.7class XSSRequestWrapper extends HttpServletRequestWrapper { private Map&lt;String, String[]&gt; sanitizedQueryString; public XSSRequestWrapper(HttpServletRequest request) { super(request); } @Override public String getParameter(String name) { String parameter = null; String[] vals = getParameterMap().get(name); if (vals != null &amp;&amp; vals.length &gt; 0) { parameter = vals[0]; } return parameter; } @Override public String[] getParameterValues(String name) { return getParameterMap().get(name); } @Override public Enumeration&lt;String&gt; getParameterNames() { return Collections.enumeration(getParameterMap().keySet()); } @Override public Object getAttribute(String name) { Object value = super.getAttribute(name); if (value instanceof String) { return StringEscapeUtils.escapeHtml4((String) value); } return value; } @Override public String getHeader(String name) { String value = super.getHeader(name); return StringUtils.isBlank(value) ? value : StringEscapeUtils.escapeHtml4(value); } @Override public Map&lt;String, String[]&gt; getParameterMap() { if (sanitizedQueryString == null) { Map&lt;String, String[]&gt; originalQueryString = super.getParameterMap(); Map&lt;String, String[]&gt; res = new HashMap&lt;&gt;(); if (originalQueryString != null) { for (Map.Entry&lt;String, String[]&gt; entry : originalQueryString.entrySet()) { String[] values = null; if (entry.getValue().length == 1) { values = new String[]{StringEscapeUtils.escapeHtml4(entry.getValue()[0])}; } else { values = Arrays.stream(entry.getValue()).map(StringEscapeUtils::escapeHtml4).toArray(String[]::new); } res.put(StringEscapeUtils.escapeHtml4(entry.getKey()), values); } } sanitizedQueryString = res; } return sanitizedQueryString; }}启用内容安全策略(CSP)Content-Security-Policy是现代浏览器用来增强文档（或网页）安全性的 HTTP 响应标头的名称。Content-Security-Policy 标头允许您限制资源（如 JavaScript、CSS 或浏览器加载的几乎任何内容）的方式。实现Java Servlet的Filter给每个请求的Header追加CSP:123456789101112131415161718public class ContentSecurityPolicyFilter implements Filter { private static final String DEFAULT_CSP = \"default-src 'self' data: 'unsafe-inline' 'unsafe-eval';\" + \" frame-src 'none'; \" + \" object-src 'none'; \" + \" report-uri /status;\"; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (response instanceof HttpServletResponse) { String csp = ((HttpServletResponse) response).getHeader(HttpHeaderNames.CONTENT_SECURITY_POLICY.toString()); if (StringUtils.isBlank(csp)) { ((HttpServletResponse) response).setHeader(HttpHeaderNames.CONTENT_SECURITY_POLICY.toString(), DEFAULT_CSP); } } chain.doFilter(request, response); }}Google 提供的免费的在线CSP评估工具，针对你的CSP设置进行安全校验，建议和评估。CSP EvaluatorCookie反射型XSS一般都是盗取用户的Cookie，并伪造用户登录从而欺骗服务器窃取数据。现代浏览器基本上都支持设置Cookie的Http-Only属性，可以避免客户端访问cookie数据。启用Http-Only和Secure示例：1Set-Cookie: Secure; HttpOnly实现Java Servlet的Filter给响应设置Cookie配置。1234567891011@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (response instanceof HttpServletResponse hsr) { // set-cookie: Secure; HttpOnly String cookie = hsr.getHeader(HttpHeaderNames.SET_COOKIE.toString()); if (!cookie.contains(DEFAULT_COOKIE)) { hsr.setHeader(HttpHeaderNames.SET_COOKIE.toString(), cookie + DEFAULT_COOKIE); } } chain.doFilter(request, response);}也可以使用web.xml配置123456&lt;session-config&gt; &lt;cookie-config&gt; &lt;http-only&gt;true&lt;/http-only&gt; &lt;secure&gt;true&lt;/secure&gt; &lt;/cookie-config&gt;&lt;/session-config&gt;更详细的信息查看MDN HTTP Cookie不暴露非必要的服务针对攻击，最好的手段是物理隔绝，不和你玩了，免疫你全部攻击。在设计和架构上对于没有必要开放给用户的页面和端口等，可以使用服务剥离，防火墙等手段将风险隔绝在门外。引用参考 OWASP XSS OWASP DOM XSS"
    } ,
  
    {
      "title"       : "Windows 11 鼠标飘？有延迟？不跟手？",
      "category"    : "",
      "tags"        : "Windows 11, 鼠标飘, 鼠标不跟手, 鼠标响应延迟, 鼠标反应慢",
      "url"         : "./windows%2011/other/2022/10/08/Mouse_delay.html",
      "date"        : "2022-10-08 08:10:00 +0800",
      "description" : "",
      "content"     : "刚刚过去的国庆假期用投影仪当作电脑的外界显示屏，发现鼠标移动很明显有迟缓，响应慢，不跟手的情况，本贴记录一下解决的过程和最终的解决方案，以供参考。最初以为是鼠标的问题，但同一个鼠标在笔记本上又完全不会有这个问题，这种情况就显得很诡异，问题完全没有头绪，也无从查起。百度，Google“鼠标不跟手”等关键词，查到的回复基本上都是无效回答，都是在扯换鼠标，鼠标老化之类的。另外一方面鼠标不跟收，也没办法录像说明这种情况和问题，属于比较主观的感受。很痛苦连续好几天断断续续的一直没有很好的解决方案，也没有搜索到相关的问题。一直到4号，假期基本上过半的时候，无意中在一个不起眼的角落里看到小破站的一个视频，讲的是调整屏幕分辨率和刷新率，up主改善了鼠标响应延迟的视频。抱着死马当活马医的心态，跟着视频尝试了一下，调整为1080P分辨率，60HZ刷新率最终解决了鼠标不跟手的问题。很难联想到一个鼠标的响应延迟和不跟手是屏幕刷新率导致的。具体的原理基本上不可查。标注收藏一下。总结鼠标飘，反应慢，响应有延迟，不跟手，可以根据不同的显示设备(e.g. 投影仪 .etc)尝试调整一下 屏幕分辨率和屏幕刷新率。"
    } ,
  
    {
      "title"       : "详解Java的 StringTable",
      "category"    : "",
      "tags"        : "JAVA, StringTable",
      "url"         : "./java/stringtable/2022/10/05/JVM_StringTable.html",
      "date"        : "2022-10-05 10:16:00 +0800",
      "description" : "",
      "content"     : "字符表是由JVM中C++实现的HashTable结构（数组+链表）的字符串常量池，长度固定，不可扩容。数据结构如下图所示：Java 6的Jvm中StringTabele是分配在永久代中，不会被GC，从Java 7开始StringTable迁移到heap堆内存中，会触发GC，Java 8完全移除了永久代的概念，并用MetaSpace替代。StringTable的不同的实现方案的细微不同之处，参考String.intern()章节。StringTable源码解析上文提到StringTable是数组+单向链表的结构。本小节，我们看一下StringTable源代码的几个核心方法。OpenJDK StringTable 源码使用Handle string_or_null_h来摒弃GC导致字符串移动(对象地址变更)带来的问题。123456789101112131415161718192021222324252627282930313233343536373839404142oop StringTable::do_intern(Handle string_or_null_h, const jchar* name, int len, uintx hash, TRAPS) { HandleMark hm(THREAD); // cleanup strings created Handle string_h; if (!string_or_null_h.is_null()) { string_h = string_or_null_h; } else { string_h = java_lang_String::create_from_unicode(name, len, CHECK_NULL); } assert(java_lang_String::equals(string_h(), name, len), \"string must be properly initialized\"); assert(len == java_lang_String::length(string_h()), \"Must be same length\"); // Notify deduplication support that the string is being interned. A string // must never be deduplicated after it has been interned. Doing so interferes // with compiler optimizations done on e.g. interned string literals. if (StringDedup::is_enabled()) { StringDedup::notify_intern(string_h()); } StringTableLookupOop lookup(THREAD, hash, string_h); StringTableGet stg(THREAD); bool rehash_warning; do { // Callers have already looked up the String using the jchar* name, so just go to add. WeakHandle wh(_oop_storage, string_h); // The hash table takes ownership of the WeakHandle, even if it's not inserted. if (_local_table-&gt;insert(THREAD, lookup, wh, &amp;rehash_warning)) { update_needs_rehash(rehash_warning); return wh.resolve(); } // In case another thread did a concurrent add, return value already in the table. // This could fail if the String got gc'ed concurrently, so loop back until success. if (_local_table-&gt;get(THREAD, lookup, stg, &amp;rehash_warning)) { update_needs_rehash(rehash_warning); return stg.get_res_oop(); } } while(true);}由于无法动态扩容，所以当链表平均长度超过2时，会进行rehash，通过重新计算hash值让字符串分布更均匀。具体的源代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Rehashbool StringTable::do_rehash() { if (!_local_table-&gt;is_safepoint_safe()) { return false; } // We use current size, not max size. size_t new_size = _local_table-&gt;get_size_log2(Thread::current()); StringTableHash* new_table = new StringTableHash(new_size, END_SIZE, REHASH_LEN, true); // Use alt hash from now on _alt_hash = true; if (!_local_table-&gt;try_move_nodes_to(Thread::current(), new_table)) { _alt_hash = false; delete new_table; return false; } // free old table delete _local_table; _local_table = new_table; return true;}void StringTable::rehash_table() { static bool rehashed = false; log_debug(stringtable)(\"Table imbalanced, rehashing called.\"); // Grow instead of rehash. if (get_load_factor() &gt; PREF_AVG_LIST_LEN &amp;&amp; !_local_table-&gt;is_max_size_reached()) { log_debug(stringtable)(\"Choosing growing over rehashing.\"); trigger_concurrent_work(); _needs_rehashing = false; return; } // Already rehashed. if (rehashed) { log_warning(stringtable)(\"Rehashing already done, still long lists.\"); trigger_concurrent_work(); _needs_rehashing = false; return; } _alt_hash_seed = AltHashing::compute_seed(); { if (do_rehash()) { rehashed = true; } else { log_info(stringtable)(\"Resizes in progress rehashing skipped.\"); } } _needs_rehashing = false;}这个时候有同学可能就会问了，为什么采用rehash的方式而不是像HashMap一样转为红黑树呢？首先红黑树是理论上上性能最优解，完全可以通过合理规划和使用，避免HashTable性能退化到这个地步，StringTable的设计初衷也是这样的。对于一般的情况，rehash已经可以满足对性能的要求。第三点，维护链表和红黑树互转的业务代码较过于复杂，维护成本更高，没有必要。String.intern()方法Java的String有一个名为 intern() 的公共方法，用户可以通过调用此方法主动将字符串添加到StringTable中。当调用intern方法时，首先检查StringTable中是否已经存在，已经存在则直接返回StringTable中的引用。当StringTable中不存在时, 实现方案会有些许不同。Java 6，不存在时，将字符串复制一份，插入到StringTable中Java 7及后续的版本，不存在时，将当前字符串的引用，插入到StringTable中。举个栗子🌰：1234var var0 = new String(\"hello \") + new String(\"world\");String intern = var0.intern();var var1 = \"hello world\";assert intern == var1; // Java 6不相同123var var0 = new String(\"hello \") + new String(\"world\");var var1 = \"hello world\";assert var0.intern() == var1;两段相同的代码在不同的JDK版本中执行，结果会有有些许的不同。Java 8可以正常执行，但是Java 6会抛出断言错误异常。其他风险及注意事项合理的规划和使用intern可以减少堆内存的使用，合理的使用可以显著的提高内存的利用率。与之相对的，滥用或者错误的使用intern()方法，由于StringTable的桶数量固定，当数据远远超过桶的数量时（2-3倍以上），导致链表的长度过长，查询效率退化为O(n)，最终反而影响程序的执行性能。线上事故案例分享: 前两年同事开发的一个项目，数据写入DB之前，会用到jackson进行序列化转为json字符串，用户的唯一ID做为json的字段名使用。问题的发现过程也比较简单，上线之后这个进程不定期的隔几天时间就会出现频繁的Full GC，再发展就会发生OOM并宕机。jmap把内存dump下来之后发现字符串数量明显异常，经过一系列的排查，最终定位为大量的用户唯一ID字符串在内存中没有被GC掉。在深入的排查发现是jackson库的默认启用intern对象的字段名。数以千万计的用户唯一ID，再内存中无法被GC掉，至此也就破案了。常见的json框架(e.g. jsckson, fastjson .etc)都会默认开启并使用intern方法，利用此特性对json对象的字段名进行常量化管理，减少内存占用，提高内存利用率。但是基本上都或多或少的出现过导致内存泄露的案例。使用前需要谨慎评估，是否业务场景可以用intern方法？依赖的第三方库是否有默认使用？。例如：国家名，地区名，类对象字段名称等重复使用率高的字符，完全可以使用intern来避免每个用户单独占用内存。 Jackson: JsonParser.Feature.INTERN_FIELD_NAMESFastjson: Feature.InternFieldNamesJVM 启动参数-XX:StringTableSize=65536通过修改启动参数可以调整字符表桶数量。JDK 11之后hashtable的数组长度缺省值为65535，之前版本的JVM默认值为60013，有些更老的版本时1009.-XX:+PrintStringTableStatistics 打印字符表统计信息, 帮助排查问题。线上环境不建议开启123456789101112131415161718SymbolTable statistics:Number of buckets : 32768 = 262144 bytes, each 8Number of entries : 129215 = 2067440 bytes, each 16Number of literals : 129215 = 7173248 bytes, avg 55.514Total footprsize_t : = 9502832 bytesAverage bucket size : 3.943Variance of bucket size : 3.990Std. dev. of bucket size: 1.998Maximum bucket size : 14StringTable statistics:Number of buckets : 65536 = 524288 bytes, each 8Number of entries : 23470 = 375520 bytes, each 16Number of literals : 23470 = 2157736 bytes, avg 91.936Total footprsize_t : = 3057544 bytesAverage bucket size : 0.358Variance of bucket size : 0.361Std. dev. of bucket size: 0.601Maximum bucket size : 5-XX:+UseStringDeduplicationG1GC引入的一个减少重复字符串的垃圾回收特性。Shenandoah GC于JDK 11支持。截至JDK 17 LTS发布，ZGC仍不支持此特性(JDK 18开始支持)。-XX:StringDeduplicationAgeThreshold=3. 默认经历3次GC，字符串将被纳入去重的候选对象。设置过大可能会导致YGC时间增长。还有一系列相关的参数： -XX:StringDeduplicationTargetTableLoad=7.000000 -XX:StringDeduplicationShrinkTableLoad=1.000000 -XX:-StringDeduplicationResizeALot -XX:StringDeduplicationInitialTableSize=500 -XX:StringDeduplicationHashSeed=0 -XX:StringDeduplicationGrowTableLoad=14.000000 -XX:StringDeduplicationCleanupDeadPercent=5 -XX:StringDeduplicationCleanupDeadMinimum=100-XX:+CompactStrings默认开启压缩字符串. 当字符串能够使用latin-1(ISO-8859-1)编码描述时，优先使用latin-1(ISO-8859-1)编码。相比于UTF-16编码，节省50%内存。 与此同时，由于内存占用的减少，字符串拼接，字符串复制等等方面也有显著的性能提升(复制的数据少)。-XX:+OptimizeStringConcat默认开启优化字符串串联连接操作。编译阶段优化字符串的串联方式，精简优化生成的字节码。参考资料 VM Options Explorer - Oracle JDK17 Performance evaluation of Java garbage collectors for large heap transaction based applications 深入浅出 String.intern () 深入解析String#intern"
    } ,
  
    {
      "title"       : "详解Java的record关键字",
      "category"    : "",
      "tags"        : "Java, record",
      "url"         : "./java/record/2022/09/29/JVM_Record.html",
      "date"        : "2022-09-29 12:10:00 +0800",
      "description" : "",
      "content"     : "record关键字record关键字主要提供了更简洁、更紧凑的final修饰的不可变数据类的定义方式。可以用于数据传输，并发编程等领域。该特性最早于Java 14引入开始孵化，经历两次孵化，最终于Java 16转为正式特性。使用方法及示例在Java日常开发中，当我们需要定义个不可变数据类对象用于数据传输，并发编程等途径时。通常写法如下代码块所示.以下示例代码块为了突显class和record的getter方法命名规则的差异，故意修改等效于record的x()和y()方法. 常规的getter方法命名方式应该为getX()和getY()123456789101112131415161718192021222324252627282930313233343536373839public final class Point { private final int x; private final int y; public Point(int x, int y) { this.x = x; this.y = y; } public int x() { return x; } public int y() { return y; } @Override public String toString() { return \"Point{\" + \"x=\" + x + \", y=\" + y + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Point point = (Point) o; return x == point.x &amp;&amp; y == point.y; } @Override public int hashCode() { return Objects.hash(x, y); }}使用record实现上面等同效果仅需简单的一行即可。12public record PointR(int x, int y) {}通过简单的对比，我们可以得知，record相当于节省了以下几个方面的代码。 全参数的构造函数 getter方法 hashCode和equals方法 toString方法 final修饰的类定义静态属性字段，静态方法、类方法和属性字段注解record内部 不允许 定义非静态属性字段. 除此之外，和class的用法基本上没有区别。123456789101112131415161718192021public record PointR(@Nullable int x, int y) { /** * 1. 定义静态属性字段 */ private static int z = 1; /** * 2. 定义静态方法 */ public static int distance(PointR o, PointR o1) { return 0; } /** * 3. 定义方法 */ public int distance(PointR o) { return 0; }}实现接口record关键字隐式继承Record类，所以 不允许 在使用 extends 继承其他类。和class一样是单根继承，多接口实现。12345678// 扩展实现其他接口public record PointR(int x, int y) implements Comparable&lt;PointR&gt; { @Override public int compareTo(PointR o) { return 0; }}泛型12345678// Record使用泛型public record PointR&lt;R extends Serializable&gt;(int x, int y, R r) { public static void main(String[] args) { // 测试 PointR&lt;ArrayList&lt;Integer&gt;&gt; pointR = new PointR&lt;&gt;(1, 2, new ArrayList&lt;Integer&gt;()); }}浅拷贝record和class一样，实现Cloneable接口后，针对引用类型都是默认浅拷贝. 在并发环境时，需要考虑是否会受到浅拷贝影响。12345678public record PointR(int x, int y) implements Cloneable { @Override protected Object clone() throws CloneNotSupportedException { // 并发环境时，需要考虑是否会受到浅拷贝影响 return super.clone(); }}反射相比于class的反射获取属性字段信息方式, record的反射有了颠覆性的变动，我个人感觉是更加简单和直观。可以通过Class定义的geRecordComponents()方法获取record字段的record组件数组，顺序等同于record构造函数中定义的顺序。1RecordComponent[] recordComponents = PointR.class.getRecordComponents();获取字段类型Class对象中新增 isRecord() 方法用于区分类是否是record类.1PointR.class.isRecord()其他常用的反射相关的方法基本上类似于Field。例如：RecordComponent#getType() 反射获取属性字段的类型, RecordComponent#getAnnotation() 反射获取属性字段的注解123456RecordComponent[] recordComponents = PointR.class.getRecordComponents();for (RecordComponent rc : recordComponents) { Assertions.assertEquals(int.class, rc.getType()); rc.getAnnotation(Nullable.class)}"
    } ,
  
    {
      "title"       : "详解Java的 安全点(SafePoint)",
      "category"    : "",
      "tags"        : "JAVA, SafePoint",
      "url"         : "./java/safepoint/2022/09/22/JVM_SafePoint.html",
      "date"        : "2022-09-22 10:16:00 +0800",
      "description" : "",
      "content"     : "在Java虚拟机（JVM）的运行过程中，有些操作需要保证所有线程都到达一个安全点（SafePoint）后才能进行。SafePoint通常指一组位置，在这些位置处所有线程都处于安全状态，即没有正在执行不可中断的代码（如native方法、VM内部代码等），也没有锁定任何对象。如果JVM要执行需要等待SafePoint的操作，但某个线程没有到达SafePoint，那么JVM就要等待这个线程到达SafePoint，然后再继续执行所需操作。因此，SafePoint对Java应用程序的性能有很大的影响，特别是当应用程序有大量线程时。SafePoint的类型在Java虚拟机中，有多种类型的SafePoint：Polling SafePointPolling SafePoint是一种最常见的类型，它通常在循环体中使用，并且可以被打断。当一个线程到达一个Polling SafePoint时，它会检查是否有新的任务或者消息需要处理。如果没有，则线程会继续执行下一个任务或者等待新的任务或消息。12345678public void run() { while (true) { // Polling SafePoint if (shouldProcessTask()) { processTask(); } }}Deoptimization SafePointDeoptimization SafePoint是一种比较特殊的SafePoint，它通常用于当JVM需要回滚一些已经做出的优化决策时。例如，如果JVM在某个方法的调用点做了内联处理，但后来发现这种内联处理导致了错误，那么JVM就需要回滚这个决策，将该方法的调用点还原为正常的方法调用。此时，JVM会等待所有线程都到达一个Deoptimization SafePoint，以确保回滚操作是安全的。Safepoint for GC当JVM启动垃圾回收时，它需要等待所有线程都到达一个Safepoint，以确保垃圾回收操作是安全的。在GC过程中，JVM需要暂停所有运行中的线程，然后才能执行垃圾回收操作。因此，Safepoint for GC可以看作是一种特殊的Polling SafePoint。常见的SafePoint操作在Java虚拟机中，有一些常见的操作需要等待SafePoint： 类加载和卸载当Java虚拟机需要加载或卸载某个类时，它需要等待所有线程都到达一个SafePoint。这是因为，在类加载或卸载的过程中，Java虚拟机需要修改ClassLoader相关的数据结构，这可能会影响到其他线程的代码执行。因此，必须确保所有线程都处于安全状态，才能进行这些操作。 JIT编译器Java虚拟机中的Just-In-Time（JIT）编译器通常在运行时将Java字节码编译成本地机器码。这种编译过程需要等待所有线程都到达一个SafePoint，以确保编译过程不会影响到其他线程的代码执行。在编译过程中，JIT编译器需要访问Java虚拟机的内部数据结构，这可能会影响到其他线程的代码执行。 垃圾回收在Java虚拟机中，垃圾回收是一项非常重要的操作。垃圾回收器需要暂停所有运行中的线程，然后才能执行垃圾回收操作。在垃圾回收操作期间，Java虚拟机需要修改对象引用关系，这可能会导致其他线程的代码执行出现问题。因此，在执行垃圾回收之前，必须确保所有线程都到达了一个SafePoint。如何优化SafePoint由于SafePoint对Java应用程序的性能有很大的影响，因此需要进行一些优化以改善性能。下面是一些常见的优化方法： 调整SafePoint间隔时间在JVM中，可以通过设置-XX:PollingPageInterval参数来调整Polling SafePoint的时间间隔。默认情况下，该参数的值为1ms。如果将其设为更高的值，可以减少SafePoint检查的频率，从而提高应用程序的吞吐量。但是，这样做也会增加某些操作（如类加载和卸载）的等待时间。 避免过多使用native方法在Java虚拟机中，native方法通常是无法被JIT编译器优化的，因此会导致频繁的SafePoint检测。如果应用程序过多地使用native方法，就会降低应用程序的性能。因此，应该尽量避免过多地使用native方法，除非必要。 使用适当的锁策略在Java应用程序中，锁是非常重要的同步机制。不同的锁策略对SafePoint检测的影响也不同。例如，如果使用synchronized关键字来实现锁，则会阻塞所有线程，直到获取到锁的线程释放锁为止。这会导致所有线程都在等待SafePoint，从而降低应用程序的性能。因此，应该使用适当的锁策略来避免这种情况的发生。 使用并发数据结构在Java应用程序中，使用并发数据结构可以避免锁定整个数据结构，从而减少等待SafePoint的时间。例如，ConcurrentHashMap就是一种高效的并发数据结构，它可以在多线程同时访问时保持高性能。总结SafePoint是Java虚拟机中的一个重要概念，它对Java应用程序的性能有很大的影响。在Java应用程序中，有一些操作需要等待SafePoint，例如类加载、JIT编译器、垃圾回收等。为了优化应用程序的性能，可以采取一些措施，如调整SafePoint间隔时间、避免过多使用native方法、使用适当的锁策略和使用并发数据结构等。"
    } ,
  
    {
      "title"       : "JVM全知道系列 -XX:+UseCompressedOops 压缩指针",
      "category"    : "",
      "tags"        : "JAVA, JVM, UseCompressedOops, 压缩指针",
      "url"         : "./java/jvm/2022/04/24/JVM_CompressedOops.html",
      "date"        : "2022-04-24 14:13:00 +0800",
      "description" : "",
      "content"     : "-XX:+UseCompressedOops 使用压缩指向普通对象的指针. Oracle Java SE 7缺省情况下，JVM最大堆小于32GB时，默认启用压缩指针. 查看详细参数 JDK 17 LTS JVM Options压缩指针的好处在JDK 1.6u23引入压缩指针，让32位JDK支持超过4GB的堆空间。有效减少64位平台的堆内存占用（有利于降低GC开销. e.g. 主要是类压缩指针）。提高CPU缓存命中率（能缓存更多的普通对象指针）。核心探秘JAVA对象模型JAVA的对象由对象头、实例数据和对齐填充三部分组成。对象头一般包含Mark Word和Klass Word两个指针，数组的对象头会额外多一个4byte的数组长度。Mark Word根据平台固定为4~8byte，Klass Word类元数据指针，指向元数据空间Metaspace对齐填充是根据平台(32或64位)对未对齐的数据4或8byte补齐，进行补0启用压缩指针启用压缩指针之后，指针表示的含义从真实的地址偏移转换为基于对齐填充的对象偏移。这样4byte(32位)指针就可以映射管理40e(2^32^-1))对象或32GB(8byte * 2^32^=32GB)的堆空间。超过32GB的堆可以通过通过 -XX:ObjectAlignmentInBytes=alignment 修改对象对齐来支持。最大堆空间 = 4GB(2^32^-1) * ObjectAlignmentInBytes。GC算法中的应用截至目前为止，除了ZGC算法外，其他全部GC算法都支持Compressed OOP(e.g. G1, Shenandoah GCJEP-404. etc)。ZGC因为着色指针(Colored Pointers)的设计先天 不支持32位平台，不支持压缩指针优化，也无法单独开启类压缩指针。但是从 JDK 15 开始，-XX:+UseCompressedClassPointers 可以脱离 -XX:+UseCompressedOops 之外，单独开启。这种变动对使用ZGC垃圾回收算法或者堆大于32GB的JVM有比较大的意义，当然还是不支持Compressed OOP。"
    } ,
  
    {
      "title"       : "梳理JDK 17中GC垃圾回收器",
      "category"    : "",
      "tags"        : "JDK17, JAVA, GC, 垃圾回收器, ZGC, Shenandoah GC",
      "url"         : "./java/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/2022/04/22/JDK17_GC.html",
      "date"        : "2022-04-22 18:09:00 +0800",
      "description" : "",
      "content"     : "JDK 17 LTS版本中GC算法梳理。 Shenandoah和ZGC的目前都已经实现了对应的分代算法，相信不久的JDK版本中会逐步的入准。"
    } ,
  
    {
      "title"       : "逆向实验室 - 实战进阶Frida进程注入框架",
      "category"    : "",
      "tags"        : "Apk, Cocos Creater, Frida, 逆向工程",
      "url"         : "./apk/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/2022/03/16/Frida.html",
      "date"        : "2022-03-16 15:09:00 +0800",
      "description" : "",
      "content"     : "逆向进阶工具Frida，当加密的资源使用 自研加密算法 时，很多时候并不能通过简单的观察推到解密算法。这个时候就可以通过Frida注入， Hook解密函数，最终提取解密密钥。再通过 Ghidra 或者 IDA 逆向算法。下载安装 Frida安装frida-serverFrida - Github发布地址通过adb获取模拟器、手机的CPU ABI信息。12345adb shell \"getprop |grep cpu\"# [ro.product.cpu.abi]: [arm64-v8a]# 连接mumu模拟器adb connect 127.0.0.1:7555根据 arm64 下载对应的Frida-server包。mumu模拟器使用 frida-server-15.1.17-android-x86.xz，其他品牌的模拟器大概率也是x86架构。12345678# frida-server推送到/data/local/tmp目录adb push frida-server-15.1.17-android-x86 /data/local/tmp# 进入目录启动frida-serveradb shell \"chmod 777 /data/local/tmp/frida-server-15.1.17-android-x86 | /data/local/tmp/frida-server-15.1.17-android-x86 &amp;\"# root@BLA-AL00:/ # cd /data/local/tmp/# root@BLA-AL00:/data/local/tmp # chmod 777 frida-server-15.1.17-android-x86# ./frida-server-15.1.17-android-x86安装 frida-CLI本地安装1pip install frida frida-tools开始逆向TODO：参考资料 安卓爬虫逆向 frida+jadx+mumu模拟器 方案总结 Frida详细安装教程 FRIDA-API使用篇"
    } ,
  
    {
      "title"       : "逆向实验室 - 处理Cocos Creater打包的Apk",
      "category"    : "",
      "tags"        : "Apk, Cocos Creater, 逆向工程",
      "url"         : "./apk/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/2022/03/16/Cocos_Creater_Apk_Reverse.html",
      "date"        : "2022-03-16 15:09:00 +0800",
      "description" : "",
      "content"     : "逆向提取安卓的apk包里面的资源。本期主要处理cocos creater发布的apk包, 默认使用xxtea算法进行加密/解密.VSCode安装 Hex Editor 插件.打开文件 libcocos2djs.so , 搜索关键字 jsb-adapter获取到加密的密钥 f1Ex2F3aHyuxXYUI, 使用密钥和xxtea算法进行解密即可.成功解密js文件。下一步尝试解密资源文件（e.g. *.png, *.mp3）。然后失败了，大概率是加密的密钥和jsc文件不相同。打开资源文件查看，发现加密方式和jsc明显不同，都有一个未加密混淆的前缀字符串 encrypt_zy_。同理，通过 libcocos2djs.so 获取到资源文件的加密密钥 8bPxY2BENM73vWBP,使用xxtea解密。"
    } ,
  
    {
      "title"       : "升级GitHub Pages构建的博客系统",
      "category"    : "",
      "tags"        : "GitHub, Blog",
      "url"         : "./github/blog/2021/12/28/Upgrade_GitHub_Pages_4_2_Jekyll.html",
      "date"        : "2021-12-28 12:10:00 +0800",
      "description" : "",
      "content"     : "距离上一次升级 GitHub Pages 过去好久了。 老博客系统还停留在 Jekyll 3.2 + disqus 的阶段, 主题也比较老，很多东西不是很兼容现代的浏览器. 部分页面出现一些奇怪情况.最近刚好比较空，抽空换个主题，扩展一下博客的功能。规划列一下最近的进展和未来准备实现的项。一部分已经完成，另外一部分还在整理和改造。规划和完成进度情况: 升级 Jekyll 版本. 3.2 -&gt; 4.2 支持 GitHub Issue 评论系统. Disqus 国内网络访问堪忧 美化语法高亮插件的样式. 修复 rouge 高亮针对 单引号的-常排版. 支持图片点击放大缩小. 美化高清图的显示 捐助功 能. 低优先级 集成 GitHub Action. 一键解决提交、编译、发布流程. 适配移动设备. 主题兼容智能手机或者 pad 的屏幕尺寸. 支持浅色、暗色模式. 主题支持. 支持 mermaid 语言的图表绘制. 支持本地化. 支持中文和英文的页面. 主题支持 其他主题提供的功能. e.g. SEO, 归档等等"
    } ,
  
    {
      "title"       : "GitHob Desktop设置Git代理, 绕过GTW",
      "category"    : "",
      "tags"        : "DevOps, Git",
      "url"         : "./devops/2021/12/20/Github_Desktop_Set_Git_Proxy.html",
      "date"        : "2021-12-20 18:13:00 +0800",
      "description" : "",
      "content"     : "目录1. 前置条件先准备一个 vpn 代理。假如 没有代理 的请直接无视。 可以考虑赛风，自由门等老牌免费科技，也可以选择其他付费科技。或者修改 hosts2. 设置 Git 代理GitHub Desktop 是 GitHub 官方提供的仓库访问 gui 工具。虽然相比于其他来拍工具能力略显不足，但是访问 GitHub 支持的比价好，也就勉强用着。但是从 2021 年开始国内政策审查日益加剧，经常出现无法 push 等奇怪的网络问题。随缘式的网络，让人心碎。于是，决定设置一下代理。 再 c 盘的 user 目录下找到.gitconfig 文件 添加 http、https、git 三个设置为代理地址.123456[http] proxy = socks5://127.0.0.1:1080[https] proxy = socks5://127.0.0.1:1080[git] proxy = socks5://127.0.0.1:10803. 指定仓库生效当不需要全局生效，仅某些特定的仓库指定生效代理提交时，可以通过修改仓库根目录的 .git 目录下 config 文件，指定特定仓库生效代理配置。"
    } ,
  
    {
      "title"       : "常见Linux工具 - Cut",
      "category"    : "",
      "tags"        : "DevOps, Linux",
      "url"         : "./devops/2021/12/20/Linux_Cut_Commond.html",
      "date"        : "2021-12-20 11:22:00 +0800",
      "description" : "",
      "content"     : "`Cut`是一个强大的字符串处理工具.Cut Command Document TOC1. `-b`和`-c`获取列表参数中的字节、字符默认使用`TAB`进行位置偏移（LIST）选取某个位置的字符. echo “Hello World!” | cut -c 2 =&gt; `e`选取位置范围的字符. echo “Hello World!” | cut -c 1-5 =&gt; `Hello`2. `-d` 使用分隔符替代`TAB`对字符进行拆分定位根据某个分隔符拆分并打印. echo ‘Hello World!’ | cut -d ‘ ‘ -f2 =&gt; `World!`3. `-f` 获取根据字段，域配合`-d`有奇效. 最常见的应用常见之一.4. `–complement`排除选择的内容 echo ‘Hello World!’ | cut -d ‘ ‘ -f2 =&gt; `Hello`5. `–only-delimited` 是否`仅`打印带分隔符的行分隔符不存的行. echo ‘Hello World!’ | cut -d ‘x’ -f2 =&gt; ``分隔符存在的行. echo ‘Hello World!’ | cut -d ‘ ‘ -f2 =&gt; `Hello`6. `–output-delimiter`替换输出的分隔符分隔符不存的行. echo ‘Hello World!’ | cut -d ‘ ‘ –output-delimiter=’ and ‘ -f-2 =&gt; `Hello and World!`"
    } ,
  
    {
      "title"       : "一张图搞定Java常见日志框架适配",
      "category"    : "",
      "tags"        : "Java",
      "url"         : "./java/2021/12/14/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9AJava%E5%B8%B8%E8%A7%81%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E9%80%82%E9%85%8D.html",
      "date"        : "2021-12-14 15:19:00 +0800",
      "description" : "",
      "content"     : "一张图搞定 Java 常见日志框架适配Java 日志和日志外观框架、方案众多。解决各日志 Facade 和日志实现库的适配兼容关系也非常复杂。本文一张图帮你熟悉常见日志中间件的适配。"
    } ,
  
    {
      "title"       : "enhancement support mermaid language code block",
      "category"    : "opinion",
      "tags"        : "copyright, creativity, neural networks, machine learning, artificial intelligence",
      "url"         : "./opinion/2021/04/20/support-mermaid.html",
      "date"        : "2021-04-20 00:00:00 +0800",
      "description" : "enhancement support mermaid language code block",
      "content"     : "新增mermaid语法代码块渲染支持flowchart TD A[Start] --&gt; B{Is it?}; B -- Yes --&gt; C[OK]; C --&gt; D[Rethink]; D --&gt; B; B -- No ----&gt; E[End];sequenceDiagram Alice-&gt;&gt;+John: Hello John, how are you? Alice-&gt;&gt;+John: John, can you hear me? John--&gt;&gt;-Alice: Hi Alice, I can hear you! John--&gt;&gt;-Alice: I feel great!"
    } ,
  
    {
      "title"       : "DevOps - Java代码增量覆盖率工具",
      "category"    : "",
      "tags"        : "DevOps",
      "url"         : "./devops/2019/10/03/java_code_coverage_with_jenkins.html",
      "date"        : "2019-10-03 22:15:00 +0800",
      "description" : "",
      "content"     : "相比于全量代码单元测试覆盖率，增量代码单元测试覆盖率，粒度更小，可以帮助开发者精准的了解每个新特性、新功能甚至每次 Commit 的代码覆盖率。目录 前言 1. Codecov 2. “定制”测试覆盖率工具 2.1. 使用 JGit 进行代码差异分析 2.2. 根据差异统计代码覆盖率变化 3. 集成到 Jenkins 3.1. 配置单元测试覆盖率插件 3.2. 覆盖率报告图表解析 4. 总结前言今年开始，部门将代码的单元测试覆盖率纳入 KPI 考核范围。领导定了两个考核指标，一个是整个工程的单元测试覆盖率，另外一个是，每个特性需求的增量测试覆盖率。1. CodecovCodecov是一个代码覆盖率分析网站，旨在通过各个维度和检测指标帮助开发者开发更加健壮的程序。 粒度细。全量代码覆盖率报告，针对每个 Commit，每个文件的有相对、绝对、增量覆盖率 对 GitHub 开源项目免费。对 GitHub 工作流非常友好。集成非常方便。 支持的测试覆盖率工具多。支持的报告种类多。分析报告非常的详细，针对开源项目而言是不可多得的工具。假如你的项目是开源项目或者能使用此类第三方覆盖率检查报告的话？ 本文的后续内容对您没有任何帮助，可以直接忽略2. “定制”测试覆盖率工具公司的老项目，不太方便开源。so 没办法享受“免费”的午餐。搜索 Jenkins 的测试覆盖率工具。对比如下：   -Codecov- -JaCoCo Plugin- -Code-coverage-api- 价格 开源项目免费 免费 免费 全量代码覆盖率 ✔ ✔ ✔ 代码健康度告警 ✔ ✔ ✔ 代码覆盖率变化趋势 ✔ ✔ ✔ 支持的报告种类 非常多 仅 JaCoCo 少 粒度 代码行 代码行 代码行 增量代码覆盖率 ✖ ✖ ✖ 扩展性 非常强 仅 Java 可扩展 最后选择 code-coverage-api-plugin 的，基于此插件扩展增量覆盖率的功能。由于新增了依赖，且功能依赖于 Git 作为版本控制工具，所以此特性被拒绝合并。对此我感到遗憾。所以 fork 了原仓库的代码，独立发布了此特性功能。言归正传，下面开始干货2.1. 使用 JGit 进行代码差异分析要统计本次提交的增量覆盖率首先要能分析代码的增量变化。我们项目使用的时 Git 作为版本控制，Git 提供了 diff 工具，可以对比文件的变化。详细参考”git diff”。在此不赘述。根据 git diff 的结果进行差异分析。代码如下：123456789101112131415161718192021222324252627282930313233343536try (Git git = Git.open(new File(gitRepoPath))) { Stream&lt;DiffEntry&gt; stream = getDifferentBetweenTwoCommit(git, oldCommit, newCommit); if (null == stream) return null; try (ByteArrayOutputStream out = new ByteArrayOutputStream()) { DiffFormatter df = new DiffFormatter(out); // ignores all whitespace df.setDiffComparator(RawTextComparator.WS_IGNORE_ALL); df.setRepository(git.getRepository()); List&lt;SourceCodeFile&gt; map = stream.map(diffEntry -&gt; { try { FileHeader header = df.toFileHeader(diffEntry); // analysis new add code block. List&lt;SourceCodeBlock&gt; list = header.getHunks().stream() .flatMap((Function&lt;HunkHeader, Stream&lt;Edit&gt;&gt;) hunk -&gt; hunk.toEditList().stream()) .filter(edit -&gt; edit.getEndB() - edit.getBeginB() &gt; 0) .map(edit -&gt; SourceCodeBlock.of(edit.getBeginB(), edit.getEndB())) .collect(Collectors.toList()); if (list.isEmpty()) return null; return new SourceCodeFile(diffEntry.getNewPath(), list); } catch (Exception e) { throw new RuntimeException(e); } finally { out.reset(); } }) .filter(Objects::nonNull) .collect(Collectors.toList()); CACHE_MAP.put(cacheKey, map); return map; }} catch (Exception e) { throw new RuntimeException(e);}2.2. 根据差异统计代码覆盖率变化根据差异和当前 JaCoCo 报告做交叉对比。统计出增量代码覆盖率变化。代码如下：12345678910111213141516171819202122232425262728293031323334List&lt;CoverageRelativeResultElement&gt; list = report.getChildrenResults() .parallelStream() .filter(cr -&gt; CoverageElement.FILE.equals(cr.getElement())) .filter(cr -&gt; cr.getPaint() != null) .map(cr -&gt; scbInfo.stream() .filter(p -&gt; p.getPath().endsWith(cr.getRelativeSourcePath())) .limit(1) .findAny() .map(scf -&gt; { int[] lines = scf.getBlocks() .stream() .flatMapToInt(block -&gt; IntStream.rangeClosed((int) (block.getStartLine() + 1), (int) block.getEndLine()) .filter(line -&gt; cr.getPaint().isPainted(line)) ).toArray(); // absolute coverage Map&lt;CoverageElement, Ratio&gt; results = new TreeMap&lt;&gt;(); Ratio crHitRatio = analysisLogicHitCoverage(cr.getPaint(), level, cr.getPaint().lines.keys()); results.put(CoverageElement.ABSOLUTE, crHitRatio); // newly code coverage results.put(CoverageElement.RELATIVE, analysisLogicHitCoverage(cr.getPaint(), level, lines)); // coverage change CoverageResult pr = cr.getPreviousResult(); if (pr != null) { Ratio prHitRatio = analysisLogicHitCoverage(pr.getPaint(), level, pr.getPaint().lines.keys()); if (prHitRatio.numerator != 0.0F) { results.put(CoverageElement.CHANGE, Ratio.create(crHitRatio.getPercentageFloat() - prHitRatio.getPercentageFloat(), 100.0F)); } } return new CoverageRelativeResultElement(cr.getName(), cr.getRelativeSourcePath(), results); }) .orElse(null) ) .filter(Objects::nonNull) .collect(Collectors.toList());3. 集成到 Jenkinscheckout 源码。编译打包生成 hpi 安装包。或者使用 release 版本code-coverage-api.hpi在 Jenkins 中安装本地插件，选择下载的 hpi 安装包。3.1. 配置单元测试覆盖率插件Step 1: 新增 Jacoco 报告分析工具覆盖率报告文件路径配置为jacoco生成的xml报告的路径.Step 2：点开”高级”. 配置增量分析相关的配置. 如下图所示 VCS Root Path：源码的版本控制跟路径. 相对于工作空间的路径 VCS Branch Name Match RegEx： 匹配需要分析的代码分支. Coverage Analysis Level：分析级别. 支持行级和逻辑分支两种粒度的覆盖率分析.3.2. 覆盖率报告图表解析Jenkins 的 Job 主页会有两个图表。一个是全局的代码覆盖率信息。Y 轴为统计粒度（分为代码逻辑分支，代码行，指令，方法，类等等）第二个为相比于上一次 master 分支的 build 新增的代码的覆盖率情况。根据配置的统计粒度显示。相对报告图标又包含为源分支信息，目标分支信息，本次覆盖率概览和单文件增量覆盖率详情四个维度的信息 Absolute：本文件的全量覆盖率信息. Relative：相比于之前的 build 的新增的代码的覆盖率 Change：本次新增的覆盖率，相对于上一次 build 的 Absolute 变化量点击查看详细文件的覆盖率情况. 类似于 Jacoco 的 html 文件报告4. 总结Enjoy it !End"
    } ,
  
    {
      "title"       : "Java随笔 - Java 8特性之接口中的default方法和其他类、接口定义方法冲突",
      "category"    : "",
      "tags"        : "Java随笔",
      "url"         : "./javanote/2019/09/30/Java_class_implements_multiple_interfaces.html",
      "date"        : "2019-09-30 20:16:00 +0800",
      "description" : "",
      "content"     : "Java 1.8 引入一个新的特性. 接口中定义的方法可以使用 default 关键字提供默认的缺省实现. 这项新特性很便捷的帮助开发者在不修改接口的实现类的前提下，达到扩展功能的目的。可以说是非常的方便。但是这项特性带来便利的同时, 也带来了一些困惑。本文章记录笔者通过实例逐步学习这项变动的过程。目录 Q1. Java 8 之前继承多个接口. 且父接口中定义的方法有冲突 Q2: Java 8 之后继承多个接口. 且父接口中定义的方法有冲突 Q3. 继承类和实现接口共存的情况 总结 Q1. Java 8 之前继承多个接口. 且父接口中定义的方法有冲突类结构如下图：示例代码：1234567891011public interface A { void print(String str);}public interface B { void print(String str);}public interface C extends A, B {}上述代码能编译通过。对 C 接口来讲. 父接口中定义的方法都没有具体的逻辑实现, 仅有一个定义。所以不会引起编译冲突.子类必须实现接口定义的方法.Q2: Java 8 之后继承多个接口. 且父接口中定义的方法有冲突而 Java 8 之后，接口中定义了冲突的方法，且有 default 实现时：12345678910111213141516171819202122public interface A { default void print(String str) { System.out.println(\"A\"); }}public interface B { default void print(String str) { System.out.println(\"B\"); }}public interface C extends A, B { /** * &lt;strong&gt;必须重写父类的方法. 否则编译报错&lt;/strong&gt; */ @Override default void print(String str) { // ...do something }}结论：当接口 A 和接口 B 任意一个有 default 实现时. 接口 C 必须 Override 接口中的冲突的方法.可以通过 A.super.print(str) 和 B.super.print(str) 来分别指定要继承的默认实现.示例：C 的 print 方法的 default 实现。先执行 A 再执行 B12345678910public interface C extends A, B { /** * &lt;strong&gt;必须重写父类的方法&lt;/strong&gt; */ @Override default void print(String str) { A.super.print(str); B.super.print(str); }}Q3. 继承类和实现接口共存的情况类结构如下图：12345678910111213141516public class A { public void print(String str) { System.out.println(\"A\"); }}public interface B { default void print(String str) { System.out.println(\"B\"); }}public class C extends A implements B {}// =&gt; 编译成功。输出“A”结论：当父类中定义的方法和接口中定义的 default 实现冲突时。隐式的采用类中的方法.总结 当父类或接口中的定义的方法实现有冲突时, 子类必须覆写父中的方法. 或者把类定义为 abstract 当子类继承父类, 实现父接口的情况时。隐式的继承父类中的方法. 类中定义的方法实现，优先级高于接口中 default 实现End"
    } ,
  
    {
      "title"       : "Github CA证书导致无法迁出和提交代码的异常",
      "category"    : "",
      "tags"        : "Github",
      "url"         : "./github/2018/07/10/Github_Ca_Bundle_Crt_No_Such_Process.html",
      "date"        : "2018-07-10 19:45:00 +0800",
      "description" : "",
      "content"     : "1git config --system http.sslcainfo \"C:\\Program Files (x86)\\git\\bin\\curl-ca-bundle.crt\"或1git config --system http.sslverify false"
    } ,
  
    {
      "title"       : "项目从Maven迁移到Gradle",
      "category"    : "",
      "tags"        : "Okra-Ax, Gradle",
      "url"         : "./okra-ax/gradle/2017/09/29/Okra_Ax_Change_Build_Tool_From_Maven_2_Gradle.html",
      "date"        : "2017-09-29 22:20:00 +0800",
      "description" : "",
      "content"     : "Okra-Ax 从 Maven 迁移到 Gradle.公司项目使用 Gradle 也将近一年时间了。准备将自己的项目转换为 Gradle。主要是使用统一的工具方便一点。1. 安装 Gradle自行安装, 不赘述。2. 项目从 Maven 转到 Gradle1gradle init --type pom转换后项目多出如下图所示文件夹和文件:模块中新增 build.gradle. 包依赖等信息由 gradle 自动转换过来..gradle 目录无需版本控制. 所以在.gitignore 中忽略增加忽略.1.gradle/*3. 总结End"
    } ,
  
    {
      "title"       : "Okra-Ax设计说明",
      "category"    : "",
      "tags"        : "Okra-Ax",
      "url"         : "./okra-ax/okra/2017/09/23/Okra_Ax_Design_Description.html",
      "date"        : "2017-09-23 23:26:00 +0800",
      "description" : "",
      "content"     : "Okra 是一个构建在 Netty 框架和 Disruptor 框架之上轻量级 JAVA 服务器框架。使用 Netty 实现高性能，可灵活扩展的网络通信，使用 Disruptor 实现高吞吐量，低延迟的并发。如何将 Okra 应用到实际开发中?本文旨在帮助初次接触 Okra 框架的用户上手使用 Okra 框架.1. 下载 Okra-x.y.z.jar首先我们需要下载 Okra 框架最新的稳定版本.Jar:下载地址. 目前 Okra 没有推送到 Maven 仓库,使用 Okra-x.y.z.jar 需要手动添加类库引用.2. 导入工程本文以 Intellij IDEA 2016.1.2 为例. IDEA 提供多种多样的添加类库的途径. 本段只做简单的举例示范.方法一: 设置通用类库导入 打开工程设置. “File” -&gt; “Project Structure…” 或者使用快捷键(Ctrl + Alt + + Shift + S). 选择”Global Libraries”, 点击符号”+”，添加 Okra-x.y.z.jar 为通用类库. 添加 Okra 到工程中, 选中新添加的 Okra-x.y.z.jar 点击鼠标右键 -&gt; “Add to Modules” 选中对应的模块, 最终”Ok”, 完成导入方法二: 在 Modules 界面设置导入 打开工程设置. “File” -&gt; “Project Structure…” 或者使用快捷键(Ctrl + Alt + + Shift + S). 选择”Modules”， 选中需要添加 Okra 的模块, 点击”Dependencies”, 点击符号”+”. 点击”JARs or directories”选择 Okra 文件或所在目录按照提示完成添加3. Okra 框架的依赖Okra 核心是整合 Netty 和 Disruptor 两个框架. 以便于快速开发高并发, 低延迟，高吞吐量， 灵活可扩展的网络服务器.(required) :12345678910&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.0.36.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt;(optional) : Spring 框架支持 使用 Spring 框架, 除了 Spring 框架自身带来的 IOC 等便利之外, 还可以快速集成大量优秀的类库, 例如: Hibernate, Mybatis, BoneCP, HikariCP 等等. 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; Flex 通信支持 Flex 客户端和 Java 服务端的通信支持依赖于BlazeDS类库. 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.flex.blazeds&lt;/groupId&gt; &lt;artifactId&gt;flex-messaging-core&lt;/artifactId&gt; &lt;version&gt;4.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.flex.blazeds&lt;/groupId&gt; &lt;artifactId&gt;flex-messaging-common&lt;/artifactId&gt; &lt;version&gt;4.7.2&lt;/version&gt;&lt;/dependency&gt; 4. 项目中使用示例 1: Okra 框架搭建 HTTP 服务器示例 2: Okra 框架搭建 Socket 服务器Java 服务器 Demo: okra-demo5. 总结本文旨在帮助初次接触 Okra 框架的用户，快速搭建基于 Okra 的网络服务器. 提供了两个简单的示例和一个相对来说比较完整的服务端 demo.用户在实际开发过程中遇到问题或者 BUG 欢迎反馈到issues."
    } ,
  
    {
      "title"       : "Unity3D的JsonUtility使用",
      "category"    : "",
      "tags"        : "Unity3D",
      "url"         : "./unity3d/2017/09/03/Unity3D_JsonUtility_1.html",
      "date"        : "2017-09-03 01:47:00 +0800",
      "description" : "",
      "content"     : "记录一下使用 JsonUtility 遇到的坑.1. 类或字段必须是可序列化的 class 必须是 public 或者带[Serializable]的 Attribute. field 必须是 public 或带[SerializeField]的 Attribute.[SerializeField]属性, 有 UnityEngine 提供, 表示序列化时需要强制序列化这个字段.12345678[Serializable]internal class CfgBuild{ public int Id; public string Name; [SerializeField] private int Age;}2. 不支持解析 Json 的 Array1234[ { \"ID\": 1, \"Name\": \"n1\" }, { \"ID\": 2, \"Name\": \"n2\" }]上面的 JSON 会直接反序列化失败. 但是支持 JSON 中包含 Array, 如下所示:123456{ \"list\": [ { \"ID\": 1, \"Name\": \"n1\" }, { \"ID\": 2, \"Name\": \"n2\" } ]}目前笔者搜索的解决方案也是在外部封装一层.3. 不支持 get 和 set12// get和set不支持// public int ret { get; set; }不会报错，不影响代码执行。但是会导致反序列化后的bean没有赋值.4. 其他笔者使用还比较少, 没有详细去处理异常的状态. 扩展信息可以从参考资料中查看5. 参考资料 SerializeField 和 Serializable."
    } ,
  
    {
      "title"       : "2017年旅行记录(上海 - 熊本)",
      "category"    : "",
      "tags"        : "Travel",
      "url"         : "./travel/2017/06/03/Travel_Kumamoto_Japan.html",
      "date"        : "2017-06-03 21:26:00 +0800",
      "description" : "",
      "content"     : "2017 年旅行记录(上海 - 熊本)概述(皇家加勒比·海洋量子号)6 天 5 夜(2017-05-30 - 2017-06-04)日本游轮旅行.笔者第一次出国，所以记录一下旅游行程纪念一下.最开始以为出国很简单，带上护照和钞票走到哪里就算那里. 但是….理想很丰满，现实很骨感。不过整体来说旅行还是蛮不错的. 无忧无虑, 吃了睡睡了吃, 而且不用上班. o(∩_∩)o 哈哈本次旅行留下不少深刻的印象，大概如下： 上海吴淞口的海水很脏，很浑浊。和八代的清澈海水形成鲜明对比. 日本的小孩子很独立. 登船日第二天 7 点+在熊本火车站遇到 3 个小孩儿自己过地下过道, 旁边完全木有大人. TAXI 很贵, 在新八代港口到八代火车站(2700 日元左右 ≈180rmb). 海上看日出日落, 真的必有一番风味. 在国外, 人生地不熟的地方, 语言不通的情况下, 要慎重选择自由行. 起码掌握日常英语口语. 日本老人超多. 大型商场全是老头老太太在逛街. 导游说:日本的老人都是有钱人 游轮的特色表演节目《星海传奇》很不错, 去看了两次.DetailDay 15 月 30 号 7 点从杭州出发坐大巴车前往上海宝山区吴淞口港口码头。到达码头后, 经过行李托运(下午 1 点后可以进房间, 行李在走廊),海关检查等等. 11:50 准时开始登船. 拿护照原件换取船卡(船卡可以用于活动预定, 消费, 下船等等).上船享受完第一顿午餐后, 在多功能玩了碰碰车(登船的旅客还不算多, 不需要排队)Day 2登船第二天，游轮海上巡航。游轮上活动超多, 每天都安排得很满. 不过笔者是后来才知道的. 第一天睡过去了就.Day 3早上 6-7 点游轮停靠在日本新八代港口（非熊本港）。参与免费的观光团. 事实证明便宜没好货, 古人诚不我欺Day 4日本熊本岸上观光第二天. 体验自由行独立前往熊本市, 体验和感受一下另外一座日本城市.Day 5游轮回上海的海上巡航日。Day 6清晨到达吴淞口港口, 在帆船自助餐厅吃完早餐, 会船舱收拾行李准备下船.要托运行李的根据时间表下船, 由于笔者不托运， 可以提早下船(8:15). 在码头坐大巴回杭州. 自此结束整个行程总结本来还想写点详细干货的。 写到一半感觉也是蛮枯燥的。有兴趣的盆友直接点开大神的游后感传送门."
    } ,
  
    {
      "title"       : "搭建自己的GitHub Pages(二) - 升级Jekyll到3.2",
      "category"    : "",
      "tags"        : "GitHub, Blog",
      "url"         : "./github/2016/10/09/Build_GitHub_Pages_Update.html",
      "date"        : "2016-10-09 15:01:00 +0800",
      "description" : "",
      "content"     : "4 月份的时候博文记录搭建 3.0 的环境搭建自己的 GitHub Pages。最近升级 Jekyll 到最新版本(3.2)。博主之前为了方便写了一个简单的批处理用于快速启动 Jekyll 本地服务器。升级 Jekyll 之后发现批处理启动不起来，批处理脚本报错。于是去官网查看一下原因。 发现版本变更貌似影响还比较大. 记录一下升级过程:官网引导如下:12345~ $ &gt;gem install jekyll bundler~ $ &gt;jekyll new my-awesome-site~ $ &gt;cd my-awesome-site~/my-awesome-site &gt;bundle exec jekyll serve# =&gt; Now browse to http://localhost:4000 (现在浏览器打开http://localhost:4000)博主对 ruby 了解甚少，假如不是 Jekyll 的话，可能都不会和 ruby 产生交集。所以…不要苛求Jekyll 引入的 Bundler，博主从未接触过，从纯新人角度跟着官网的示例一行一行的执行命令记录自己踩的坑。Step 1: 遇到 gem 报 SSL_connect 错误win7 系统电脑, 使用 ruby installer 安装完 ruby 环境.当时不知道因为啥引发的，但是根据错误输出知道是 SSL 引发的问题。增加 http 的 gem 仓库解决。默认的 gem 是https://rubygems.org/1&gt; gem sources --add http://rubygems.org/Step 2: bundle install首先安装完 bundler 之后，进入 jekyll 目录(Gemfile)文件所在目录, 执行:1$&gt; bundle exec jekyll serve输出一段英文. 大意是需要 bundle install 先执行一次。1~ $&gt; bundle installwin10 电脑很顺利的安装完成了 bundle install 的各种安装下载等等巴拉巴拉….但是在 win7 电脑的时候，cmd 中执行之后中途会因为各种各样的问题停下来。请按照输出的提示安装相对于的库? 等等还是蛮多的。1~$&gt; gem install execjs -v '2.7.0'当时没注意，直接无脑的按照提示命令进行手动安装，居然手动安装成功了。也是感觉怪怪的，不知道啥原因也。紧跟着手动处理了两三次，感觉有点不正常，于是下决定查一下原因，仔细看输出信息，发现都是因为 SSL 连接引发，再跟着注意到 Gemfile 中 gem 仓库使用的是 https修改为 http 之后，在执行 install，一步到底。解决脱坑隔了几天再去查 SSL_connect 错误原因，发现下面的文章脱坑办法感觉还是直接 http 算了。折腾。反正博主基本上除了 GitHub pages 基本上也不用 ruby"
    } ,
  
    {
      "title"       : "Glances监控服务器状态",
      "category"    : "",
      "tags"        : "CentOS, Python",
      "url"         : "./centos/python/2016/10/01/Glances_Monitor_Centos_InfluxDB_Grafana.html",
      "date"        : "2016-10-01 22:17:00 +0800",
      "description" : "",
      "content"     : "Glances 是 Python 编写的基于 curses 的跨平台系统监控工具。最近 leader 引入了 InfluxDB + Grafana 做服务状态监控，主要监控用户在线，队列 IO，线程状态等服务端服务有关性能指标和参数。笔者在服务监控这块接触的并不是特别多。所以打算花点业余时间研究记录学习一下。在这个过程中想到是否可以利用 Python 脚本解析(top, iostat)等工具的监控数据，汇总并上报信息到 InfluxDB，在 Grafana 显示，实现对服务器机器状态的监控。万事先 Google，看看是否有前辈已经造轮子，避免重复制造垃圾轮子。o(∩_∩)o 哈哈Google 发现了 Glances 项目，使用 Python 开发并且直接支持 InfluxDB+Grafana 输出显示。从 Glances 安装开始Glances 提供多系统的多种安装途径。本文只记录笔者安装流程和遇到的问题。依赖： python 2.7,&gt;=3.3 psutil&gt;=2.0.0 setuptools可选依赖:有兴趣可以参见官网说明文档环境： 操作系统 : CentOS 7-x64 Python 版本 : 2.7.8(系统自带)值得一提的是，安装过程中庆幸也是不幸的事情是 : 安装过程笔者没遇到啥问题。我只能攒一句 Glances 官方提供的自动安装初始化脚本 下载地址支持的太好了。1&gt; curl -L https://bit.ly/glances | /bin/bash对于 InfluxDB 相关的参数配置:1234567[influxdb]host=localhostport=8086user=rootpassword=rootdb=glances # InfluxDB中的数据库 - 启动Glances前要创建对应的数据库tags=foo:bar,spam:eggs启动 Glances：1&gt; glances --export-influxdb配置 Grafana 数据源同样庆幸也是不幸的是：Glances 提供了便捷的模板配置。官网模板配置:下载地址在 Grafana 中选择”Import” -&gt; glances-grafana.json 文件Grafana 导入的*.json 文件中的 datasource 配置必须对应 InfluxDB 中的 db，否则无法找到数据源总结至此，整个环境就安装好了。看一下效果：Glances 监控包括 CPU，IO，网络，磁盘等等。Enjoy it!!!"
    } ,
  
    {
      "title"       : "InfluxDB - 安装",
      "category"    : "",
      "tags"        : "Database, InfluxDB",
      "url"         : "./database/2016/09/30/InfluxDB_Init.html",
      "date"        : "2016-09-30 16:53:00 +0800",
      "description" : "",
      "content"     : "本篇文章记录 CentOS 7-x64 操作系统，安装 InfluxDB 时序数据库。环境: 系统 : CentOS 7-x64 InfluxDB : 1.0.0InfluxDB 下载页笔者下载1.0.0 版本CentOS12wget https://dl.influxdata.com/influxdb/releases/influxdb-1.0.0.x86_64.rpmsudo yum localinstall influxdb-1.0.0.x86_64.rpm启动 influxdb1&gt;systemctl start influxdb创建配置文件 influxdb 配置文件:1&gt;influxd config &gt; influxdb.generated.conf8083 端口用于后台管理界面, 8086 端口用于 HTTP API 接口总结笔者使用的是下载 rpm 之后安装的办法。各位看官可以使用官网示例的安装过程官方安装示例"
    } ,
  
    {
      "title"       : "并发和并行的区别",
      "category"    : "",
      "tags"        : "Code",
      "url"         : "./code/2016/09/16/Diff_Between_Concurrency_And__Parallesim.html",
      "date"        : "2016-09-16 22:55:00 +0800",
      "description" : "",
      "content"     : "一张图解释并发(Concurrency)和并行(Parallesim)的区别:并发:单核处理多个任务.并行:多核同时处理多个任务."
    } ,
  
    {
      "title"       : "Python - 语法基础",
      "category"    : "",
      "tags"        : "Python",
      "url"         : "./python/2016/09/15/Note_Python_2.html",
      "date"        : "2016-09-15 21:15:00 +0800",
      "description" : "",
      "content"     : "第一次接触程序且语言是 Python，推荐仔细看一下本文章. 内容主要介绍 Python 的一些语法基础信息1. Hello World！创建第一个 python 文件 hello_world.py,123#!/usr/bin/python# -*- coding: UTF-8 -*-print(\"Hello World!\")第一行: 调用/usr/bin 下的 python 解释器第二行: -- coding: UTF-8 --用于解决文件编码问题。第三行: 输出 Hello World！文本2. Python 保留关键字3. 标准数据类型3.1 数字数字类型有四种 : int, long, float, complex3.2 字符串略3.3 列表(list)12345678910111213141516171819# 1. 创建list - 内部元素没有类型要求list = ['abc', \"xxx\", True, 10, 10.5, [1, 2]]# 2. 元组索引，截取# 获取第一个元素first = list[0]# 获取最后一个元素last = list[len(list) - 1]# 截取listary = list[1:3] # [\"xxx\", True]ary1 = list[-5:-3] # [\"xxx\", True]# 3. 删除del list[2]# 清空list# 方式一del list[:]# 方式二list[:] = []3.4 元组123456789101112131415161718192021# 1. 创建元组 - 类似于listtuple = ()tuple1 = ('xx', 'yy', 1, 2.0, ['x', 1])# 只包含一个元素时，需要在元素后面添加逗号tup1 = (50,)# 2. 修改操作# 禁止修改元素值# tuple[0] = 100;tup1 = (12, 34.56)tup2 = ('abc', 'xyz')tup3 = tup1 + tup2# 2. 删除操作del tup3# 3. 元组索引，截取 - 类似于list# 4. 任意无符号的对象，以逗号隔开，默认为元组x, y = 1, 2tuple = x, y3.5 字典123456789101112# 1. 创建info = {\"name\": 'lily', 'age': 17, 'isAdult': False}# 2. 访问print(info['name'])# 3. 修改info['name'] = 'lucy'# 4. 删除del info['name'] # 删除键是'Name'的条目info.clear() # 清空词典所有条目del info # 删除词典4. 条件与循环12345678var1 = 1var2 = 2if var1 == var2: print var1elif var1 == 0: print 0else: print var212345678910111213141516world = 'Python'# forfor letter in world: print 'for:', letter# whileindex = 0while (index &lt; len(world)): print 'while:', world[index] index += 1# while - breakin dex = 0while (1): if index &gt;= len(world): break print 'while - break:', world[index] index += 14. 日期与时间Python 的日期时间类库 time 和 datetime 库推荐文章链接地址"
    } ,
  
    {
      "title"       : "Python - 安装py环境",
      "category"    : "",
      "tags"        : "Python",
      "url"         : "./python/2016/09/12/Note_Python_Init.html",
      "date"        : "2016-09-12 23:27:00 +0800",
      "description" : "",
      "content"     : "昨天帮同事从 MySQL 数据库统计查运营数据。越查越感觉到深深的恶意（要查的数据太多了，而且由于数据量问题，每一个 SQL 执行时间都比较长）。于是下定决心折腾一下 Python。下次可以用脚本去完成查询操作。避免人工手动查询的作死。第一天下午开始学习 Python，折腾下载和安装相关的环境。今天搞定了记录一下。笔者从事网络游戏服务器开发，业务基本不需要 Python 脚本，感觉 linux 环境需要一个脚本语言，快速帮助自己开发一些小工具。且一般 CentOS 6.5 和 7.0 操作系统打交道比较多。 CentOS 系统默认自带 Python 环境是 2.x 版本。最终选择学习 python 2.x 而不是 3.x。开发环境：Windows 10编辑器：PyCharm 2016 社区开源版安装 Python 环境下载 python 2.7.12官网下载地址版本。选择“Windows x86 MSI installer”下载安装对应版本。安装 MySQLdb初次入门就直接选择 mysql 相关的内容作为切入口(新手不推荐这么做)，MySQL 安装遇到很多坑。1#&gt; pip install MySQL-python提示缺少 VC 对 Python 的编译环境。下载和安装 VCForPython27下载地址继续 pip 安装。依旧报错1#&gt; ... Cannot open include file: 'config-win.h': .....一番 Google 之后改用 easy_install。easy_install 默认在{$_PYTHON_HOME}/Scripts/目录下和 pip 同级。1#&gt; easy_install MySQL-python在公司采用这种方式顺利安装 MySQL 扩展完成。晚上回家之后重复走了一遍安装配置流程。网络不好的情况，会出现 time out 问题。一番尝试，最后没办法修改为从MySQL-python下载对应的版本MySQL-python-1.2.5.win32-py2.7.exe (md5)测试示例12345678910111213141516171819#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdbconfig = {'host': '127.0.0.1', 'db': 'test_db', 'user': 'root', 'passwd': '123456'}try: conn = MySQLdb.connect(host=config['host'], db=config['db'], user=config['user'], passwd=config['passwd']) conn.set_character_set('utf8') cur = conn.cursor() cur.execute(\"show databases;\") cur.close() conn.close()except MySQLdb.Error, e: print \"Mysql Error %d: %s\" % (e.args[0], e.args[1])print \"endl\"总结至此, 完整的 python 环境就安装好了。enjoy it !"
    } ,
  
    {
      "title"       : "日志 - 20160710",
      "category"    : "",
      "tags"        : "生活",
      "url"         : "./other/2016/07/10/Date_Note_16_07_10.html",
      "date"        : "2016-07-10 23:27:00 +0800",
      "description" : "",
      "content"     : "不知不觉的已经入职半个多月。目前工作内容以熟悉代码，维护老项目的版本的更新发布为主。公司氛围轻松，加班文化基本没有。每天熟悉代码，熟悉发布更新流程，熟悉内部的各种工具和平台，熟悉项目架构日子就过得很快。晚上闲来无事，最近折腾起了 Okra-LOG 日志。上周五晚上算是基础功能已经完成。说起 Okra-Log 就有点故事了。o(∩_∩)o 哈哈，故事要从项目上线腾讯互娱开始说起，手游项目上线接入 tlog 日志（腾讯内部闭源的用户行为日志上报系统）。研发侧服务器上报用户的行为日志，运营侧有专人维护和开发相关上报 web 页面（查看分析平台）。主要用于分析用户留存，玩家针对某些功能或活动的参与度、热情度等等。说简单点就是数据分析，分析成功，也分析失败。再然后我开始接手和负责项目的后期维护工作，项目后续海外平台的上线。问题是：海外的平台没有日志系统。这时候我面临的 2 个选择，一个是研发属于自己的日志系统，二全面兼容 tlog 的接口。其实两种是一个选择啦。第二种还简单点。恰好上线稳定后那段时间，工作压力不大，笔者闲着无聊，一方面也是自己好奇，于是在个人工具项目 tinyz-kernel 中集成仿 tlog 的实现。于是海外版本，就这么自然而然的偷了个懒， 最后将 kernel 的日志部分剥离出来，形成了当时内部代号 eos 的日志系统。这里需要说明一下，tinyz-kernel 项目也就是 Okra 的前身。算是笔者自己的私人工具库吧。第三步，也就是现在了 o(∩_∩)o 哈哈。其实也没什么，就是感觉笔者当初设计和实现不好。而且一直有推掉重新设计实现的想法。之前一方面是工作的事情比较多（新项目研发和架构），另一方面海外平台线上使用的情况比较稳定，也没遇到什么大问题所以也就一直拖着拖着就搁置了。最近刚好离职，就准备重新按照自己的想法实现一下。也算是为未来的可能做个积累。这时候可能有小朋友说现在第三方日志收集和分析工具这么多为什么不接入第三方实现呢？大概就以下几个原因。 日志系统实现不难。工作量主要集中在 web 展示数据分析模块 自研的标准统一。针对不同的运营商接入不同的日志平台是非常费劲的一件事情，环境复杂（各大应用分发商，运营商可能使用的不同的 log） 更新和部署简单。自研对系统了解程度更高，方便扩展各种需要的功能。使用 Java 实现，部署提供 jar 包和启动脚本即可 接入简单。随时根据需求调整日志功能。实在编不下去了。o(∩_∩)o 哈哈。 其实最关键的问题很简单，接入第三方需要按别人的规则走，自己的实现自由度很高。详细见Okra-LOG项目吧，已开源 o(∩_∩)o 哈哈，有需要就拿去。 会逐步完善设计文档和 web 的部分。"
    } ,
  
    {
      "title"       : "在上海的最后一夜",
      "category"    : "",
      "tags"        : "生活",
      "url"         : "./other/2016/06/12/Last_Night_On_ShangHai.html",
      "date"        : "2016-06-12 23:49:00 +0800",
      "description" : "",
      "content"     : "2014 年，孤身一人从杭州来到上海，不知不觉在这座城市已然生活了 2 年多了。将要离开这座国际大都市，离开我奋斗 2 年的地方，离开过去的喜悦、辛酸以及成就。感觉有些失落。我是一个有点感性的 IT 程序员。喜欢时不时感慨。o(∩_∩)o 哈哈14 年，YS 公司从 100+的规模，扩张失败，情况急转直下，公司核心技术离职，资方挖人，最终面临解散。在那时，恰好朋友（客户端主程序）在的 LJ 公司的研发部刚刚成立没多久需要服务器，于是就这么进了 LJ 公司负责网络游戏的服务端研发。在我加入的时候，公司已经实现了一个游戏的 demo，准备开始不断的完善玩法，活动、找运营等等。于是，大家都懂的剧情来了。开始一段很凶残的加班生活（远超 996 的水平），现在回想那个时候就是靠着有梦想，坚信产品会成功的希望坚持下来，虽然我们人少，但是我们一直在努力的按计划完成各个版本的开发。后来上了腾讯的大船(几轮测试后评级是 5 星产品，国内独家代理)。这是一个振奋人心的消息（业内你懂的，用户量那个 biangbiang 的多，项目前途稍微有保障）。同样的，腾讯的严格要求,公司项目组研发人员少，我“更苦的日子”也开始了。留存数据测试，版本迭代变更。为了赶版本进度，曾经一度周五上班，周一回家休息的节奏（直接住公司，吃饭叫外卖）。国内由于是腾讯独家代理，按照规定我们组团去深圳腾讯互娱进行了 1 个多月的上线前开发，每天都加班到深夜，记得那个时候，恰逢元旦，于是大家放了一天假。独自一个人休闲爬山（大南山），隔江(海?)可以看到对面的香港。那整整一年过的真的很累，很辛苦，一度曾经想到放弃，但是最终坚持了下来。现在回想一切都是值的的。一方面从事的是自己喜欢的事业，另外一方面产品准备腾讯的微信和应用宝上线，内心期盼产品被世人知晓，这是一种荣誉感，成就感。当然还有就是比较不错的项目奖金（总计 3 个月的薪水，后面因为被发现的 bug 问题，数据下滑比较快，也就没多少奖金了）。项目的“成功”，以及海外市场的扩展的需求。最终公司拆分了部门，我也进阶成为其中一个研发部门的服务端主程序，一方面维护老项目，另外一方面负责新项目的架构和研发。和之前做“主程序”不同(负责维护项目为主)，LJ 使用 PHP 做服务器的逻辑开发，Java 负责推送，定时任务，日志，数据落地等等。因为要拓展海外业务(当时代码级的接入了腾讯的 tlog 系统)，为了减少代码变更，我搞了一套 eos 日志(仿 tlog)兼容。海外版本的跨服等等版本需求。再后来负责研发一款手游的服务端，公司又加了一个小伙伴帮我，那段时间，基本上每天都睡不好，晚上躺床上想着各种事情直到睡着。第二天按照睡着前的思路去整理优化。那段时间压力大，但也懂职责越大，任务越重，收获越多。熬过去了，能轻车熟路的驾驭技术了，就会轻松啦。那段时间根据上线的项目为根基，吸取经验和教训，不断的优化，改进。最终取得算是不错的优化成果（响应时间减少 50+%，通信量减少 30+%）。可惜公司最终没采取我的方案。可惜，可惜。在后面被小伙伴拉去搞 VR 的研究和开发。我们的设想是开发一个 VR 平台，一个 VR 世界。分布式服务器架构。前前后后 6-7 版服务器变更，终于完成了 Okra-Ax。后面考虑像 Okra 一样剥离出来开源。值得一提的是：我终于吃到秋葵了，口感真心感觉不怎么样。不知不觉写了这么多。都 1 点多了。准备休息。期待未来能顺利入职。写在最后。衷心的感谢一起奋斗努力的小伙伴。感谢小伙伴的支持、包容、谅解。也感谢公司给机会我展示自我。世界这么大，生活如此艰辛，这一去，也不知何时才能再相聚。朋友！珍重！再见！"
    } ,
  
    {
      "title"       : "面试笔试题 - 续",
      "category"    : "",
      "tags"        : "Other, 生活",
      "url"         : "./other/2016/06/05/Interview_Next.html",
      "date"        : "2016-06-05 07:42:00 +0800",
      "description" : "面试笔试题 - 续",
      "content"     : "回顾一下之前的笔试题。URL 地址。 问题：有一个数组 a，有一个变量 n，大于变量 n 的放到数组的前面，小于变量 n 的放到数组的后面（不需要排序）。解决思路：数组 a 从 0 开始向后遍历，检查到小于 n 的元素 k1，那么从队尾指针 tail 处向前遍历，检查到大于 n 的元素 k2 停止，并 k1 和 k2 互换位置。在从 k1 处继续向后遍历直至 k1 位置大于队尾指针位置（遍历结束）。测试用例:1234567public static void main(String[] args) { int[] ary = new int[] { 1,2,3,4,5,6,8,5,2,1,3,9,5}; int n = 5; sort(ary, n); System.out.println();}逻辑代码如下:12345678910111213141516171819public static void sort(int[] array, int n) { int tail = array.length - 1; for (int h = 0; h &lt; array.length; h++) { if (h &gt; tail){ break; } if (array[h] &lt; n) { for (int k = tail; k &gt;= h; k--) { tail = k; if (array[k] &gt;= n) { int obj = array[h]; array[h] = array[k]; array[k] = obj; break; } } } }}延伸版本，当 n 改为 n1，n2…nx 数组时如何实现?晚上洗澡的时候想起了这么一个问题。决定折腾一下解决这个问题。最开始有点钻进死胡同。想通过一次遍历实现相应的拆分功能（效率最高的情况）。感觉情况略微有点复杂。考虑十几分钟后感觉可能需要向效率妥协，转变思路。解决思路：根据 n1, n2… nx 分隔数组 array，先将 n 的数组从大到小排序。再将分隔问题简化成 x 个拆分 n 的连续小问题。 按照 n1 和其他拆分 在 n1 和其他的分界点为起始点, 按照 n2 和其他拆分 重复步骤 2，直至起始点到达数组终点，退出循环.算法根据数据的复杂度，时间复杂度最小是(O(n)), 最大是 O(n(n+1)/2)。1234567891011121314151617181920212223242526272829303132333435363738public static void sortn(int[] array, Integer... ns) { // 这里的排序保证n的数组是从大到小有序的， 当然可以自己设置，以避免排序的损耗 Arrays.sort(ns, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2-o1; } }); int index = 0; for (int i = 0; i &lt; ns.length; i++) { index = sort(array, ns[i], index); if (index &gt;= array.length) { break; } }}public static int sort(int[] array, int n, int index) { int tail = array.length - 1; for (int h = index; h &lt; array.length; h++) { if (h &gt; tail){ break; } if (array[h] &lt; n) { for (int k = tail; k &gt;= h; k--) { tail = k; if (array[k] &gt;= n) { int obj = array[h]; array[h] = array[k]; array[k] = obj; break; } } } } return tail;}ok。解决问题。以后想到更高效的算法逻辑了。再继续优化。目前可能就这样啦。各位晚安"
    } ,
  
    {
      "title"       : "为什么使用HikariCP连接池?",
      "category"    : "",
      "tags"        : "Database, HikariCP",
      "url"         : "./database/2016/06/05/Why_Use_HikariCP.html",
      "date"        : "2016-06-05 00:47:00 +0800",
      "description" : "",
      "content"     : "笔者最近在换工作的时，被面试官问数据库和连接池相关的一些问题。下面从面试这块开始简单介绍一下笔者项目中数据库的使用情况。项目中使用 MySQL 做数据存储，Redis 做数据缓存。读写数据流程如下： 读数据：先查询 Redis 中是否存在，存在直接取出数据，不存在从 MySQL 查询并保存包 Redis 中缓存起来。 写数据：先写入 Redis，然后异步提交到 MySQL 写入线程，实现数据落地。问题 1：如何保证数据读写的“原子性”?如何解决脏数据?众所周知，当使用数据库跨表操作时，利用数据库引擎提供的事务和回滚机制，可以保证数据库跨表操作的原子性。一方面在项目中引入数据缓存层也是一种常见的减轻数据库压力的做法。另一方面引入了缓存增加了数据操作的复杂度。如何解决缓存中和数据库中数据不一致的问题?笔者以线上项目为例简单的说了说。在线上的代码，主要以缓存层数据为主，数据不统一的情况，会在下一次落地时覆盖数据库的数据，实现同步。假如是因为版本迭代数据库字段变更导致数据库落地错误时，由于 Redis 缓存的有效期是 7 天，在缓存失效前手动执行脚本将数据重新落地。由于面试官一再强调是自动修复脏数据。说实话笔者在保证 Redis 和 MySQL 两者数据操作的原子性这块没有什么涉猎。也没想出什么好的办法。由于面试官一再询问，笔者就稍微讲了讲一个思路回答：也许是否可以使用数据库的原子性，回滚的时候回退数据?当然事实证明一时的想法总是有漏洞的。数据回退涉及到数据回退前多次被修改的复杂情况。显得不是很合适。最后引发尴尬的是面试官的总结：(大意如下)在修改数据前，尽可能多的判定用户是否满足操作的条件，以便于提早发现问题并退出, 以避免数据操作。同时避免异步操作数据库，同步操作及早出现问题并退出。wtf… 当时一下子感觉自己有点懵逼的。才发现整个就理解错了。瞬间也是好尴尬。问题 2：HikariCP 是什么?HikariCP 是一个高性能的 JDBC 连接池。Hikari 是日语“光”的意思。可能是目前 java 业界最快的数据库连接池（BoneCP 因此停止维护，其作者推荐 HikariCP）。面试官说项目用的 c3p0 作为数据库连接池，也没接触过 HikariCP。还问了何时连接池会关闭数据库的连接。说实在的，当时笔者没回答好，一般数据库连接池会自动管理数据库连接建立、复用和关闭。一般情况下不会关闭已经建立的数据库连接。连接池关闭连接方面，其他连接池竞品不清楚，HikariCP 会在设置的最大生命周期后，最大空闲时间后等多个条件作用下自动关闭释放连接。下面是总结数据库连接池技术数据库连接池负责分配、管理和释放数据库的连接。 数据库连接复用。重复使用现有的数据库连接，可以避免连接频繁建立、关闭的开销。 统一的连接管理。释放空闲时间超过最大空闲时间的数据库连接，避免因为没有释放数据库连接而引起的数据库连接泄漏。一些数据库连接池的对比首先明确：无论任何形式的数据库连接复用（数据库连接池技术）都避免了频繁建立、关闭数据库连接带来的开销。性能相对于没有连接池有质的提升。另外一点需要明确：数据库连接池一般不会成为整个程序的性能瓶颈。更多的出现在数据库读写，带宽，cpu 等方面（开始人云亦云模式，o(∩_∩)o 哈哈）。下面引入正文，先来一个对比。文章数据库连接池性能比对很早之前看到过，但一直没找到原帖。皇天不负有心人，今天总算是挖出来了原帖（鄙视一下盗链和转帖不挂源地址的）。HikariCPHikariCP可能是目前业内最快的数据库连接池。说到 HikariCP 就不得不说 BoneCP。笔者之前是 BoneCP 的使用者。突然那么一天（忘记具体是哪天了）想看看 BoneCP 是否有新版本。然后发现 BoneCP 作者在项目主页的描述说不再更新 BoneCP 并且推荐了 HikariCP。笔者也有段时间没关注这个类库了，面试的时候因为也好久没看了，所以讲的也不是很清楚。于是就抽空复习总结一下。笔者之前在博客园发表过一篇关于 HikariCP 的文章从 BoneCP 到 HikariCP，简单讲了 Spring+Mybatis+HikariCP 的配合使用。那时候刚接触 HikariCP，被官方的测试数据所吸引，毕竟 BoneCP 停产了，而且在代码基本上不需要改动的情况下就能获得更好的性能，何乐而不为呢? 所以决定试试这个“新家伙”HikariCP 的官方 Wiki 中提到的为什么 HikariCP 是如何实现这么高效率。详细见:Down the Rabbit Hole掉进兔子洞? 反正我是不懂这是什么谚语。o(∩_∩)o 哈哈。大概内容如下： 优化字节码（JVM 内联），减少生成的机器码 精简代码, 使用 Javassist 生成委托。 无锁容器。FastStatementList、ConcurrentBag 等等针对 BoneCP 的优化。(好针对 BoneCP 啊，o(∩_∩)o 哈哈)DruidDruid是阿里巴巴开源的“为监控而生的数据库连接池！”。性能测试过程略低于 HikariCP，但是提供了强大的监控和扩展功能。支持 psCache。有兴趣可以去 GitHub 查看。有中文文档。o(∩_∩)o 哈哈。阿里威武结论为什么使用 HikariCP?首先它是一个优秀的数据库连接池，代码少，效率高。支持多种常见的数据库（包含但不限于：Oracle、MS SQL Server、MySQL、PostgreSQL）轻松集成 Spring+Hibernate/Mybatis。而且笔者平时的业务内容不是特别需要监控这么“重度”的功能。有慢查询日志基本上就足够了。"
    } ,
  
    {
      "title"       : "2016年离职总结",
      "category"    : "",
      "tags"        : "Other, 生活",
      "url"         : "./other/2016/06/03/Interview.html",
      "date"        : "2016-06-03 20:00:00 +0800",
      "description" : "2016年离职总结",
      "content"     : "最近忙着离职的事情，O(∩_∩)O 哈哈~，自我总结一下。离职原因从业四年，先后在 3 家公司任职，在最近一家公司工作两年，主要从事网络游戏服务端(后端)开发相关的工作。也算是一步一步从的“打杂”过度到项目组服务端主程序，领导一个小中型项目的后端的设计和研发。任职的三家公司都不算是大公司（最大的规模，公司技术人员也就 30-40 人左右），技术氛围一般，所以很多时候都需要自己去尝试和摸索道路来（传说中的野路子?）。踩过了很多坑，也填了很多坑。感觉假如自己想在技术道路上走的更远，真的需要一个技术氛围良好的团队或公司。闭门造成终归是成就有限。于是就有了离职和这篇文字。(*^__^*) 嘻嘻……游戏行业，游戏研发团队往往都是人员比较少的小规模团队。项目组人员一般不超过 20 个，前后端研发占一半策划占一半，可能会捎带几个美术。服务端人数往往也略少于客户端。后端同学往往都需要肩负一部分运维的职责（例如部署服务器运行环境，调优等等）。因此在某种程度上讲，相比于其他行业的后端，更辛苦。当然，付出和收获是成正比的。做得越多对搞技术的来说是能学习到更多的东西。跑题跑得有点远诶。O(∩_∩)O 哈哈~面试收获最近一段时间东跑西跑的面试，虽然很辛苦（刮风下雨的啊），但收获满满。主要分为下面两个方面：一方面参加一些行业内公司的面试，有了和技术主管/技术牛人有面对面沟通的机会。O(∩*∩)O 哈哈~。和资深程序聊天，往往很快就能知道了自身的问题和不足。总结一下自己的不足：~~(&gt;*&lt;)~~) 理论基础知识不算特别扎实。多看些技术书籍，补充扩展自己的知识面 缺乏实践。多动手测试，不能人云亦云，尝试实践分析后端的技术。准备好好读读 《JAVA 性能优化权威指南》虽然知道自己的缺点和不足是一件很打击人的事情，但是很感谢这些大牛能抽时间，给我一个面试聊聊的机会（窃喜）。O(∩_∩)O 哈哈~。后面要慢慢花时间补足自己的短板。另外一方面和业内的朋友聊聊天，谈谈人生理想，未来规划。和这些过来人的聊天。开阔了视野，增长了见识。分享一个最近面试遇到的唯一一个代码题。嘿嘿 问题：有一个数组 a，有一个变量 n，大于变量 n 的放到数组的前面，小于变量 n 的放到数组的后面（不需要排序）。解决思路：数组 a 从 0 开始向后遍历，检查到小于 n 的元素 k1，那么从队尾指针 tail 处向前遍历，检查到大于 n 的元素 k2 停止，并 k1 和 k2 互换位置。在从 k1 处继续向后遍历直至 k1 位置大于队尾指针位置（遍历结束）。后面还有延伸版本，当 n 改为 n1，n2…nx 数组时如何实现，后面有空就整一个。123456789101112131415161718192021222324252627282930public class SimpleSort { public static void main(String[] args) { int[] ary = new int[] { 1,2,3,4,5,6,8,5,2,1,3,9,5}; int n = 5; sort(ary, n); System.out.println(); } public static void sort(int[] array, int n) { int tail = array.length - 1; for (int h = 0; h &lt; array.length; h++) { if (h &gt; tail){ break; } if (array[h] &lt; n) { for (int k = tail; k &gt;= h; k--) { tail = k; if (array[k] &gt;= n) { int obj = array[h]; array[h] = array[k]; array[k] = obj; break; } } } } }}补充于 2016-06-04延伸试题解决"
    } ,
  
    {
      "title"       : "使用Redis实现高实时性的排序",
      "category"    : "",
      "tags"        : "Redis, 排行榜",
      "url"         : "./database/2016/05/26/Redis_SortedSet_Implement_Rank.html",
      "date"        : "2016-05-26 09:00:00 +0800",
      "description" : "",
      "content"     : "一般应用或游戏都会有各种各样的排行榜。排行榜往往可以满足了用户互相攀比炫耀，刺激内消费等等好处。用户往往希望自己能在排行榜取得显著的位置。 那如何实现开销低实时性高的排行榜呢?引言记得那年，笔者还刚入行的时候。需要为一款 MMORPG 实现一个玩家的等级排行榜。排序规则是优先根据等级排序，等级相同根据经验值排序，经验值相同根据满级时间排序。那个时候能想到的做法就是数据库新增一个字段用于保存玩家到达满级的时间戳，配合当时在数据库中已经存在的保存玩家的经验和等级的字段，使用 MySQL 数据库的 Select 查询语句根据三个条件最终实现排序,排序之后将排名数据缓存到内存中,以减轻数据库的压力, 设定排行榜数据过期时间为 3 个小时，每当数据过期重新查询排序并更新缓存。那个时候的业务量小，小区小服玩家不多，对实时性要求也不高，就这么算是实现了。O(∩_∩)O 哈哈~。跑偏了。下面正题Sorted Set 应用Redis 提供基于跳跃表(skip list)实现的时间复杂度大致为(O(log(n)))的有序集合(Sorted Set)。本文讲的核心内容实现高实时性的排行榜，就是根据 Redis 的这一数据结构来的。假若项目中未使用 Redis, 未来也不准备引入 Redis 的朋友。可以借鉴引用一下跳跃表的自己实现 SortedSet 或引用 GitHub 上其他网友的开源实现。Redis 中的 SortedSet 根据一个名为 score 的 64 位双精度浮点数的参数实现排序. 但是在实际应用中推荐将 score 当做 64 位长整型来使用.原因很简单: long 的取值范围要大于 double. double 范围为[-(2^53), +(2^53)] long 范围为[-(2^63), +(2^63) - 1] 当只有一个排序原则时，直接使用 score 排序即可。但是引言中的排序有三个条件，而 SortedSet 只提供一个参数而且还是数字，那该如何应用呢?下面来正菜了。因为 redis 保存的数据是 64 位的，而我们需要的数据可能不需要 64 位这么多。既如此合理分析拆分这 64 位长度拼接并组合成我们需要的数据，就可以实现简单的多条件排序了。分析各部分数据的取值范围先普及一点基础知识. 8 位二进制: 有符号[-128, 127]， 无符号[0, 255] 8 位二进制: 有符号[-128, 127]， 无符号[0, 255] … 32 位二进制: 有符号[-2^31, 2^31 - 1]， 无符号[0, 2^32] … 64 位二进制: 有符号[-2^63, 2^63 - 1]， 无符号[0, 2^64]64 位二进制数，首先时间戳精确到秒 则需要 32 位，等级一般 8 位即可（根据需求扩展到 9 位、10 位…）。这么拆分下来经验值最多使用剩余 24 位表示，有符号[-2^23, 2^23 - 1],也就 800w+。对于一些小数值经验应该是足够了。但是假如是类似于暗黑三这种按 E 计算的咋办?目前笔者能想到的就是通过降低数值规模。例如：每 1w 实际经验值转换为 1 点排序经验值。即 20E 实际经验 / 1w = 20w 排序经验. 20w 完全足够 24 位二进制来表示了。示例实现优先等级排序，经验排序，满级时间。1234567891011int level = 60;int exp = 6000000;int timestamp = (int) (System.currentTimeMillis() / 1000);long redisScore = ((level &amp; 0xFFL) &lt;&lt; 56) | ((exp &amp; 0xFFFFFFL) &lt;&lt; 32) | (timestamp &amp; 0xFFFFFFFFL);int tempTime = redisScore &amp; 0xFFFFFFFFL;int tempExp = (redisScore &gt;&gt; 32) &amp; 0xFFFFFFL;int tempLevel = (redisScore &gt;&gt; 56) &amp; 0xFFL;总结详细可以查看 Redis 的官方命令说明文档或笔者在 Okra 框架的 example 包下的示例代码。"
    } ,
  
    {
      "title"       : "Okra框架(四) 使用引导说明",
      "category"    : "",
      "tags"        : "Okra框架",
      "url"         : "./okra/2016/05/19/Okra_Get_Started.html",
      "date"        : "2016-05-19 09:26:00 +0800",
      "description" : "",
      "content"     : "Okra 是一个构建在 Netty 框架和 Disruptor 框架之上轻量级 JAVA 服务器框架。使用 Netty 实现高性能，可灵活扩展的网络通信，使用 Disruptor 实现高吞吐量，低延迟的并发。如何将 Okra 应用到实际开发中?本文旨在帮助初次接触 Okra 框架的用户上手使用 Okra 框架.1. 下载 Okra-x.y.z.jar首先我们需要下载 Okra 框架最新的稳定版本.Jar:下载地址. 目前 Okra 没有推送到 Maven 仓库,使用 Okra-x.y.z.jar 需要手动添加类库引用.2. 导入工程本文以 Intellij IDEA 2016.1.2 为例. IDEA 提供多种多样的添加类库的途径. 本段只做简单的举例示范.方法一: 设置通用类库导入 打开工程设置. “File” -&gt; “Project Structure…” 或者使用快捷键(Ctrl + Alt + + Shift + S). 选择”Global Libraries”, 点击符号”+”，添加 Okra-x.y.z.jar 为通用类库. 添加 Okra 到工程中, 选中新添加的 Okra-x.y.z.jar 点击鼠标右键 -&gt; “Add to Modules” 选中对应的模块, 最终”Ok”, 完成导入方法二: 在 Modules 界面设置导入 打开工程设置. “File” -&gt; “Project Structure…” 或者使用快捷键(Ctrl + Alt + + Shift + S). 选择”Modules”， 选中需要添加 Okra 的模块, 点击”Dependencies”, 点击符号”+”. 点击”JARs or directories”选择 Okra 文件或所在目录按照提示完成添加3. Okra 框架的依赖Okra 核心是整合 Netty 和 Disruptor 两个框架. 以便于快速开发高并发, 低延迟，高吞吐量， 灵活可扩展的网络服务器.(required) :12345678910&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.0.36.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt;(optional) : Spring 框架支持 使用 Spring 框架, 除了 Spring 框架自身带来的 IOC 等便利之外, 还可以快速集成大量优秀的类库, 例如: Hibernate, Mybatis, BoneCP, HikariCP 等等. 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; Flex 通信支持 Flex 客户端和 Java 服务端的通信支持依赖于BlazeDS类库. 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.flex.blazeds&lt;/groupId&gt; &lt;artifactId&gt;flex-messaging-core&lt;/artifactId&gt; &lt;version&gt;4.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.flex.blazeds&lt;/groupId&gt; &lt;artifactId&gt;flex-messaging-common&lt;/artifactId&gt; &lt;version&gt;4.7.2&lt;/version&gt;&lt;/dependency&gt; 4. 项目中使用示例 1: Okra 框架搭建 HTTP 服务器示例 2: Okra 框架搭建 Socket 服务器Java 服务器 Demo: okra-demo5. 总结本文旨在帮助初次接触 Okra 框架的用户，快速搭建基于 Okra 的网络服务器. 提供了两个简单的示例和一个相对来说比较完整的服务端 demo.用户在实际开发过程中遇到问题或者 BUG 欢迎反馈到issues."
    } ,
  
    {
      "title"       : "Okra框架(三) 搭建HTTP服务器",
      "category"    : "",
      "tags"        : "Okra框架",
      "url"         : "./okra/2016/04/18/Okra_Example_HTTP.html",
      "date"        : "2016-04-18 20:58:00 +0800",
      "description" : "",
      "content"     : "Okra 通过封装成熟高效的框架以简化应用程序服务器构建的过程。上一篇介绍了使用 Okra 快速搭建 Socket 服务器。本篇承接上一篇，介绍快速搭建简单高性能的 Http 服务器。这里需要说明一下 Okra 框架不适用于 web 服务器。Okra 的通信是基于 Netty 框架的，而 Netty 本身不提供强有力的 web 相关功能支持。但是作为 app 或者是网页游戏的短连接服务器，Okra 还是绰绰有余的。1. 创建 Executor和 Socket 服务器搭建流程类似。首先实现一个简单的 HttpRequestExecutor，用于处理 Http 请求:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class HttpRequestExecutor implements Executor { private static final Logger LOG = LogManager.getLogger(HttpRequestExecutor.class); protected Session session; protected FullHttpRequest request; public HttpRequestExecutor(Session session, FullHttpRequest request) { this.session = session; this.request = request; } @Override public void onExecute() { if (null == request) { throw new NullPointerException(\"request\"); } try { QueryStringDecoder decoder = new QueryStringDecoder(request.getUri()); switch (decoder.path()) { case \"/test\": response(session.ctx(), \"{state:0}\"); return; case \"/favicon.ico\": break; } simple(session.ctx().channel(), HttpResponseStatus.FORBIDDEN); } catch (Exception e) { session.ctx().close(); LOG.info(\"HTTP Api throw exception : \", e); } } private static void simple(Channel channel, HttpResponseStatus status) { ChannelFuture channelFuture = channel.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status)); channelFuture.addListener(ChannelFutureListener.CLOSE); } private static void response(ChannelHandlerContext ctx, String msg) { HttpResponse response; if (msg != null) { ByteBuf byteBuf = Unpooled.wrappedBuffer(msg.getBytes()); response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, byteBuf); } else { response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK); } ChannelFuture channelFuture = ctx.channel().writeAndFlush(response); channelFuture.addListener(ChannelFutureListener.CLOSE); } @Override public void release() { this.session = null; this.request = null; }}Okra 提供了封装好的 Disruptor 桥用于 Netty 结合 Disruptor。Okra 通过 Executor 工厂让用户可以便捷灵活的定制特殊的处理者.继承 DisruptorAdapterBy41xHandler（依赖于Netty4.1.x）或者 DisruptorAdapterHandler（依赖于 Netty4.0.x）实现创建 HttpRequestExecutor 的 Executor 工厂。123456public class ExampleApiHandler extends DisruptorAdapterBy41xHandler&lt;FullHttpRequest&gt; { @Override protected Executor newExecutor(Session session, FullHttpRequest msg) { return new HttpRequestExecutor(session, msg); }}2. 创建 Server然后创建一个 Server 继承 TcpProtocolServer 实现自己的服务器类. 增加 Handler 处理1234567891011121314151617181920public class HttpServer extends TcpProtocolServer { public HttpServer(int port) { setPort(port); } @Override protected ChannelHandler newChannelInitializer() { return new ChannelInitializer&lt;NioSocketChannel&gt;() { @Override protected void initChannel(NioSocketChannel ch) throws Exception { ChannelPipeline cp = ch.pipeline(); cp.addLast(\"decoder\", new HttpRequestDecoder()); cp.addLast(\"encoder\", new HttpResponseEncoder()); cp.addLast(\"aggregator\", new HttpObjectAggregator(1048576)); cp.addLast(\"handler\", new ExampleApiHandler()); } }; }}3. 启动服务器假如你的项目中使用了 Spring 框架，那么只需要在配置如下 bean 就可以启动:1234&lt;!-- Http protocol server --&gt;&lt;bean id=\"httpServer\" class=\"org.ogcs.okra.example.http.HttpServer\" init-method=\"start\" destroy-method=\"stop\"&gt; &lt;constructor-arg name=\"port\" value=\"${http.port}\"/&gt;&lt;/bean&gt;普通 Java 程序:12HttpServer server = new HttpServer(9005);server.start();只需要简短的两行代码就可以启动服务器了。4. 总结和搭建 Socket 服务器基本类似。更换了处理协议的 Handler 和处理并发任务的 Executor。基本结构并无太大变更（感谢 Netty 框架，呦吼！）本文介绍了使用 Okra 快速搭建高可用，高性能，可扩展，高并发服务器的示例。Okra 通过封装，简化了服务器搭建过程。"
    } ,
  
    {
      "title"       : "Okra框架(二) 搭建Socket服务器",
      "category"    : "",
      "tags"        : "Okra框架",
      "url"         : "./okra/2016/04/18/Okra_Example_TCP.html",
      "date"        : "2016-04-18 19:29:00 +0800",
      "description" : "",
      "content"     : "本文将介绍使用 Okra 框架帮助开发者快速搭建高性能应用程序 Socket 服务端。博主接触的网络游戏（包含但不限于网页, 手机）的服务端通信使用的协议基本上就 Socket，Http 或是 WebSocket 三种方式。本系列教程将介绍利用 Okra 框架这三种通信方式的示例。1. 创建 Executor在通信过程中，我们可以把每一个消息可以当做是一个任务。Executor 则是 Okra 中负责处理每一条消息的任务执行者。同时，每一个 Executor 都是一个并发线程。如下代码实现一个简单的示例 ObjectExecutor:12345678910111213141516171819202122232425public class ObjectExecutor implements Executor { protected Session session; protected Object request; public ObjectExecutor(Session session, Object request) { this.session = session; this.request = request; } @Override public void onExecute() { if (null == request) { throw new NullPointerException(\"request\"); } // TODO: Just send message back, do some logic on real session.writeAndFlush(String.valueOf(request)); } @Override public void release() { this.session = null; this.request = null; }}Okra 提供了封装好的 Disruptor 桥用于 Netty 结合 Disruptor。Okra 通过 Executor 工厂让用户可以便捷灵活的定制特殊的处理者.123456public class ExampleSocketHandler extends DisruptorAdapterBy41xHandler&lt;Object&gt; { @Override protected Executor newExecutor(Session session, Object msg) { return new ObjectExecutor(session, msg); }}2. 创建 Server然后创建一个 Server 继承 TcpProtocolServer 实现自己的服务器类. 增加 Handler 处理12345678910111213141516171819202122public class TcpServer extends TcpProtocolServer { public TcpServer(int port) { setPort(port); } private static final ChannelHandler FRAME_PREPENDER = new LengthFieldPrepender(4, false); @Override protected ChannelHandler newChannelInitializer() { return new ChannelInitializer&lt;NioSocketChannel&gt;() { @Override protected void initChannel(NioSocketChannel ch) throws Exception { ChannelPipeline cp = ch.pipeline(); cp.addLast(\"frame\", new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 2, 0, 2)); cp.addLast(\"prepender\", FRAME_PREPENDER); // Any other useful handler cp.addLast(\"handler\", new ExampleSocketHandler()); } }; }}3. 启动服务器假如你的项目中使用了 Spring 框架，那么只需要在配置如下 bean 就可以启动:1234&lt;!-- Tcp server --&gt;&lt;bean id=\"tcpServer\" class=\"org.ogcs.okra.example.socket.TcpServer\" init-method=\"start\" destroy-method=\"stop\"&gt; &lt;constructor-arg name=\"port\" value=\"${tcp.port}\"/&gt;&lt;/bean&gt;普通 Java 程序:12TcpServer server = new TcpServer(9005);server.start();只需要简短的两行代码就可以启动服务器了。4. 总结本文介绍了使用 Okra 快速搭建高可用，高性能，可扩展，高并发服务器的示例。Okra 通过封装，简化了服务器搭建过程。"
    } ,
  
    {
      "title"       : "Okra框架(一) 简介",
      "category"    : "",
      "tags"        : "Okra框架",
      "url"         : "./okra/2016/04/18/Okra_Framework_Intruduce.html",
      "date"        : "2016-04-18 19:26:00 +0800",
      "description" : "",
      "content"     : "Okra 是一个构建在 Netty 框架和 Disruptor 框架之上轻量级 JAVA 服务器框架。使用 Netty 实现高性能，可灵活扩展的网络通信，使用 Disruptor 实现高吞吐量，低延迟的并发。Okra 主要依赖如下： Netty 4.x 以上版本 Disruptor 3.3.x 以上版本 JDK 1.8 above相关资料:GitHub WikiOkra 开源在 GitHub开源地址 : https://github.com/ogcs/Okra/为什么叫 Okra?Okra 中文意思是秋葵。作者一直很想试试，但一直都没机会吃。所以就这么称呼，已提醒自己啥时候有机会要尝试一下。"
    } ,
  
    {
      "title"       : "Rust笔记(一) 搭建开发环境",
      "category"    : "",
      "tags"        : "Rust笔记",
      "url"         : "./rust/2016/04/15/Rust_Note_1.html",
      "date"        : "2016-04-15 14:14:00 +0800",
      "description" : "",
      "content"     : "Rust 是一门强调安全、并发、高效的系统编程语言。无 GC 实现内存安全机制、无数据竞争的并发机制、无运行时开销的抽象机制，是 Rust 独特的优越特性。它声称解决了传统 C 语言和 C++语言几十年来饱受责难的内存安全问题，同时还保持了很高的运行效率、很深的底层控制、很广的应用范围，在系统编程领域具有强劲的竞争力和广阔的应用前景。搭建 Rust 开发环境博主从 Rust 0.9 版本时开始关注 Rust 项目。到现在落笔时 Rust 的 1.8 稳定版本。感觉是时候接触一下这门新系统级编程语言了。Rust 诞生至今还不算很长，虽然社区等对各种 IDE 都有了初步支持，但是相比于其他老牌语法而言，仍很不完善。本文记录博主搭建 Rust 环境的流程和遇到的坑需求： Rust 环境 Visual Studio 2015 VisualRust 插件 racer 代码补全1.1 安装 Rust 环境选择适合自己开发平台的 Rust 包.由于博主使用的是 VS2015，这里选择下载 Rust 的 MSVC 安装包。另外一个需要下载的是 source 包（用于 rust 标准库的代码提示）。双击运行”rust-1.8.0-x86_64-pc-windows-msvc.msi”启动 windows 操作系统的安装程序. 默认安装路径: C:\\Progrem Files\\Rust *** 版本号 自定义安装路径: 点选”advanced”按钮.在设置里面安装路径和需要的模块.一路 Next 然后 Finish 由于需要写入注册列表和修改环境变量，所以操作系统中安装了安全软件的请允许安装器操作1.2 校验 Rust 编译环境运行 windows 命令行(快捷键:Win + R 输入 cmd 回车). 输入如下命令并回车12&gt; rustc --version&gt; cargo --version正确输出版本信息说明安装和环境变量配置成功.假如出现 “‘rustc’不是内部或外部命令，也不是可运行的程序或批处理文件”请在”环境变量”的 Path 中增加 rust 的 bin 目录cargocargo 是 rust 官方推荐使用的项目管理软件。功能大概类似于 java 里面的 maven 和 ant。负责管理依赖项和编译。安装 rust 时，默认安装(可以自定义为不安装)2 安装 VisualRust 插件VisualRust 插件下载地址: MSDN-VisualRust下载插件，选择对应的 Visual Studio 版本安装即可.3 安装 racerracer 是 rust 社区里面出现的一个代码补全提示工具。针对多种 IDE 都有相对应的支持。(截至于 v1.2.6 版本貌似只支持标准库的代码提示)在命令行中输入如下指令并回车:1&gt; cargo install racer此方法来自《Rust primer》pdf 电子书。博主一直无法编译安装成功。所以采用了下载源码包编译的办法，具体办法如下 在https://github.com/phildawes/racer项目下载最新的 racer 包 在解压缩之后的目录中，使用 cargo 编译 racer12&gt; cd racer&gt; cargo build --release编译需要联网，cargo 会管理和下载 racer 的相关依赖。中途可能会出现编译失败（基本上都是因为网络原因无法下载到，你懂的）。多尝试编译几次即可。编译完成，在 racer 目录下面的 target 目录会生成一个 racer.exe 的可执行文件将 racer.exe 文件复制到 rust 的 bin 目录下3.1 在 VS2015 中配置 racer点击”工具” -&gt; “选项” -&gt; “Visual Rust” 界面如下:根据 racer.exe 的路径配置。设置 rust 源码的 source/src 的目录。博主这里设置了 RUST_SRC_PATH 的环境变量，所以无需手动设置 Rust sources 的路径至此，在 Windows 10 操作系统中使用 Visual Studio 2015 开发 Rust 的环境就搭建完成了。enjoy it !:)"
    } ,
  
    {
      "title"       : "搭建自己的GitHub Pages",
      "category"    : "",
      "tags"        : "GitHub, Blog",
      "url"         : "./github/2016/04/13/Build_GitHub_Pages.html",
      "date"        : "2016-04-13 17:54:00 +0800",
      "description" : "",
      "content"     : "本文记录博主使用 Win 10 操作系统和 Jekyll 3.1.2 搭建 GitHub Pages 的过程。希望能帮助到相同有需要的朋友。[2016-10-09 补充]升级 Jekyll 到 3.2基本需求 GitHub账号及一个命名为{GitHub 昵称}.github.io 的仓库 Jekyll 软件 Jekyll 官网, Jekyll 中文站1.创建 GitHub 账号及用户名开头的仓库:）.本步骤默认已经完成。2. 安装 JekyllJekyll 是一个将纯文本转换为静态博客网站的轻量级快速建站工作。也是 GitHub Page 官方推荐使用的静态网站生成工具(大量应用于 GitHub 内)。下面开始安装过程。Jekyll 是有 Ruby 开发, 所以依赖于 Ruby 环境。所以我们的第一步就是安装 Ruby 环境2.1 安装 Ruby 环境下载 Ruby 环境和开发者工具包。下载地址：Ruby Windows 平台。Ruby 环境安装包：Ruby DevKit 安装包：安装完成后打开命令行(或 Win + R, 输入 cmd 回车)输入 ruby -version ：2.2 安装 Jekyll在命令行中使用如下命令安装 Jekyll:1&gt; gem install jekyll笔者出现安装失败的情况。Google 之后一说百说的推荐了淘宝 Gem 仓库，但是博主无法成功更换使用淘宝的 Gem（HTTPS）。(淘宝的 Gem 目前已不支持 Http 连接)。经过一番研究解决,博主命令如下:1&gt; gem sources --remove https://rubygems.org/ -a http://rubygems.org/怀疑可能是 Windows Installer 安装的 Ruby 对 Https 支持不是很好。更换为 http 源就解决问题了。2.3 markdown 文档解析Jekyll 默认的 md 文档解析器是 kramdown，缺省的代码高亮插件是 rouge。详细的缺省配置见:Jekyll 缺省配置.未安装的可以使用以下命令安装.12&gt; gem install kramdown&gt; gem install rouge2.4 代码高亮无代码高亮需求的小伙伴无视本节内容即可。Jekyll 相关的代码高亮插件有很多。本站使用 CodeRay + rouge 实现代码高亮。示例配置如下:123456789101112markdown: kramdown # [rdiscount, karkdown]highlighter: rouge # [rouge, pygments]kramdown: input: GFM extensions: - autolink - footnotes - smart enable_coderay: true syntax_highlighter: rouge coderay: coderay_line_numbers: nil2.4 创建 Jekyll 模板创建一个简单的缺省页面示例。123&gt; jekyll new myblog&gt; jekyll build&gt; jekyll server在浏览器访问127.0.0.1:4000预览文字及内容本站使用的是 Jekyll-uno 模板，遵循 MIT 开源协议(博主通过 Google 搜索出来的)。参考资料 GitHub Pages 官方引导 一步一步引导在 Windows 系统安装 Jekyll CodeRay 插件 rouge 插件"
    } ,
  
    {
      "title"       : "Netty4.x中文教程系列(七) UDP协议",
      "category"    : "",
      "tags"        : "Netty4.x中文教程系列",
      "url"         : "./netty/2015/06/10/Netty4.x_7.html",
      "date"        : "2015-06-10 21:12:00 +0800",
      "description" : "",
      "content"     : "　　将近快一年时间没有更新Netty的博客。一方面原因是因为项目进度的问题。另外一方面是博主有一段时间去熟悉Unity3D引擎。　　本章节主要记录博主自己Netty的UDP协议使用。　　1.　　构建UDP服务端　　首先我们应该清楚UDP协议是一种无连接状态的协议。所以Netty框架区别于一般的有链接协议服务端启动程序（ServerBootstrap）。　　Netty开发基于UDP协议的服务端需要使用Bootstrap　　 1 package dev.tinyz.game; 2 3 import io.netty.bootstrap.Bootstrap; 4 import io.netty.buffer.Unpooled; 5 import io.netty.channel.*; 6 import io.netty.channel.nio.NioEventLoopGroup; 7 import io.netty.channel.socket.DatagramPacket; 8 import io.netty.channel.socket.nio.NioDatagramChannel; 9 import io.netty.handler.codec.MessageToMessageDecoder;1011 import java.net.InetSocketAddress;12 import java.nio.charset.Charset;13 import java.util.List;1415 /**16 * @author TinyZ on 2015/6/8.17 */18 public class GameMain {1920 public static void main(String[] args) throws InterruptedException {2122 final NioEventLoopGroup nioEventLoopGroup = new NioEventLoopGroup();2324 Bootstrap bootstrap = new Bootstrap();25 bootstrap.channel(NioDatagramChannel.class);26 bootstrap.group(nioEventLoopGroup);27 bootstrap.handler(new ChannelInitializer&lt;NioDatagramChannel&gt;() {2829 @Override30 public void channelActive(ChannelHandlerContext ctx) throws Exception {31 super.channelActive(ctx);32 }3334 @Override35 protected void initChannel(NioDatagramChannel ch) throws Exception {36 ChannelPipeline cp = ch.pipeline();37 cp.addLast(\"framer\", new MessageToMessageDecoder&lt;DatagramPacket&gt;() {38 @Override39 protected void decode(ChannelHandlerContext ctx, DatagramPacket msg, List&lt;Object&gt; out) throws Exception {40 out.add(msg.content().toString(Charset.forName(\"UTF-8\")));41 }42 }).addLast(\"handler\", new UdpHandler());43 }44 });45 // 监听端口46 ChannelFuture sync = bootstrap.bind(9009).sync();47 Channel udpChannel = sync.channel();4849 // String data = \"我是大好人啊\";50 // udpChannel.writeAndFlush(new DatagramPacket(Unpooled.copiedBuffer(data.getBytes(Charset.forName(\"UTF-8\"))), new InetSocketAddress(\"192.168.2.29\", 9008)));5152 Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {53 @Override54 public void run() {55 nioEventLoopGroup.shutdownGracefully();56 }57 }));58 }59 } View Code　　于Tcp协议的客户端启动程序基本一样。唯一区别就在于，UDP服务器使用的是bind方法，来监听端口　　在Netty的Bootstrap类中的注释，发现有如下注释内容：　　　　大意就是：bind()用于UDP， TCP连接使用connect()。　　上面的源码监听的是端口9009，那么所有使用UDP协议的数据，发送到端口9009，就会被我们的Netty接收到了。　　为了输出方便，博主在上面的代码中增加一个MessageToMessageDecoder将接收到的Datagram，排除其他信息，仅将字符串传递下去。并在UDPHandler中打印出来。　　2.　　构建UDP客户端　　UDP协议来说，其实没有客户端和服务端的区别啦。只是为了贴近TCP协议做的一点文字描述上面的区分。　　简单来讲，上面的那段逻辑其实就可以作为UDP客户端来使用。注释掉的那行逻辑其实就是发送&ldquo;我是大好人啊&rdquo;这个字符串到ip地址为192.168.2.29的服务端的9008端口。代码如下：　　 1 package dev.tinyz.game; 2 3 import io.netty.bootstrap.Bootstrap; 4 import io.netty.buffer.Unpooled; 5 import io.netty.channel.*; 6 import io.netty.channel.nio.NioEventLoopGroup; 7 import io.netty.channel.socket.DatagramPacket; 8 import io.netty.channel.socket.nio.NioDatagramChannel; 9 import io.netty.handler.codec.MessageToMessageDecoder;1011 import java.net.InetSocketAddress;12 import java.nio.charset.Charset;13 import java.util.List;1415 /**16 * @author TinyZ on 2015/6/8.17 */18 public class GameMain {1920 public static void main(String[] args) throws InterruptedException {2122 final NioEventLoopGroup nioEventLoopGroup = new NioEventLoopGroup();2324 Bootstrap bootstrap = new Bootstrap();25 bootstrap.channel(NioDatagramChannel.class);26 bootstrap.group(nioEventLoopGroup);27 bootstrap.handler(new ChannelInitializer&lt;NioDatagramChannel&gt;() {2829 @Override30 public void channelActive(ChannelHandlerContext ctx) throws Exception {31 super.channelActive(ctx);32 }3334 @Override35 protected void initChannel(NioDatagramChannel ch) throws Exception {36 ChannelPipeline cp = ch.pipeline();37 cp.addLast(\"framer\", new MessageToMessageDecoder&lt;DatagramPacket&gt;() {38 @Override39 protected void decode(ChannelHandlerContext ctx, DatagramPacket msg, List&lt;Object&gt; out) throws Exception {40 out.add(msg.content().toString(Charset.forName(\"UTF-8\")));41 }42 }).addLast(\"handler\", new UdpHandler());43 }44 });45 // 监听端口46 ChannelFuture sync = bootstrap.bind(0).sync();47 Channel udpChannel = sync.channel();4849 String data = \"我是大好人啊\";50 udpChannel.writeAndFlush(new DatagramPacket(Unpooled.copiedBuffer(data.getBytes(Charset.forName(\"UTF-8\"))), new InetSocketAddress(\"192.168.2.29\", 9008)));5152 Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {53 @Override54 public void run() {55 nioEventLoopGroup.shutdownGracefully();56 }57 }));58 }59 } View Code　　和上面的&ldquo;服务端&rdquo;代码最大的差别就是，监听的端口号修改成0.为　　使用Netty的Channel发送DatagramPacket。写好目标地址，然后运行起来就可以自己测试一下了。　　3.　　JAVA原生UDP　　有朋友这个时候就会问：为什么不是有JAVA原生的UDP呢？　　其实很简单。说白了Netty使用的也是Java底层的代码。只是做了一层封装，以便于使用。服务端使用Netty框架构建高性能，高扩展的UDP服务器。　　客户端则使用JAVA或者任意其他的语言的API（遵循UDP协议即可）。　　下面上一段博主使用的的JAVA　　 1 package dev.tinyz.game; 2 3 import java.io.IOException; 4 import java.net.DatagramPacket; 5 import java.net.DatagramSocket; 6 import java.net.InetSocketAddress; 7 import java.nio.charset.Charset; 8 9 /**10 * @author TinyZ on 2015/6/10.11 */12 public class UdpTest {1314 public static void main(String[] args) throws IOException {15 final String data = \"博主邮箱:zou90512@126.com\";16 byte[] bytes = data.getBytes(Charset.forName(\"UTF-8\"));17 InetSocketAddress targetHost = new InetSocketAddress(\"192.168.2.29\", 9009);1819 // 发送udp内容20 DatagramSocket socket = new DatagramSocket();21 socket.send(new DatagramPacket(bytes, 0, bytes.length, targetHost));22 }23 } View Code　　..　　ps.UDP协议最大特点就是效率高，速度快。用于某些场合可以极大改善系统的性能。&nbsp;"
    } ,
  
    {
      "title"       : "Netty4.x中文教程系列(六) 从头开始Bootstrap",
      "category"    : "",
      "tags"        : "Netty4.x中文教程系列",
      "url"         : "./netty/2014/08/12/Netty4.x_6.html",
      "date"        : "2014-08-12 18:24:00 +0800",
      "description" : "",
      "content"     : "&nbsp;&nbsp;&nbsp;&nbsp;其实自从中文教程系列（五）一直不知道自己到底想些什么。加上忙着工作上出现了一些问题。本来想就这么放弃维护了。没想到有朋友和我说百度搜索推荐了我的文章。瞬间有点小激动啊。决定自己要把这个教程系列完善下去。这里诚挚的想支持我的盆友们道歉。真的是让你们失望了。我居然有想放弃的这种丧心病狂的念头。以后绝对不会了。&nbsp;&nbsp;&nbsp;&nbsp;其实伴随着对Netty的逐步深入学习。感觉自己对netty的了解仍然有所欠缺。加上笔者语文课是美术老师教的。所以。。说多了都是泪啊。~~o(&gt;_&lt;)o ~~&nbsp;&nbsp;下面开始正文：纵览Netty框架的包结构，不难看出。其实Netty是有五大模块组成。 Bootstrap负责启动引导 Buffer是Netty自己封装的缓存器 Channel负责管理和建立连接 Handler是责任链路模式中的处理者 Util是Netty提供和使用到的一些工具 如何启动Netty服务器&nbsp;&nbsp;&nbsp;&nbsp;Netty的启动服务器相关的类全部都在bootstrap包里面。所以本章我们从头开始，从bootstrap包里面的内容开始。从创建一个Netty服务器开始为大家逐步讲解Netty的应用。相比于第五章的ChannelHandler里面的编解码器bootstrap里面可以说是内容少的可怜。来看一下他的包内容：简简单单的三个类，一个接口。Bootstrap是客户端的启动程序类。ServerBootstrap是服务端的启动程序类Bootstrap和ServerBootstrap继承AbstractBootstrap。ChannelFactory则是AbstractBootstrap中用于创建Channel的接口以下代码以服务端的启动程序启动为例：步骤一：实例化ServerBootstrap首先我们需要实例化一个ServerBootstrap服务端启动引导程序。如下图：步骤二：设置它的线程组&nbsp;&nbsp;&nbsp;&nbsp;创建两个NioEventLoopGroup，一个是父线程（Boss线程），一个是子线程(work线程)。设置bootstrap的线程组设置线程组主要的目的是为了处理Channel中的事件和IO操作。&nbsp;下图为ServerBootstrap的group方法的源码：父线程组被传递到父类中。详细的解释在最后面。涉及的东西太多。在后面在进行解释。步骤三：设置Channel类型&nbsp;&nbsp;&nbsp;&nbsp;设置Channel类型：&nbsp;下图ServerBootstrap中channel()方法的源码：&nbsp;我们可以看到创建并设置了一个Channel工厂。下图是BootstrapChannelFactory的源码。它是一个终态的静态的类。实现ChannelFactory。作用是根据初始设置的Channel类型，创建并返回一个新的Channel。步骤四：设置责任链路&nbsp;&nbsp;&nbsp;&nbsp;责任链模式是Netty的核心部分。每个处理者只负责自己有关的东西。然后将处理结果根据责任链传递下去。&nbsp;&nbsp;&nbsp;&nbsp;我们要在初始的设置一个责任链路。当一个Channel被创建之后初始化的时候将被设置。下图是ServerBootstrap在init（）方法的源码：创建一个Channel，在初始化的设置管道里面的处理者。&nbsp;步骤五：绑定并监听端口&nbsp;&nbsp;&nbsp;&nbsp;绑定并设置监听端口。&nbsp;&nbsp;&nbsp;&nbsp;经过以上的5个步骤，我们的服务器就足以启动了。很多的设置都是Netty默认的。我们想设置自己的参数怎么办呢？Netty提供了这个方法。&nbsp;步骤六：其他设置1. 设置Channel选项配置：在Netty 以前的版本中都是以字符串来配置的。4.x版本发布之后统一修改为使用ChannelOption类来实现配置。例如：Socket连接是否保存连接:&nbsp;&nbsp;&nbsp;&nbsp;还有很多其他的参数。如下图所示：这里不详细讲了。参考：io.netty.channel.ChannelOption&nbsp;2. 设置子Channel的属性：&nbsp;&nbsp;&nbsp;&nbsp;设置子Channel的属性。当值为null是，属性将被删除。&nbsp;&nbsp;解释EventLoopGroup这里解释一下我们上面创建的两个完全一样的线程组的作用。Netty的架构使用了非常复杂的主从式Reactor线程模型。简单的说就是。父线程组（代码中的parentBosser）担任（acceptor）的角色。负责接收客户端的连接请求，处理完成请求，创建一个Channel并注册到子线程组（代码中的childWorker）中的某个线程上面，然后这个线程将负责Channel的读写，编解码等操作。&nbsp;源代码查看：在步骤四中我们设置了责任链路。这里是Channel初始化和注册。在这里的init就是Channel的初始化。初始化完成之后。Group()则是获取在步骤一种的设置父线程组，并将这个新的Channel注册进来。下图是AbstractBootstrap的initAndRegister方法&nbsp;方法Init()实现在ServerBootstrap中。代码如下：看到下面的代码是不是有种和熟悉的感觉？没错。就是在步骤四中设置责任链路的那段代码。这里将注册新创建的Channel到子线程组&nbsp;Ps: 完。。。O(&cap;_&cap;)O哈哈~。。。写的好辛苦的说。。。附上我的测试示例代码。好累。。写这么多字。希望能帮助到大家&nbsp; 1 import io.netty.bootstrap.ServerBootstrap; 2 import io.netty.channel.*; 3 import io.netty.channel.nio.NioEventLoopGroup; 4 import io.netty.channel.socket.nio.NioServerSocketChannel; 5 import io.netty.channel.socket.nio.NioSocketChannel; 6 import io.netty.handler.codec.LengthFieldBasedFrameDecoder; 7 import io.netty.handler.codec.LengthFieldPrepender; 8 9 /**10 * 测试。。O(&cap;_&cap;)O哈哈~11 * Created by TinyZ on 2014/8/12.12 */13 public class MainTest {1415 public static void main(String[] args) throws Exception {1617 NioEventLoopGroup parentBosser = new NioEventLoopGroup();18 NioEventLoopGroup childWorker = new NioEventLoopGroup();1920 ServerBootstrap bootstrap = new ServerBootstrap();21 bootstrap.group(parentBosser, childWorker);22 bootstrap.channel(NioServerSocketChannel.class);23 bootstrap.childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() {24 @Override25 protected void initChannel(NioSocketChannel ch) throws Exception {26 ChannelPipeline cp = ch.pipeline();27 // 基于长度的解码器28 cp.addLast(\"framer\", new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 2, 0, 2));29 cp.addLast(\"prepender\", new LengthFieldPrepender(4));30 //31 cp.addLast(\"handler\", new SimpleChannelInboundHandler&lt;Object&gt;() {3233 @Override34 protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {3536 System.out.println();37 ctx.channel().writeAndFlush(msg);3839 }40 });41 }42 });43 bootstrap.option(ChannelOption.SO_KEEPALIVE, true);44 //bootstrap.childAttr()45 try {46 // 绑定并监听端口47 ChannelFuture future = bootstrap.bind(9002).sync();48 // 等待关闭事件49 future.channel().closeFuture().sync();50 } finally {51 // 释放资源52 parentBosser.shutdownGracefully();53 childWorker.shutdownGracefully();54 }55 }56 } View Code&nbsp;&nbsp;作者：TinyZ出处：http://www.cnblogs.com/zou90512/关于作者：努力学习，天天向上。不断探索学习，提升自身价值。记录经验分享。本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接如有问题，可以通过&nbsp;zou90512@126.com&nbsp;联系我，非常感谢。笔者网店: http://aoleitaisen.taobao.com. 欢迎广大读者围观&nbsp;"
    } ,
  
    {
      "title"       : "Netty4.x中文教程系列(五) 编解码器Codec",
      "category"    : "",
      "tags"        : "Netty4.x中文教程系列",
      "url"         : "./netty/2014/04/09/Netty4.x_5.html",
      "date"        : "2014-04-09 14:27:00 +0800",
      "description" : "",
      "content"     : "&nbsp;&nbsp;&nbsp; 上一篇文章详细解释了ChannelHandler的相关构架设计，版本和设计逻辑变更等等。&nbsp;&nbsp;&nbsp; 这篇文章主要在于讲述Handler里面的Codec，也就是相关的编解码器。原本想把编解码器写在上一篇文章里面的。后来想想Netty里面的编解码器太多了。想要一次写完比较困难。于是重新开了一篇文章来专门写这个。1.&nbsp;&nbsp;&nbsp;&nbsp; Hello World ！实例中的使用　　在这里先讲一下我们第一篇文章里面的实例使用到编解码器。1.1 DelimiterBasedFrameDecoder解码器　　DelimiterBasedFrameDecoder 顾名思义我们可以理解为基于分隔符的帧解码器。参数有两个，一个是最大帧长度，另外一个是定义分隔符。在Delimiters中提供给我们两种分隔符。一种是&ldquo;0x00-NUL&rdquo;分隔符。另外一种就是实例中使用的&ldquo;\\r\\n&rdquo;或&ldquo;\\n&rdquo;分隔符。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在构造函数中我们可以看出，当分隔符是&ldquo;\\n&rdquo;的时候，框架默认解码器为基于行的帧解码器（LineBasedFrameDecoder）。否则按照可读取比特长度进行帧解码。1.2 StringDecoder 字符串解码器 和 编码器　　解码器:将比特流转换为默认编码的字符串。默认编码为UTF-8。当然开发者可以通过设置字符编码参数来设置字符编码。编码器:将字符串转换为Byte[]2.&nbsp;&nbsp;&nbsp;&nbsp; Netty中Handler详述　　在Netty的类库的handler目录可以看出它的基本结构(下图)：&nbsp;图2.1 handler包结构　　整个包由6个主要部分组成，笔者将由简入繁，慢慢想读者解释每个包的含义和用法。(若有不正确之处，希望大家能给予指点)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.1 Logging 日志&nbsp;　　　　用于Netty中的日志输出。　　　　2.1.1 loggingHandler　　LoggingHandler 继承于ChannelDuplexHandler。它的注释我们可以看出：&ldquo;是一个使用日志框架记录全部事件的ChannelHandler,&nbsp; 缺省值是记录全部DEBUG级别以上的事件&rdquo;。它的功能是记录全部事件，包含Inbound和Outbound的，之所以选择了继承ChannelDuplexHandler，是由于ChannelDuplexHandler 继承ChannelInboundHandlerAdapter 实现ChannelOutboundHandler。所以相当于Netty框架内的全部通信相关的事件都会得到处理。　　　　2.1.2LogLevel在这里作者定义了5个级别的log。TRACE，DEBUG，INFO，WARN，ERROR。　　2.2 Ssl&nbsp;　　用于SSL协议解析和编码。　　　　2.2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SslHandler　　　　熟悉了解过Http的朋友应该是知道ssl的。SSL 的英文全称是 &ldquo;Secure Sockets Layer&rdquo; ，中文名为 &ldquo; 安全套接层协议层 &rdquo; ，它是网景（ Netscape ）公司提出的基于 WEB 应用的安全协议。 SSL 协议指定了一种在应用程序协议（如 HTTP 、 Telenet 、 NMTP 和 FTP 等）和 TCP/IP 协议之间提供数据安全性分层的机制，它为 TCP/IP 连接提供数据加密、服务器认证、消息完整性以及可选的客户机认证。现在的相当一部分网站都有SSL加密。而SslHander则是Netty提供的Ssl解码编码处理。　　　　2.2.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NotSslRecordException 和 SslHandshakeCompletionEvent&nbsp;抛出异常和处理完成触发事件。　　2.3 Stream 流&nbsp;　　用于文件的的传输。将Java里面的File转换为Stream流，然后进行传输。　　2.4 Timeout 空闲检测&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于Netty框架中空闲超时相关。IdleState 空闲状态。Netty中的空闲时间包括，读空闲，写空闲和读写空闲3种时间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 顾名思义，读空闲即一段时间内没有接受到消息，写空闲即一段时间内没有发送消息。读写空闲即一段时间内读写都空闲。主要是用于检测空闲状态。并且特定条件下服务端关闭和释放一些资源。　　2.5 Traffic 流量统计&nbsp;　　用于流量统计。　　Netty提供了一个流量统计抽象类，一个Channel流量统计Handler和一个全局带宽流量统计Handler。　　2.6 Codec 编解码器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个是目前Netty的重点。也是最核心最复杂的部分。也是笔者认为Netty设计里面最好的一部分。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于数据的编解码。　　编解码器可以理解为订立一个规范让客户端和服务端能够理解和识别字节流所包含的意思。其实编码和解码就是这么简单的事情，没什么复杂的。&nbsp;　　看到codec里面的这么一大堆的包类。读者是不是赶脚着很头晕？ O(&cap;_&cap;)O哈哈~。作者设计了非常友好的包逻辑结构。方便我们理解源码。即Codec包中的类优先看，下面的子包都是一些Netty开发者们提供的一些实现。有没有看到HelloWorld出现的LengthFieldBaseFrameDecoder和FixedLengthFrameDecoder。&nbsp;这里主要讲的是Netty中最重要的两个编解码器ByteToMessageCodec和MessageToMessageCodec。之所只讲着两个的原因是其他的编解码器都是继承于这两个的。ByteToMessageCodec：在Netty4.x版本中允许传递Java中的对象，所以这个编解码起的作用就是讲Byte流转换为对象。而MessageToMessageCodec则是将Object转换为Object。这两个的区分其实很模糊。可能需要大家亲自动手写过之后才会有比较好的感受。包base64：继承MessageToMessageEncoder&lt;ByteBuf&gt;。是base64编码的一些东西。包bytes：继承MessageToMessageEncoder&lt;ByteBuf&gt;。用于字节数组和Netty里面的ByteBuf互相转换包compression：用于ByteBuf数据压缩和解压缩的。继承MessageToMessageEncoder&lt;ByteBuf&gt;包http：用于HTTP请求相关的。这个包里面就比较复杂了。下面详细讲一下。 包空间：HTTP内容，请求，响应等。 包cors: 包名称是（跨域资源分享）Cross Origin Resource Sharing 的简写。用于客户端跨域请求。&nbsp; 可以参考 http://www.w3.org/TR/cors/ 包multipart：POST消息和文件上传相关的一些。只是粗略看了一下。 包websocketx：针对近年来Html5发展起来的websocket技术的。不过貌似由于Html5标准还未正式的确定。所以这个包里面的内容比较多。编解码器版本也很多。相信以后统一标准之后会简单一些。暂时不推荐吧包marshalling：包protoBuf：用于Google Protocol Buffers 编解码包rtsp：实时流传输协议（Real Time Streaming Protocol，RTSP）包sctp：流控制传输协议（Stream Control Transmission Protocol，SCTP）包serialization：用于序列化的Java对象的和ByteBuf之间的转换。包scoks：用于Java Socket通信相关的。支持Socket4a和 Socket 5两个版本包spdy：SPDY协议是近年来发展的一种协议。主要目的是为了减少网页加载的时间。它是HTTP协议的增强版本。它从某种程度上讲提高了HTTP协议在数据传输时的速度和性能包string：用于java里面字符串的编解码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者：TinyZ出处：http://www.cnblogs.com/zou90512/关于作者：努力学习，天天向上。不断探索学习，提升自身价值。记录经验分享。本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接如有问题，可以通过&nbsp;zou90512@126.com&nbsp;联系我，非常感谢。笔者网店: http://aoleitaisen.taobao.com. 欢迎广大读者围观&nbsp;"
    } ,
  
    {
      "title"       : "Netty4.x中文教程系列(四) ChannelHandler",
      "category"    : "",
      "tags"        : "Netty4.x中文教程系列",
      "url"         : "./netty/2014/01/15/Netty4.x_4.html",
      "date"        : "2014-01-15 17:32:00 +0800",
      "description" : "",
      "content"     : "&nbsp;&nbsp;&nbsp; 上一篇文章详细解释了Hello World示例的代码。里面涉及了一些Netty框架的基础。&nbsp;&nbsp;&nbsp; 这篇文章用以解释ChannelHandler。笔者本身在以前写过文章ChannelHandler改动及影响 和 ChannelInitializer 学习 对Netty的.ChannelHandler做过阐述。里面主要描述了4.x版本相对于3.x版本的改动以及影响。并引用了一些文章。为大家详细的解释了ChannelHandler里面涉及架构。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.在4.x版本中的ChannelHandler&nbsp;&nbsp;&nbsp; ChannelHandler接口是Handler里面的最高的接口。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ChannelInboundHandler接口和ChannelOutboundHandler接口，继承ChannelHandler接口。&nbsp;&nbsp;&nbsp; 流程如下图:&nbsp;&nbsp;&nbsp;&nbsp; ChannelInBoundHandler负责数据进入并在ChannelPipeline中按照从上至下的顺序查找调用相应的InBoundHandler。&nbsp;&nbsp;&nbsp; ChannelOutBoundHandler负责数据出去并在ChannelPipeline中按照从下至上的顺序查找调用相应的OutBoundHandler。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.在5.x版本中的改动&nbsp;&nbsp;&nbsp; 在5.x版本中。作者再次对ChannelHandler进行了改动。&nbsp;&nbsp;&nbsp; 在更新说明里可以看到:&nbsp;&nbsp;&nbsp; 作者简化了Handler的类型层次结构。ChannelInboundHandler和ChannelOutboundHandler接口合并到ChannelHandler里面。ChannelInboundHandlerAdapter，ChannelOutboundHandlerAdapter以及ChannelDuplexHandlerAdapter被取消，其功能被ChannelHandlerAdapter代替。由于上述的改动，开发者将无法区分InBoundHandler和OutBoundHandler 所以CombinedChannelDuplexHandler&nbsp;的功能也被ChannelHandlerAdapter代替。有兴趣了解的可以看一下注释。假如不看也影响不大。因为5.x看上去改动很大，实际上框架的设计思路并没有改变。&nbsp;(注释:5.x版本中虽然删除了InBoundHandler和OutBoundHandler，但是在设计思想上InBound和OurBound的概念还是存在的。只不过是作者使用了另外一种方式去实现罢了。查看过4.x版本代码的朋友可能已经了解知道了。消息在管道中都是以ChannelHandlerContext的形势传递的。而InBound和OutBound主要作用是被当做ChannelPipeline管道中标识。用于Handler中相对应的调用处理，通过两个布尔值变量inBound和outBound来区分是进入还是出去。并以此来区分Handler并调用相应的方法，其实没有什么实际用途。于是作者在5.x版本中对此做出了优化。优化方案笔者感觉very nice。由于删除了InBoundHandler和OutBoundHandler的接口。作者在DefaultChannelHandlerContext中重写了findContextInBound()和findContextOutBound()方法。并且在方法里引入了参数mask。在类开始处定义静态终态的变量来标记4.x版本中定义的InBound和OutBound中的方法名(可以变相的认为是枚举)。在源代码中的实现是利用mask来获取对应的flag，最终实现使用mask来区分InBoundHandler亦或是OutBoundHandler。这样的改动，优点显而易见。简化了层次结构，降低了框架的复杂度。同时功能上却没有什么变化。易于使用了解。)目前在不涉及框架底层的情况下。笔者将继续使用Netty 4.0.14 final版本。正如第一章介绍所说。5.x版本作者并没有进行大规模的设计变更。仅仅只是局部的小部分修改。所以在版本没有稳定之前。教程都将采用4.0.14final为框架包。3.认识Handler中的编解码器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 编解码器在Netty框架中占了相当大的一部分代码量。由此可见其重要性。本章内容旨在阐述编解码器的基础。下一章会详细分类的按照框架的结构详解其余编解码器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在Netty的codec包内部我们可以看到很多的编解码器和一些异常捕获。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下一章为大家相熟Handler里面的各种编解码器。&nbsp;&nbsp;作者：TinyZ出处：http://www.cnblogs.com/zou90512/关于作者：努力学习，天天向上。不断探索学习，提升自身价值。记录经验分享。本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接如有问题，可以通过&nbsp;zou90512@126.com&nbsp;联系我，非常感谢。笔者网店: http://aoleitaisen.taobao.com. 欢迎广大读者围观&nbsp;"
    } ,
  
    {
      "title"       : "Netty4.x中文教程系列(三) Hello World ！详解",
      "category"    : "",
      "tags"        : "Netty4.x中文教程系列",
      "url"         : "./netty/2014/01/06/Netty4.x_3.html",
      "date"        : "2014-01-06 18:33:00 +0800",
      "description" : "",
      "content"     : "&nbsp;&nbsp;&nbsp; 上一篇文章，笔者提供了一个Hello World 的Netty示例。&nbsp;&nbsp;&nbsp; 时间过去了这么久，准备解释一下示例代码。1.HelloServer 详解&nbsp;&nbsp;&nbsp; HelloServer首先定义了一个静态终态的变量---服务端绑定端口7878。至于为什么是这个7878端口，纯粹是笔者个人喜好。大家可以按照自己的习惯选择端口。当然了。常用的几个端口(例如:80,8080,843(Flash及Silverlight策略文件请求端口等等)，3306(Mysql数据库占用端口))最好就不要占用了，避免一些奇怪的问题。&nbsp;&nbsp;&nbsp; HelloServer类里面的代码并不多。只有一个main函数，加上内部短短的几行代码。&nbsp;&nbsp;&nbsp; Main函数开始的位置定义了两个工作线程，一个命名为WorkerGroup，另一个命名为BossGroup。都是实例化NioEventLoopGroup。这一点和3.x版本中基本思路是一致的。Worker线程用于管理线程为Boss线程服务。讲到这里需要解释一下EventLoopGroup，它是4.x版本提出来的一个新概念。类似于3.x版本中的线程。用于管理Channel连接的。在main函数的结尾就用到了EventLoopGroup提供的便捷的方法，shutdownGraceFully()，翻译为中文就是优雅的全部关闭。感觉是不是很有意思。作者居然会如此可爱的命名了这样一个函数。查看相应的源代码。我们可以在DefaultEventExecutorGroup的父类MultithreadEventExecutorGroup中看到它的实现代码。关闭了全部EventExecutor数组child里面子元素。相比于3.x版本这是一个比较重大的改动。开发者可以很轻松的全部关闭，而不需要担心出现内存泄露。&nbsp;&nbsp;&nbsp; 在try里面实例化一个ServerBootstrap b。设置group。设置channel为NioServerSocketChannel。设置childHandler，在这里使用实例化一个HelloServerInitializer类来实现，继承ChannelInitializer&lt;SocketChannel&gt;。内部的代码我们可以在前文的注视中大致了解一下，主要作用是设置相关的字节解码编码器，和代码处理逻辑。Handler是Netty包里面占很大一个比例。可见其的作用和用途。Handler涉及很多领域。HTTP，UDP，Socket，WebSocket等等。详细的部分在本章的第三节解释。设置好Handler绑定端口7878，并调用函数sync()，监听端口(等待客户端连接和发送消息)。并监听端口关闭(为了防止线程停止)。&nbsp;&nbsp;&nbsp; 最后finally我们要优雅的全部关闭服务端。^_^&nbsp;2.HelloClient详解&nbsp;&nbsp;&nbsp; 相比于服务端的代码。客户端要精简一些。&nbsp;&nbsp;&nbsp; 客户端仅仅只需要一个worker的EventLoopGroup。其次是类似于ServerBootstrap的HandlerInitializer。&nbsp;&nbsp;&nbsp; 唯一不同的可能就是客户端的connect方法。服务端的绑定并监听端口，客户端是连接指定的地址。Sync().channel()是为了返回这个连接服务端的channel，并用于后面代码的调用。BufferedReader 这个是用于控制台输入的。不做详细的解释了就。大家都懂的。当用户输入一行内容并回车之后。循环的读取每一行内容。然后使用writeAndFlush向服务端发送消息。3.HandlerInitializer详解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Handler在Netty中是一个比较重要的概念。有着相当重要的作用。相比于Netty的底层。我们接触更多的应该是他的Handler。在这里我将它剥离出来单独解释。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ServerHandlerInitializer继承与ChannelInitializer&lt;SocketChannel&gt;需要我们实现一个initChannel()方法。我们定义的handler就是写在这里面。&nbsp;&nbsp;&nbsp; 在最开始的地方定义了一个DelimiterBasedFrameDecoder。按直接翻译就是基于分隔符的帧解码器。再一次感觉框架的作者的命名，好直接好简单。详细的内容我们在后面的文章中在为大家详细的解释。目前大家知道他是以分隔符为分割标准的解码器就好了。&nbsp;&nbsp;&nbsp; 也许有人会问分隔符是什么？我只能 !*_* :&ldquo;纳尼 ！！&rdquo;。分隔符其实就是&ldquo;\\n&rdquo;我们在学习C语言的时候最常用的的也许就是这个分隔符了吧。&nbsp;&nbsp;&nbsp; 下面的则是StringDecoder 和StringEncoder。字符串解码器和字符串编码器。&nbsp;&nbsp;&nbsp; 最后面则是我们自己的逻辑。服务/客户端逻辑是在消息解码之后处理的。然后服务/客户端返回相关消息则是需要对消息进行相对应的编码。最终才是以二进制数据流的形势发送给服务/客户端的。&nbsp;&nbsp;&nbsp; 内容暂时就写到这里。O(&cap;_&cap;)O哈哈~。后面的东西慢慢为大家完善。&nbsp;&nbsp;&nbsp; 假如有甚么不正确的地方，敬请谅解。求大神指正。&nbsp;作者：TinyZ出处：http://www.cnblogs.com/zou90512/关于作者：努力学习，天天向上。不断探索学习，提升自身价值。记录经验分享。本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接如有问题，可以通过&nbsp;zou90512@126.com&nbsp;联系我，非常感谢。笔者网店: http://aoleitaisen.taobao.com. 欢迎广大读者围观&nbsp;"
    } ,
  
    {
      "title"       : "Netty4.x中文教程系列(二) Hello World !",
      "category"    : "",
      "tags"        : "Netty4.x中文教程系列",
      "url"         : "./netty/2013/12/26/Netty4.x_2.html",
      "date"        : "2013-12-26 18:14:00 +0800",
      "description" : "",
      "content"     : "　　在中国程序界。我们都是学着Hello World !慢慢成长起来的。逐渐从一无所知到熟悉精通的。　　第二章就从Hello World 开始讲述Netty的中文教程。　　首先创建一个Java项目。引入一个Netty 框架的包。这个步骤我在本系列教程的后面就不在重复了。　　先上一张我示例的项目工程图给大家看一下:1.下载并为项目添加Netty框架　　Netty的包大家可以从Netty官网:http://netty.io/downloads.html&nbsp;下载　　如图所示: Netty提供了三个主要版本的框架包给大家下载。3.9版本Final 说明这个版本是3.x版本中最新的版本。final意味着功能不再继续添加更新。仅为修改bug等提供继续的更新。5.x版本由于是开始。不能排除是否稳定运行等问题。加上5.x在4.x的版本上略微修改的。在5.x稳定之前。不推荐大家学习使用。本教程是基于Netty4.x版本的。　　笔者也是从3.6版本，经过了相当痛苦的一段时间才算是真正的过度到4.x版本。　　下载之后解压缩。大家可以看到这样一个目录结构。非常的清晰。　　第一个文件夹jar是jar包的文件夹。第二个javadoc是API文档。第三个license文件夹是开源的授权文件(可以直接无视)。　　javadoc文件夹下面是一个jar包。可以直接解压缩出来。解压缩之后的文件夹就是api文档(以网页的形势展现)。　　jar文件夹里面有很多的jar包和一个all-in-one文件夹。都是Netty框架的组成部分。all-in-one里面有两个文件一个是jar包，另一个是对应的source源代码包。这样做的目的是为了给程序员有选择的添加自己所需要的包。　　假如读者是初学者的话。推荐直接套用all-in-one里面的jar包。假如你熟悉Netty的话可以根据自己的项目需求添加不同的jar包。2.创建Server 服务端　　Netty创建全部都是实现自AbstractBootstrap。客户端的是Bootstrap，服务端的则是ServerBootstrap。　　2.1创建一个 HelloServer package org.example.hello;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;public class HelloServer { /** * 服务端监听的端口地址 */ private static final int portNumber = 7878; public static void main(String[] args) throws InterruptedException { EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup); b.channel(NioServerSocketChannel.class); b.childHandler(new HelloServerInitializer()); // 服务器绑定端口监听 ChannelFuture f = b.bind(portNumber).sync(); // 监听服务器关闭监听 f.channel().closeFuture().sync(); // 可以简写为 /* b.bind(portNumber).sync().channel().closeFuture().sync(); */ } finally { bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } }}　　EventLoopGroup 是在4.x版本中提出来的一个新概念。用于channel的管理。服务端需要两个。和3.x版本一样，一个是boss线程一个是worker线程。　　b.childHandler(new HelloServerInitializer());　　　　//用于添加相关的Handler　　服务端简单的代码，真的没有办法在精简了感觉。就是一个绑定端口操作。2.2创建和实现HelloServerInitializer　　在HelloServer中的HelloServerInitializer在这里实现。　　首先我们需要明确我们到底是要做什么的。很简单。HelloWorld!。我们希望实现一个能够像服务端发送文字的功能。服务端假如可以最好还能返回点消息给客户端，然客户端去显示。　　需求简单。那我们下面就准备开始实现。　　DelimiterBasedFrameDecoder Netty在官方网站上提供的示例显示 有这么一个解码器可以简单的消息分割。　　其次 在decoder里面我们找到了String解码编码器。着都是官网提供给我们的。 1 package org.example.hello; 2 3 import io.netty.channel.ChannelInitializer; 4 import io.netty.channel.ChannelPipeline; 5 import io.netty.channel.socket.SocketChannel; 6 import io.netty.handler.codec.DelimiterBasedFrameDecoder; 7 import io.netty.handler.codec.Delimiters; 8 import io.netty.handler.codec.string.StringDecoder; 9 import io.netty.handler.codec.string.StringEncoder;1011 public class HelloServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; {1213 @Override14 protected void initChannel(SocketChannel ch) throws Exception {15 ChannelPipeline pipeline = ch.pipeline();1617 // 以(\"\\n\")为结尾分割的 解码器18 pipeline.addLast(\"framer\", new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter()));1920 // 字符串解码 和 编码21 pipeline.addLast(\"decoder\", new StringDecoder());22 pipeline.addLast(\"encoder\", new StringEncoder());2324 // 自己的逻辑Handler25 pipeline.addLast(\"handler\", new HelloServerHandler());26 }27 }　　上面的三个解码和编码都是系统。　　另外我们自己的Handler怎么办呢。在最后我们添加一个自己的Handler用于写自己的处理逻辑。2.3 增加自己的逻辑HelloServerHandler　　自己的Handler我们这里先去继承extends官网推荐的SimpleChannelInboundHandler&lt;C&gt; 。在这里C，由于我们需求里面发送的是字符串。这里的C改写为String。　　 1 package org.example.hello; 2 3 import java.net.InetAddress; 4 5 import io.netty.channel.ChannelHandlerContext; 6 import io.netty.channel.SimpleChannelInboundHandler; 7 8 public class HelloServerHandler extends SimpleChannelInboundHandler&lt;String&gt; { 910 @Override11 protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {12 // 收到消息直接打印输出13 System.out.println(ctx.channel().remoteAddress() + \" Say : \" + msg);1415 // 返回客户端消息 - 我已经接收到了你的消息16 ctx.writeAndFlush(\"Received your message !\\n\");17 }1819 /*20 *21 * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)22 *23 * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述24 * */25 @Override26 public void channelActive(ChannelHandlerContext ctx) throws Exception {2728 System.out.println(\"RamoteAddress : \" + ctx.channel().remoteAddress() + \" active !\");2930 ctx.writeAndFlush( \"Welcome to \" + InetAddress.getLocalHost().getHostName() + \" service!\\n\");3132 super.channelActive(ctx);33 }34 }　　在channelHandlerContent自带一个writeAndFlush方法。方法的作用是写入Buffer并刷入。　　注意:在3.x版本中此处有很大区别。在3.x版本中write()方法是自动flush的。在4.x版本的前面几个版本也是一样的。但是在4.0.9之后修改为WriteAndFlush。普通的write方法将不会发送消息。需要手动在write之后flush()一次　　这里channeActive的意思是当连接活跃(建立)的时候触发.输出消息源的远程地址。并返回欢迎消息。　　channelRead0 在这里的作用是类似于3.x版本的messageReceived()。可以当做是每一次收到消息是触发。　　我们在这里的代码是返回客户端一个字符串\"Received your message !\".　　注意:字符串最后面的\"\\n\"是必须的。因为我们在前面的解码器DelimiterBasedFrameDecoder是一个根据字符串结尾为&ldquo;\\n&rdquo;来结尾的。假如没有这个字符的话。解码会出现问题。&nbsp;&nbsp;2.Client客户端　　类似于服务端的代码。我们不做特别详细的解释。　　直接上示例代码:　　 1 package org.example.hello; 2 3 import io.netty.bootstrap.Bootstrap; 4 import io.netty.channel.Channel; 5 import io.netty.channel.EventLoopGroup; 6 import io.netty.channel.nio.NioEventLoopGroup; 7 import io.netty.channel.socket.nio.NioSocketChannel; 8 9 import java.io.BufferedReader;10 import java.io.IOException;11 import java.io.InputStreamReader;1213 public class HelloClient {1415 public static String host = \"127.0.0.1\";16 public static int port = 7878;1718 /**19 * @param args20 * @throws InterruptedException21 * @throws IOException22 */23 public static void main(String[] args) throws InterruptedException, IOException {24 EventLoopGroup group = new NioEventLoopGroup();25 try {26 Bootstrap b = new Bootstrap();27 b.group(group)28 .channel(NioSocketChannel.class)29 .handler(new HelloClientInitializer());3031 // 连接服务端32 Channel ch = b.connect(host, port).sync().channel();3334 // 控制台输入35 BufferedReader in = new BufferedReader(new InputStreamReader(System.in));36 for (;;) {37 String line = in.readLine();38 if (line == null) {39 continue;40 }41 /*42 * 向服务端发送在控制台输入的文本 并用\"\\r\\n\"结尾43 * 之所以用\\r\\n结尾 是因为我们在handler中添加了 DelimiterBasedFrameDecoder 帧解码。44 * 这个解码器是一个根据\\n符号位分隔符的解码器。所以每条消息的最后必须加上\\n否则无法识别和解码45 * */46 ch.writeAndFlush(line + \"\\r\\n\");47 }48 } finally {49 // The connection is closed automatically on shutdown.50 group.shutdownGracefully();51 }52 }53 }&nbsp;　　下面的是HelloClientInitializer代码貌似是和服务端的完全一样。我没注意看。其实编码和解码是相对的。多以服务端和客户端都是解码和编码。才能通信。　　 1 package org.example.hello; 2 3 import io.netty.channel.ChannelInitializer; 4 import io.netty.channel.ChannelPipeline; 5 import io.netty.channel.socket.SocketChannel; 6 import io.netty.handler.codec.DelimiterBasedFrameDecoder; 7 import io.netty.handler.codec.Delimiters; 8 import io.netty.handler.codec.string.StringDecoder; 9 import io.netty.handler.codec.string.StringEncoder;1011 public class HelloClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; {1213 @Override14 protected void initChannel(SocketChannel ch) throws Exception {15 ChannelPipeline pipeline = ch.pipeline();1617 /*18 * 这个地方的 必须和服务端对应上。否则无法正常解码和编码19 *20 * 解码和编码 我将会在下一张为大家详细的讲解。再次暂时不做详细的描述21 *22 * */23 pipeline.addLast(\"framer\", new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter()));24 pipeline.addLast(\"decoder\", new StringDecoder());25 pipeline.addLast(\"encoder\", new StringEncoder());2627 // 客户端的逻辑28 pipeline.addLast(\"handler\", new HelloClientHandler());29 }30 }　　HellClientHandler：　　 1 package org.example.hello; 2 3 import io.netty.channel.ChannelHandlerContext; 4 import io.netty.channel.SimpleChannelInboundHandler; 5 6 public class HelloClientHandler extends SimpleChannelInboundHandler&lt;String&gt; { 7 8 @Override 9 protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {1011 System.out.println(\"Server say : \" + msg);12 }1314 @Override15 public void channelActive(ChannelHandlerContext ctx) throws Exception {16 System.out.println(\"Client active \");17 super.channelActive(ctx);18 }1920 @Override21 public void channelInactive(ChannelHandlerContext ctx) throws Exception {22 System.out.println(\"Client close \");23 super.channelInactive(ctx);24 }25 }&nbsp;本教程的示例源代码:http://pan.baidu.com/s/1hABzK#dir大家可以再我的百度云盘里面找到。下面上几张成果图:　　客户端在连接建立是输出了Client active 信息，并收到服务端返回的Welcome消息。　　输入Hello World ! 回车发送消息。服务端响应返回消息已接受。1.客户端控制台截图2.服务端控制台截图&nbsp;&nbsp;&nbsp;作者：TinyZ出处：http://www.cnblogs.com/zou90512/关于作者：努力学习，天天向上。不断探索学习，提升自身价值。记录经验分享。本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接如有问题，可以通过&nbsp;zou90512@126.com&nbsp;联系我，非常感谢。笔者网店: http://aoleitaisen.taobao.com. 欢迎广大读者围观&nbsp;"
    } ,
  
    {
      "title"       : "Netty4.x中文教程系列(一) 目录及概述",
      "category"    : "",
      "tags"        : "Netty4.x中文教程系列",
      "url"         : "./netty/2013/12/26/Netty4.x_1.html",
      "date"        : "2013-12-26 13:54:00 +0800",
      "description" : "",
      "content"     : "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Netty 提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Netty是一个NIO客户端 服务端框架。允许快速简单的开发网络应用程序。例如：服务端和客户端之间的协议。它最棒的地方在于简化了网络编程规范。例如:TCP和UDP socket服务。&nbsp; &nbsp; &nbsp;&nbsp;Netty官网:Netty.io　　笔者个人理解：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　Netty本身是用于快速构建服务端与客户端之间通信协议的框架。Netty在消息处理上使用责任链模式，用户可以轻松方便的对它进行扩展。官方也提供了大量的优秀的扩展。　　本系列主要讲的内容将是Netty的一些基础概念和一些应用。&nbsp; &nbsp; &nbsp; ps：博客内容若有错误，还望各位大神指正。教程目录 1.Netty4.x中文教程系列(一) 2.Netty4.x中文教程系列(二) Hello World ! 3.Netty4.x中文教程系列(三) Hello World ！详解 4.Netty4.x中文教程系列(四) ChannelHandler 5.Netty4.x中文教程系列(五)&nbsp;编解码器Codec 6.Netty4.x中文教程系列(六) 从头开始Bootstrap&nbsp;教程相关代码和文档&nbsp;百度云盘：http://pan.baidu.com/s/1pJsKEAR&nbsp;作者：TinyZ出处：http://www.cnblogs.com/zou90512/关于作者：努力学习，天天向上。不断探索学习，提升自身价值。记录经验分享。本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接如有问题，可以通过&nbsp;zou90512@126.com&nbsp;联系我，非常感谢。笔者网店: http://aoleitaisen.taobao.com. 欢迎广大读者围观&nbsp;"
    } 
  
]
