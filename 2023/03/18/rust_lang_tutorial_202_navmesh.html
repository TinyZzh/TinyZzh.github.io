
<p>Navmesh是一种寻路数据结构，它将地图分解为三角形，可以轻松地进行路径计算。</p>

<p>我们将使用一些外部库来帮助我们实现Navmesh寻路算法。在项目的Cargo.toml文件中，添加以下依赖项：</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nn">[dependencies]</span>
<span class="py">rand</span> <span class="p">=</span> <span class="s">"0.8.3"</span>
<span class="py">nalgebra</span> <span class="p">=</span> <span class="s">"0.27.1"</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这将添加rand和nalgebra库作为我们的依赖项。</p>

<h2 id="navmesh寻路算法">Navmesh寻路算法</h2>

<p>现在我们开始实现Navmesh。我们需要定义一个三角形结构体，并将其存储在一个向量中。我们还需要实现一个函数来检查点是否在三角形内。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">nalgebra</span><span class="p">::{</span><span class="n">Point2</span><span class="p">,</span> <span class="n">Vector2</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">Triangle</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Triangle</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">contains_point</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">v0</span> <span class="o">=</span> <span class="k">self</span><span class="py">.c</span> <span class="o">-</span> <span class="k">self</span><span class="py">.a</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">self</span><span class="py">.b</span> <span class="o">-</span> <span class="k">self</span><span class="py">.a</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="k">self</span><span class="py">.a</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">dot00</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.dot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v0</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">dot01</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.dot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v1</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">dot02</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.dot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">dot11</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.dot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v1</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">dot12</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.dot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">inv_denom</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dot00</span> <span class="o">*</span> <span class="n">dot11</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot01</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot11</span> <span class="o">*</span> <span class="n">dot02</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot12</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_denom</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot00</span> <span class="o">*</span> <span class="n">dot12</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot02</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_denom</span><span class="p">;</span>

        <span class="p">(</span><span class="n">u</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Navmesh</span> <span class="p">{</span>
    <span class="n">triangles</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Triangle</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Navmesh</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Navmesh</span> <span class="p">{</span>
        <span class="n">Navmesh</span> <span class="p">{</span>
            <span class="n">triangles</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">add_triangle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">triangle</span><span class="p">:</span> <span class="n">Triangle</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.triangles</span><span class="nf">.push</span><span class="p">(</span><span class="n">triangle</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">get_triangle_containing_point</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Triangle</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">triangle</span> <span class="n">in</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.triangles</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">triangle</span><span class="nf">.contains_point</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">triangle</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>现在我们已经实现了Navmesh，我们可以开始实现寻路算法。我们将使用A*算法来计算路径。我们需要定义一个节点结构体，并将其存储在一个向量中。我们还需要实现一个函数来计算两个节点之间的距离。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
</pre></td><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BinaryHeap</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">position</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">g</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="n">h</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="p">{</span>
            <span class="n">position</span><span class="p">,</span>
            <span class="n">g</span><span class="p">,</span>
            <span class="n">h</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.g</span> <span class="o">+</span> <span class="k">self</span><span class="py">.h</span><span class="p">)</span><span class="nf">.eq</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">other</span><span class="py">.g</span> <span class="o">+</span> <span class="n">other</span><span class="py">.h</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Eq</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="nb">PartialOrd</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">((</span><span class="k">self</span><span class="py">.g</span> <span class="o">+</span> <span class="k">self</span><span class="py">.h</span><span class="p">)</span><span class="nf">.partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">other</span><span class="py">.g</span> <span class="o">+</span> <span class="n">other</span><span class="py">.h</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Ord</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Ordering</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.g</span> <span class="o">+</span> <span class="k">self</span><span class="py">.h</span><span class="p">)</span>
            <span class="nf">.partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">other</span><span class="py">.g</span> <span class="o">+</span> <span class="n">other</span><span class="py">.h</span><span class="p">))</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="nf">.reverse</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">distance</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f32</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="nf">.norm</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">find_path</span><span class="p">(</span><span class="n">navmesh</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Navmesh</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">open_set</span> <span class="o">=</span> <span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">closed_set</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">nodes</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">start_triangle</span> <span class="o">=</span> <span class="n">navmesh</span><span class="nf">.get_triangle_containing_point</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">end_triangle</span> <span class="o">=</span> <span class="n">navmesh</span><span class="nf">.get_triangle_containing_point</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">start_node</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nf">distance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">),</span> <span class="nb">None</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">end_node</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>

    <span class="n">nodes</span><span class="nf">.push</span><span class="p">(</span><span class="n">start_node</span><span class="p">);</span>
    <span class="n">open_set</span><span class="nf">.push</span><span class="p">(</span><span class="n">start_node</span><span class="p">);</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">current_node</span><span class="p">)</span> <span class="o">=</span> <span class="n">open_set</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">current_node</span><span class="py">.position</span> <span class="o">==</span> <span class="n">end_node</span><span class="py">.position</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">path</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">current_node</span><span class="py">.parent</span><span class="o">?</span><span class="p">];</span>
            <span class="n">path</span><span class="nf">.push</span><span class="p">(</span><span class="n">node</span><span class="py">.position</span><span class="p">);</span>
            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">parent_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span><span class="py">.parent</span> <span class="p">{</span>
                <span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">parent_index</span><span class="p">];</span>
                <span class="n">path</span><span class="nf">.push</span><span class="p">(</span><span class="n">node</span><span class="py">.position</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">path</span><span class="nf">.reverse</span><span class="p">();</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">closed_set</span><span class="nf">.push</span><span class="p">(</span><span class="n">current_node</span><span class="py">.position</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">current_triangle</span> <span class="o">=</span> <span class="n">navmesh</span><span class="nf">.get_triangle_containing_point</span><span class="p">(</span><span class="n">current_node</span><span class="py">.position</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">neighbor_triangle</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">navmesh</span><span class="py">.triangles</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">neighbor_triangle</span> <span class="o">==</span> <span class="n">current_triangle</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">neighbor_point</span> <span class="n">in</span> <span class="o">&amp;</span><span class="p">[</span>
                <span class="n">neighbor_triangle</span><span class="py">.a</span><span class="p">,</span>
                <span class="n">neighbor_triangle</span><span class="py">.b</span><span class="p">,</span>
                <span class="n">neighbor_triangle</span><span class="py">.c</span><span class="p">,</span>
            <span class="p">]</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">closed_set</span><span class="nf">.contains</span><span class="p">(</span><span class="n">neighbor_point</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">let</span> <span class="n">neighbor_node</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
                    <span class="o">*</span><span class="n">neighbor_point</span><span class="p">,</span>
                    <span class="n">current_node</span><span class="py">.g</span> <span class="o">+</span> <span class="nf">distance</span><span class="p">(</span><span class="n">current_node</span><span class="py">.position</span><span class="p">,</span> <span class="o">*</span><span class="n">neighbor_point</span><span class="p">),</span>
                    <span class="nf">distance</span><span class="p">(</span><span class="o">*</span><span class="n">neighbor_point</span><span class="p">,</span> <span class="n">end</span><span class="p">),</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">nodes</span><span class="nf">.len</span><span class="p">()),</span>
                <span class="p">);</span>

                <span class="k">if</span> <span class="n">neighbor_triangle</span><span class="nf">.contains_point</span><span class="p">(</span><span class="n">neighbor_node</span><span class="py">.position</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">existing_node_index</span> <span class="o">=</span> <span class="n">nodes</span>
                        <span class="nf">.iter</span><span class="p">()</span>
                        <span class="nf">.position</span><span class="p">(|</span><span class="n">n</span><span class="p">|</span> <span class="n">n</span><span class="py">.position</span> <span class="o">==</span> <span class="n">neighbor_node</span><span class="py">.position</span><span class="p">);</span>

                    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">existing_node_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">existing_node_index</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">existing_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">existing_node_index</span><span class="p">];</span>

                        <span class="k">if</span> <span class="n">neighbor_node</span><span class="py">.g</span> <span class="o">&lt;</span> <span class="n">existing_node</span><span class="py">.g</span> <span class="p">{</span>
                            <span class="n">nodes</span><span class="p">[</span><span class="n">existing_node_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor_node</span><span class="p">;</span>
                            <span class="n">open_set</span><span class="nf">.push</span><span class="p">(</span><span class="n">neighbor_node</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">nodes</span><span class="nf">.push</span><span class="p">(</span><span class="n">neighbor_node</span><span class="p">);</span>
                        <span class="n">open_set</span><span class="nf">.push</span><span class="p">(</span><span class="n">neighbor_node</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">nodes</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">n</span><span class="p">|</span><span class="n">n</span><span class="py">.position</span><span class="p">)</span><span class="nf">.collect</span><span class="p">())</span>
<span class="p">}</span>
<span class="c1">//    输出结果</span>
<span class="c1">//    </span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="测试navmesh寻路算法">测试Navmesh寻路算法</h2>

<p>现在我们已经实现了Navmesh和寻路算法，我们可以编写一些测试代码来测试它们。在<code>main.rs</code>文件中添加以下代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">navmesh</span> <span class="o">=</span> <span class="nn">Navmesh</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">navmesh</span><span class="nf">.add_triangle</span><span class="p">(</span><span class="n">Triangle</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">:</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
        <span class="n">b</span><span class="p">:</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">c</span><span class="p">:</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="p">});</span>
    <span class="n">navmesh</span><span class="nf">.add_triangle</span><span class="p">(</span><span class="n">Triangle</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">:</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">b</span><span class="p">:</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">c</span><span class="p">:</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="p">});</span>

    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nf">find_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">navmesh</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Path: {:?}"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这将创建一个简单的Navmesh，并计算从起点到终点的路径。运行代码，输出应该类似于以下内容：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Path</span><span class="p">:</span> <span class="p">[</span><span class="n">Point2</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.1</span> <span class="p">},</span> <span class="n">Point2</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.5</span> <span class="p">},</span> <span class="n">Point2</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.9</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.9</span> <span class="p">}]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="总结">总结</h2>

<p>在本教程中，我们使用Rust编写了一个Navmesh寻路算法。我们实现了一个Navmesh数据结构，用于存储三角形，并使用A*算法计算路径。我们还编写了一些测试代码来测试我们的算法。</p>

<p>完整示例代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
</pre></td><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">nalgebra</span><span class="p">::{</span><span class="n">Point2</span><span class="p">,</span> <span class="n">Vector2</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BinaryHeap</span><span class="p">;</span>


<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">PartialEq,</span> <span class="nd">Copy)]</span>
<span class="k">struct</span> <span class="n">Triangle</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Triangle</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">contains_point</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">v0</span> <span class="o">=</span> <span class="k">self</span><span class="py">.c</span> <span class="o">-</span> <span class="k">self</span><span class="py">.a</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">self</span><span class="py">.b</span> <span class="o">-</span> <span class="k">self</span><span class="py">.a</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="k">self</span><span class="py">.a</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">dot00</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.dot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v0</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">dot01</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.dot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v1</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">dot02</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.dot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">dot11</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.dot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v1</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">dot12</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.dot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">inv_denom</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dot00</span> <span class="o">*</span> <span class="n">dot11</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot01</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot11</span> <span class="o">*</span> <span class="n">dot02</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot12</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_denom</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot00</span> <span class="o">*</span> <span class="n">dot12</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot02</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_denom</span><span class="p">;</span>

        <span class="p">(</span><span class="n">u</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">Navmesh</span> <span class="p">{</span>
    <span class="n">triangles</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Triangle</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Navmesh</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Navmesh</span> <span class="p">{</span>
        <span class="n">Navmesh</span> <span class="p">{</span>
            <span class="n">triangles</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">add_triangle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">triangle</span><span class="p">:</span> <span class="n">Triangle</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.triangles</span><span class="nf">.push</span><span class="p">(</span><span class="n">triangle</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">get_triangle_containing_point</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Triangle</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">triangle</span> <span class="n">in</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.triangles</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">triangle</span><span class="nf">.contains_point</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">triangle</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">position</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">g</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="n">h</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="p">{</span>
            <span class="n">position</span><span class="p">,</span>
            <span class="n">g</span><span class="p">,</span>
            <span class="n">h</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.g</span> <span class="o">+</span> <span class="k">self</span><span class="py">.h</span><span class="p">)</span><span class="nf">.eq</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">other</span><span class="py">.g</span> <span class="o">+</span> <span class="n">other</span><span class="py">.h</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Eq</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="nb">PartialOrd</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">((</span><span class="k">self</span><span class="py">.g</span> <span class="o">+</span> <span class="k">self</span><span class="py">.h</span><span class="p">)</span><span class="nf">.partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">other</span><span class="py">.g</span> <span class="o">+</span> <span class="n">other</span><span class="py">.h</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Ord</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Ordering</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.g</span> <span class="o">+</span> <span class="k">self</span><span class="py">.h</span><span class="p">)</span>
            <span class="nf">.partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">other</span><span class="py">.g</span> <span class="o">+</span> <span class="n">other</span><span class="py">.h</span><span class="p">))</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="nf">.reverse</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">distance</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f32</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="nf">.norm</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">find_path</span><span class="p">(</span><span class="n">navmesh</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Navmesh</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Point2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">open_set</span> <span class="o">=</span> <span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">closed_set</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">nodes</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">start_triangle</span> <span class="o">=</span> <span class="n">navmesh</span><span class="nf">.get_triangle_containing_point</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">end_triangle</span> <span class="o">=</span> <span class="n">navmesh</span><span class="nf">.get_triangle_containing_point</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">start_node</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nf">distance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">),</span> <span class="nb">None</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">end_node</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>

    <span class="n">nodes</span><span class="nf">.push</span><span class="p">(</span><span class="n">start_node</span><span class="p">);</span>
    <span class="n">open_set</span><span class="nf">.push</span><span class="p">(</span><span class="n">start_node</span><span class="p">);</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">current_node</span><span class="p">)</span> <span class="o">=</span> <span class="n">open_set</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">current_node</span><span class="py">.position</span> <span class="o">==</span> <span class="n">end_node</span><span class="py">.position</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">path</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">current_node</span><span class="py">.parent</span><span class="o">?</span><span class="p">];</span>
            <span class="n">path</span><span class="nf">.push</span><span class="p">(</span><span class="n">node</span><span class="py">.position</span><span class="p">);</span>
            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">parent_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span><span class="py">.parent</span> <span class="p">{</span>
                <span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">parent_index</span><span class="p">];</span>
                <span class="n">path</span><span class="nf">.push</span><span class="p">(</span><span class="n">node</span><span class="py">.position</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">path</span><span class="nf">.reverse</span><span class="p">();</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">closed_set</span><span class="nf">.push</span><span class="p">(</span><span class="n">current_node</span><span class="py">.position</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">current_triangle</span> <span class="o">=</span> <span class="n">navmesh</span><span class="nf">.get_triangle_containing_point</span><span class="p">(</span><span class="n">current_node</span><span class="py">.position</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">neighbor_triangle</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">navmesh</span><span class="py">.triangles</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">neighbor_triangle</span> <span class="o">==</span> <span class="n">current_triangle</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">neighbor_point</span> <span class="n">in</span> <span class="o">&amp;</span><span class="p">[</span>
                <span class="n">neighbor_triangle</span><span class="py">.a</span><span class="p">,</span>
                <span class="n">neighbor_triangle</span><span class="py">.b</span><span class="p">,</span>
                <span class="n">neighbor_triangle</span><span class="py">.c</span><span class="p">,</span>
            <span class="p">]</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">closed_set</span><span class="nf">.contains</span><span class="p">(</span><span class="n">neighbor_point</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">let</span> <span class="n">neighbor_node</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
                    <span class="o">*</span><span class="n">neighbor_point</span><span class="p">,</span>
                    <span class="n">current_node</span><span class="py">.g</span> <span class="o">+</span> <span class="nf">distance</span><span class="p">(</span><span class="n">current_node</span><span class="py">.position</span><span class="p">,</span> <span class="o">*</span><span class="n">neighbor_point</span><span class="p">),</span>
                    <span class="nf">distance</span><span class="p">(</span><span class="o">*</span><span class="n">neighbor_point</span><span class="p">,</span> <span class="n">end</span><span class="p">),</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">nodes</span><span class="nf">.len</span><span class="p">()),</span>
                <span class="p">);</span>

                <span class="k">if</span> <span class="n">neighbor_triangle</span><span class="nf">.contains_point</span><span class="p">(</span><span class="n">neighbor_node</span><span class="py">.position</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">existing_node_index</span> <span class="o">=</span> <span class="n">nodes</span>
                        <span class="nf">.iter</span><span class="p">()</span>
                        <span class="nf">.position</span><span class="p">(|</span><span class="n">n</span><span class="p">|</span> <span class="n">n</span><span class="py">.position</span> <span class="o">==</span> <span class="n">neighbor_node</span><span class="py">.position</span><span class="p">);</span>

                    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">existing_node_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">existing_node_index</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">existing_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">existing_node_index</span><span class="p">];</span>

                        <span class="k">if</span> <span class="n">neighbor_node</span><span class="py">.g</span> <span class="o">&lt;</span> <span class="n">existing_node</span><span class="py">.g</span> <span class="p">{</span>
                            <span class="n">nodes</span><span class="p">[</span><span class="n">existing_node_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor_node</span><span class="p">;</span>
                            <span class="n">open_set</span><span class="nf">.push</span><span class="p">(</span><span class="n">neighbor_node</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">nodes</span><span class="nf">.push</span><span class="p">(</span><span class="n">neighbor_node</span><span class="p">);</span>
                        <span class="n">open_set</span><span class="nf">.push</span><span class="p">(</span><span class="n">neighbor_node</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">nodes</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">n</span><span class="p">|</span><span class="n">n</span><span class="py">.position</span><span class="p">)</span><span class="nf">.collect</span><span class="p">())</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">navmesh</span> <span class="o">=</span> <span class="nn">Navmesh</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">navmesh</span><span class="nf">.add_triangle</span><span class="p">(</span><span class="n">Triangle</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">:</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
        <span class="n">b</span><span class="p">:</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">c</span><span class="p">:</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="p">});</span>
    <span class="n">navmesh</span><span class="nf">.add_triangle</span><span class="p">(</span><span class="n">Triangle</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">:</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">b</span><span class="p">:</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">c</span><span class="p">:</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="p">});</span>

    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="nn">Point2</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nf">find_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">navmesh</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Path: {:?}"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
